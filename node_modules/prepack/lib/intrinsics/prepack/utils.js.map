{"version":3,"sources":["../../../src/intrinsics/prepack/utils.js"],"names":["throwTemplateSrc","parseTypeNameOrTemplate","realm","typeNameOrTemplate","undefined","UndefinedValue","type","Value","template","Utils","getTypeFromName","createErrorThrowCompletion","intrinsics","TypeError","StringValue","typeNameString","To","ToStringPartial","hasFunctionResultType","startsWith","substring","FunctionValue","functionResultType","ObjectValue","createAbstract","name","options","additionalValues","useAbstractInterpretation","optionsMap","properties","Map","result","locString","loc","executionContext","contextStack","slice","reverse","caller","function","lexicalEnvironment","locVal","AbstractValue","createFromTemplate","hashValue","objectCount","get","isNameStringUnique","error","CompilerDiagnostic","handleError","FatalError","saveNameString","DisablePlaceholderSuffix","intrinsicName","values","ValuesDomain","Set","makePartial","rebuildNestedProperties","AbstractObjectValue","length","createAbstractConcreteUnion"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../../realm.js\";\nimport {\n  AbstractValue,\n  ConcreteValue,\n  FunctionValue,\n  ObjectValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"../../values/index.js\";\nimport { DisablePlaceholderSuffix } from \"../../utils/PreludeGenerator.js\";\nimport { ValuesDomain } from \"../../domains/index.js\";\nimport { describeLocation } from \"../ecma262/Error.js\";\nimport { To } from \"../../singletons.js\";\nimport AbstractObjectValue from \"../../values/AbstractObjectValue.js\";\nimport { CompilerDiagnostic, FatalError } from \"../../errors.js\";\nimport { Utils } from \"../../singletons.js\";\nimport invariant from \"../../invariant.js\";\n\nconst throwTemplateSrc = \"(function(){throw new global.Error('abstract value defined at ' + A);})()\";\n\nexport function parseTypeNameOrTemplate(\n  realm: Realm,\n  typeNameOrTemplate: void | Value | string\n): { type: typeof Value, template: void | ObjectValue, functionResultType?: typeof Value } {\n  if (typeNameOrTemplate === undefined || typeNameOrTemplate instanceof UndefinedValue) {\n    return { type: Value, template: undefined };\n  } else if (typeof typeNameOrTemplate === \"string\") {\n    let type = Utils.getTypeFromName(typeNameOrTemplate);\n    if (type === undefined) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown typeNameOrTemplate\");\n    }\n    return { type, template: undefined };\n  } else if (typeNameOrTemplate instanceof StringValue) {\n    let typeNameString = To.ToStringPartial(realm, typeNameOrTemplate);\n    let hasFunctionResultType = typeNameString.startsWith(\":\");\n    if (hasFunctionResultType) typeNameString = typeNameString.substring(1);\n    let type = Utils.getTypeFromName(typeNameString);\n    if (type === undefined) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown typeNameOrTemplate\");\n    }\n    return hasFunctionResultType\n      ? { type: FunctionValue, template: undefined, functionResultType: type }\n      : { type, template: undefined };\n  } else if (typeNameOrTemplate instanceof FunctionValue) {\n    return { type: FunctionValue, template: typeNameOrTemplate };\n  } else if (typeNameOrTemplate instanceof ObjectValue) {\n    return { type: ObjectValue, template: typeNameOrTemplate };\n  } else {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"typeNameOrTemplate has unsupported type\");\n  }\n}\n\nexport function createAbstract(\n  realm: Realm,\n  typeNameOrTemplate?: Value | string,\n  name?: string,\n  options?: ObjectValue,\n  ...additionalValues: Array<ConcreteValue>\n): AbstractValue | AbstractObjectValue {\n  if (!realm.useAbstractInterpretation) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"realm is not partial\");\n  }\n\n  let { type, template, functionResultType } = parseTypeNameOrTemplate(realm, typeNameOrTemplate);\n  let optionsMap = options ? options.properties : new Map();\n\n  let result;\n  let locString,\n    loc = null;\n  for (let executionContext of realm.contextStack.slice().reverse()) {\n    let caller = executionContext.caller;\n    loc = executionContext.loc;\n    locString = describeLocation(\n      realm,\n      caller ? caller.function : undefined,\n      caller ? caller.lexicalEnvironment : undefined,\n      loc\n    );\n    if (locString !== undefined) break;\n  }\n  if (name === undefined) {\n    let locVal = new StringValue(realm, locString !== undefined ? locString : \"(unknown location)\");\n    result = AbstractValue.createFromTemplate(realm, throwTemplateSrc, type, [locVal]);\n    result.hashValue = ++realm.objectCount; // need not be an object, but must be unique\n  } else {\n    if (!optionsMap.get(\"allowDuplicateNames\") && !realm.isNameStringUnique(name)) {\n      let error = new CompilerDiagnostic(\"An abstract value with the same name exists\", loc, \"PP0019\", \"FatalError\");\n      realm.handleError(error);\n      throw new FatalError();\n    } else {\n      realm.saveNameString(name);\n    }\n    result = AbstractValue.createFromTemplate(\n      realm,\n      optionsMap.get(\"disablePlaceholders\") ? name + DisablePlaceholderSuffix : name,\n      type,\n      []\n    );\n    result.intrinsicName = name;\n  }\n\n  if (template) result.values = new ValuesDomain(new Set([template]));\n  if (template && !(template instanceof FunctionValue)) {\n    // why exclude functions?\n    template.makePartial();\n    if (name !== undefined) realm.rebuildNestedProperties(result, name);\n  }\n  if (functionResultType) {\n    invariant(result instanceof AbstractObjectValue);\n    result.functionResultType = functionResultType;\n  }\n\n  if (additionalValues.length > 0) result = AbstractValue.createAbstractConcreteUnion(realm, result, additionalValues);\n  return result;\n}\n"],"file":"utils.js"}