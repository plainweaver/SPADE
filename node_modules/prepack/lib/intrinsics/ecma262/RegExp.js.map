{"version":3,"sources":["../../../src/intrinsics/ecma262/RegExp.js"],"names":["realm","func","NativeFunctionValue","context","pattern","flags","argCount","NewTarget","patternIsRegExp","newTarget","UndefinedValue","ObjectValue","patternConstructor","P","F","$RegExpMatcher","$OriginalSource","StringValue","$OriginalFlags","throwIfNotConcrete","O","defineNativeGetter","intrinsics","SymbolSpecies"],"mappings":";;;;;;;AAYA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;AAjBA;;;;;;;;;AASA;AAUe,kBAASA,KAAT,EAA4C;AACzD,MAAIC,IAAI,GAAG,IAAIC,0BAAJ,CAAwBF,KAAxB,EAA+B,QAA/B,EAAyC,QAAzC,EAAmD,CAAnD,EAAsD,CAACG,OAAD,EAAU,CAACC,OAAD,EAAUC,KAAV,CAAV,EAA4BC,QAA5B,EAAsCC,SAAtC,KAAoD;AACnH;AACA,QAAIC,eAAe,GAAG,kBAASR,KAAT,EAAgBI,OAAhB,CAAtB;AACA,QAAIK,SAAJ,CAHmH,CAInH;;AACA,QAAIF,SAAJ,EAAe;AACbE,MAAAA,SAAS,GAAGF,SAAZ;AACD,KAFD,MAEO;AACL;AACA;AACAE,MAAAA,SAAS,GAAGR,IAAZ,CAHK,CAKL;;AACA,UAAIO,eAAe,IAAIH,KAAK,YAAYK,qBAAxC,EAAwD;AACtD,gCAAUN,OAAO,YAAYO,kBAA7B,EADsD,CAEtD;;AACA,YAAIC,kBAAkB,GAAG,cAAIZ,KAAJ,EAAWI,OAAX,EAAoB,aAApB,CAAzB,CAHsD,CAKtD;;AACA,YAAI,gCAAiBJ,KAAjB,EAAwBS,SAAxB,EAAmCG,kBAAnC,CAAJ,EAA4D;AAC1D,iBAAOR,OAAP;AACD;AACF;AACF;;AAED,QAAIS,CAAJ,EAAOC,CAAP,CAzBmH,CA0BnH;;AACA,QAAIV,OAAO,YAAYO,kBAAnB,IAAkCP,OAAO,CAACW,cAA9C,EAA8D;AAC5D;AACA,8BAAU,OAAOX,OAAO,CAACY,eAAf,KAAmC,QAA7C;AACAH,MAAAA,CAAC,GAAG,IAAII,kBAAJ,CAAgBjB,KAAhB,EAAuBI,OAAO,CAACY,eAA/B,CAAJ,CAH4D,CAK5D;;AACA,UAAIX,KAAK,YAAYK,qBAArB,EAAqC;AACnC,gCAAU,OAAON,OAAO,CAACc,cAAf,KAAkC,QAA5C;AACAJ,QAAAA,CAAC,GAAG,IAAIG,kBAAJ,CAAgBjB,KAAhB,EAAuBI,OAAO,CAACc,cAA/B,CAAJ;AACD,OAHD,MAGO;AACL;AACAJ,QAAAA,CAAC,GAAGT,KAAK,CAACc,kBAAN,EAAJ;AACD;AACF,KAbD,MAaO,IAAIX,eAAJ,EAAqB;AAC1B;AACA,8BAAUJ,OAAO,YAAYO,kBAA7B,EAF0B,CAG1B;;AACAE,MAAAA,CAAC,GAAG,cAAIb,KAAJ,EAAWI,OAAX,EAAoB,QAApB,CAAJ,CAJ0B,CAM1B;;AACA,UAAIC,KAAK,YAAYK,qBAArB,EAAqC;AACnC;AACAI,QAAAA,CAAC,GAAG,cAAId,KAAJ,EAAWI,OAAX,EAAoB,OAApB,CAAJ;AACD,OAHD,MAGO;AACL;AACAU,QAAAA,CAAC,GAAGT,KAAK,CAACc,kBAAN,EAAJ;AACD;AACF,KAdM,MAcA;AACL;AACA;AACAN,MAAAA,CAAC,GAAGT,OAAO,CAACe,kBAAR,EAAJ,CAHK,CAIL;;AACAL,MAAAA,CAAC,GAAGT,KAAK,CAACc,kBAAN,EAAJ;AACD,KA5DkH,CA8DnH;;;AACA,QAAIC,CAAC,GAAG,yBAAYpB,KAAZ,EAAmBS,SAAnB,CAAR,CA/DmH,CAiEnH;;AACA,WAAO,8BAAiBT,KAAjB,EAAwBoB,CAAxB,EAA2BP,CAA3B,EAA8BC,CAA9B,CAAP;AACD,GAnEU,CAAX,CADyD,CAsEzD;;AACAb,EAAAA,IAAI,CAACoB,kBAAL,CAAwBrB,KAAK,CAACsB,UAAN,CAAiBC,aAAzC,EAAwDpB,OAAO,IAAI;AACjE;AACA,WAAOA,OAAP;AACD,GAHD;AAKA,SAAOF,IAAP;AACD","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../../realm.js\";\nimport { StringValue, NativeFunctionValue, UndefinedValue, ObjectValue } from \"../../values/index.js\";\nimport { IsRegExp } from \"../../methods/is.js\";\nimport { Get } from \"../../methods/get.js\";\nimport { SameValuePartial } from \"../../methods/abstract.js\";\nimport { RegExpAlloc, RegExpInitialize } from \"../../methods/regexp.js\";\nimport invariant from \"../../invariant.js\";\n\nexport default function(realm: Realm): NativeFunctionValue {\n  let func = new NativeFunctionValue(realm, \"RegExp\", \"RegExp\", 2, (context, [pattern, flags], argCount, NewTarget) => {\n    // 1. Let patternIsRegExp be ? IsRegExp(pattern).\n    let patternIsRegExp = IsRegExp(realm, pattern);\n    let newTarget;\n    // 2. If NewTarget is not undefined, let newTarget be NewTarget.\n    if (NewTarget) {\n      newTarget = NewTarget;\n    } else {\n      // 3. Else,\n      // a. Let newTarget be the active function object.\n      newTarget = func;\n\n      // b. If patternIsRegExp is true and flags is undefined, then\n      if (patternIsRegExp && flags instanceof UndefinedValue) {\n        invariant(pattern instanceof ObjectValue);\n        // i. Let patternConstructor be ? Get(pattern, \"constructor\").\n        let patternConstructor = Get(realm, pattern, \"constructor\");\n\n        // ii. If SameValue(newTarget, patternConstructor) is true, return pattern.\n        if (SameValuePartial(realm, newTarget, patternConstructor)) {\n          return pattern;\n        }\n      }\n    }\n\n    let P, F;\n    // 4. If Type(pattern) is Object and pattern has a [[RegExpMatcher]] internal slot, then\n    if (pattern instanceof ObjectValue && pattern.$RegExpMatcher) {\n      // a. Let P be the value of pattern's [[OriginalSource]] internal slot.\n      invariant(typeof pattern.$OriginalSource === \"string\");\n      P = new StringValue(realm, pattern.$OriginalSource);\n\n      // b. If flags is undefined, let F be the value of pattern's [[OriginalFlags]] internal slot.\n      if (flags instanceof UndefinedValue) {\n        invariant(typeof pattern.$OriginalFlags === \"string\");\n        F = new StringValue(realm, pattern.$OriginalFlags);\n      } else {\n        // c. Else, let F be flags.\n        F = flags.throwIfNotConcrete();\n      }\n    } else if (patternIsRegExp) {\n      // 5. Else if patternIsRegExp is true, then\n      invariant(pattern instanceof ObjectValue);\n      // a. Let P be ? Get(pattern, \"source\").\n      P = Get(realm, pattern, \"source\");\n\n      // b. If flags is undefined, then\n      if (flags instanceof UndefinedValue) {\n        // i. Let F be ? Get(pattern, \"flags\").\n        F = Get(realm, pattern, \"flags\");\n      } else {\n        // c. Else, let F be flags.\n        F = flags.throwIfNotConcrete();\n      }\n    } else {\n      // 6. Else,\n      // a. Let P be pattern.\n      P = pattern.throwIfNotConcrete();\n      // b. Let F be flags.\n      F = flags.throwIfNotConcrete();\n    }\n\n    // 7. Let O be ? RegExpAlloc(newTarget).\n    let O = RegExpAlloc(realm, newTarget);\n\n    // 8. Return ? RegExpInitialize(O, P, F).\n    return RegExpInitialize(realm, O, P, F);\n  });\n\n  // ECMA262 21.2.4.2\n  func.defineNativeGetter(realm.intrinsics.SymbolSpecies, context => {\n    // 1. Return the this value\n    return context;\n  });\n\n  return func;\n}\n"],"file":"RegExp.js"}