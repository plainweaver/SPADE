"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("../../values/index.js");

var _index2 = require("../../methods/index.js");

var _invariant = _interopRequireDefault(require("../../invariant.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, obj) {
  const tsTemplateSrc = "('' + A)"; // ECMA262 19.4.3.2

  obj.defineNativeMethod("toString", 0, context => {
    const target = context instanceof _index.ObjectValue ? context.$SymbolData : context;

    if (target instanceof _index.AbstractValue && target.getType() === _index.SymbolValue) {
      return _index.AbstractValue.createFromTemplate(realm, tsTemplateSrc, _index.StringValue, [target]);
    } // 1. Let s be the this value.


    let s = context.throwIfNotConcrete(); // 2. If Type(s) is Symbol, let sym be s.

    let sym;

    if (s instanceof _index.SymbolValue) {
      sym = s;
    } else {
      // 3. Else,
      // a. If Type(s) is not Object, throw a TypeError exception.
      if (!(s instanceof _index.ObjectValue)) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      } // b. If s does not have a [[SymbolData]] internal slot, throw a TypeError exception.


      if (!s.$SymbolData) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
      } // c. Let sym be the value of s's [[SymbolData]] internal slot.


      sym = s.$SymbolData;
    }

    sym.throwIfNotConcreteSymbol();
    (0, _invariant.default)(sym instanceof _index.SymbolValue, "expected symbol data internal slot to be a symbol value"); // 4. Return SymbolDescriptiveString(sym).

    return new _index.StringValue(realm, (0, _index2.SymbolDescriptiveString)(realm, sym));
  }); // ECMA262 19.4.3.3

  obj.defineNativeMethod("valueOf", 0, context => {
    // 1. Let s be the this value.
    let s = context.throwIfNotConcrete(); // 2. If Type(s) is Symbol, return s.

    if (s instanceof _index.SymbolValue) return s; // 3. If Type(s) is not Object, throw a TypeError exception.

    if (!(s instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. If s does not have a [[SymbolData]] internal slot, throw a TypeError exception.


    if (!s.$SymbolData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 5. Return the value of s's [[SymbolData]] internal slot.


    return s.$SymbolData;
  }); // ECMA262 19.4.3.4

  obj.defineNativeMethod(realm.intrinsics.SymbolToPrimitive, 1, (context, [hint]) => {
    // 1. Let s be the this value.
    let s = context.throwIfNotConcrete(); // 2. If Type(s) is Symbol, return s.

    if (s instanceof _index.SymbolValue) return s; // 3. If Type(s) is not Object, throw a TypeError exception.

    if (!(s instanceof _index.ObjectValue)) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 4. If s does not have a [[SymbolData]] internal slot, throw a TypeError exception.


    if (!s.$SymbolData) {
      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);
    } // 5. Return s.[[SymbolData]].


    return s.$SymbolData;
  }, {
    writable: false
  }); // ECMA262 19.4.3.5

  obj.defineNativeProperty(realm.intrinsics.SymbolToStringTag, new _index.StringValue(realm, "Symbol"), {
    writable: false
  });
}
//# sourceMappingURL=SymbolPrototype.js.map