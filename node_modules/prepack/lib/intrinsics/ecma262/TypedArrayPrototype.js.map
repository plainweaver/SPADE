{"version":3,"sources":["../../../src/intrinsics/ecma262/TypedArrayPrototype.js"],"names":["realm","obj","defineNativeGetter","context","O","throwIfNotConcrete","ObjectValue","createErrorThrowCompletion","intrinsics","TypeError","$ViewedArrayBuffer","buffer","zero","size","$ByteLength","NumberValue","offset","$ByteOffset","defineNativeMethod","target","start","end","To","ToObject","len","throwIfNotConcreteObject","$ArrayLength","relativeTarget","ToInteger","to","Math","max","min","relativeStart","from","relativeEnd","UndefinedValue","final","count","direction","fromKey","ToString","toKey","fromPresent","fromVal","Properties","Set","DeletePropertyOrThrow","Create","CreateArrayIterator","callbackfn","thisArg","T","undefined","k","Pk","StringValue","kPresent","kValue","testResult","ToBooleanPartial","false","true","value","kept","captured","selected","push","A","n","e","predicate","searchElement","fromIndex","elementK","Object","is","same","_separator","separator","sep","ToStringPartial","emptyString","element0","R","NullValue","S","element","next","length","mappedValue","initialValue","accumulator","middle","floor","lower","upper","upperP","lowerP","lowerExists","lowerValue","upperExists","upperValue","overloaded","$TypedArrayName","array","targetOffset","RangeError","targetBuffer","targetLength","targetName","targetElementSize","ArrayElementSize","targetType","ArrayElementType","targetByteOffset","src","srcLength","ToLength","targetByteIndex","limit","kNumber","ToNumber","typedArray","srcBuffer","srcName","srcType","srcElementSize","srcByteOffset","srcByteIndex","ArrayBuffer","elementSize","ElementSize","comparefn","SortCompare","x","y","mightBeUndefined","v","isNaN","comparefn_","result_","numb","arr","j","val","sort","begin","relativeBegin","beginIndex","endIndex","newLength","constructorName","beginByteOffset","argumentsList","firstElement","nextElement","defineNativeProperty","ArrayProto_toString","TypedArrayProto_values","SymbolIterator","SymbolToStringTag","name","build","type","$Prototype","TypedArrayPrototype","defineNativeConstant"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../../realm.js\";\nimport type { ElementType } from \"../../types.js\";\nimport { ElementSize } from \"../../types.js\";\nimport { ObjectValue, StringValue, NumberValue, UndefinedValue, NullValue } from \"../../values/index.js\";\nimport { Call, Invoke } from \"../../methods/call.js\";\nimport { Get } from \"../../methods/get.js\";\nimport { HasProperty, HasSomeCompatibleType } from \"../../methods/has.js\";\nimport { IsDetachedBuffer, IsCallable } from \"../../methods/is.js\";\nimport {\n  ArrayElementSize,\n  ArrayElementType,\n  ValidateTypedArray,\n  TypedArraySpeciesCreate,\n  IntegerIndexedElementSet,\n  IntegerIndexedElementGet,\n} from \"../../methods/typedarray.js\";\nimport { SetValueInBuffer, GetValueFromBuffer, CloneArrayBuffer } from \"../../methods/arraybuffer.js\";\nimport { SameValue, SameValueZeroPartial, StrictEqualityComparisonPartial } from \"../../methods/abstract.js\";\nimport { Create, Properties, To } from \"../../singletons.js\";\nimport invariant from \"../../invariant.js\";\n\nexport default function(realm: Realm, obj: ObjectValue): void {\n  // ECMA262 22.2.3.1\n  obj.defineNativeGetter(\"buffer\", context => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, return undefined.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!(\"$TypedArrayName\" in O)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"O does not have a [[TypedArrayName]] internal slot\"\n      );\n    }\n\n    // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]]\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer;\n\n    // 6. Return buffer.\n    return buffer;\n  });\n\n  // ECMA262 22.2.3.2\n  obj.defineNativeGetter(\"byteLength\", context => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, throw a TypeError exception.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!(\"$TypedArrayName\" in O)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"O does not have a [[TypedArrayName]] internal slot\"\n      );\n    }\n\n    // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]] internal slot\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer;\n    invariant(buffer);\n\n    // 6. If IsDetachedBuffer(buffer) is true, return 0.\n    if (IsDetachedBuffer(realm, buffer) === true) return realm.intrinsics.zero;\n\n    // 7. Let size be O.[[ByteLength]].\n    let size = O.$ByteLength;\n    invariant(typeof size === \"number\");\n\n    // 8. Return size.\n    return new NumberValue(realm, size);\n  });\n\n  // ECMA262 22.2.3.3\n  obj.defineNativeGetter(\"byteOffset\", context => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, throw a TypeError exception.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!(\"$TypedArrayName\" in O)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"O does not have a [[TypedArrayName]] internal slot\"\n      );\n    }\n\n    // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]] internal slot\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer;\n    invariant(buffer);\n\n    // 6. If IsDetachedBuffer(buffer) is true, return 0.\n    if (IsDetachedBuffer(realm, buffer) === true) return realm.intrinsics.zero;\n\n    // 7. Let offset be O.[[ByteOffset]].\n    let offset = O.$ByteOffset;\n    invariant(typeof offset === \"number\");\n\n    // 8. Return offset.\n    return new NumberValue(realm, offset);\n  });\n\n  // ECMA262 22.2.3.5\n  obj.defineNativeMethod(\"copyWithin\", 2, (context, [target, start, end]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. Let relativeTarget be ? ToInteger(target).\n    let relativeTarget = To.ToInteger(realm, target);\n\n    // 5. If relativeTarget < 0, let to be max((len + relativeTarget), 0); else let to be min(relativeTarget, len).\n    let to = relativeTarget < 0 ? Math.max(len + relativeTarget, 0) : Math.min(relativeTarget, len);\n\n    // 6. Let relativeStart be ? ToInteger(start).\n    let relativeStart = To.ToInteger(realm, start);\n\n    // 7. If relativeStart < 0, let from be max((len + relativeStart), 0); else let from be min(relativeStart, len).\n    let from = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\n    // 8. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).\n    let relativeEnd = !end || end instanceof UndefinedValue ? len : To.ToInteger(realm, end.throwIfNotConcrete());\n\n    // 9. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).\n    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n    // 10. Let count be min(final-from, len-to).\n    let count = Math.min(final - from, len - to);\n\n    let direction;\n    // 11. If from<to and to<from+count, then\n    if (from < to && to < from + count) {\n      // a. Let direction be -1.\n      direction = -1;\n\n      // b. Let from be from + count - 1.\n      from = from + count - 1;\n\n      // c. Let to be to + count - 1.\n      to = to + count - 1;\n    } else {\n      // 12. Else,\n      // a. Let direction be 1.\n      direction = 1;\n    }\n\n    // 13. Repeat, while count > 0\n    while (count > 0) {\n      // a. Let fromKey be ! ToString(from).\n      let fromKey = To.ToString(realm, new NumberValue(realm, from));\n\n      // b. Let toKey be ! ToString(to).\n      let toKey = To.ToString(realm, new NumberValue(realm, to));\n\n      // c. Let fromPresent be ? HasProperty(O, fromKey).\n      let fromPresent = HasProperty(realm, O, fromKey);\n\n      // d. If fromPresent is true, then\n      if (fromPresent === true) {\n        // i. Let fromVal be ? Get(O, fromKey).\n        let fromVal = Get(realm, O, fromKey);\n        // ii. Perform ? Set(O, toKey, fromVal, true).\n        Properties.Set(realm, O, toKey, fromVal, true);\n      } else {\n        // e. Else fromPresent is false,\n        // i. Perform ? DeletePropertyOrThrow(O, toKey).\n        Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), toKey);\n      }\n\n      // f. Let from be from + direction.\n      from = from + direction;\n\n      // g. Let to be to + direction.\n      to = to + direction;\n\n      // h. Let count be count - 1.\n      count = count - 1;\n    }\n\n    // 14. Return O.\n    return O;\n  });\n\n  // ECMA262 22.2.3.6\n  obj.defineNativeMethod(\"entries\", 0, context => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Return CreateArrayIterator(O, \"key+value\").\n    return Create.CreateArrayIterator(realm, O, \"key+value\");\n  });\n\n  // ECMA262 22.2.3.7\n  obj.defineNativeMethod(\"every\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let testResult be ToBoolean(? Call(callbackfn, T,  kValue, k, O )).\n        let testResult = To.ToBooleanPartial(realm, Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]));\n\n        // iii. If testResult is false, return false.\n        if (!testResult) return realm.intrinsics.false;\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 8. Return true.\n    return realm.intrinsics.true;\n  });\n\n  // ECMA262 22.2.3.8\n  obj.defineNativeMethod(\"fill\", 1, (context, [value, start, end]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. Let relativeStart be ? ToInteger(start).\n    let relativeStart = To.ToInteger(realm, start || realm.intrinsics.undefined);\n\n    // 5. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).\n    let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\n    // 6. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).\n    let relativeEnd = !end || end instanceof UndefinedValue ? len : To.ToInteger(realm, end.throwIfNotConcrete());\n\n    // 7. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).\n    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n    // 8. Repeat, while k < final\n    while (k < final) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Perform ? Set(O, Pk, value, true).\n      Properties.Set(realm, O, Pk, value, true);\n\n      // c. Increase k by 1.\n      k++;\n    }\n\n    // 9. Return O.\n    return O;\n  });\n\n  // ECMA262 22.2.3.9\n  obj.defineNativeMethod(\"filter\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (IsCallable(realm, callbackfn) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsCallable(callbackfn) is false\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg ? thisArg : realm.intrinsics.undefined;\n\n    // 6. Let kept be a new empty List.\n    let kept = [];\n\n    // 7. Let k be 0.\n    let k = 0;\n\n    // 8. Let captured be 0.\n    let captured = 0;\n\n    // 9. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, Pk);\n\n      // c. Let selected be ToBoolean(? Call(callbackfn, T,  kValue, k, O )).\n      let selected = To.ToBooleanPartial(realm, Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]));\n\n      // d. If selected is true, then\n      if (selected === true) {\n        // i. Append kValue to the end of kept.\n        kept.push(kValue);\n\n        // ii. Increase captured by 1.\n        captured += 1;\n      }\n\n      // e. Increase k by 1.\n      k += 1;\n    }\n\n    // 10. Let A be ? TypedArraySpeciesCreate(O,  captured ).\n    let A = TypedArraySpeciesCreate(realm, O, [new NumberValue(realm, captured)]);\n\n    // 11. Let n be 0.\n    let n = 0;\n\n    // 12. For each element e of kept\n    for (let e of kept) {\n      // a. Perform ! Set(A, ! ToString(n), e, true).\n      Properties.Set(realm, A, new StringValue(realm, To.ToString(realm, new NumberValue(realm, n))), e, true);\n\n      // b. Increment n by 1.\n      n = n + 1;\n    }\n\n    // 13. Return A.\n    return A;\n  });\n\n  // ECMA262 22.2.3.10\n  obj.defineNativeMethod(\"find\", 1, (context, [predicate, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(predicate) is false, throw a TypeError exception.\n    if (!IsCallable(realm, predicate)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, Pk);\n\n      // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).\n      let testResult = To.ToBooleanPartial(realm, Call(realm, predicate, T, [kValue, new NumberValue(realm, k), O]));\n\n      // d. If testResult is true, return kValue.\n      if (testResult) return kValue;\n\n      // e. Increase k by 1.\n      k++;\n    }\n\n    // 8. Return undefined.\n    return realm.intrinsics.undefined;\n  });\n\n  // ECMA262 22.2.3.11\n  obj.defineNativeMethod(\"findIndex\", 1, (context, [predicate, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(predicate) is false, throw a TypeError exception.\n    if (IsCallable(realm, predicate) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg ? thisArg : realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, new StringValue(realm, Pk));\n\n      // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).\n      let testResult = To.ToBooleanPartial(realm, Call(realm, predicate, T, [kValue, new NumberValue(realm, k), O]));\n\n      // d. If testResult is true, return k.\n      if (testResult === true) return new NumberValue(realm, k);\n\n      // e. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 8. Return -1.\n    return new NumberValue(realm, -1);\n  });\n\n  // ECMA262 22.2.3.12\n  obj.defineNativeMethod(\"forEach\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Perform ? Call(callbackfn, T,  kValue, k, O ).\n        Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]);\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 8. Return undefined.\n    return realm.intrinsics.undefined;\n  });\n\n  // ECMA262 22.2.3.14\n  obj.defineNativeMethod(\"includes\", 1, (context, [searchElement, fromIndex]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If len is 0, return false.\n    if (len === 0) return realm.intrinsics.false;\n\n    // 5. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)\n    let n = To.ToInteger(realm, fromIndex || realm.intrinsics.undefined);\n\n    let k;\n    // 6. If n  0, then\n    if (n >= 0) {\n      // a. Let k be n.\n      k = n;\n    } else {\n      // 7. Else n < 0,\n      // a. Let k be len + n.\n      k = len + n;\n      // b. If k < 0, let k be 0.\n      if (k < 0) k = 0;\n    }\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n      // a. Let elementK be the result of ? Get(O, ! ToString(k)).\n      let elementK = Get(realm, O, To.ToString(realm, new NumberValue(realm, k)));\n\n      // b. If SameValueZero(searchElement, elementK) is true, return true.\n      if (SameValueZeroPartial(realm, searchElement, elementK) === true) return realm.intrinsics.true;\n\n      // c. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 9. Return false.\n    return realm.intrinsics.false;\n  });\n\n  // ECMA262 22.2.3.14\n  obj.defineNativeMethod(\"indexOf\", 1, (context, [searchElement, fromIndex]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If len is 0, return -1.\n    if (len === 0) return new NumberValue(realm, -1);\n\n    // 5. Let n be ? ToInteger(fromIndex). (If fromIndex is undefined, this step produces the value 0.)\n    let n = fromIndex ? To.ToInteger(realm, fromIndex) : 0;\n\n    // 6. If n  len, return -1.\n    if (n >= len) return new NumberValue(realm, -1);\n\n    // 7. If n  0, then\n    let k;\n    if (n >= 0) {\n      // a. If n is -0, let k be +0; else let k be n.\n      k = Object.is(n, -0) ? +0 : n;\n    } else {\n      // 8. Else n < 0,\n      // a. Let k be len + n.\n      k = len + n;\n\n      // b. If k < 0, let k be 0.\n      if (k < 0) k = 0;\n    }\n\n    // 9. Repeat, while k < len\n    while (k < len) {\n      // a. Let kPresent be ? HasProperty(O, ! ToString(k)).\n      let kPresent = HasProperty(realm, O, k + \"\");\n\n      // b. If kPresent is true, then\n      if (kPresent === true) {\n        // i. Let elementK be ? Get(O, ! ToString(k)).\n        let elementK = Get(realm, O, k + \"\");\n\n        // ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.\n        let same = StrictEqualityComparisonPartial(realm, searchElement, elementK);\n\n        // iii. If same is true, return k.\n        if (same) return new NumberValue(realm, k);\n      }\n\n      // c. Increase k by 1.\n      k++;\n    }\n\n    // 10. Return -1.\n    return new NumberValue(realm, -1);\n  });\n\n  // ECMA262 22.2.3.15\n  obj.defineNativeMethod(\"join\", 1, (context, [_separator]) => {\n    let separator = _separator;\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If separator is undefined, let separator be the single-element String \",\".\n    if (!separator || separator instanceof UndefinedValue) separator = new StringValue(realm, \",\");\n\n    // 5. Let sep be ? ToString(separator).\n    let sep = To.ToStringPartial(realm, separator);\n\n    // 6. If len is zero, return the empty String.\n    if (len === 0) return realm.intrinsics.emptyString;\n\n    // 7. Let element0 be Get(O, \"0\").\n    let element0 = Get(realm, O, \"0\");\n\n    // 8. If element0 is undefined or null, let R be the empty String; otherwise, let R be ? ToString(element0).\n    let R: ?string;\n    if (HasSomeCompatibleType(element0, UndefinedValue, NullValue)) {\n      R = \"\";\n    } else {\n      R = To.ToStringPartial(realm, element0);\n    }\n\n    // 9. Let k be 1.\n    let k = 1;\n\n    // 10. Repeat, while k < len\n    while (k < len) {\n      // a. Let S be the String value produced by concatenating R and sep.\n      let S: string = R + sep;\n\n      // b. Let element be ? Get(O, ! ToString(k)).\n      let element = Get(realm, O, new StringValue(realm, k + \"\"));\n\n      // c. If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).\n      let next: ?string;\n      if (HasSomeCompatibleType(element, UndefinedValue, NullValue)) {\n        next = \"\";\n      } else {\n        next = To.ToStringPartial(realm, element);\n      }\n\n      // d. Let R be a String value produced by concatenating S and next.\n      R = S + next;\n\n      // e. Increase k by 1.\n      k++;\n    }\n\n    // 11. Return R.\n    return new StringValue(realm, R + \"\");\n  });\n\n  // ECMA262 22.2.3.16\n  obj.defineNativeMethod(\"keys\", 0, context => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Return CreateArrayIterator(O, \"key\").\n    return Create.CreateArrayIterator(realm, O, \"key\");\n  });\n\n  // ECMA262 22.2.3.17\n  obj.defineNativeMethod(\"lastIndexOf\", 1, (context, [searchElement, fromIndex]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If len is 0, return -1.\n    if (len === 0) return new NumberValue(realm, -1);\n\n    // 5. If argument fromIndex was passed, let n be ? ToInteger(fromIndex); else let n be len-1.\n    let n = fromIndex ? To.ToInteger(realm, fromIndex) : len - 1;\n\n    // 6. If n  0, then\n    let k;\n    if (n >= 0) {\n      // a. If n is -0, let k be +0; else let k be min(n, len - 1).\n      k = Object.is(n, -0) ? +0 : Math.min(n, len - 1);\n    } else {\n      // 7. Else n < 0,\n      // a. Let k be len + n.\n      k = len + n;\n    }\n\n    // 8. Repeat, while k  0\n    while (k >= 0) {\n      // a. Let kPresent be ? HasProperty(O, ! ToString(k)).\n      let kPresent = HasProperty(realm, O, new StringValue(realm, k + \"\"));\n\n      // b. If kPresent is true, then\n      if (kPresent) {\n        // i. Let elementK be ? Get(O, ! ToString(k)).\n        let elementK = Get(realm, O, new StringValue(realm, k + \"\"));\n\n        // ii. Let same be the result of performing Strict Equality Comparison searchElement === elementK.\n        let same = StrictEqualityComparisonPartial(realm, searchElement, elementK);\n\n        // iii. If same is true, return k.\n        if (same) return new NumberValue(realm, k);\n      }\n\n      // c. Decrease k by 1.\n      k--;\n    }\n\n    // 9. Return -1.\n    return new NumberValue(realm, -1);\n  });\n\n  // ECMA262 22.2.3.18\n  obj.defineNativeGetter(\"length\", context => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, throw a TypeError exception.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!(\"$TypedArrayName\" in O)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"O does not have a [[TypedArrayName]] internal slot\"\n      );\n    }\n\n    // 4. Assert: O has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]] internal slot\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer;\n    invariant(buffer);\n\n    // 6. If IsDetachedBuffer(buffer) is true, return 0.\n    if (IsDetachedBuffer(realm, buffer) === true) return realm.intrinsics.zero;\n\n    // 7. Let length be O.[[ArrayLength]].\n    let length = O.$ArrayLength;\n    invariant(typeof length === \"number\");\n\n    // 8. Return length.\n    return new NumberValue(realm, length);\n  });\n\n  // ECMA262 22.2.3.19\n  obj.defineNativeMethod(\"map\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (IsCallable(realm, callbackfn) === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsCallable(callbackfn) is false\");\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg ? thisArg : realm.intrinsics.undefined;\n\n    // 6. Let A be ? TypedArraySpeciesCreate(O,  len ).\n    let A = TypedArraySpeciesCreate(realm, O, [new NumberValue(realm, len)]);\n\n    // 7. Let k be 0.\n    let k = 0;\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n      // b. Let kValue be ? Get(O, Pk).\n      let kValue = Get(realm, O, Pk);\n\n      // c. Let mappedValue be ? Call(callbackfn, T,  kValue, k, O ).\n      let mappedValue = Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]);\n\n      // d. Perform ? Set(A, Pk, mappedValue, true).\n      Properties.Set(realm, A, Pk, mappedValue, true);\n\n      // e. Increase k by 1.\n      k = k + 1;\n    }\n\n    // 9. Return A.\n    return A;\n  });\n\n  // ECMA262 22.2.3.20\n  obj.defineNativeMethod(\"reduce\", 1, (context, [callbackfn, initialValue]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If len is 0 and initialValue is not present, throw a TypeError exception.\n    if (len === 0 && !initialValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Array.prototype\");\n    }\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. If initialValue is present, then\n    let accumulator;\n    if (initialValue) {\n      // a. Set accumulator to initialValue.\n      accumulator = initialValue;\n    } else {\n      // 8. Else initialValue is not present,\n      // a. Let kPresent be false.\n      let kPresent = false;\n\n      // b. Repeat, while kPresent is false and k < len\n      while (kPresent === false && k < len) {\n        // i. Let Pk be ! ToString(k).\n        let Pk = new StringValue(realm, k + \"\");\n\n        // ii. Let kPresent be ? HasProperty(O, Pk).\n        kPresent = HasProperty(realm, O, Pk);\n\n        // iv. If kPresent is true, then\n        if (kPresent) {\n          // 1. Let accumulator be ? Get(O, Pk).\n          accumulator = Get(realm, O, Pk);\n        }\n\n        // v. Increase k by 1.\n        k++;\n      }\n\n      // c. If kPresent is false, throw a TypeError exception.\n      if (!kPresent) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"kPresent is false\");\n      }\n\n      invariant(accumulator);\n    }\n\n    // 9. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let accumulator be ? Call(callbackfn, undefined,  accumulator, kValue, k, O ).\n        accumulator = Call(realm, callbackfn, realm.intrinsics.undefined, [\n          accumulator,\n          kValue,\n          new NumberValue(realm, k),\n          O,\n        ]);\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 10. Return accumulator.\n    return accumulator;\n  });\n\n  // ECMA262 22.2.3.21\n  obj.defineNativeMethod(\"reduceRight\", 1, (context, [callbackfn, initialValue]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. If len is 0 and initialValue is not present, throw a TypeError exception.\n    if (len === 0 && !initialValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Array.prototype\");\n    }\n\n    // 6. Let k be len-1.\n    let k = len - 1;\n\n    // 7. If initialValue is present, then\n    let accumulator;\n    if (initialValue) {\n      // 1. Set accumulator to initialValue.\n      accumulator = initialValue;\n    } else {\n      // 8. Else initialValue is not present,\n      // a. Let kPresent be false.\n      let kPresent = false;\n\n      // b. Repeat, while kPresent is false and k  0\n      while (!kPresent && k >= 0) {\n        // i. Let Pk be ! ToString(k).\n        let Pk = new StringValue(realm, k + \"\");\n\n        // ii. Let kPresent be ? HasProperty(O, Pk).\n        kPresent = HasProperty(realm, O, Pk);\n\n        // iii. If kPresent is true, then\n        if (kPresent) {\n          // 1. Let accumulator be ? Get(O, Pk).\n          accumulator = Get(realm, O, Pk);\n        }\n\n        // iv. Decrease k by 1.\n        k--;\n      }\n\n      // c. If kPresent is false, throw a TypeError exception.\n      if (!kPresent || !accumulator) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Array.prototype\");\n      }\n    }\n\n    // 9. Repeat, while k  0\n    while (k >= 0) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let accumulator be ? Call(callbackfn, undefined,  accumulator, kValue, k, O ).\n        accumulator = Call(realm, callbackfn, realm.intrinsics.undefined, [\n          accumulator,\n          kValue,\n          new NumberValue(realm, k),\n          O,\n        ]);\n      }\n\n      // d. Decrease k by 1.\n      k--;\n    }\n\n    // 10. Return accumulator.\n    return accumulator;\n  });\n\n  // ECMA262 22.2.3.21\n  obj.defineNativeMethod(\"reverse\", 0, context => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. Let middle be floor(len/2).\n    let middle = Math.floor(len / 2);\n\n    // 5. Let lower be 0.\n    let lower = 0;\n\n    // 6. Repeat, while lower  middle\n    while (lower !== middle) {\n      // a. Let upper be len - lower - 1.\n      let upper = len - lower - 1;\n\n      // b. Let upperP be ! ToString(upper).\n      let upperP = new StringValue(realm, upper + \"\");\n\n      // c. Let lowerP be ! ToString(lower).\n      let lowerP = new StringValue(realm, lower + \"\");\n\n      // d. Let lowerExists be ? HasProperty(O, lowerP).\n      let lowerExists = HasProperty(realm, O, lowerP);\n\n      // e. If lowerExists is true, then\n      let lowerValue;\n      if (lowerExists) {\n        // i. Let lowerValue be ? Get(O, lowerP).\n        lowerValue = Get(realm, O, lowerP);\n      }\n\n      // f. Let upperExists be ? HasProperty(O, upperP).\n      let upperExists = HasProperty(realm, O, upperP);\n\n      // g. If upperExists is true, then\n      let upperValue;\n      if (upperExists) {\n        // i. Let upperValue be ? Get(O, upperP).\n        upperValue = Get(realm, O, upperP);\n      }\n\n      // h. If lowerExists is true and upperExists is true, then\n      if (lowerExists && upperExists) {\n        invariant(lowerValue, \"expected lower value to exist\");\n        invariant(upperValue, \"expected upper value to exist\");\n\n        // i. Perform ? Set(O, lowerP, upperValue, true).\n        Properties.Set(realm, O, lowerP, upperValue, true);\n\n        // ii. Perform ? Set(O, upperP, lowerValue, true).\n        Properties.Set(realm, O, upperP, lowerValue, true);\n      } else if (!lowerExists && upperExists) {\n        // i. Else if lowerExists is false and upperExists is true, then\n        invariant(upperValue, \"expected upper value to exist\");\n\n        // i. Perform ? Set(O, lowerP, upperValue, true).\n        Properties.Set(realm, O, lowerP, upperValue, true);\n\n        // ii. Perform ? DeletePropertyOrThrow(O, upperP).\n        Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), upperP);\n      } else if (lowerExists && !upperExists) {\n        // j. Else if lowerExists is true and upperExists is false, then\n        invariant(lowerValue, \"expected lower value to exist\");\n\n        // i. Perform ? DeletePropertyOrThrow(O, lowerP).\n        Properties.DeletePropertyOrThrow(realm, O.throwIfNotConcreteObject(), lowerP);\n\n        // ii. Perform ? Set(O, upperP, lowerValue, true).\n        Properties.Set(realm, O, upperP, lowerValue, true);\n      } else {\n        // k. Else both lowerExists and upperExists are false,\n        // i. No action is required.\n      }\n\n      // l. Increase lower by 1.\n      lower++;\n    }\n\n    // 7. Return O.\n    return O;\n  });\n\n  // ECMA262 22.2.3.23\n  obj.defineNativeMethod(\"set\", 1, (context, [overloaded, offset]) => {\n    if (overloaded.$TypedArrayName === undefined) {\n      let array = overloaded;\n\n      // 1. Assert: array is any ECMAScript language value other than an Object with a [[TypedArrayName]] internal slot. If it is such an Object, the definition in 22.2.3.23.2 applies.\n      invariant(!(overloaded instanceof ObjectValue && overloaded.$TypedArrayName));\n\n      // 2. Let target be the this value.\n      let target = context.throwIfNotConcrete();\n\n      // 3. If Type(target) is not Object, throw a TypeError exception.\n      if (!(target instanceof ObjectValue)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(target) is not Object\");\n      }\n\n      // 4. If target does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n      if (typeof target.$TypedArrayName !== \"string\") {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"target does not have a [[TypedArrayName]] internal slot\"\n        );\n      }\n\n      // 5. Assert: target has a [[ViewedArrayBuffer]] internal slot.\n      invariant(target.$ViewedArrayBuffer, \"target has a [[ViewedArrayBuffer]] internal slot\");\n\n      // 6. Let targetOffset be ? ToInteger(offset).\n      let targetOffset = To.ToInteger(realm, offset || realm.intrinsics.undefined);\n\n      // 7. If targetOffset < 0, throw a RangeError exception.\n      if (targetOffset < 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"targetOffset < 0\");\n      }\n\n      // 8. Let targetBuffer be target.[[ViewedArrayBuffer]].\n      let targetBuffer = target.$ViewedArrayBuffer;\n      invariant(targetBuffer instanceof ObjectValue);\n\n      // 9. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, targetBuffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(targetBuffer) is true\");\n      }\n\n      // 10. Let targetLength be target.[[ArrayLength]].\n      let targetLength = target.$ArrayLength;\n      invariant(typeof targetLength === \"number\");\n\n      // 11. Let targetName be the String value of target.[[TypedArrayName]].\n      let targetName = target.$TypedArrayName;\n      invariant(typeof targetName === \"string\");\n\n      // 12. Let targetElementSize be the Number value of the Element Size value specified in Table 50 for targetName.\n      let targetElementSize = ArrayElementSize[targetName];\n\n      // 13. Let targetType be the String value of the Element Type value in Table 50 for targetName.\n      let targetType = ArrayElementType[targetName];\n\n      // 14. Let targetByteOffset be target.[[ByteOffset]].\n      let targetByteOffset = target.$ByteOffset;\n      invariant(typeof targetByteOffset === \"number\");\n\n      // 15. Let src be ? ToObject(array).\n      let src = To.ToObject(realm, array);\n\n      // 16. Let srcLength be ? ToLength(? Get(src, \"length\")).\n      let srcLength = To.ToLength(realm, Get(realm, src, \"length\"));\n\n      // 17. If srcLength + targetOffset > targetLength, throw a RangeError exception.\n      if (srcLength + targetOffset > targetLength) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"srcLength + targetOffset > targetLength\");\n      }\n\n      // 18. Let targetByteIndex be targetOffset  targetElementSize + targetByteOffset.\n      let targetByteIndex = targetOffset * targetElementSize + targetByteOffset;\n\n      // 19. Let k be 0.\n      let k = 0;\n\n      // 20. Let limit be targetByteIndex + targetElementSize  srcLength.\n      let limit = targetByteIndex + targetElementSize * srcLength;\n\n      // 21. Repeat, while targetByteIndex < limit\n      while (targetByteIndex < limit) {\n        // a. Let Pk be ! ToString(k).\n        let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n        // b. Let kNumber be ? ToNumber(? Get(src, Pk)).\n        let kNumber = To.ToNumber(realm, Get(realm, src, Pk));\n\n        // c. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.\n        if (IsDetachedBuffer(realm, targetBuffer) === true) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(targetBuffer) is true\");\n        }\n\n        // d. Perform SetValueInBuffer(targetBuffer, targetByteIndex, targetType, kNumber).\n        SetValueInBuffer(realm, targetBuffer, targetByteIndex, targetType, kNumber);\n\n        // e. Set k to k + 1.\n        k = k + 1;\n\n        // f. Set targetByteIndex to targetByteIndex + targetElementSize.\n        targetByteIndex = targetByteIndex + targetElementSize;\n      }\n\n      // 22. Return undefined.\n      return realm.intrinsics.undefined;\n    } else {\n      let typedArray = overloaded;\n\n      // 1. Assert: typedArray has a [[TypedArrayName]] internal slot. If it does not, the definition in 22.2.3.23.1 applies.\n      invariant(typedArray instanceof ObjectValue && typedArray.$TypedArrayName);\n\n      // 2. Let target be the this value.\n      let target = context.throwIfNotConcrete();\n\n      // 3. If Type(target) is not Object, throw a TypeError exception.\n      if (!(target instanceof ObjectValue)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(target) is not Object\");\n      }\n\n      // 4. If target does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n      if (typeof target.$TypedArrayName !== \"string\") {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"target does not have a [[TypedArrayName]] internal slot\"\n        );\n      }\n\n      // 5. Assert: target has a [[ViewedArrayBuffer]] internal slot.\n      invariant(target.$ViewedArrayBuffer);\n\n      // 6. Let targetOffset be ? ToInteger(offset).\n      let targetOffset = To.ToInteger(realm, offset || realm.intrinsics.undefined);\n\n      // 7. If targetOffset < 0, throw a RangeError exception.\n      if (targetOffset < 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"targetOffset < 0\");\n      }\n\n      // 8. Let targetBuffer be target.[[ViewedArrayBuffer]].\n      let targetBuffer = target.$ViewedArrayBuffer;\n      invariant(targetBuffer instanceof ObjectValue);\n\n      // 9. If IsDetachedBuffer(targetBuffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, targetBuffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(targetBuffer) is true\");\n      }\n\n      // 10. Let targetLength be target.[[ArrayLength]].\n      let targetLength = target.$ArrayLength;\n      invariant(typeof targetLength === \"number\");\n\n      // 11. Let srcBuffer be typedArray.[[ViewedArrayBuffer]].\n      let srcBuffer = typedArray.$ViewedArrayBuffer;\n      invariant(srcBuffer);\n\n      // 12. If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, srcBuffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(srcBuffer) is true\");\n      }\n\n      // 13. Let targetName be the String value of target.[[TypedArrayName]].\n      let targetName = target.$TypedArrayName;\n      invariant(typeof targetName === \"string\");\n\n      // 14. Let targetType be the String value of the Element Type value in Table 50 for targetName.\n      let targetType = ArrayElementType[targetName];\n\n      // 15. Let targetElementSize be the Number value of the Element Size value specified in Table 50 for targetName.\n      let targetElementSize = ArrayElementSize[targetName];\n\n      // 16. Let targetByteOffset be target.[[ByteOffset]].\n      let targetByteOffset = target.$ByteOffset;\n      invariant(typeof targetByteOffset === \"number\");\n\n      // 17. Let srcName be the String value of typedArray.[[TypedArrayName]].\n      let srcName = typedArray.$TypedArrayName;\n      invariant(typeof srcName === \"string\");\n\n      // 18. Let srcType be the String value of the Element Type value in Table 50 for srcName.\n      let srcType = ArrayElementType[srcName];\n\n      // 19. Let srcElementSize be the Number value of the Element Size value specified in Table 50 for srcName.\n      let srcElementSize = ArrayElementSize[srcName];\n\n      // 20. Let srcLength be typedArray.[[ArrayLength]].\n      let srcLength = typedArray.$ArrayLength;\n      invariant(typeof srcLength === \"number\");\n\n      // 21. Let srcByteOffset be typedArray.[[ByteOffset]].\n      let srcByteOffset = typedArray.$ByteOffset;\n      invariant(typeof srcByteOffset === \"number\");\n\n      // 22. If srcLength + targetOffset > targetLength, throw a RangeError exception.\n      if (srcLength + targetOffset > targetLength) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"srcLength + targetOffset > targetLength\");\n      }\n\n      let srcByteIndex;\n      // 23. If SameValue(srcBuffer, targetBuffer) is true, then\n      if (SameValue(realm, srcBuffer, targetBuffer) === true) {\n        // a. Let srcBuffer be ? CloneArrayBuffer(targetBuffer, srcByteOffset, %ArrayBuffer%).\n        srcBuffer = CloneArrayBuffer(realm, targetBuffer, srcByteOffset, realm.intrinsics.ArrayBuffer);\n\n        // b. NOTE: %ArrayBuffer% is used to clone srcBuffer because is it known to not have any observable side-effects.\n\n        // c. Let srcByteIndex be 0.\n        srcByteIndex = 0;\n      } else {\n        // 24. Else, let srcByteIndex be srcByteOffset.\n        srcByteIndex = srcByteOffset;\n      }\n\n      // 25. Let targetByteIndex be targetOffset  targetElementSize + targetByteOffset.\n      let targetByteIndex = targetOffset * targetElementSize + targetByteOffset;\n\n      // 26. Let limit be targetByteIndex + targetElementSize  srcLength.\n      let limit = targetByteIndex + targetElementSize * srcLength;\n\n      // 27. If SameValue(srcType, targetType) is true, then\n      if (srcType === targetType) {\n        // a. NOTE: If srcType and targetType are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.\n\n        // b. Repeat, while targetByteIndex < limit\n        while (targetByteIndex < limit) {\n          // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, \"Uint8\").\n          let value = GetValueFromBuffer(realm, srcBuffer, srcByteIndex, \"Uint8\");\n\n          // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, \"Uint8\", value).\n          SetValueInBuffer(realm, targetBuffer, targetByteIndex, \"Uint8\", value.value);\n\n          // iii. Set srcByteIndex to srcByteIndex + 1.\n          srcByteIndex += 1;\n\n          // iv. Set targetByteIndex to targetByteIndex + 1.\n          targetByteIndex += 1;\n        }\n      } else {\n        // 28. Else,\n        // a. Repeat, while targetByteIndex < limit\n        while (targetByteIndex < limit) {\n          // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, srcType).\n          let value = GetValueFromBuffer(realm, srcBuffer, srcByteIndex, srcType);\n\n          // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, targetType, value).\n          SetValueInBuffer(realm, targetBuffer, targetByteIndex, targetType, value.value);\n\n          // iii. Set srcByteIndex to srcByteIndex + srcElementSize.\n          srcByteIndex = srcByteIndex + srcElementSize;\n\n          // iv. Set targetByteIndex to targetByteIndex + targetElementSize.\n          targetByteIndex = targetByteIndex + targetElementSize;\n        }\n      }\n\n      // 29. Return undefined.\n      return realm.intrinsics.undefined;\n    }\n  });\n\n  // ECMA262 22.2.3.24\n  obj.defineNativeMethod(\"slice\", 2, (context, [start, end]) => {\n    // 1. Let O be the this value.\n    let O = context;\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n    invariant(O instanceof ObjectValue);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. Let relativeStart be ? ToInteger(start).\n    let relativeStart = To.ToInteger(realm, start);\n\n    // 5. If relativeStart < 0, let k be max((len + relativeStart), 0); else let k be min(relativeStart, len).\n    let k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n\n    // 6. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToInteger(end).\n    let relativeEnd = !end || end instanceof UndefinedValue ? len : To.ToInteger(realm, end.throwIfNotConcrete());\n\n    // 7. If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let final be min(relativeEnd, len).\n    let final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n    // 8. Let count be max(final - k, 0).\n    let count = Math.max(final - k, 0);\n\n    // 9. Let A be ? TypedArraySpeciesCreate(O,  count ).\n    let A = TypedArraySpeciesCreate(realm, O, [new NumberValue(realm, count)]);\n\n    // 10. Let srcName be the String value of O.[[TypedArrayName]].\n    let srcName = O.$TypedArrayName;\n    invariant(typeof srcName === \"string\");\n\n    // 11. Let srcType be the String value of the Element Type value in Table 50 for srcName.\n    let srcType = ArrayElementType[srcName];\n\n    // 12. Let targetName be the String value of A.[[TypedArrayName]].\n    let targetName = A.$TypedArrayName;\n    invariant(typeof targetName === \"string\");\n\n    // 13. Let targetType be the String value of the Element Type value in Table 50 for targetName.\n    let targetType = ArrayElementType[targetName];\n\n    // 14. If SameValue(srcType, targetType) is false, then\n    if (srcType !== targetType) {\n      // a. Let n be 0.\n      let n = 0;\n\n      // b. Repeat, while k < final\n      while (k < final) {\n        // i. Let Pk be ! ToString(k).\n        let Pk = To.ToString(realm, new NumberValue(realm, k));\n\n        // ii. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // iii. Perform ! Set(A, ! ToString(n), kValue).\n        Properties.Set(realm, A, To.ToString(realm, new NumberValue(realm, n)), kValue, true);\n\n        // iv. Increase k by 1.\n        k += 1;\n\n        // v. Increase n by 1.\n        n += 1;\n      }\n    } else if (count > 0) {\n      // 15. Else if count > 0, then\n      // a. Let srcBuffer be O.[[ViewedArrayBuffer]].\n      let srcBuffer = O.$ViewedArrayBuffer;\n      invariant(srcBuffer);\n\n      // b. If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.\n      if (IsDetachedBuffer(realm, srcBuffer) === true) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsDetachedBuffer(srcBuffer) is true\");\n      }\n\n      // c. Let targetBuffer be A.[[ViewedArrayBuffer]].\n      let targetBuffer = A.$ViewedArrayBuffer;\n      invariant(targetBuffer instanceof ObjectValue);\n\n      // d. Let elementSize be the Number value of the Element Size value specified in Table 50 for srcType.\n      let elementSize = ElementSize[srcType];\n\n      // e. NOTE: If srcType and targetType are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.\n\n      // f. Let srcByteOffset be O.[[ByteOffset]].\n      let srcByteOffset = O.$ByteOffset;\n      invariant(typeof srcByteOffset === \"number\");\n\n      // g. Let targetByteIndex be A.[[ByteOffset]].\n      let targetByteIndex = A.$ByteOffset;\n      invariant(typeof targetByteIndex === \"number\");\n\n      // h. Let srcByteIndex be (k  elementSize) + srcByteOffset.\n      let srcByteIndex = k * elementSize + srcByteOffset;\n\n      // i. Let limit be targetByteIndex + count  elementSize.\n      let limit = targetByteIndex + count * elementSize;\n\n      // j. Repeat, while targetByteIndex < limit\n      while (targetByteIndex < limit) {\n        // i. Let value be GetValueFromBuffer(srcBuffer, srcByteIndex, \"Uint8\").\n        let value = GetValueFromBuffer(realm, srcBuffer, srcByteIndex, \"Uint8\");\n\n        // ii. Perform SetValueInBuffer(targetBuffer, targetByteIndex, \"Uint8\", value).\n        SetValueInBuffer(realm, targetBuffer, targetByteIndex, \"Uint8\", value.value);\n\n        // iii. Increase srcByteIndex by 1.\n        srcByteIndex += 1;\n\n        // iv. Increase targetByteIndex by 1.\n        targetByteIndex += 1;\n      }\n    }\n\n    // 16. Return A.\n    return A;\n  });\n\n  // ECMA262 22.2.3.25\n  obj.defineNativeMethod(\"some\", 1, (context, [callbackfn, thisArg]) => {\n    // 1. Let O be ? ToObject(this value).\n    let O = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(O).\n    ValidateTypedArray(realm, O);\n\n    // 3. Let len be O.[[ArrayLength]].\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (!IsCallable(realm, callbackfn)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"callback passed to Array.prototype.some isn't callable\"\n      );\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    let T = thisArg || realm.intrinsics.undefined;\n\n    // 6. Let k be 0.\n    let k = 0;\n\n    // 7. Repeat, while k < len\n    while (k < len) {\n      // a. Let Pk be ! ToString(k).\n      let Pk = new StringValue(realm, k + \"\");\n\n      // b. Let kPresent be ? HasProperty(O, Pk).\n      let kPresent = HasProperty(realm, O, Pk);\n\n      // c. If kPresent is true, then\n      if (kPresent) {\n        // i. Let kValue be ? Get(O, Pk).\n        let kValue = Get(realm, O, Pk);\n\n        // ii. Let testResult be ToBoolean(? Call(callbackfn, T,  kValue, k, O )).\n        let testResult = To.ToBooleanPartial(realm, Call(realm, callbackfn, T, [kValue, new NumberValue(realm, k), O]));\n\n        // iii. If testResult is true, return true.\n        if (testResult) return realm.intrinsics.true;\n      }\n\n      // d. Increase k by 1.\n      k++;\n    }\n\n    // 8. Return false.\n    return realm.intrinsics.false;\n  });\n\n  // ECMA262 22.2.3.26\n  obj.defineNativeMethod(\"sort\", 1, (context, [comparefn]) => {\n    // 1. Let obj be the this value.\n    let O = To.ToObject(realm, context);\n\n    // 2. Let buffer be ? ValidateTypedArray(obj).\n    let buffer = ValidateTypedArray(realm, O);\n\n    // 3. Let len be the value of obj's [[ArrayLength]] internal slot.\n    let len = O.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 22.2.3.26 Runtime Semantics: SortCompare( x, y )#\n    let SortCompare = (x, y) => {\n      // 1. Assert: Both Type(x) and Type(y) is Number.\n      invariant(x instanceof NumberValue);\n      invariant(y instanceof NumberValue);\n\n      // 2. If the argument comparefn is not undefined, then\n      if (!comparefn.mightBeUndefined()) {\n        // a. Let v be ? Call(comparefn, undefined,  x, y ).\n        let v = Call(realm, comparefn, realm.intrinsics.undefined, [x, y]);\n\n        // b. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.\n        if (IsDetachedBuffer(realm, buffer) === true)\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"array buffer has been detached\");\n\n        // c. If v is NaN, return +0.\n        if (v instanceof NumberValue && isNaN(v.value)) return realm.intrinsics.zero;\n\n        // d. Return v.\n        return v;\n      }\n      comparefn.throwIfNotConcrete();\n\n      // If x and y are both NaN, return +0.\n      // If x is NaN, return 1.\n      if (isNaN(x.value)) {\n        if (isNaN(y.value)) return realm.intrinsics.zero;\n        return new NumberValue(realm, 1);\n      }\n\n      // If y is NaN, return -1.\n      if (isNaN(y.value)) return new NumberValue(realm, -1);\n\n      // If x < y, return -1.\n      if (x.value < y.value) return new NumberValue(realm, -1);\n\n      // If x > y, return 1.\n      if (x.value > y.value) return new NumberValue(realm, +1);\n\n      // If x is -0 and y is +0, return -1.\n      if (Object.is(x.value, -0) && Object.is(y.value, +0)) return new NumberValue(realm, -1);\n\n      // If x is +0 and y is -0, return 1.\n      if (Object.is(x.value, +0) && Object.is(y.value, -0)) return new NumberValue(realm, 1);\n\n      // Return +0.\n      return realm.intrinsics.zero;\n    };\n\n    //1. Perform an implementation-dependent sequence of calls to the [[Get]] and [[Set]] internal methods of obj, to the DeletePropertyOrThrow and HasOwnProperty abstract operation with obj as the first argument, and to SortCompare (described below), such that:\n    //   The property key argument for each call to [[Get]], [[Set]], HasOwnProperty, or DeletePropertyOrThrow is the string representation of a nonnegative integer less than len.\n\n    // We leverage the underlying implementation sort by copying the element in a temp. array, sorting it, and\n    // transfering back the value inside the our array.\n\n    // We need to adapt the comparefn function to match the expected types\n    let comparefn_ = (x, y) => {\n      invariant(x instanceof NumberValue, \"Unexpected type\");\n      invariant(y instanceof NumberValue, \"Unexpected type\");\n\n      let result_ = SortCompare(x, y);\n      let numb = To.ToNumber(realm, result_);\n      return numb;\n    };\n\n    let arr = [];\n    for (let j = 0; j < len; j++) {\n      let val = IntegerIndexedElementGet(realm, O.throwIfNotConcreteObject(), j);\n      arr[j] = val;\n    }\n\n    arr.sort(comparefn_);\n\n    //Apply the permutation back to the original array.\n    for (let j = 0; j < len; j++) {\n      IntegerIndexedElementSet(realm, O.throwIfNotConcreteObject(), j, arr[j]);\n    }\n\n    // 2. Return obj;\n    return context;\n  });\n\n  // ECMA262 22.2.3.27\n  obj.defineNativeMethod(\"subarray\", 2, (context, [begin, end]) => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, throw a TypeError exception.\n    if (!(O instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(O) is not Object\");\n    }\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, throw a TypeError exception.\n    if (!(\"$TypedArrayName\" in O)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"O does not have a [[TypedArrayName]] internal slot\"\n      );\n    }\n\n    // 4. Assert: O has a [[ViewedArrayBuffer]] internal slot.\n    invariant(O.$ViewedArrayBuffer, \"O has a [[ViewedArrayBuffer]] internal slot\");\n\n    // 5. Let buffer be O.[[ViewedArrayBuffer]].\n    let buffer = O.$ViewedArrayBuffer;\n    invariant(buffer);\n\n    // 6. Let srcLength be O.[[ArrayLength]].\n    let srcLength = O.$ArrayLength;\n    invariant(typeof srcLength === \"number\");\n\n    // 7. Let relativeBegin be ? ToInteger(begin).\n    let relativeBegin = To.ToInteger(realm, begin);\n\n    // 8. If relativeBegin < 0, let beginIndex be max((srcLength + relativeBegin), 0); else let beginIndex be min(relativeBegin, srcLength).\n    let beginIndex = relativeBegin < 0 ? Math.max(srcLength + relativeBegin, 0) : Math.min(relativeBegin, srcLength);\n\n    // 9. If end is undefined, let relativeEnd be srcLength; else, let relativeEnd be ? ToInteger(end).\n    let relativeEnd = !end || end instanceof UndefinedValue ? srcLength : To.ToInteger(realm, end.throwIfNotConcrete());\n\n    // 10. If relativeEnd < 0, let endIndex be max((srcLength + relativeEnd), 0); else let endIndex be min(relativeEnd, srcLength).\n    let endIndex = relativeEnd < 0 ? Math.max(srcLength + relativeEnd, 0) : Math.min(relativeEnd, srcLength);\n\n    // 11. Let newLength be max(endIndex - beginIndex, 0).\n    let newLength = Math.max(endIndex - beginIndex, 0);\n\n    // 12. Let constructorName be the String value of O.[[TypedArrayName]].\n    let constructorName = O.$TypedArrayName;\n    invariant(typeof constructorName === \"string\");\n\n    // 13. Let elementSize be the Number value of the Element Size value specified in Table 50 for constructorName.\n    let elementSize = ArrayElementSize[constructorName];\n\n    // 14. Let srcByteOffset be O.[[ByteOffset]].\n    let srcByteOffset = O.$ByteOffset;\n    invariant(typeof srcByteOffset === \"number\");\n\n    // 15. Let beginByteOffset be srcByteOffset + beginIndex  elementSize.\n    let beginByteOffset = srcByteOffset + beginIndex * elementSize;\n\n    // 16. Let argumentsList be  buffer, beginByteOffset, newLength .\n    let argumentsList = [buffer, new NumberValue(realm, beginByteOffset), new NumberValue(realm, newLength)];\n\n    // 17. Return ? TypedArraySpeciesCreate(O, argumentsList).\n    return TypedArraySpeciesCreate(realm, O, argumentsList);\n  });\n\n  // ECMA262 22.2.3.28\n  obj.defineNativeMethod(\"toLocaleString\", 0, context => {\n    // 1. Let array be ? ToObject(this value).\n    let array = To.ToObject(realm, context);\n\n    // 2. Perform ? ValidateTypedArray(array).\n    ValidateTypedArray(realm, array);\n\n    // 3. Let len be array.[[ArrayLength]].\n    let len = array.throwIfNotConcreteObject().$ArrayLength;\n    invariant(typeof len === \"number\");\n\n    // 4. Let separator be the String value for the list-separator String appropriate for the host environment's current locale (this is derived in an implementation-defined way).\n    let separator = \",\";\n\n    // 5. If len is zero, return the empty String.\n    if (len === 0) return realm.intrinsics.emptyString;\n\n    // 6. Let firstElement be ? Get(array, \"0\").\n    let firstElement = Get(realm, array, \"0\");\n\n    // 7. If firstElement is undefined or null, then\n    let R: ?string;\n    if (HasSomeCompatibleType(firstElement, UndefinedValue, NullValue)) {\n      // a. Let R be the empty String.\n      R = \"\";\n    } else {\n      // 8. Else,\n      // a. Let R be ? ToString(? Invoke(firstElement, \"toLocaleString\")).\n      R = To.ToStringPartial(realm, Invoke(realm, firstElement, \"toLocaleString\"));\n    }\n\n    // 9. Let k be 1.\n    let k = 1;\n\n    // 10. Repeat, while k < len\n    while (k < len) {\n      // a. Let S be a String value produced by concatenating R and separator.\n      let S: string = R + separator;\n\n      // b. Let nextElement be ? Get(array, ! ToString(k)).\n      let nextElement = Get(realm, array, new StringValue(realm, k + \"\"));\n\n      // c. If nextElement is undefined or null, then\n      if (HasSomeCompatibleType(nextElement, UndefinedValue, NullValue)) {\n        // i. Let R be the empty String.\n        R = \"\";\n      } else {\n        // d. Else,\n        // i. Let R be ? ToString(? Invoke(nextElement, \"toLocaleString\")).\n        R = To.ToStringPartial(realm, Invoke(realm, nextElement, \"toLocaleString\"));\n      }\n\n      // e. Let R be a String value produced by concatenating S and R.\n      R = S + R;\n\n      // f. Increase k by 1.\n      k++;\n    }\n\n    // 11. Return R.\n    return new StringValue(realm, R);\n  });\n\n  // ECMA262 22.2.3.29\n  obj.defineNativeProperty(\"toString\", realm.intrinsics.ArrayProto_toString);\n\n  // ECMA262 22.2.3.30\n  obj.defineNativeProperty(\"values\", realm.intrinsics.TypedArrayProto_values);\n\n  // ECMA262 22.2.3.31\n  obj.defineNativeProperty(realm.intrinsics.SymbolIterator, realm.intrinsics.TypedArrayProto_values);\n\n  // ECMA262 22.2.3.32\n  obj.defineNativeGetter(realm.intrinsics.SymbolToStringTag, context => {\n    // 1. Let O be the this value.\n    let O = context.throwIfNotConcrete();\n\n    // 2. If Type(O) is not Object, return undefined.\n    if (!(O instanceof ObjectValue)) return realm.intrinsics.undefined;\n\n    // 3. If O does not have a [[TypedArrayName]] internal slot, return undefined.\n    if (!(\"$TypedArrayName\" in O)) return realm.intrinsics.undefined;\n\n    // 4. Let name be O.[[TypedArrayName]].\n    let name = O.$TypedArrayName;\n\n    // 5. Assert: name is a String value.\n    invariant(typeof name === \"string\", \"name is a String value\");\n\n    // 6. Return name.\n    return new StringValue(realm, name);\n  });\n}\n\nexport function build(realm: Realm, obj: ObjectValue, type: ElementType): void {\n  // ECMA262 22.2.6\n  obj.$Prototype = realm.intrinsics.TypedArrayPrototype;\n\n  // ECMA262 22.2.6.1\n  obj.defineNativeConstant(\"BYTES_PER_ELEMENT\", new NumberValue(realm, ElementSize[type]));\n}\n"],"file":"TypedArrayPrototype.js"}