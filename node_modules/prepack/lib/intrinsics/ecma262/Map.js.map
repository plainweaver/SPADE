{"version":3,"sources":["../../../src/intrinsics/ecma262/Map.js"],"names":["realm","func","NativeFunctionValue","context","_iterable","argCount","NewTarget","iterable","createErrorThrowCompletion","intrinsics","TypeError","map","Create","OrdinaryCreateFromConstructor","$MapData","undefined","isCompatibleWith","MOBILE_JSC_VERSION","iter","adder","NullValue","UndefinedValue","next","nextItem","mightNotBeObject","mightBeObject","throwIfNotConcrete","error","ObjectValue","AbstractObjectValue","k","kCompletion","AbruptCompletion","v","vCompletion","status","statusCompletion","defineNativeGetter","SymbolSpecies"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../../realm.js\";\nimport {\n  AbstractObjectValue,\n  ObjectValue,\n  NativeFunctionValue,\n  NullValue,\n  UndefinedValue,\n} from \"../../values/index.js\";\nimport { AbruptCompletion } from \"../../completions.js\";\nimport {\n  Get,\n  IsCallable,\n  IteratorStep,\n  IteratorClose,\n  IteratorValue,\n  GetIterator,\n  Call,\n  HasSomeCompatibleType,\n} from \"../../methods/index.js\";\nimport { Create } from \"../../singletons.js\";\nimport invariant from \"../../invariant.js\";\n\nexport default function(realm: Realm): NativeFunctionValue {\n  let func = new NativeFunctionValue(realm, \"Map\", \"Map\", 0, (context, [_iterable], argCount, NewTarget) => {\n    let iterable = _iterable;\n    // 1. If NewTarget is undefined, throw a TypeError exception.\n    if (!NewTarget) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 2. Let map be ? OrdinaryCreateFromConstructor(NewTarget, \"%MapPrototype%\", « [[MapData]] »).\n    let map = Create.OrdinaryCreateFromConstructor(realm, NewTarget, \"MapPrototype\", {\n      $MapData: undefined,\n    });\n\n    // 3. Set map's [[MapData]] internal slot to a new empty List.\n    map.$MapData = [];\n\n    // 4. If iterable is not present, let iterable be undefined.\n    if (iterable && realm.isCompatibleWith(realm.MOBILE_JSC_VERSION)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"the map constructor doesn't take arguments\");\n    }\n    if (!iterable) iterable = realm.intrinsics.undefined;\n\n    // 5. If iterable is either undefined or null, let iter be undefined.\n    let iter, adder;\n    if (HasSomeCompatibleType(iterable, NullValue, UndefinedValue)) {\n      adder = realm.intrinsics.undefined;\n      iter = realm.intrinsics.undefined;\n    } else {\n      // 6. Else,\n      // a. Let adder be ? Get(map, \"set\").\n      adder = Get(realm, map, \"set\");\n\n      // b. If IsCallable(adder) is false, throw a TypeError exception.\n      if (!IsCallable(realm, adder)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // c. Let iter be ? GetIterator(iterable).\n      iter = GetIterator(realm, iterable);\n    }\n\n    // 7. If iter is undefined, return map.\n    if (iter instanceof UndefinedValue) return map;\n\n    // 8. Repeat\n    while (true) {\n      // a. Let next be ? IteratorStep(iter).\n      let next = IteratorStep(realm, iter);\n\n      // b. If next is false, return map.\n      if (!next) return map;\n\n      // c. Let nextItem be ? IteratorValue(next).\n      let nextItem = IteratorValue(realm, next);\n\n      // d. If Type(nextItem) is not Object, then\n      if (nextItem.mightNotBeObject()) {\n        if (nextItem.mightBeObject()) nextItem.throwIfNotConcrete();\n        // i. Let error be Completion{[[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty}.\n        let error = realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n\n        // ii. Return ? IteratorClose(iter, error).\n        throw IteratorClose(realm, iter, error);\n      }\n      invariant(nextItem instanceof ObjectValue || nextItem instanceof AbstractObjectValue);\n\n      // e. Let k be Get(nextItem, \"0\").\n      let k;\n      try {\n        k = Get(realm, nextItem, \"0\");\n      } catch (kCompletion) {\n        if (kCompletion instanceof AbruptCompletion) {\n          // f. If k is an abrupt completion, return ? IteratorClose(iter, k).\n          throw IteratorClose(realm, iter, kCompletion);\n        } else throw kCompletion;\n      }\n\n      // g. Let v be Get(nextItem, \"1\").\n      let v;\n      try {\n        v = Get(realm, nextItem, \"1\");\n      } catch (vCompletion) {\n        if (vCompletion instanceof AbruptCompletion) {\n          // h. If v is an abrupt completion, return ? IteratorClose(iter, v).\n          throw IteratorClose(realm, iter, vCompletion);\n        } else throw vCompletion;\n      }\n\n      // i. Let status be Call(adder, map, « k.[[Value]], v.[[Value]] »).\n      let status;\n      try {\n        status = Call(realm, adder, map, [k, v]);\n      } catch (statusCompletion) {\n        if (statusCompletion instanceof AbruptCompletion) {\n          // j. If status is an abrupt completion, return ? IteratorClose(iter, status).\n          throw IteratorClose(realm, iter, statusCompletion);\n        } else throw statusCompletion;\n      }\n      status;\n    }\n\n    invariant(false);\n  });\n\n  // ECMA262 23.1.2.2\n  func.defineNativeGetter(realm.intrinsics.SymbolSpecies, context => {\n    // 1. Return the this value\n    return context;\n  });\n\n  return func;\n}\n"],"file":"Map.js"}