"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("../../values/index.js");

var _abstract = require("../../methods/abstract.js");

var _has = require("../../methods/has.js");

var _call = require("../../methods/call.js");

var _singletons = require("../../singletons.js");

var _errors = require("../../errors.js");

var _invariant = _interopRequireDefault(require("../../invariant.js"));

var _index2 = require("../../domains/index.js");

var _generator = require("../../utils/generator.js");

var _descriptors = require("../../descriptors.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function _default(realm, obj) {
  // ECMA262 19.1.3.2
  const ObjectPrototypeHasOwnPrototype = obj.defineNativeMethod("hasOwnProperty", 1, (context, [V]) => {
    // 1. Let P be ? ToPropertyKey(V).
    let P = _singletons.To.ToPropertyKey(realm, V.throwIfNotConcrete()); // The pure parts are wrapped with a recovery mode.


    try {
      // 2. Let O be ? ToObject(this value).
      let O = _singletons.To.ToObject(realm, context); // 3. Return ? HasOwnProperty(O, P).


      return new _index.BooleanValue(realm, (0, _has.HasOwnProperty)(realm, O, P));
    } catch (x) {
      if (realm.isInPureScope() && x instanceof _errors.FatalError) {
        // If we're in pure scope we can try to recover from any fatals by
        // leaving the call in place which we do by default, but we don't
        // have to leak the state of any arguments since this function is pure.
        // This also lets us define the return type properly.
        const key = typeof P === "string" ? new _index.StringValue(realm, P) : P;
        return realm.evaluateWithPossibleThrowCompletion(() => _index.AbstractValue.createTemporalFromBuildFunction(realm, _index.BooleanValue, [ObjectPrototypeHasOwnPrototype, context, key], (0, _generator.createOperationDescriptor)("OBJECT_PROTO_HAS_OWN_PROPERTY")), _index2.TypesDomain.topVal, _index2.ValuesDomain.topVal);
      }

      throw x;
    }
  }); // ECMA262 19.1.3.3

  obj.defineNativeMethod("isPrototypeOf", 1, (context, [V]) => {
    // 1. If Type(V) is not Object, return false.
    if (!V.mightBeObject()) return realm.intrinsics.false;
    V = V.throwIfNotConcreteObject(); // 2. Let O be ? ToObject(this value).

    let O = _singletons.To.ToObject(realm, context); // 3. Repeat


    while (true) {
      // a. Let V be ? V.[[GetPrototypeOf]]().
      V = V.$GetPrototypeOf(); // b. If V is null, return false.

      if (V instanceof _index.NullValue) return realm.intrinsics.false; // c. If SameValue(O, V) is true, return true.

      if ((0, _abstract.SameValuePartial)(realm, O, V) === true) return realm.intrinsics.true;
    }

    (0, _invariant.default)(false);
  }); // ECMA262 19.1.3.4

  obj.defineNativeMethod("propertyIsEnumerable", 1, (context, [V]) => {
    // 1. Let P be ? ToPropertyKey(V).
    let P = _singletons.To.ToPropertyKey(realm, V.throwIfNotConcrete()); // 2. Let O be ? ToObject(this value).


    let O = _singletons.To.ToObject(realm, context); // 3. Let desc be ? O.[[GetOwnProperty]](P).


    let desc = O.$GetOwnProperty(P); // 4. If desc is undefined, return false.

    if (!desc) return realm.intrinsics.false;

    _singletons.Properties.ThrowIfMightHaveBeenDeleted(desc);

    desc = desc.throwIfNotConcrete(realm); // 5. Return the value of desc.[[Enumerable]].

    return desc.enumerable === undefined ? realm.intrinsics.undefined : new _index.BooleanValue(realm, desc.enumerable);
  }); // ECMA262 19.1.3.5

  obj.defineNativeMethod("toLocaleString", 0, context => {
    // 1. Let O be the this value.
    let O = context; // 2. Return ? Invoke(O, "toString").

    return (0, _call.Invoke)(realm, O, "toString");
  }); // ECMA262 19.1.3.6

  obj.defineNativeProperty("toString", realm.intrinsics.ObjectProto_toString); // ECMA262 19.1.3.7

  obj.defineNativeMethod("valueOf", 0, context => {
    // 1. Return ? ToObject(this value).
    return _singletons.To.ToObject(realm, context);
  });
  obj.$DefineOwnProperty("__proto__", new _descriptors.PropertyDescriptor({
    // B.2.2.1.1
    get: new _index.NativeFunctionValue(realm, undefined, "get __proto__", 0, context => {
      // 1. Let O be ? ToObject(this value).
      let O = _singletons.To.ToObject(realm, context); // 2. Return ? O.[[GetPrototypeOf]]().


      return O.$GetPrototypeOf();
    }),
    // B.2.2.1.2
    set: new _index.NativeFunctionValue(realm, undefined, "set __proto__", 1, (context, [proto]) => {
      // 1. Let O be ? RequireObjectCoercible(this value).
      let O = (0, _abstract.RequireObjectCoercible)(realm, context); // 2. If Type(proto) is neither Object nor Null, return undefined.

      if (!(0, _has.HasSomeCompatibleType)(proto, _index.ObjectValue, _index.NullValue)) return realm.intrinsics.undefined; // 3. If Type(O) is not Object, return undefined.

      if (!O.mightBeObject()) return realm.intrinsics.undefined;
      O = O.throwIfNotConcreteObject(); // 4. Let status be ? O.[[SetPrototypeOf]](proto).

      let status = O.$SetPrototypeOf(proto.throwIfNotConcrete()); // 5. If status is false, throw a TypeError exception.

      if (!status) {
        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, "couldn't set proto");
      } // 6. Return undefined.


      return realm.intrinsics.undefined;
    })
  }));
}
//# sourceMappingURL=ObjectPrototype.js.map