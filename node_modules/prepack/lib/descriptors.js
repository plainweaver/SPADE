"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneDescriptor = cloneDescriptor;
exports.equalDescriptors = equalDescriptors;
exports.AbstractJoinedDescriptor = exports.InternalSlotDescriptor = exports.PropertyDescriptor = exports.Descriptor = void 0;

var _invariant = _interopRequireDefault(require("./invariant.js"));

var _errors = require("./errors.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
class Descriptor {
  constructor() {
    (0, _invariant.default)(this.constructor !== Descriptor, "Descriptor is an abstract base class");
  }

  throwIfNotConcrete(realm) {
    let error = new _errors.CompilerDiagnostic("only known descriptors supported", realm.currentLocation, "PP0042", "FatalError");
    realm.handleError(error);
    throw new _errors.FatalError();
  }

  mightHaveBeenDeleted() {
    (0, _invariant.default)(false, "should have been overridden by subclass");
  }

}

exports.Descriptor = Descriptor;

// Normal descriptors are returned just like spec descriptors
class PropertyDescriptor extends Descriptor {
  // If value instanceof EmptyValue, then this descriptor indicates that the
  // corresponding property has been deleted.
  constructor(desc) {
    super();
    this.writable = desc.writable;
    this.enumerable = desc.enumerable;
    this.configurable = desc.configurable;
    this.value = desc.value;
    this.get = desc.get;
    this.set = desc.set;
  }

  throwIfNotConcrete(realm) {
    return this;
  }

  mightHaveBeenDeleted() {
    if (this.value === undefined) return false;
    return this.value.mightHaveBeenDeleted();
  }

} // Only internal properties (those starting with $ / where internalSlot of owning property binding is true) will ever have array values.


exports.PropertyDescriptor = PropertyDescriptor;

class InternalSlotDescriptor extends Descriptor {
  constructor(value) {
    super();
    this.value = Array.isArray(value) ? value.slice(0) : value;
  }

  mightHaveBeenDeleted() {
    return false;
  }

} // Only used if the result of a join of two descriptors is not a data descriptor with identical attribute values.
// When present, any update to the property must produce effects that are the join of updating both descriptors,
// using joinCondition as the condition of the join.


exports.InternalSlotDescriptor = InternalSlotDescriptor;

class AbstractJoinedDescriptor extends Descriptor {
  // An undefined descriptor means it might be empty in this branch.
  constructor(joinCondition, descriptor1, descriptor2) {
    super();
    this.joinCondition = joinCondition;
    this.descriptor1 = descriptor1;
    this.descriptor2 = descriptor2;
  }

  mightHaveBeenDeleted() {
    if (!this.descriptor1 || this.descriptor1.mightHaveBeenDeleted()) {
      return true;
    }

    if (!this.descriptor2 || this.descriptor2.mightHaveBeenDeleted()) {
      return true;
    }

    return false;
  }

}

exports.AbstractJoinedDescriptor = AbstractJoinedDescriptor;

function cloneDescriptor(d) {
  if (d === undefined) return undefined;
  return new PropertyDescriptor(d);
} // does not check if the contents of value properties are the same


function equalDescriptors(d1, d2) {
  if (d1.writable !== d2.writable) return false;
  if (d1.enumerable !== d2.enumerable) return false;
  if (d1.configurable !== d2.configurable) return false;

  if (d1.value !== undefined) {
    if (d2.value === undefined) return false;
  }

  if (d1.get !== d2.get) return false;
  if (d1.set !== d2.set) return false;
  return true;
}
//# sourceMappingURL=descriptors.js.map