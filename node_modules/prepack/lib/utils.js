"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.typeToString = typeToString;
exports.getTypeFromName = getTypeFromName;
exports.describeValue = describeValue;
exports.jsonToDisplayString = jsonToDisplayString;
exports.verboseToDisplayJson = verboseToDisplayJson;
exports.createModelledFunctionCall = createModelledFunctionCall;

var _index = require("./values/index.js");

var _invariant = _interopRequireDefault(require("./invariant.js"));

var _ShapeInformation = require("./utils/ShapeInformation.js");

var _errors = require("./errors.js");

var t = _interopRequireWildcard(require("@babel/types"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function typeToString(type) {
  function isInstance(proto, Constructor) {
    return proto instanceof Constructor || proto === Constructor.prototype;
  }

  let proto = type.prototype;

  if (isInstance(proto, _index.UndefinedValue)) {
    return "undefined";
  } else if (isInstance(proto, _index.NullValue)) {
    return "object";
  } else if (isInstance(proto, _index.StringValue)) {
    return "string";
  } else if (isInstance(proto, _index.BooleanValue)) {
    return "boolean";
  } else if (isInstance(proto, _index.NumberValue)) {
    return "number";
  } else if (isInstance(proto, _index.SymbolValue)) {
    return "symbol";
  } else if (isInstance(proto, _index.ObjectValue)) {
    if (_index.Value.isTypeCompatibleWith(type, _index.FunctionValue)) {
      return "function";
    }

    return "object";
  } else {
    return undefined;
  }
}

function getTypeFromName(typeName) {
  switch (typeName) {
    case "empty":
      return _index.EmptyValue;

    case "void":
      return _index.UndefinedValue;

    case "null":
      return _index.NullValue;

    case "boolean":
      return _index.BooleanValue;

    case "string":
      return _index.StringValue;

    case "symbol":
      return _index.SymbolValue;

    case "number":
      return _index.NumberValue;

    case "object":
      return _index.ObjectValue;

    case "array":
      return _index.ArrayValue;

    case "function":
      return _index.FunctionValue;

    case "integral":
      return _index.IntegralValue;

    default:
      return undefined;
  }
}

function describeValue(value) {
  let title;
  let suffix = "";
  if (value instanceof _index.PrimitiveValue) title = value.toDisplayString();else if (value instanceof _index.ObjectValue) title = "[object]";else {
    (0, _invariant.default)(value instanceof _index.AbstractValue, value.constructor.name);
    title = "[abstract]";
    if (value.kind !== undefined) title += `, kind: ${value.kind}`;

    for (let arg of value.args) {
      let desc = describeValue(arg);
      suffix += desc.split("\n").map(u => "  " + u).join("\n") + "\n";
    }
  }
  title += `, hash: ${value.getHash()}`;
  if (value.intrinsicName !== undefined) title += `, intrinsic name: ${value.intrinsicName}`;
  if (value.__originalName !== undefined) title += `, original name: ${value.__originalName}`;
  return suffix ? `${title}\n${suffix}` : title;
}

function jsonToDisplayString(instance, depth) {
  let result = instance.toDisplayJson(depth);
  return typeof result === "string" ? result : JSON.stringify(result, null, 2).replace(/\"/g, "");
}

function verboseToDisplayJson(obj, depth) {
  let result = {};

  function valueOfProp(prop) {
    if (typeof prop === "function") return undefined;

    if (Array.isArray(prop)) {
      // Try to return a 1-line string if possible
      if (prop.length === 0) return "[]";
      let valuesArray = prop.map(x => valueOfProp(x));

      if (valuesArray.length < 5) {
        let string = "[" + valuesArray.reduce((acc, x) => `${acc}, ${x instanceof Object ? JSON.stringify(x) : x}`) + "]";
        string = string.replace(/\"/g, "");
        if (string.length < 60) return string;
      }

      return valuesArray;
    }

    if (prop instanceof Set || prop instanceof Map) return `${prop.constructor.name}(${prop.size})`;
    if (prop.toDisplayJson) return prop.toDisplayJson(depth - 1);
    if (prop.toDisplayString) return prop.toDisplayString();
    if (prop.toJSON) return prop.toJSON();
    return prop.toString();
  }

  for (let key in obj) {
    let prop = obj[key];
    if (!prop) continue;
    let value = valueOfProp(prop);
    if (value !== undefined && value !== "[object Object]") result[key] = value;
  }

  return result;
}

function createModelledFunctionCall(realm, funcValue, argModelInput, thisValue) {
  let call = funcValue.$Call;
  (0, _invariant.default)(call);
  let numArgs = funcValue.getLength();
  let args = [];
  let argModel = typeof argModelInput === "string" ? JSON.parse(argModelInput) : argModelInput;
  (0, _invariant.default)(funcValue instanceof _index.ECMAScriptSourceFunctionValue);
  let params = funcValue.$FormalParameters;

  if (numArgs !== undefined && numArgs > 0 && params) {
    for (let parameterId of params) {
      if (t.isIdentifier(parameterId)) {
        // $FlowFixMe: Flow strict file does not allow for casting
        let paramName = parameterId.name;

        let shape = _ShapeInformation.ShapeInformation.createForArgument(argModel, paramName); // Create an AbstractValue similar to __abstract being called


        args.push(_index.AbstractValue.createAbstractArgument(realm, paramName, funcValue.expressionLocation, shape !== undefined ? shape.getAbstractType() : _index.Value, shape));
      } else {
        realm.handleError(new _errors.CompilerDiagnostic("Non-identifier args to additional functions unsupported", funcValue.expressionLocation, "PP1005", "FatalError"));
        throw new _errors.FatalError("Non-identifier args to additional functions unsupported");
      }
    }
  }

  let thisArg = thisValue !== undefined ? thisValue : _index.AbstractValue.createAbstractArgument(realm, "this", funcValue.expressionLocation, _index.ObjectValue);
  return () => {
    let savedPathConditions = realm.pathConditions;
    let newPathConditions = funcValue.pathConditionDuringDeclaration || savedPathConditions;
    realm.pathConditions = newPathConditions;

    try {
      let result = call(thisArg, args);
      return result;
    } finally {
      realm.pathConditions = savedPathConditions;
    }
  };
}
//# sourceMappingURL=utils.js.map