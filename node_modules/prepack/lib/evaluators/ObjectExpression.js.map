{"version":3,"sources":["../../src/evaluators/ObjectExpression.js"],"names":["EvalPropertyName","prop","env","realm","strictCode","result","EvalPropertyNamePartial","AbstractValue","error","CompilerDiagnostic","loc","handleError","FatalError","computed","propertyKeyName","Environment","GetValue","evaluate","key","ConcreteValue","To","ToPropertyKey","type","StringValue","name","ToString","ast","obj","Create","ObjectCreate","intrinsics","ObjectPrototype","properties","propKey","exprValueRef","value","propValue","ObjectValue","hasNameProperty","Functions","SetFunctionName","mightNotBeString","$SetPartial","CreateDataPropertyOrThrow","exprValue","argument","fromValue","excludedNames","CopyDataProperties","Properties","PropertyDefinitionEvaluation"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { AbstractValue, ConcreteValue, ObjectValue, StringValue } from \"../values/index.js\";\nimport { IsAnonymousFunctionDefinition, HasOwnProperty } from \"../methods/index.js\";\nimport { Create, Environment, Functions, Properties, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type {\n  BabelNodeObjectExpression,\n  BabelNodeObjectProperty,\n  BabelNodeObjectMethod,\n  BabelNodeClassMethod,\n} from \"@babel/types\";\n\n// Returns the result of evaluating PropertyName.\nexport function EvalPropertyName(\n  prop: BabelNodeObjectProperty | BabelNodeObjectMethod | BabelNodeClassMethod,\n  env: LexicalEnvironment,\n  realm: Realm,\n  strictCode: boolean\n): PropertyKeyValue {\n  let result = EvalPropertyNamePartial(prop, env, realm, strictCode);\n  if (result instanceof AbstractValue) {\n    let error = new CompilerDiagnostic(\"unknown computed property name\", prop.loc, \"PP0014\", \"FatalError\");\n    realm.handleError(error);\n    throw new FatalError();\n  }\n  return (result: any);\n}\n\nfunction EvalPropertyNamePartial(\n  prop: BabelNodeObjectProperty | BabelNodeObjectMethod | BabelNodeClassMethod,\n  env: LexicalEnvironment,\n  realm: Realm,\n  strictCode: boolean\n): AbstractValue | PropertyKeyValue {\n  if (prop.computed) {\n    let propertyKeyName = Environment.GetValue(realm, env.evaluate(prop.key, strictCode));\n    if (propertyKeyName instanceof AbstractValue) return propertyKeyName;\n    invariant(propertyKeyName instanceof ConcreteValue);\n    return To.ToPropertyKey(realm, propertyKeyName);\n  } else {\n    if (prop.key.type === \"Identifier\") {\n      return new StringValue(realm, prop.key.name);\n    } else {\n      let propertyKeyName = Environment.GetValue(realm, env.evaluate(prop.key, strictCode));\n      invariant(propertyKeyName instanceof ConcreteValue); // syntax only allows literals if !prop.computed\n      return To.ToString(realm, propertyKeyName);\n    }\n  }\n}\n\n// ECMA262 12.2.6.8\nexport default function(\n  ast: BabelNodeObjectExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): ObjectValue {\n  // 1. Let obj be ObjectCreate(%ObjectPrototype%).\n  let obj = Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n  // 2. Let status be the result of performing PropertyDefinitionEvaluation of PropertyDefinitionList with arguments obj and true.\n  for (let prop of ast.properties) {\n    if (prop.type === \"ObjectProperty\") {\n      // 12.2.6.9 case 3\n      // 1. Let propKey be the result of evaluating PropertyName.\n      let propKey = EvalPropertyNamePartial(prop, env, realm, strictCode);\n\n      // 2. ReturnIfAbrupt(propKey).\n\n      // 3. Let exprValueRef be the result of evaluating AssignmentExpression.\n      let exprValueRef = env.evaluate(prop.value, strictCode);\n\n      // 4. Let propValue be ? GetValue(exprValueRef).\n      let propValue = Environment.GetValue(realm, exprValueRef);\n\n      // 5. If IsAnonymousFunctionDefinition(AssignmentExpression) is true, then\n      if (IsAnonymousFunctionDefinition(realm, prop.value)) {\n        invariant(propValue instanceof ObjectValue);\n\n        // a. Let hasNameProperty be ? HasOwnProperty(propValue, \"name\").\n        let hasNameProperty = HasOwnProperty(realm, propValue, \"name\");\n\n        // b. If hasNameProperty is false, perform SetFunctionName(propValue, propKey).\n        invariant(!hasNameProperty); // No expression that passes through IsAnonymousFunctionDefinition can have it here\n        Functions.SetFunctionName(realm, propValue, propKey);\n      }\n\n      // 6. Assert: enumerable is true.\n\n      // 7. Return CreateDataPropertyOrThrow(object, propKey, propValue).\n      if (propKey instanceof AbstractValue) {\n        if (propKey.mightNotBeString()) {\n          let error = new CompilerDiagnostic(\"property key value is unknown\", prop.loc, \"PP0011\", \"FatalError\");\n          if (realm.handleError(error) === \"Fail\") throw new FatalError();\n          continue; // recover by ignoring the property, which is only ever safe to do if the property is dead,\n          // which is assuming a bit much, hence the designation as a FatalError.\n        }\n        obj.$SetPartial(propKey, propValue, obj);\n      } else {\n        Create.CreateDataPropertyOrThrow(realm, obj, propKey, propValue);\n      }\n    } else if (prop.type === \"SpreadElement\") {\n      // 1. Let exprValue be the result of evaluating AssignmentExpression.\n      let exprValue = env.evaluate(prop.argument, strictCode);\n\n      // 2. Let fromValue be GetValue(exprValue).\n      let fromValue = Environment.GetValue(realm, exprValue);\n\n      // 3. ReturnIfAbrupt(fromValue).\n\n      // 4. Let excludedNames be a new empty List.\n      let excludedNames = [];\n\n      // 4. Return ? CopyDataProperties(object, fromValue, excludedNames).\n      Create.CopyDataProperties(realm, obj, fromValue, excludedNames);\n    } else {\n      invariant(prop.type === \"ObjectMethod\");\n      Properties.PropertyDefinitionEvaluation(realm, prop, obj, (env: any), strictCode, true);\n    }\n  }\n\n  // 3. ReturnIfAbrupt(status).\n\n  // 4. Return obj.\n  return obj;\n}\n"],"file":"ObjectExpression.js"}