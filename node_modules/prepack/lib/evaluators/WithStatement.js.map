{"version":3,"sources":["../../src/evaluators/WithStatement.js"],"names":["ast","strictCode","env","realm","val","evaluate","object","Environment","GetValue","AbstractValue","ObjectValue","isPartialObject","loc","error","CompilerDiagnostic","handleError","FatalError","obj","To","ToObject","oldEnv","newEnv","NewObjectEnvironment","environmentRecord","ObjectEnvironmentRecord","withEnvironment","getRunningContext","lexicalEnvironment","C","evaluateCompletion","body","Value","AbruptCompletion","res","intrinsics","undefined","onDestroyScope"],"mappings":";;;;;;;AAYA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;AAlBA;;;;;;;;;AASA;AAYA;AACe,kBACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKN;AACP;AACA,MAAIC,GAAG,GAAGF,GAAG,CAACG,QAAJ,CAAaL,GAAG,CAACM,MAAjB,EAAyBL,UAAzB,CAAV,CAFO,CAIP;;AACAG,EAAAA,GAAG,GAAGG,wBAAYC,QAAZ,CAAqBL,KAArB,EAA4BC,GAA5B,CAAN;;AACA,MAAIA,GAAG,YAAYK,oBAAf,IAAiCL,GAAG,YAAYM,kBAAf,IAA8BN,GAAG,CAACO,eAAJ,EAAnE,EAA2F;AACzF,QAAIC,GAAG,GAAGZ,GAAG,CAACM,MAAJ,CAAWM,GAArB;AACA,QAAIC,KAAK,GAAG,IAAIC,0BAAJ,CAAuB,mCAAvB,EAA4DF,GAA5D,EAAiE,QAAjE,EAA2E,kBAA3E,CAAZ;AACA,QAAIT,KAAK,CAACY,WAAN,CAAkBF,KAAlB,MAA6B,MAAjC,EAAyC,MAAM,IAAIG,kBAAJ,EAAN;AAC1C;;AACD,MAAIC,GAAG,GAAGC,eAAGC,QAAH,CAAYhB,KAAZ,EAAmBC,GAAnB,CAAV,CAXO,CAaP;;;AACA,MAAIgB,MAAM,GAAGlB,GAAb,CAdO,CAgBP;;AACA,MAAImB,MAAM,GAAGd,wBAAYe,oBAAZ,CAAiCnB,KAAjC,EAAwCc,GAAxC,EAA6CG,MAA7C,CAAb,CAjBO,CAmBP;;;AACA,0BAAUC,MAAM,CAACE,iBAAP,YAAoCC,oCAA9C;AACAH,EAAAA,MAAM,CAACE,iBAAP,CAAyBE,eAAzB,GAA2C,IAA3C,CArBO,CAuBP;;AACAtB,EAAAA,KAAK,CAACuB,iBAAN,GAA0BC,kBAA1B,GAA+CN,MAA/C;;AAEA,MAAI;AACF;AACA,QAAIO,CAAC,GAAGP,MAAM,CAACQ,kBAAP,CAA0B7B,GAAG,CAAC8B,IAA9B,EAAoC7B,UAApC,CAAR;AACA,4BAAU2B,CAAC,YAAYG,YAAb,IAAsBH,CAAC,YAAYI,6BAA7C,EAHE,CAKF;;AACA,QAAIC,GAAG,GAAG,yBAAY9B,KAAZ,EAAmByB,CAAnB,EAAsBzB,KAAK,CAAC+B,UAAN,CAAiBC,SAAvC,CAAV;AACA,QAAIF,GAAG,YAAYD,6BAAnB,EAAqC,MAAMC,GAAN;AACrC,4BAAUA,GAAG,YAAYF,YAAzB;AACA,WAAOE,GAAP;AACD,GAVD,SAUU;AACR;AACA9B,IAAAA,KAAK,CAACuB,iBAAN,GAA0BC,kBAA1B,GAA+CP,MAA/C;AACAjB,IAAAA,KAAK,CAACiC,cAAN,CAAqBf,MAArB;AACD;AACF","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../realm.js\";\nimport { LexicalEnvironment, ObjectEnvironmentRecord } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { AbruptCompletion } from \"../completions.js\";\nimport { AbstractValue, ObjectValue, Value } from \"../values/index.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport { Environment, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeWithStatement } from \"@babel/types\";\n\n// ECMA262 13.11.7\nexport default function(\n  ast: BabelNodeWithStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // 1. Let val be the result of evaluating Expression.\n  let val = env.evaluate(ast.object, strictCode);\n\n  // 2. Let obj be ? ToObject(? GetValue(val)).\n  val = Environment.GetValue(realm, val);\n  if (val instanceof AbstractValue || (val instanceof ObjectValue && val.isPartialObject())) {\n    let loc = ast.object.loc;\n    let error = new CompilerDiagnostic(\"with object must be a known value\", loc, \"PP0007\", \"RecoverableError\");\n    if (realm.handleError(error) === \"Fail\") throw new FatalError();\n  }\n  let obj = To.ToObject(realm, val);\n\n  // 3. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = env;\n\n  // 4. Let newEnv be NewObjectEnvironment(obj, oldEnv).\n  let newEnv = Environment.NewObjectEnvironment(realm, obj, oldEnv);\n\n  // 5. Set the withEnvironment flag of newEnv's EnvironmentRecord to true.\n  invariant(newEnv.environmentRecord instanceof ObjectEnvironmentRecord);\n  newEnv.environmentRecord.withEnvironment = true;\n\n  // 6. Set the running execution context's LexicalEnvironment to newEnv.\n  realm.getRunningContext().lexicalEnvironment = newEnv;\n\n  try {\n    // 7. Let C be the result of evaluating Statement.\n    let C = newEnv.evaluateCompletion(ast.body, strictCode);\n    invariant(C instanceof Value || C instanceof AbruptCompletion);\n\n    // 9. Return Completion(UpdateEmpty(C, undefined)).\n    let res = UpdateEmpty(realm, C, realm.intrinsics.undefined);\n    if (res instanceof AbruptCompletion) throw res;\n    invariant(res instanceof Value);\n    return res;\n  } finally {\n    // 8. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n    realm.onDestroyScope(newEnv);\n  }\n}\n"],"file":"WithStatement.js"}