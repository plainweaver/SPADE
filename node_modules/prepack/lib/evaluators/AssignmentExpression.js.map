{"version":3,"sources":["../../src/evaluators/AssignmentExpression.js"],"names":["ast","strictCode","env","realm","hasOwnProperty","operator","Error","LeftHandSideExpression","left","AssignmentExpression","right","AssignmentOperator","type","lref","evaluate","rref","rval","Environment","GetValue","ObjectValue","hasNameProperty","Reference","Functions","SetFunctionName","GetReferencedName","Properties","PutValue","assignmentPattern","lval","op","slice","r","loc"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Value, ObjectValue } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport {\n  DestructuringAssignmentEvaluation,\n  HasOwnProperty,\n  IsAnonymousFunctionDefinition,\n  IsIdentifierRef,\n} from \"../methods/index.js\";\nimport { Environment, Functions, Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeAssignmentExpression, BabelBinaryOperator } from \"@babel/types\";\nimport { computeBinary } from \"./BinaryExpression.js\";\n\n// ECMA262 12.15 Assignment Operators\nexport default function(\n  ast: BabelNodeAssignmentExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  if (!ast.hasOwnProperty(\"operator\") || ast.operator === null) throw Error(\"Unexpected AST form\");\n\n  let LeftHandSideExpression = ast.left;\n  let AssignmentExpression = ast.right;\n  let AssignmentOperator = ast.operator;\n\n  // AssignmentExpression : LeftHandSideExpression = AssignmentExpression\n  if (AssignmentOperator === \"=\") {\n    // 1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then\n    //\n    // The spec assumes we haven't yet distinguished between literals and\n    // patterns, but our parser does that work for us. That means we check for\n    // \"*Pattern\" instead of \"*Literal\" like the spec text suggests.\n    if (LeftHandSideExpression.type !== \"ObjectPattern\" && LeftHandSideExpression.type !== \"ArrayPattern\") {\n      // a. Let lref be the result of evaluating LeftHandSideExpression.\n      let lref = env.evaluate(LeftHandSideExpression, strictCode);\n      // b. ReturnIfAbrupt(lref). -- Not neccessary\n      // c. Let rref be the result of evaluating AssignmentExpression.\n      let rref = env.evaluate(AssignmentExpression, strictCode);\n      // d. Let rval be ? GetValue(rref).\n      let rval = Environment.GetValue(realm, rref);\n      // e. If IsAnonymousFunctionDefinition(AssignmentExpression) and IsIdentifierRef of LeftHandSideExpression are both true, then\n      if (\n        IsAnonymousFunctionDefinition(realm, AssignmentExpression) &&\n        IsIdentifierRef(realm, LeftHandSideExpression)\n      ) {\n        invariant(rval instanceof ObjectValue);\n        // i. Let hasNameProperty be ? HasOwnProperty(rval, \"name\").\n        let hasNameProperty = HasOwnProperty(realm, rval, \"name\");\n        // ii. If hasNameProperty is false, perform SetFunctionName(rval, GetReferencedName(lref)).\n        if (!hasNameProperty) {\n          invariant(lref instanceof Reference);\n          Functions.SetFunctionName(realm, rval, Environment.GetReferencedName(realm, lref));\n        }\n      }\n      // f. Perform ? PutValue(lref, rval).\n      Properties.PutValue(realm, lref, rval);\n      // g. Return rval.\n      return rval;\n    }\n\n    // 2. Let assignmentPattern be the parse of the source text corresponding to LeftHandSideExpression using AssignmentPattern[?Yield] as the goal symbol.\n    let assignmentPattern = LeftHandSideExpression;\n\n    // 3. Let rref be the result of evaluating AssignmentExpression.\n    let rref = env.evaluate(AssignmentExpression, strictCode);\n\n    // 4. Let rval be ? GetValue(rref).\n    let rval = Environment.GetValue(realm, rref);\n\n    // 5. Let status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using rval as the argument.\n    DestructuringAssignmentEvaluation(realm, assignmentPattern, rval, strictCode, env);\n\n    // 6. ReturnIfAbrupt(status).\n\n    // 7. Return rval.\n    return rval;\n  }\n\n  // AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression\n\n  // 1. Let lref be the result of evaluating LeftHandSideExpression.\n  let lref = env.evaluate(LeftHandSideExpression, strictCode);\n  // 2. Let lval be ? GetValue(lref).\n  let lval = Environment.GetValue(realm, lref);\n  // 3. Let rref be the result of evaluating AssignmentExpression.\n  let rref = env.evaluate(AssignmentExpression, strictCode);\n  // 4. Let rval be ? GetValue(rref).\n  let rval = Environment.GetValue(realm, rref);\n  // 5. Let op be the @ where AssignmentOperator is @=.\n  let op = ((AssignmentOperator.slice(0, -1): any): BabelBinaryOperator);\n  // 6. Let r be the result of applying op to lval and rval as if evaluating the expression lval op rval.\n  let r = Environment.GetValue(realm, computeBinary(realm, op, lval, rval, ast.left.loc, ast.right.loc));\n  // 7. Perform ? PutValue(lref, r).\n  Properties.PutValue(realm, lref, r);\n  // 8. Return r.\n  return r;\n}\n"],"file":"AssignmentExpression.js"}