{"version":3,"sources":["../../src/evaluators/CatchClause.js"],"names":["ast","strictCode","env","realm","thrownValue","ThrowCompletion","oldEnv","getRunningContext","lexicalEnvironment","catchEnv","Environment","NewDeclarativeEnvironment","catchEnvRec","environmentRecord","argName","BoundNames","param","CreateMutableBinding","BindingInitialization","value","B","evaluate","body","Value","onDestroyScope"],"mappings":";;;;;;;AAaA;;AACA;;AACA;;AACA;;;;AAhBA;;;;;;;;AAmBA;AACe,kBACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKbC,WALa,EAMN;AACP,0BAAUA,WAAW,YAAYC,4BAAjC,EAAkD,mCAAlD,EADO,CAGP;;AACA,MAAIC,MAAM,GAAGH,KAAK,CAACI,iBAAN,GAA0BC,kBAAvC,CAJO,CAMP;;AACA,MAAIC,QAAQ,GAAGC,wBAAYC,yBAAZ,CAAsCR,KAAtC,EAA6CG,MAA7C,CAAf,CAPO,CASP;;;AACA,MAAIM,WAAW,GAAGH,QAAQ,CAACI,iBAA3B,CAVO,CAYP;;AACA,OAAK,IAAIC,OAAT,IAAoBJ,wBAAYK,UAAZ,CAAuBZ,KAAvB,EAA8BH,GAAG,CAACgB,KAAlC,CAApB,EAA8D;AAC5D;AACAJ,IAAAA,WAAW,CAACK,oBAAZ,CAAiCH,OAAjC,EAA0C,KAA1C;AACD,GAhBM,CAkBP;;;AACAX,EAAAA,KAAK,CAACI,iBAAN,GAA0BC,kBAA1B,GAA+CC,QAA/C;;AAEA,MAAI;AACF;AACAC,4BAAYQ,qBAAZ,CAAkCf,KAAlC,EAAyCH,GAAG,CAACgB,KAA7C,EAAoDZ,WAAW,CAACe,KAAhE,EAAuElB,UAAvE,EAAmFQ,QAAnF,EAFE,CAIF;AACA;AACA;AAEA;;;AACA,QAAIW,CAAC,GAAGX,QAAQ,CAACY,QAAT,CAAkBrB,GAAG,CAACsB,IAAtB,EAA4BrB,UAA5B,CAAR;AACA,4BAAUmB,CAAC,YAAYG,YAAvB,EAVE,CAYF;;AACA,WAAOH,CAAP;AACD,GAdD,SAcU;AACR;AACAjB,IAAAA,KAAK,CAACI,iBAAN,GAA0BC,kBAA1B,GAA+CF,MAA/C;AACAH,IAAAA,KAAK,CAACqB,cAAN,CAAqBf,QAArB;AACD;AACF","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Value } from \"../values/index.js\";\nimport { ThrowCompletion } from \"../completions.js\";\nimport invariant from \"../invariant.js\";\nimport { Environment } from \"../singletons.js\";\nimport type { BabelNodeCatchClause } from \"@babel/types\";\n\n// ECAM262 13.15.7\nexport default function(\n  ast: BabelNodeCatchClause,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  thrownValue: any\n): Value {\n  invariant(thrownValue instanceof ThrowCompletion, \"Metadata isn't a throw completion\");\n\n  // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. Let catchEnv be NewDeclarativeEnvironment(oldEnv).\n  let catchEnv = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n  // 3. Let catchEnvRec be catchEnv's EnvironmentRecord.\n  let catchEnvRec = catchEnv.environmentRecord;\n\n  // 4. For each element argName of the BoundNames of CatchParameter, do\n  for (let argName of Environment.BoundNames(realm, ast.param)) {\n    // a. Perform ! catchEnvRec.CreateMutableBinding(argName, false).\n    catchEnvRec.CreateMutableBinding(argName, false);\n  }\n\n  // 5. Set the running execution context's LexicalEnvironment to catchEnv.\n  realm.getRunningContext().lexicalEnvironment = catchEnv;\n\n  try {\n    // 6. Let status be the result of performing BindingInitialization for CatchParameter passing thrownValue and catchEnv as arguments.\n    Environment.BindingInitialization(realm, ast.param, thrownValue.value, strictCode, catchEnv);\n\n    // 7. If status is an abrupt completion, then\n    // a. Set the running execution context's LexicalEnvironment to oldEnv.\n    // b. Return Completion(status).\n\n    // 8. Let B be the result of evaluating Block.\n    let B = catchEnv.evaluate(ast.body, strictCode);\n    invariant(B instanceof Value);\n\n    // 10. Return Completion(B).\n    return B;\n  } finally {\n    // 9. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n    realm.onDestroyScope(catchEnv);\n  }\n}\n"],"file":"CatchClause.js"}