{"version":3,"sources":["../../src/evaluators/BinaryExpression.js"],"names":["ast","strictCode","env","realm","lref","evaluate","left","lval","Environment","GetValue","rref","right","rval","computeBinary","operator","loc","unknownValueOfOrToString","getPureBinaryOperationResultType","op","lloc","rloc","reportErrorIfNotPure","purityTest","typeIfPure","leftPure","rightPure","error","CompilerDiagnostic","handleError","FatalError","ltype","To","GetToPrimitivePureResultType","rtype","StringValue","IsToStringPure","undefined","IsToNumberPure","getType","SymbolValue","createErrorThrowCompletion","intrinsics","TypeError","IntegralValue","NumberValue","Value","IsToPrimitivePure","bind","BooleanValue","NullValue","UndefinedValue","mightNotBeObject","isSimpleObject","useAbstractInterpretation","resultType","compute","lvalIsAbstract","AbstractValue","rvalIsAbstract","isTypeCompatibleWith","PrimitiveValue","AbstractObjectValue","false","result","createFromBinaryOp","convertToTemporalIfArgsAreTemporal","x","kind","condition","consequentL","alternateL","args","evaluateWithAbstractConditional","evaluateForEffects","consequentR","alternateR","ObjectValue","ConcreteValue","ValuesDomain","isInPureScope","previousErrorHandler","errorHandler","isPure","diagnostic","effects","applyEffects","SimpleNormalCompletion","value","Leak","evaluateWithPossibleThrowCompletion","createTemporalFromBuildFunction","binaryOperator","TypesDomain","topVal"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { SimpleNormalCompletion } from \"../completions.js\";\nimport type { Realm } from \"../realm.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  NullValue,\n  NumberValue,\n  IntegralValue,\n  ObjectValue,\n  PrimitiveValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { Environment, Leak, To } from \"../singletons.js\";\nimport type { BabelBinaryOperator, BabelNodeBinaryExpression, BabelNodeSourceLocation } from \"@babel/types\";\nimport { createOperationDescriptor } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\n\nexport default function(\n  ast: BabelNodeBinaryExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // evaluate left\n  let lref = env.evaluate(ast.left, strictCode);\n  let lval = Environment.GetValue(realm, lref);\n\n  // evaluate right\n  let rref = env.evaluate(ast.right, strictCode);\n  let rval = Environment.GetValue(realm, rref);\n\n  return computeBinary(realm, ast.operator, lval, rval, ast.left.loc, ast.right.loc, ast.loc);\n}\n\nlet unknownValueOfOrToString = \"might be an object with an unknown valueOf or toString or Symbol.toPrimitive method\";\n\n// Returns result type if binary operation is pure (terminates, does not throw exception, does not read or write heap), otherwise undefined.\nexport function getPureBinaryOperationResultType(\n  realm: Realm,\n  op: BabelBinaryOperator,\n  lval: Value,\n  rval: Value,\n  lloc: ?BabelNodeSourceLocation,\n  rloc: ?BabelNodeSourceLocation\n): typeof Value {\n  function reportErrorIfNotPure(purityTest: (Realm, Value) => boolean, typeIfPure: typeof Value): typeof Value {\n    let leftPure = purityTest(realm, lval);\n    let rightPure = purityTest(realm, rval);\n    if (leftPure && rightPure) return typeIfPure;\n    let loc = !leftPure ? lloc : rloc;\n    let error = new CompilerDiagnostic(unknownValueOfOrToString, loc, \"PP0002\", \"RecoverableError\");\n    if (realm.handleError(error) === \"Recover\") {\n      // Assume that an unknown value is actually a primitive or otherwise a well behaved object.\n      return typeIfPure;\n    }\n    throw new FatalError();\n  }\n  if (op === \"+\") {\n    let ltype = To.GetToPrimitivePureResultType(realm, lval);\n    let rtype = To.GetToPrimitivePureResultType(realm, rval);\n    if (ltype === StringValue || rtype === StringValue) {\n      // If either type is a string, the other one will be called with ToString, so that has to be pure.\n      if (!To.IsToStringPure(realm, rval)) {\n        rtype = undefined;\n      }\n      if (!To.IsToStringPure(realm, lval)) {\n        ltype = undefined;\n      }\n    } else {\n      // Otherwise, they will be called with ToNumber, so that has to be pure.\n      if (!To.IsToNumberPure(realm, rval)) {\n        rtype = undefined;\n      }\n      if (!To.IsToNumberPure(realm, lval)) {\n        ltype = undefined;\n      }\n    }\n    if (ltype === undefined || rtype === undefined) {\n      if (lval.getType() === SymbolValue || rval.getType() === SymbolValue) {\n        // Symbols never implicitly coerce to primitives.\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n      let loc = ltype === undefined ? lloc : rloc;\n      let error = new CompilerDiagnostic(unknownValueOfOrToString, loc, \"PP0002\", \"RecoverableError\");\n      if (realm.handleError(error) === \"Recover\") {\n        // Assume that the unknown value is actually a primitive or otherwise a well behaved object.\n        ltype = lval.getType();\n        rtype = rval.getType();\n        if (ltype === StringValue || rtype === StringValue) return StringValue;\n        if (ltype === IntegralValue && rtype === IntegralValue) return IntegralValue;\n        if ((ltype === NumberValue || ltype === IntegralValue) && (rtype === NumberValue || rtype === IntegralValue))\n          return NumberValue;\n\n        return Value;\n      }\n      throw new FatalError();\n    }\n    if (ltype === StringValue || rtype === StringValue) return StringValue;\n    return NumberValue;\n  } else if (op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\") {\n    return reportErrorIfNotPure(To.IsToPrimitivePure.bind(To), BooleanValue);\n  } else if (op === \"!=\" || op === \"==\") {\n    let ltype = lval.getType();\n    let rtype = rval.getType();\n    if (ltype === NullValue || ltype === UndefinedValue || rtype === NullValue || rtype === UndefinedValue)\n      return BooleanValue;\n    return reportErrorIfNotPure(To.IsToPrimitivePure.bind(To), BooleanValue);\n  } else if (op === \"===\" || op === \"!==\") {\n    return BooleanValue;\n  } else if (\n    op === \">>>\" ||\n    op === \"<<\" ||\n    op === \">>\" ||\n    op === \"&\" ||\n    op === \"|\" ||\n    op === \"^\" ||\n    op === \"**\" ||\n    op === \"%\" ||\n    op === \"/\" ||\n    op === \"*\" ||\n    op === \"-\"\n  ) {\n    if (lval.getType() === SymbolValue || rval.getType() === SymbolValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n    return reportErrorIfNotPure(To.IsToNumberPure.bind(To), NumberValue);\n  } else if (op === \"in\" || op === \"instanceof\") {\n    if (rval.mightNotBeObject()) {\n      let error = new CompilerDiagnostic(\n        `might not be an object, hence the ${op} operator might throw a TypeError`,\n        rloc,\n        \"PP0003\",\n        \"RecoverableError\"\n      );\n      if (realm.handleError(error) === \"Recover\") {\n        // Assume that the object is actually a well behaved object.\n        return BooleanValue;\n      }\n      throw new FatalError();\n    }\n    if (!rval.mightNotBeObject()) {\n      // Simple object won't throw here, aren't proxy objects or typed arrays and do not have @@hasInstance properties.\n      if (rval.isSimpleObject()) return BooleanValue;\n    }\n    let error = new CompilerDiagnostic(\n      `might be an object that behaves badly for the ${op} operator`,\n      rloc,\n      \"PP0004\",\n      \"RecoverableError\"\n    );\n    if (realm.handleError(error) === \"Recover\") {\n      // Assume that the object is actually a well behaved object.\n      return BooleanValue;\n    }\n    throw new FatalError();\n  }\n  invariant(false, \"unimplemented \" + op);\n}\n\nexport function computeBinary(\n  realm: Realm,\n  op: BabelBinaryOperator,\n  lval: Value,\n  rval: Value,\n  lloc: ?BabelNodeSourceLocation,\n  rloc: ?BabelNodeSourceLocation,\n  loc?: ?BabelNodeSourceLocation\n): Value {\n  // partial evaluation shortcut for a particular pattern\n  if (realm.useAbstractInterpretation && (op === \"==\" || op === \"===\" || op === \"!=\" || op === \"!==\")) {\n    if (\n      (!lval.mightNotBeObject() && (rval instanceof NullValue || rval instanceof UndefinedValue)) ||\n      ((lval instanceof NullValue || lval instanceof UndefinedValue) && !rval.mightNotBeObject())\n    ) {\n      return new BooleanValue(realm, op[0] !== \"=\");\n    }\n  }\n\n  let resultType;\n  const compute = () => {\n    let lvalIsAbstract = lval instanceof AbstractValue;\n    let rvalIsAbstract = rval instanceof AbstractValue;\n    if (lvalIsAbstract || rvalIsAbstract) {\n      // If the left-hand side of an instanceof operation is a primitive,\n      // and the right-hand side is a simple object (it does not have [Symbol.hasInstance]),\n      // then the result should always compute to `false`.\n      if (\n        op === \"instanceof\" &&\n        Value.isTypeCompatibleWith(lval.getType(), PrimitiveValue) &&\n        rval instanceof AbstractObjectValue &&\n        rval.isSimpleObject()\n      ) {\n        return realm.intrinsics.false;\n      }\n\n      try {\n        // generate error if binary operation might throw or have side effects\n        resultType = getPureBinaryOperationResultType(realm, op, lval, rval, lloc, rloc);\n        let result = AbstractValue.createFromBinaryOp(realm, op, lval, rval, loc);\n\n        if ((op === \"in\" || op === \"instanceof\") && result instanceof AbstractValue && rvalIsAbstract)\n          // This operation is a conditional atemporal\n          // See #2327\n          result = AbstractValue.convertToTemporalIfArgsAreTemporal(\n            realm,\n            result,\n            [rval] /* throwing does not depend upon lval */\n          );\n        return result;\n      } catch (x) {\n        if (x instanceof FatalError) {\n          // There is no need to revert any effects, because the above operation is pure.\n          // If this failed and one of the arguments was conditional, try each value\n          // and join the effects based on the condition.\n          if (lval instanceof AbstractValue && lval.kind === \"conditional\") {\n            let [condition, consequentL, alternateL] = lval.args;\n            invariant(condition instanceof AbstractValue);\n            return realm.evaluateWithAbstractConditional(\n              condition,\n              () =>\n                realm.evaluateForEffects(\n                  () => computeBinary(realm, op, consequentL, rval, lloc, rloc, loc),\n                  undefined,\n                  \"ConditionalBinaryExpression/1\"\n                ),\n              () =>\n                realm.evaluateForEffects(\n                  () => computeBinary(realm, op, alternateL, rval, lloc, rloc, loc),\n                  undefined,\n                  \"ConditionalBinaryExpression/2\"\n                )\n            );\n          }\n          if (rval instanceof AbstractValue && rval.kind === \"conditional\") {\n            let [condition, consequentR, alternateR] = rval.args;\n            invariant(condition instanceof AbstractValue);\n            return realm.evaluateWithAbstractConditional(\n              condition,\n              () =>\n                realm.evaluateForEffects(\n                  () => computeBinary(realm, op, lval, consequentR, lloc, rloc, loc),\n                  undefined,\n                  \"ConditionalBinaryExpression/3\"\n                ),\n              () =>\n                realm.evaluateForEffects(\n                  () => computeBinary(realm, op, lval, alternateR, lloc, rloc, loc),\n                  undefined,\n                  \"ConditionalBinaryExpression/4\"\n                )\n            );\n          }\n        }\n        throw x;\n      }\n    } else {\n      // ECMA262 12.10.3\n\n      // 5. If Type(rval) is not Object, throw a TypeError exception.\n      if (op === \"in\" && !(rval instanceof ObjectValue)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n      invariant(lval instanceof ConcreteValue);\n      invariant(rval instanceof ConcreteValue);\n      const result = ValuesDomain.computeBinary(realm, op, lval, rval);\n      resultType = result.getType();\n      return result;\n    }\n  };\n\n  if (realm.isInPureScope()) {\n    // If we're in pure mode we can recover even if this operation might not be pure.\n    // To do that, we'll temporarily override the error handler.\n    const previousErrorHandler = realm.errorHandler;\n    let isPure = true;\n    realm.errorHandler = diagnostic => {\n      isPure = false;\n      return \"Recover\";\n    };\n    let effects;\n    try {\n      effects = realm.evaluateForEffects(compute, undefined, \"computeBinary\");\n    } catch (x) {\n      if (x instanceof FatalError) {\n        isPure = false;\n      } else {\n        throw x;\n      }\n    } finally {\n      realm.errorHandler = previousErrorHandler;\n    }\n\n    if (isPure && effects) {\n      realm.applyEffects(effects);\n      if (effects.result instanceof SimpleNormalCompletion) return effects.result.value;\n    }\n\n    // If this ended up reporting an error, it might not be pure, so we'll leave it in\n    // as a temporal operation with a known return type.\n    // Some of these values may trigger side-effectful user code such as valueOf.\n    // To be safe, we have to leak them.\n    Leak.value(realm, lval, loc);\n    if (op !== \"in\") {\n      // The \"in\" operator have side-effects on its right val other than throw.\n      Leak.value(realm, rval, loc);\n    }\n    return realm.evaluateWithPossibleThrowCompletion(\n      () =>\n        AbstractValue.createTemporalFromBuildFunction(\n          realm,\n          resultType,\n          [lval, rval],\n          createOperationDescriptor(\"BINARY_EXPRESSION\", { binaryOperator: op }),\n          { isPure: true }\n        ),\n      TypesDomain.topVal,\n      ValuesDomain.topVal\n    );\n  }\n  return compute();\n}\n"],"file":"BinaryExpression.js"}