{"version":3,"sources":["../../src/evaluators/CallExpression.js"],"names":["ast","strictCode","env","realm","callee","type","arguments","ref","evaluate","previousLoc","setNextExecutionContextLocation","loc","evaluateReference","getPrimitivePrototypeFromType","value","getType","IntegralValue","NumberValue","intrinsics","NumberPrototype","StringValue","StringPrototype","BooleanValue","BooleanPrototype","SymbolValue","SymbolPrototype","undefined","Reference","base","AbstractValue","mightNotBeObject","isInPureScope","kind","condValue","consequentVal","alternateVal","args","evaluateConditionalReferenceBase","leftValue","rightValue","referencedName","prototypeIfPrimitive","possibleMethodValue","_SafeGetDataPropertyValue","FunctionValue","EvaluateCall","evaluateWithPossibleThrowCompletion","generateRuntimeCall","TypesDomain","topVal","ValuesDomain","func","Environment","GetValue","evaluateWithAbstractConditional","evaluateForEffects","consequentRef","strict","thisValue","alternateRef","callBothFunctionsAndJoinTheirEffects","thisArg","propName","Value","push","concat","arg","Leak","resultType","AbstractObjectValue","functionResultType","createTemporalFromBuildFunction","propRef","tryToEvaluateCallOrLeaveAsAbstract","tailCall","instantRender","enabled","effects","savedSuppressDiagnostics","suppressDiagnostics","NativeFunctionValue","name","error","FatalError","applyEffects","returnOrThrowCompletion","result","property","isTypeCompatibleWith","CompilerDiagnostic","handleError","ConcreteValue","IsPropertyReference","GetReferencedName","eval","argList","length","evalText","strictCaller","evalRealm","Functions","PerformEval","refEnv","GetBase","EnvironmentRecord","WithBaseObject","thisCall"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport type { Realm } from \"../realm.js\";\nimport { type LexicalEnvironment, type BaseValue, isValidBaseValue } from \"../environment.js\";\nimport { EnvironmentRecord } from \"../environment.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport {\n  AbstractValue,\n  AbstractObjectValue,\n  BooleanValue,\n  ConcreteValue,\n  FunctionValue,\n  IntegralValue,\n  NativeFunctionValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  Value,\n} from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { Environment, Functions, Leak } from \"../singletons.js\";\nimport {\n  ArgumentListEvaluation,\n  EvaluateDirectCall,\n  GetThisValue,\n  IsInTailPosition,\n  SameValue,\n} from \"../methods/index.js\";\nimport type { BabelNodeCallExpression } from \"@babel/types\";\nimport invariant from \"../invariant.js\";\nimport SuperCall from \"./SuperCall.js\";\nimport { createOperationDescriptor } from \"../utils/generator.js\";\n\nexport default function(\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  if (ast.callee.type === \"Super\") {\n    return SuperCall(ast.arguments, strictCode, env, realm);\n  }\n\n  // ECMA262 12.3.4.1\n\n  // 1. Let ref be the result of evaluating MemberExpression.\n  let ref = env.evaluate(ast.callee, strictCode);\n\n  let previousLoc = realm.setNextExecutionContextLocation(ast.loc);\n  try {\n    return evaluateReference(ref, ast, strictCode, env, realm);\n  } finally {\n    realm.setNextExecutionContextLocation(previousLoc);\n  }\n}\n\nfunction getPrimitivePrototypeFromType(realm: Realm, value: AbstractValue): void | ObjectValue {\n  switch (value.getType()) {\n    case IntegralValue:\n    case NumberValue:\n      return realm.intrinsics.NumberPrototype;\n    case StringValue:\n      return realm.intrinsics.StringPrototype;\n    case BooleanValue:\n      return realm.intrinsics.BooleanPrototype;\n    case SymbolValue:\n      return realm.intrinsics.SymbolPrototype;\n    default:\n      return undefined;\n  }\n}\n\nfunction evaluateReference(\n  ref: Reference | Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  if (\n    ref instanceof Reference &&\n    ref.base instanceof AbstractValue &&\n    // TODO: what about ref.base conditionals that mightBeObjects?\n    ref.base.mightNotBeObject() &&\n    realm.isInPureScope()\n  ) {\n    let base = ref.base;\n    if (base.kind === \"conditional\") {\n      let [condValue, consequentVal, alternateVal] = base.args;\n      invariant(condValue instanceof AbstractValue);\n      return evaluateConditionalReferenceBase(ref, condValue, consequentVal, alternateVal, ast, strictCode, env, realm);\n    } else if (base.kind === \"||\") {\n      let [leftValue, rightValue] = base.args;\n      invariant(leftValue instanceof AbstractValue);\n      return evaluateConditionalReferenceBase(ref, leftValue, leftValue, rightValue, ast, strictCode, env, realm);\n    } else if (base.kind === \"&&\") {\n      let [leftValue, rightValue] = base.args;\n      invariant(leftValue instanceof AbstractValue);\n      return evaluateConditionalReferenceBase(ref, leftValue, rightValue, leftValue, ast, strictCode, env, realm);\n    }\n    let referencedName = ref.referencedName;\n\n    // When dealing with a PrimitiveValue, like StringValue, NumberValue, IntegralValue etc\n    // if we are referencing a prototype method, then it's safe to access, even\n    // on an abstract value as the value is immutable and can't have a property\n    // that matches the prototype method (unless the prototype was modified).\n    // We assume the global prototype of built-ins has not been altered since\n    // global code has finished. See #1233 for more context in regards to unmodified\n    // global prototypes.\n    let prototypeIfPrimitive = getPrimitivePrototypeFromType(realm, base);\n    if (prototypeIfPrimitive !== undefined && typeof referencedName === \"string\") {\n      let possibleMethodValue = prototypeIfPrimitive._SafeGetDataPropertyValue(referencedName);\n\n      if (possibleMethodValue instanceof FunctionValue) {\n        return EvaluateCall(ref, possibleMethodValue, ast, strictCode, env, realm);\n      }\n    }\n    // avoid explicitly converting ref.base to an object because that will create a generator entry\n    // leading to two object allocations rather than one.\n    return realm.evaluateWithPossibleThrowCompletion(\n      () => generateRuntimeCall(ref, base, ast, strictCode, env, realm),\n      TypesDomain.topVal,\n      ValuesDomain.topVal\n    );\n  }\n  // 2. Let func be ? GetValue(ref).\n  let func = Environment.GetValue(realm, ref);\n\n  return EvaluateCall(ref, func, ast, strictCode, env, realm);\n}\n\nfunction evaluateConditionalReferenceBase(\n  ref: Reference,\n  condValue: AbstractValue,\n  consequentVal: Value,\n  alternateVal: Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  return realm.evaluateWithAbstractConditional(\n    condValue,\n    () => {\n      return realm.evaluateForEffects(\n        () => {\n          if (isValidBaseValue(consequentVal)) {\n            let consequentRef = new Reference(\n              ((consequentVal: any): BaseValue),\n              ref.referencedName,\n              ref.strict,\n              ref.thisValue\n            );\n            return evaluateReference(consequentRef, ast, strictCode, env, realm);\n          }\n          return consequentVal;\n        },\n        null,\n        \"evaluateConditionalReferenceBase consequent\"\n      );\n    },\n    () => {\n      return realm.evaluateForEffects(\n        () => {\n          if (isValidBaseValue(alternateVal)) {\n            let alternateRef = new Reference(\n              ((alternateVal: any): BaseValue),\n              ref.referencedName,\n              ref.strict,\n              ref.thisValue\n            );\n            return evaluateReference(alternateRef, ast, strictCode, env, realm);\n          }\n          return alternateVal;\n        },\n        null,\n        \"evaluateConditionalReferenceBase alternate\"\n      );\n    }\n  );\n}\n\nfunction callBothFunctionsAndJoinTheirEffects(\n  condValue: AbstractValue,\n  consequentVal: Value,\n  alternateVal: Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  return realm.evaluateWithAbstractConditional(\n    condValue,\n    () => {\n      return realm.evaluateForEffects(\n        () => EvaluateCall(consequentVal, consequentVal, ast, strictCode, env, realm),\n        null,\n        \"callBothFunctionsAndJoinTheirEffects consequent\"\n      );\n    },\n    () => {\n      return realm.evaluateForEffects(\n        () => EvaluateCall(alternateVal, alternateVal, ast, strictCode, env, realm),\n        null,\n        \"callBothFunctionsAndJoinTheirEffects alternate\"\n      );\n    }\n  );\n}\n\nfunction generateRuntimeCall(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n) {\n  let args = [func];\n  let [thisArg, propName] = ref instanceof Reference ? [ref.base, ref.referencedName] : [];\n  if (thisArg instanceof Value) args = [thisArg];\n  if (propName !== undefined && typeof propName !== \"string\") args.push(propName);\n  args = args.concat(ArgumentListEvaluation(realm, strictCode, env, ast.arguments));\n  for (let arg of args) {\n    if (arg !== func) {\n      // Since we don't know which function we are calling, we assume that any unfrozen object\n      // passed as an argument has leaked to the environment as is any other object that is known to be reachable from this object.\n      // NB: Note that this is still optimistic, particularly if the environment exposes the same object\n      // to Prepack via alternative means, thus creating aliasing that is not tracked by Prepack.\n      Leak.value(realm, arg, ast.loc);\n    }\n  }\n  let resultType = (func instanceof AbstractObjectValue ? func.functionResultType : undefined) || Value;\n  return AbstractValue.createTemporalFromBuildFunction(\n    realm,\n    resultType,\n    args,\n    createOperationDescriptor(\"CALL_BAILOUT\", { propRef: propName, thisArg })\n  );\n}\n\nfunction tryToEvaluateCallOrLeaveAsAbstract(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  thisValue: Value,\n  tailCall: boolean\n): Value {\n  invariant(!realm.instantRender.enabled);\n  let effects;\n  let savedSuppressDiagnostics = realm.suppressDiagnostics;\n  try {\n    realm.suppressDiagnostics = !(func instanceof NativeFunctionValue) || func.name !== \"__optimize\";\n    effects = realm.evaluateForEffects(\n      () => EvaluateDirectCall(realm, strictCode, env, ref, func, thisValue, ast.arguments, tailCall),\n      undefined,\n      \"tryToEvaluateCallOrLeaveAsAbstract\"\n    );\n  } catch (error) {\n    if (error instanceof FatalError) {\n      if (func instanceof NativeFunctionValue && func.name === \"__fatal\") throw error;\n      realm.suppressDiagnostics = savedSuppressDiagnostics;\n      Leak.value(realm, func, ast.loc);\n      return realm.evaluateWithPossibleThrowCompletion(\n        () => generateRuntimeCall(ref, func, ast, strictCode, env, realm),\n        TypesDomain.topVal,\n        ValuesDomain.topVal\n      );\n    } else {\n      throw error;\n    }\n  } finally {\n    realm.suppressDiagnostics = savedSuppressDiagnostics;\n  }\n  realm.applyEffects(effects);\n  return realm.returnOrThrowCompletion(effects.result);\n}\n\nfunction EvaluateCall(\n  ref: Value | Reference,\n  func: Value,\n  ast: BabelNodeCallExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  if (func instanceof AbstractValue) {\n    let loc = ast.callee.type === \"MemberExpression\" ? ast.callee.property.loc : ast.callee.loc;\n    if (func.kind === \"conditional\") {\n      let [condValue, consequentVal, alternateVal] = func.args;\n      invariant(condValue instanceof AbstractValue);\n      // If neither values are functions than do not try and call both functions with a conditional\n      if (\n        Value.isTypeCompatibleWith(consequentVal.getType(), FunctionValue) ||\n        Value.isTypeCompatibleWith(alternateVal.getType(), FunctionValue)\n      ) {\n        return callBothFunctionsAndJoinTheirEffects(\n          condValue,\n          consequentVal,\n          alternateVal,\n          ast,\n          strictCode,\n          env,\n          realm\n        );\n      }\n    } else if (func.kind === \"||\") {\n      let [leftValue, rightValue] = func.args;\n      invariant(leftValue instanceof AbstractValue);\n      // If neither values are functions than do not try and call both functions with a conditional\n      if (\n        Value.isTypeCompatibleWith(leftValue.getType(), FunctionValue) ||\n        Value.isTypeCompatibleWith(rightValue.getType(), FunctionValue)\n      ) {\n        return callBothFunctionsAndJoinTheirEffects(leftValue, leftValue, rightValue, ast, strictCode, env, realm);\n      }\n    } else if (func.kind === \"&&\") {\n      let [leftValue, rightValue] = func.args;\n      invariant(leftValue instanceof AbstractValue);\n      // If neither values are functions than do not try and call both functions with a conditional\n      if (\n        Value.isTypeCompatibleWith(leftValue.getType(), FunctionValue) ||\n        Value.isTypeCompatibleWith(rightValue.getType(), FunctionValue)\n      ) {\n        return callBothFunctionsAndJoinTheirEffects(leftValue, rightValue, leftValue, ast, strictCode, env, realm);\n      }\n    }\n    if (!Value.isTypeCompatibleWith(func.getType(), FunctionValue)) {\n      if (!realm.isInPureScope()) {\n        // If this is not a function, this call might throw which can change the state of the program.\n        // If this is called from a pure function we handle it using evaluateWithPossiblyAbruptCompletion.\n        let error = new CompilerDiagnostic(\"might not be a function\", loc, \"PP0005\", \"RecoverableError\");\n        if (realm.handleError(error) === \"Fail\") throw new FatalError();\n      }\n    } else {\n      // Assume that it is a safe function. TODO #705: really?\n    }\n    if (realm.isInPureScope()) {\n      // In pure functions we allow abstract functions to throw, which this might.\n      return realm.evaluateWithPossibleThrowCompletion(\n        () => generateRuntimeCall(ref, func, ast, strictCode, env, realm),\n        TypesDomain.topVal,\n        ValuesDomain.topVal\n      );\n    }\n    return generateRuntimeCall(ref, func, ast, strictCode, env, realm);\n  }\n  invariant(func instanceof ConcreteValue);\n\n  // 3. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is \"eval\", then\n  if (\n    ref instanceof Reference &&\n    !Environment.IsPropertyReference(realm, ref) &&\n    Environment.GetReferencedName(realm, ref) === \"eval\"\n  ) {\n    // a. If SameValue(func, %eval%) is true, then\n    if (SameValue(realm, func, realm.intrinsics.eval)) {\n      // i. Let argList be ? ArgumentListEvaluation(Arguments).\n      let argList = ArgumentListEvaluation(realm, strictCode, env, ast.arguments);\n      // ii. If argList has no elements, return undefined.\n      if (argList.length === 0) return realm.intrinsics.undefined;\n      // iii. Let evalText be the first element of argList.\n      let evalText = argList[0];\n      // iv. If the source code matching this CallExpression is strict code, let strictCaller be true. Otherwise let strictCaller be false.\n      let strictCaller = strictCode;\n      // v. Let evalRealm be the current Realm Record.\n      let evalRealm = realm;\n      // vi. Return ? PerformEval(evalText, evalRealm, strictCaller, true).\n      if (evalText instanceof AbstractValue) {\n        let loc = ast.arguments[0].loc;\n        let error = new CompilerDiagnostic(\"eval argument must be a known value\", loc, \"PP0006\", \"RecoverableError\");\n        if (realm.handleError(error) === \"Fail\") throw new FatalError();\n        // Assume that it is a safe eval with no visible heap changes or abrupt control flow.\n        return generateRuntimeCall(ref, func, ast, strictCode, env, realm);\n      }\n      return Functions.PerformEval(realm, evalText, evalRealm, strictCaller, true);\n    }\n  }\n\n  let thisValue;\n\n  // 4. If Type(ref) is Reference, then\n  if (ref instanceof Reference) {\n    // a. If IsPropertyReference(ref) is true, then\n    if (Environment.IsPropertyReference(realm, ref)) {\n      // i. Let thisValue be GetThisValue(ref).\n      thisValue = GetThisValue(realm, ref);\n    } else {\n      // b. Else, the base of ref is an Environment Record\n      // i. Let refEnv be GetBase(ref).\n      let refEnv = Environment.GetBase(realm, ref);\n      invariant(refEnv instanceof EnvironmentRecord);\n\n      // ii. Let thisValue be refEnv.WithBaseObject().\n      thisValue = refEnv.WithBaseObject();\n    }\n  } else {\n    // 5. Else Type(ref) is not Reference,\n    // a. Let thisValue be undefined.\n    thisValue = realm.intrinsics.undefined;\n  }\n\n  // 6. Let thisCall be this CallExpression.\n  let thisCall = ast;\n\n  // 7. Let tailCall be IsInTailPosition(thisCall). (See 14.6.1)\n  let tailCall = IsInTailPosition(realm, thisCall);\n\n  // 8. Return ? EvaluateDirectCall(func, thisValue, Arguments, tailCall).\n  if (realm.isInPureScope() && !realm.instantRender.enabled) {\n    return tryToEvaluateCallOrLeaveAsAbstract(ref, func, ast, strictCode, env, realm, thisValue, tailCall);\n  } else {\n    return EvaluateDirectCall(realm, strictCode, env, ref, func, thisValue, ast.arguments, tailCall);\n  }\n}\n"],"file":"CallExpression.js"}