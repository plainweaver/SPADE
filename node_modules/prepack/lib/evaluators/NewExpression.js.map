{"version":3,"sources":["../../src/evaluators/NewExpression.js"],"names":["ast","strictCode","env","realm","constructProduction","callee","args","arguments","ref","evaluate","constructor","Environment","GetValue","argsList","length","previousLoc","setNextExecutionContextLocation","loc","isInPureScope","tryToEvaluateConstructOrLeaveAsAbstract","createConstruct","effects","evaluateForEffects","undefined","error","FatalError","Leak","value","arg","abstractValue","evaluateWithPossibleThrowCompletion","AbstractValue","createTemporalFromBuildFunction","ObjectValue","TypesDomain","topVal","ValuesDomain","AbstractObjectValue","applyEffects","completion","returnOrThrowCompletion","result","createErrorThrowCompletion","intrinsics","TypeError"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { ObjectValue, Value, AbstractObjectValue, AbstractValue } from \"../values/index.js\";\nimport { Environment, Leak } from \"../singletons.js\";\nimport { IsConstructor, ArgumentListEvaluation } from \"../methods/index.js\";\nimport { Construct } from \"../methods/index.js\";\nimport invariant from \"../invariant.js\";\nimport { FatalError } from \"../errors.js\";\nimport { BabelNodeNewExpression } from \"@babel/types\";\nimport { createOperationDescriptor } from \"../utils/generator.js\";\n\nexport default function(\n  ast: BabelNodeNewExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): ObjectValue | AbstractObjectValue {\n  // ECMA262 12.3.3.1 We just implement this method inline since it's only called here.\n  // 1. Return ? EvaluateNew(NewExpression, empty).\n\n  // ECMA262 2.3.3.1.1\n\n  let constructProduction = ast.callee;\n  let args = ast.arguments;\n\n  // These steps not necessary due to our AST representation.\n  // 1. Assert: constructProduction is either a NewExpression or a MemberExpression.\n  // 2. Assert: arguments is either empty or an Arguments production.\n\n  // 3. Let ref be the result of evaluating constructProduction.\n  let ref = env.evaluate(constructProduction, strictCode);\n\n  // 4. Let constructor be ? GetValue(ref).\n  let constructor = Environment.GetValue(realm, ref);\n\n  let argsList;\n\n  // 5. If arguments is empty, let argList be a new empty List.\n  if (!args.length) {\n    argsList = [];\n  } else {\n    // 6. Else,\n    // a. Let argList be ArgumentListEvaluation of arguments.\n    argsList = ArgumentListEvaluation(realm, strictCode, env, (args: any)); // BabelNodeNewExpression needs updating\n\n    // This step not necessary since we propagate completions with exceptions.\n    // b. ReturnIfAbrupt(argList).\n  }\n\n  let previousLoc = realm.setNextExecutionContextLocation(ast.loc);\n  try {\n    // If we are in pure scope, attempt to recover from creating the construct if\n    // it fails by creating a temporal abstract\n    if (realm.isInPureScope()) {\n      return tryToEvaluateConstructOrLeaveAsAbstract(constructor, argsList, strictCode, realm);\n    } else {\n      return createConstruct(constructor, argsList, realm);\n    }\n  } finally {\n    realm.setNextExecutionContextLocation(previousLoc);\n  }\n}\n\nfunction tryToEvaluateConstructOrLeaveAsAbstract(\n  constructor: Value,\n  argsList: Array<Value>,\n  strictCode: boolean,\n  realm: Realm\n): ObjectValue | AbstractObjectValue {\n  let effects;\n  try {\n    effects = realm.evaluateForEffects(\n      () => createConstruct(constructor, argsList, realm),\n      undefined,\n      \"tryToEvaluateConstructOrLeaveAsAbstract\"\n    );\n  } catch (error) {\n    // if a FatalError occurs when constructing the constructor\n    // then try and recover and create an abstract for this construct\n    if (error instanceof FatalError) {\n      // we need to leak all the arguments and the constructor\n      Leak.value(realm, constructor);\n      for (let arg of argsList) {\n        Leak.value(realm, arg);\n      }\n      let abstractValue = realm.evaluateWithPossibleThrowCompletion(\n        () =>\n          AbstractValue.createTemporalFromBuildFunction(\n            realm,\n            ObjectValue,\n            [constructor, ...argsList],\n            createOperationDescriptor(\"NEW_EXPRESSION\")\n          ),\n        TypesDomain.topVal,\n        ValuesDomain.topVal\n      );\n      invariant(abstractValue instanceof AbstractObjectValue);\n      return abstractValue;\n    } else {\n      throw error;\n    }\n  }\n  realm.applyEffects(effects);\n  let completion = realm.returnOrThrowCompletion(effects.result);\n  invariant(completion instanceof ObjectValue || completion instanceof AbstractObjectValue);\n  return completion;\n}\n\nfunction createConstruct(constructor: Value, argsList: Array<Value>, realm: Realm): ObjectValue | AbstractObjectValue {\n  // 7. If IsConstructor(constructor) is false, throw a TypeError exception.\n  if (IsConstructor(realm, constructor) === false) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n  invariant(constructor instanceof ObjectValue);\n\n  // 8. Return ? Construct(constructor, argList).\n  return Construct(realm, constructor, argsList);\n}\n"],"file":"NewExpression.js"}