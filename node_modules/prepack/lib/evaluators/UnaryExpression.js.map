{"version":3,"sources":["../../src/evaluators/UnaryExpression.js"],"names":["isInstance","proto","Constructor","prototype","evaluateDeleteOperation","expr","realm","ref","Reference","intrinsics","true","Environment","IsUnresolvableReference","IsStrictReference","IsPropertyReference","IsSuperReference","createErrorThrowCompletion","ReferenceError","base","GetBase","ConcreteValue","AbstractObjectValue","baseObj","To","ToObject","deleteStatus","$Delete","GetReferencedName","TypeError","BooleanValue","bindings","EnvironmentRecord","referencedName","DeleteBinding","tryToEvaluateOperationOrLeaveAsAbstract","ast","func","strictCode","effects","evaluateForEffects","undefined","error","FatalError","evaluateWithPossibleThrowCompletion","value","GetValue","AbstractValue","createFromUnaryOp","operator","TypesDomain","topVal","ValuesDomain","applyEffects","returnOrThrowCompletion","result","evaluateOperation","reportError","getType","SymbolValue","CompilerDiagnostic","argument","loc","handleError","IsToNumberPure","IntegralValue","createFromNumberValue","ToNumber","oldValue","isNaN","NaN","ToInt32","GetConditionValue","ToBoolean","false","val","StringValue","UndefinedValue","NullValue","NumberValue","ObjectValue","env","evaluate","isInPureScope"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\n//import { SimpleNormalCompletion } from \"../completions.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport {\n  AbstractObjectValue,\n  Value,\n  BooleanValue,\n  ConcreteValue,\n  NumberValue,\n  IntegralValue,\n  StringValue,\n  UndefinedValue,\n  NullValue,\n  SymbolValue,\n  ObjectValue,\n  AbstractValue,\n} from \"../values/index.js\";\nimport { Reference, EnvironmentRecord } from \"../environment.js\";\nimport invariant from \"../invariant.js\";\nimport { IsCallable } from \"../methods/index.js\";\nimport { Environment, To } from \"../singletons.js\";\nimport type { BabelNodeUnaryExpression } from \"@babel/types\";\n\nfunction isInstance(proto, Constructor): boolean {\n  return proto instanceof Constructor || proto === Constructor.prototype;\n}\n\nfunction evaluateDeleteOperation(expr: Value | Reference, realm: Realm) {\n  // ECMA262 12.5.3.2\n\n  // 1. Let ref be the result of evaluating UnaryExpression.\n  let ref = expr;\n\n  // 2. ReturnIfAbrupt(ref).\n\n  // 3. If Type(ref) is not Reference, return true.\n  if (!(ref instanceof Reference)) return realm.intrinsics.true;\n\n  // 4. If IsUnresolvableReference(ref) is true, then\n  if (Environment.IsUnresolvableReference(realm, ref)) {\n    // a. Assert: IsStrictReference(ref) is false.\n    invariant(!Environment.IsStrictReference(realm, ref), \"did not expect a strict reference\");\n\n    // b. Return true.\n    return realm.intrinsics.true;\n  }\n\n  // 5. If IsPropertyReference(ref) is true, then\n  if (Environment.IsPropertyReference(realm, ref)) {\n    // a. If IsSuperReference(ref) is true, throw a ReferenceError exception.\n    if (Environment.IsSuperReference(realm, ref)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // b. Let baseObj be ! ToObject(GetBase(ref)).\n    let base = Environment.GetBase(realm, ref);\n    // Constructing the reference checks that base is coercible to an object hence\n    invariant(base instanceof ConcreteValue || base instanceof AbstractObjectValue);\n    let baseObj = To.ToObject(realm, base);\n\n    // c. Let deleteStatus be ? baseObj.[[Delete]](GetReferencedName(ref)).\n    let deleteStatus = baseObj.$Delete(Environment.GetReferencedName(realm, ref));\n\n    // d. If deleteStatus is false and IsStrictReference(ref) is true, throw a TypeError exception.\n    if (!deleteStatus && Environment.IsStrictReference(realm, ref)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // e. Return deleteStatus.\n    return new BooleanValue(realm, deleteStatus);\n  }\n\n  // 6. Else ref is a Reference to an Environment Record binding,\n  // a. Let bindings be GetBase(ref).\n  let bindings = Environment.GetBase(realm, ref);\n  invariant(bindings instanceof EnvironmentRecord);\n\n  // b. Return ? bindings.DeleteBinding(GetReferencedName(ref)).\n  let referencedName = Environment.GetReferencedName(realm, ref);\n  invariant(typeof referencedName === \"string\");\n  return new BooleanValue(realm, bindings.DeleteBinding(referencedName));\n}\n\nfunction tryToEvaluateOperationOrLeaveAsAbstract(\n  ast: BabelNodeUnaryExpression,\n  expr: Value | Reference,\n  func: (ast: BabelNodeUnaryExpression, expr: Value | Reference, strictCode: boolean, realm: Realm) => Value,\n  strictCode: boolean,\n  realm: Realm\n): Value {\n  let effects;\n  try {\n    effects = realm.evaluateForEffects(\n      () => func(ast, expr, strictCode, realm),\n      undefined,\n      \"tryToEvaluateOperationOrLeaveAsAbstract\"\n    );\n  } catch (error) {\n    if (error instanceof FatalError) {\n      return realm.evaluateWithPossibleThrowCompletion(\n        () => {\n          let value = Environment.GetValue(realm, expr);\n\n          // if the value is abstract, then create a unary op for it,\n          // otherwise we rethrow the error as we don't handle it at this\n          // point in time\n          if (value instanceof AbstractValue) {\n            return AbstractValue.createFromUnaryOp(realm, ast.operator, value);\n          }\n          throw error;\n        },\n        TypesDomain.topVal,\n        ValuesDomain.topVal\n      );\n    } else {\n      throw error;\n    }\n  }\n  realm.applyEffects(effects);\n  return realm.returnOrThrowCompletion(effects.result);\n}\n\nfunction evaluateOperation(\n  ast: BabelNodeUnaryExpression,\n  expr: Value | Reference,\n  strictCode: boolean,\n  realm: Realm\n): Value {\n  function reportError(value: Value) {\n    if (value.getType() === SymbolValue) {\n      // Symbols never implicitly coerce to primitives.\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n    let error = new CompilerDiagnostic(\n      \"might be a symbol or an object with an unknown valueOf or toString or Symbol.toPrimitive method\",\n      ast.argument.loc,\n      \"PP0008\",\n      \"RecoverableError\"\n    );\n    if (realm.handleError(error) === \"Fail\") throw new FatalError();\n  }\n\n  if (ast.operator === \"+\") {\n    // ECMA262 12.5.6.1\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Return ? ToNumber(? GetValue(expr)).\n    let value = Environment.GetValue(realm, expr);\n    if (value instanceof AbstractValue) {\n      if (!To.IsToNumberPure(realm, value)) reportError(value);\n      return AbstractValue.createFromUnaryOp(realm, \"+\", value);\n    }\n    invariant(value instanceof ConcreteValue);\n\n    return IntegralValue.createFromNumberValue(realm, To.ToNumber(realm, value));\n  } else if (ast.operator === \"-\") {\n    // ECMA262 12.5.7.1\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ? ToNumber(? GetValue(expr)).\n    let value = Environment.GetValue(realm, expr);\n    if (value instanceof AbstractValue) {\n      if (!To.IsToNumberPure(realm, value)) reportError(value);\n      return AbstractValue.createFromUnaryOp(realm, \"-\", value);\n    }\n    invariant(value instanceof ConcreteValue);\n    let oldValue = To.ToNumber(realm, value);\n\n    // 3. If oldValue is NaN, return NaN.\n    if (isNaN(oldValue)) {\n      return realm.intrinsics.NaN;\n    }\n\n    // 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.\n    return IntegralValue.createFromNumberValue(realm, -oldValue);\n  } else if (ast.operator === \"~\") {\n    // ECMA262 12.5.8\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ? ToInt32(? GetValue(expr)).\n    let value = Environment.GetValue(realm, expr);\n    if (value instanceof AbstractValue) {\n      if (!To.IsToNumberPure(realm, value)) reportError(value);\n      return AbstractValue.createFromUnaryOp(realm, \"~\", value);\n    }\n    invariant(value instanceof ConcreteValue);\n    let oldValue = To.ToInt32(realm, value);\n\n    // 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.\n    return IntegralValue.createFromNumberValue(realm, ~oldValue);\n  } else if (ast.operator === \"!\") {\n    // ECMA262 12.6.9\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Let oldValue be ToBoolean(? GetValue(expr)).\n    let value = Environment.GetConditionValue(realm, expr);\n    if (value instanceof AbstractValue) return AbstractValue.createFromUnaryOp(realm, \"!\", value);\n    invariant(value instanceof ConcreteValue);\n    let oldValue = To.ToBoolean(realm, value);\n\n    // 3. If oldValue is true, return false.\n    if (oldValue === true) return realm.intrinsics.false;\n\n    // 4. Return true.\n    return realm.intrinsics.true;\n  } else if (ast.operator === \"void\") {\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    expr;\n\n    // 2. Perform ? GetValue(expr).\n    Environment.GetValue(realm, expr);\n\n    // 3. Return undefined.\n    return realm.intrinsics.undefined;\n  } else {\n    invariant(ast.operator === \"typeof\");\n    // ECMA262 12.6.5\n\n    // 1. Let val be the result of evaluating UnaryExpression.\n    let val = expr;\n\n    // 2. If Type(val) is Reference, then\n    if (val instanceof Reference) {\n      // a. If IsUnresolvableReference(val) is true, return \"undefined\".\n      if (Environment.IsUnresolvableReference(realm, val)) {\n        return new StringValue(realm, \"undefined\");\n      }\n    }\n\n    // 3. Let val be ? GetValue(val).\n    val = Environment.GetValue(realm, val);\n\n    // 4. Return a String according to Table 35.\n    let proto = val.getType().prototype;\n    if (isInstance(proto, UndefinedValue)) {\n      return new StringValue(realm, \"undefined\");\n    } else if (isInstance(proto, NullValue)) {\n      return new StringValue(realm, \"object\");\n    } else if (isInstance(proto, StringValue)) {\n      return new StringValue(realm, \"string\");\n    } else if (isInstance(proto, BooleanValue)) {\n      return new StringValue(realm, \"boolean\");\n    } else if (isInstance(proto, NumberValue)) {\n      return new StringValue(realm, \"number\");\n    } else if (isInstance(proto, SymbolValue)) {\n      return new StringValue(realm, \"symbol\");\n    } else if (isInstance(proto, ObjectValue)) {\n      if (IsCallable(realm, val)) {\n        return new StringValue(realm, \"function\");\n      }\n      return new StringValue(realm, \"object\");\n    } else {\n      invariant(val instanceof AbstractValue);\n      return AbstractValue.createFromUnaryOp(realm, \"typeof\", val);\n    }\n  }\n}\n\nexport default function(\n  ast: BabelNodeUnaryExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  let expr = env.evaluate(ast.argument, strictCode);\n\n  if (ast.operator === \"delete\") {\n    return evaluateDeleteOperation(expr, realm);\n  }\n  if (realm.isInPureScope()) {\n    return tryToEvaluateOperationOrLeaveAsAbstract(ast, expr, evaluateOperation, strictCode, realm);\n  } else {\n    return evaluateOperation(ast, expr, strictCode, realm);\n  }\n}\n"],"file":"UnaryExpression.js"}