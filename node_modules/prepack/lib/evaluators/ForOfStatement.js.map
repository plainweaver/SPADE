{"version":3,"sources":["../../src/evaluators/ForOfStatement.js"],"names":["InternalGetResultValue","realm","result","Completion","value","LoopContinues","completion","labelSet","Value","NormalCompletion","JoinedAbruptCompletions","consequent","alternate","ContinueCompletion","target","indexOf","BindingInstantiation","ast","env","envRec","environmentRecord","DeclarativeEnvironmentRecord","name","Environment","BoundNames","kind","CreateImmutableBinding","CreateMutableBinding","ForInOfHeadEvaluation","TDZnames","expr","iterationKind","strictCode","oldEnv","getRunningContext","lexicalEnvironment","length","TDZ","NewDeclarativeEnvironment","TDZEnvRec","exprRef","evaluate","lexEnv","onDestroyScope","exprValue","GetValue","NullValue","UndefinedValue","BreakCompletion","intrinsics","empty","loc","obj","To","ToObject","isPartialObject","AbstractObjectValue","Properties","EnumerateObjectProperties","AbstractValue","error","CompilerDiagnostic","handleError","FatalError","ForInOfBodyEvaluation","lhs","stmt","iterator","lhsKind","V","undefined","destructuring","IsDestructuring","type","nextResult","nextValue","iterationEnv","lhsRef","evaluateCompletion","names","lhsName","ResolveBinding","status","AbruptCompletion","Reference","InitializeReferencedBinding","PutValue","BindingInitialization","e","resultValue","EmptyValue","left","right","body","keyResult","ObjectValue","declarations","id"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { Reference } from \"../environment.js\";\nimport {\n  AbruptCompletion,\n  BreakCompletion,\n  Completion,\n  ContinueCompletion,\n  JoinedAbruptCompletions,\n  NormalCompletion,\n} from \"../completions.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  EmptyValue,\n  NullValue,\n  ObjectValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\nimport {\n  IteratorStep,\n  IteratorValue,\n  IteratorClose,\n  UpdateEmpty,\n  DestructuringAssignmentEvaluation,\n  GetIterator,\n} from \"../methods/index.js\";\nimport { Environment, Properties, To } from \"../singletons.js\";\nimport type {\n  BabelNode,\n  BabelNodeForOfStatement,\n  BabelNodeLVal,\n  BabelNodeStatement,\n  BabelNodeVariableDeclaration,\n} from \"@babel/types\";\n\nexport type IterationKind = \"iterate\" | \"enumerate\";\nexport type LhsKind = \"lexicalBinding\" | \"varBinding\" | \"assignment\";\n\nexport function InternalGetResultValue(realm: Realm, result: Value | Completion): Value {\n  if (result instanceof Completion) {\n    return result.value;\n  } else {\n    return result;\n  }\n}\n\n// ECMA262 13.7.1.2\nexport function LoopContinues(realm: Realm, completion: Value | Completion, labelSet: ?Array<string>): boolean {\n  // 1. If completion.[[Type]] is normal, return true.\n  if (completion instanceof Value || completion instanceof NormalCompletion) return true;\n  if (completion instanceof JoinedAbruptCompletions) {\n    return (\n      LoopContinues(realm, completion.consequent, labelSet) || LoopContinues(realm, completion.alternate, labelSet)\n    );\n  }\n\n  // 2. If completion.[[Type]] is not continue, return false.\n  if (!(completion instanceof ContinueCompletion)) return false;\n\n  // 3. If completion.[[Target]] is empty, return true.\n  if (!completion.target) return true;\n\n  // 4. If completion.[[Target]] is an element of labelSet, return true.\n  if (labelSet != null && labelSet.indexOf(completion.target) >= 0) return true;\n\n  // 5. Return false.\n  return false;\n}\n\n// ECMA262 13.7.5.10\nfunction BindingInstantiation(realm: Realm, ast: BabelNodeVariableDeclaration, env: LexicalEnvironment) {\n  // ast = ForDeclaration : LetOrConst ForBinding\n\n  // 1. Let envRec be environment's EnvironmentRecord.\n  let envRec = env.environmentRecord;\n\n  // 2. Assert: envRec is a declarative Environment Record.\n  invariant(envRec instanceof DeclarativeEnvironmentRecord);\n\n  // 3. For each element name of the BoundNames of ForBinding do\n  for (let name of Environment.BoundNames(realm, ast)) {\n    // a. If IsConstantDeclaration of LetOrConst is true, then\n    if (ast.kind === \"const\") {\n      // i. Perform ! envRec.CreateImmutableBinding(name, true).\n      envRec.CreateImmutableBinding(name, true);\n    } else {\n      // b.\n      // i. Perform ! envRec.CreateMutableBinding(name, false).\n      envRec.CreateMutableBinding(name, false);\n    }\n  }\n}\n\n// ECMA262 13.7.5.12\nexport function ForInOfHeadEvaluation(\n  realm: Realm,\n  env: LexicalEnvironment,\n  TDZnames: Array<string>,\n  expr: BabelNode,\n  iterationKind: IterationKind,\n  strictCode: boolean\n): ObjectValue | AbstractObjectValue {\n  // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. If TDZnames is not an empty List, then\n  if (TDZnames.length) {\n    // a. Assert: TDZnames has no duplicate entries.\n\n    // b. Let TDZ be NewDeclarativeEnvironment(oldEnv).\n    let TDZ = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n    // c. Let TDZEnvRec be TDZ's EnvironmentRecord.\n    let TDZEnvRec = TDZ.environmentRecord;\n\n    // d. For each string name in TDZnames, do\n    for (let name of TDZnames) {\n      // i. Perform ! TDZEnvRec.CreateMutableBinding(name, false).\n      TDZEnvRec.CreateMutableBinding(name, false);\n    }\n\n    // e. Set the running execution context's LexicalEnvironment to TDZ.\n    realm.getRunningContext().lexicalEnvironment = TDZ;\n    env = TDZ;\n  }\n\n  let exprRef;\n  try {\n    // 3. Let exprRef be the result of evaluating expr.\n    exprRef = env.evaluate(expr, strictCode);\n  } finally {\n    // 4. Set the running execution context's LexicalEnvironment to oldEnv.\n    let lexEnv = realm.getRunningContext().lexicalEnvironment;\n    if (lexEnv !== oldEnv) realm.onDestroyScope(lexEnv);\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n  }\n  env = oldEnv;\n\n  // 5. Let exprValue be ? GetValue(exprRef).\n  let exprValue = Environment.GetValue(realm, exprRef);\n\n  // 6. If iterationKind is enumerate, then\n  if (iterationKind === \"enumerate\") {\n    // a. If exprValue.[[Value]] is null or undefined, then\n    if (exprValue instanceof NullValue || exprValue instanceof UndefinedValue) {\n      // i. Return Completion{[[Type]]: break, [[Value]]: empty, [[Target]]: empty}.\n      throw new BreakCompletion(realm.intrinsics.empty, expr.loc, null);\n    }\n\n    // b. Let obj be ToObject(exprValue).\n    let obj = To.ToObject(realm, exprValue);\n\n    // c. Return ? EnumerateObjectProperties(obj).\n    if (obj.isPartialObject() || obj instanceof AbstractObjectValue) {\n      return obj;\n    } else {\n      return Properties.EnumerateObjectProperties(realm, obj);\n    }\n  } else {\n    // 8. Else,\n    // 1. Assert: iterationKind is iterate.\n    invariant(iterationKind === \"iterate\", \"expected iterationKind to be iterate\");\n\n    if (exprValue instanceof AbstractValue) {\n      let error = new CompilerDiagnostic(\n        \"for of loops over unknown collections are not yet supported\",\n        expr.loc,\n        \"PP0014\",\n        \"FatalError\"\n      );\n      realm.handleError(error);\n      throw new FatalError();\n    }\n\n    // 1. Return ? GetIterator(exprValue).\n    return GetIterator(realm, exprValue);\n  }\n}\n\n// ECMA262 13.7.5.13\nexport function ForInOfBodyEvaluation(\n  realm: Realm,\n  env: LexicalEnvironment,\n  lhs: BabelNodeVariableDeclaration | BabelNodeLVal,\n  stmt: BabelNodeStatement,\n  iterator: ObjectValue,\n  lhsKind: LhsKind,\n  labelSet: ?Array<string>,\n  strictCode: boolean\n): Value {\n  // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. Let V be undefined.\n  let V: Value = realm.intrinsics.undefined;\n\n  // 3. Let destructuring be IsDestructuring of lhs.\n  let destructuring = Environment.IsDestructuring(lhs);\n\n  // 4. If destructuring is true and if lhsKind is assignment, then\n  if (destructuring && lhsKind === \"assignment\") {\n    // a. Assert: lhs is a LeftHandSideExpression.\n    invariant(lhs.type !== \"VariableDeclaration\");\n\n    // b. Let assignmentPattern be the parse of the source text corresponding to lhs using AssignmentPattern as the goal symbol.\n  }\n\n  // 5. Repeat\n  while (true) {\n    // a. Let nextResult be ? IteratorStep(iterator).\n    let nextResult = IteratorStep(realm, iterator);\n\n    // b. If nextResult is false, return NormalCompletion(V).\n    if (!nextResult) return V;\n\n    // c. Let nextValue be ? IteratorValue(nextResult).\n    let nextValue = IteratorValue(realm, nextResult);\n\n    // d. If lhsKind is either assignment or varBinding, then\n    let iterationEnv: void | LexicalEnvironment;\n    let lhsRef;\n    if (lhsKind === \"assignment\" || lhsKind === \"varBinding\") {\n      // i. If destructuring is false, then\n      if (!destructuring) {\n        // 1. Let lhsRef be the result of evaluating lhs. (It may be evaluated repeatedly.)\n        lhsRef = env.evaluateCompletion(lhs, strictCode);\n      }\n    } else {\n      // e. Else,\n      // i. Assert: lhsKind is lexicalBinding.\n      invariant(lhsKind === \"lexicalBinding\", \"expected lhsKind to be lexicalBinding\");\n      invariant(lhs.type === \"VariableDeclaration\");\n\n      // ii. Assert: lhs is a ForDeclaration.\n\n      // iii. Let iterationEnv be NewDeclarativeEnvironment(oldEnv).\n      iterationEnv = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n      // iv. Perform BindingInstantiation for lhs passing iterationEnv as the argument.\n      BindingInstantiation(realm, lhs, iterationEnv);\n\n      // v. Set the running execution context's LexicalEnvironment to iterationEnv.\n      realm.getRunningContext().lexicalEnvironment = iterationEnv;\n      env = iterationEnv;\n\n      // vi. If destructuring is false, then\n      if (!destructuring) {\n        let names = Environment.BoundNames(realm, lhs);\n\n        // 1. Assert: lhs binds a single name.\n        invariant(names.length === 1, \"expected single name\");\n\n        // 2. Let lhsName be the sole element of BoundNames of lhs.\n        let lhsName = names[0];\n\n        // 3. Let lhsRef be ! ResolveBinding(lhsName).\n        lhsRef = Environment.ResolveBinding(realm, lhsName, strictCode);\n      }\n    }\n\n    // f. If destructuring is false, then\n    let status;\n    try {\n      if (!destructuring) {\n        // i. If lhsRef is an abrupt completion, then\n        if (lhsRef instanceof AbruptCompletion) {\n          // 1. Let status be lhsRef.\n          status = lhsRef;\n        } else if (lhsKind === \"lexicalBinding\") {\n          // ii. Else if lhsKind is lexicalBinding, then\n          // 1. Let status be InitializeReferencedBinding(lhsRef, nextValue).\n          invariant(lhsRef instanceof Reference);\n          status = Environment.InitializeReferencedBinding(realm, lhsRef, nextValue);\n        } else {\n          // iii. Else,\n          // 1. Let status be PutValue(lhsRef, nextValue).\n          invariant(lhsRef !== undefined);\n          status = Properties.PutValue(realm, lhsRef, nextValue);\n        }\n      } else {\n        // g. Else,\n        // i. If lhsKind is assignment, then\n        if (lhsKind === \"assignment\") {\n          invariant(lhs.type === \"ArrayPattern\" || lhs.type === \"ObjectPattern\");\n\n          // 1. Let status be the result of performing DestructuringAssignmentEvaluation of assignmentPattern using nextValue as the argument.\n          status = DestructuringAssignmentEvaluation(realm, lhs, nextValue, strictCode, iterationEnv || env);\n        } else if (lhsKind === \"varBinding\") {\n          // ii. Else if lhsKind is varBinding, then\n          // 1. Assert: lhs is a ForBinding.\n\n          // 2. Let status be the result of performing BindingInitialization for lhs passing nextValue and undefined as the arguments.\n          status = Environment.BindingInitialization(realm, lhs, nextValue, strictCode, undefined);\n        } else {\n          // iii. Else,\n          // 1. Assert: lhsKind is lexicalBinding.\n          invariant(lhsKind === \"lexicalBinding\");\n\n          // 2. Assert: lhs is a ForDeclaration.\n\n          // 3. Let status be the result of performing BindingInitialization for lhs passing nextValue and iterationEnv as arguments.\n          invariant(iterationEnv !== undefined);\n          status = Environment.BindingInitialization(realm, lhs, nextValue, strictCode, iterationEnv);\n        }\n      }\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        status = e;\n      } else {\n        throw e;\n      }\n    }\n\n    // h. If status is an abrupt completion, then\n    if (status instanceof AbruptCompletion) {\n      // i. Set the running execution context's LexicalEnvironment to oldEnv.\n      realm.getRunningContext().lexicalEnvironment = oldEnv;\n\n      // ii. Return ? IteratorClose(iterator, status).\n      throw IteratorClose(realm, iterator, status);\n    }\n\n    // i. Let result be the result of evaluating stmt.\n    let result = env.evaluateCompletion(stmt, strictCode);\n    invariant(result instanceof Value || result instanceof AbruptCompletion);\n\n    // j. Set the running execution context's LexicalEnvironment to oldEnv.\n\n    let lexEnv = realm.getRunningContext().lexicalEnvironment;\n    if (lexEnv !== oldEnv) realm.onDestroyScope(lexEnv);\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n    env = oldEnv;\n\n    // k. If LoopContinues(result, labelSet) is false, return ? IteratorClose(iterator, UpdateEmpty(result, V)).\n    if (!LoopContinues(realm, result, labelSet)) {\n      invariant(result instanceof AbruptCompletion);\n      result = UpdateEmpty(realm, result, V);\n      invariant(result instanceof AbruptCompletion);\n      throw IteratorClose(realm, iterator, result);\n    }\n\n    // l. If result.[[Value]] is not empty, let V be result.[[Value]].\n    let resultValue = InternalGetResultValue(realm, result);\n    if (!(resultValue instanceof EmptyValue)) V = resultValue;\n  }\n\n  /* istanbul ignore next */\n  invariant(false); // can't get here but there is no other way to make Flow happy\n}\n\n// ECMA262 13.7.5.11\nexport default function(\n  ast: BabelNodeForOfStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  let { left, right, body } = ast;\n\n  try {\n    if (left.type === \"VariableDeclaration\") {\n      if (left.kind === \"var\") {\n        // for (var ForBinding o fAssignmentExpression) Statement\n        // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).\n        let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"iterate\", strictCode);\n        invariant(keyResult instanceof ObjectValue);\n\n        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, varBinding, labelSet).\n        return ForInOfBodyEvaluation(\n          realm,\n          env,\n          left.declarations[0].id,\n          body,\n          keyResult,\n          \"varBinding\",\n          labelSet,\n          strictCode\n        );\n      } else {\n        // for (ForDeclaration of AssignmentExpression) Statement\n        // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, iterate).\n        let keyResult = ForInOfHeadEvaluation(\n          realm,\n          env,\n          Environment.BoundNames(realm, left),\n          right,\n          \"iterate\",\n          strictCode\n        );\n        invariant(keyResult instanceof ObjectValue);\n\n        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, lexicalBinding, labelSet).\n        return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"lexicalBinding\", labelSet, strictCode);\n      }\n    } else {\n      // for (LeftHandSideExpression of AssignmentExpression) Statement\n      // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).\n      let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"iterate\", strictCode);\n      invariant(keyResult instanceof ObjectValue);\n\n      // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, assignment, labelSet).\n      return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"assignment\", labelSet, strictCode);\n    }\n  } catch (e) {\n    if (e instanceof BreakCompletion) {\n      if (!e.target) return (UpdateEmpty(realm, e, realm.intrinsics.undefined): any).value;\n    }\n    throw e;\n  }\n}\n"],"file":"ForOfStatement.js"}