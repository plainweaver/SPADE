{"version":3,"sources":["../../src/evaluators/UpdateExpression.js"],"names":["ast","strictCode","env","realm","expr","evaluate","argument","oldExpr","Environment","GetValue","AbstractValue","operator","op","newAbstractValue","createFromBinaryOp","NumberValue","loc","To","IsToNumberPure","isInPureScope","Leak","value","evaluateWithPossibleThrowCompletion","createTemporalFromBuildFunction","incrementor","TypesDomain","topVal","ValuesDomain","error","CompilerDiagnostic","handleError","FatalError","Properties","PutValue","prefix","oldValue","ToNumber","newValue","IntegralValue","createFromNumberValue"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { Add } from \"../methods/index.js\";\nimport { AbstractValue, NumberValue, IntegralValue } from \"../values/index.js\";\nimport type { BabelNodeUpdateExpression } from \"@babel/types\";\nimport { Environment, Leak, Properties, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport { ValuesDomain, TypesDomain } from \"../domains/index.js\";\nimport { createOperationDescriptor } from \"../utils/generator.js\";\n\nexport default function(\n  ast: BabelNodeUpdateExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // ECMA262 12.4 Update Expressions\n\n  // Let expr be the result of evaluating UnaryExpression.\n  let expr = env.evaluate(ast.argument, strictCode);\n\n  // Let oldValue be ? ToNumber(? GetValue(expr)).\n  let oldExpr = Environment.GetValue(realm, expr);\n  if (oldExpr instanceof AbstractValue) {\n    invariant(ast.operator === \"++\" || ast.operator === \"--\"); // As per BabelNodeUpdateExpression\n    let op = ast.operator === \"++\" ? \"+\" : \"-\";\n    let newAbstractValue = AbstractValue.createFromBinaryOp(realm, op, oldExpr, new NumberValue(realm, 1), ast.loc);\n    if (!To.IsToNumberPure(realm, oldExpr)) {\n      if (realm.isInPureScope()) {\n        // In pure scope we have to treat the ToNumber operation as temporal since it\n        // might throw or mutate something. We also need to leak the argument due to the\n        // possible mutations.\n        Leak.value(realm, oldExpr);\n        newAbstractValue = realm.evaluateWithPossibleThrowCompletion(\n          () =>\n            AbstractValue.createTemporalFromBuildFunction(\n              realm,\n              NumberValue,\n              [oldExpr],\n              createOperationDescriptor(\"UPDATE_INCREMENTOR\", { incrementor: op })\n            ),\n          TypesDomain.topVal,\n          ValuesDomain.topVal\n        );\n      } else {\n        let error = new CompilerDiagnostic(\n          \"might be a symbol or an object with an unknown valueOf or toString or Symbol.toPrimitive method\",\n          ast.argument.loc,\n          \"PP0008\",\n          \"RecoverableError\"\n        );\n        if (realm.handleError(error) === \"Fail\") throw new FatalError();\n      }\n    }\n    Properties.PutValue(realm, expr, newAbstractValue);\n    if (ast.prefix === true) {\n      return newAbstractValue;\n    } else {\n      return oldExpr;\n    }\n  }\n  let oldValue = To.ToNumber(realm, oldExpr);\n\n  if (ast.prefix === true) {\n    if (ast.operator === \"++\") {\n      // ECMA262 12.4.6.1\n\n      // 3. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5)\n      let newValue = Add(realm, oldValue, 1);\n\n      // 4. Perform ? PutValue(expr, newValue).\n      Properties.PutValue(realm, expr, newValue);\n\n      // 5. Return newValue.\n      return newValue;\n    } else if (ast.operator === \"--\") {\n      // ECMA262 12.4.7.1\n\n      // 3. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).\n      let newValue = Add(realm, oldValue, -1);\n\n      // 4. Perform ? PutValue(expr, newValue).\n      Properties.PutValue(realm, expr, newValue);\n\n      // 5. Return newValue.\n      return newValue;\n    }\n    invariant(false);\n  } else {\n    if (ast.operator === \"++\") {\n      // ECMA262 12.4.4.1\n\n      // 3. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5).\n      let newValue = Add(realm, oldValue, 1);\n\n      // 4. Perform ? PutValue(lhs, newValue).\n      Properties.PutValue(realm, expr, newValue);\n\n      // 5. Return oldValue.\n      return IntegralValue.createFromNumberValue(realm, oldValue);\n    } else if (ast.operator === \"--\") {\n      // ECMA262 12.4.5.1\n\n      // 3. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).\n      let newValue = Add(realm, oldValue, -1);\n\n      // 4. Perform ? PutValue(lhs, newValue).\n      Properties.PutValue(realm, expr, newValue);\n\n      // 5. Return oldValue.\n      return IntegralValue.createFromNumberValue(realm, oldValue);\n    }\n    invariant(false);\n  }\n}\n"],"file":"UpdateExpression.js"}