{"version":3,"sources":["../../src/evaluators/LabeledStatement.js"],"names":["LabelledEvaluation","labelSet","ast","strictCode","env","realm","type","labeledAst","label","name","push","normalCompletionStmtResult","body","stmtResult","BreakCompletion","target","value","JoinedAbruptCompletions","JoinedNormalAndAbruptCompletions","nc","Completion","normalizeSelectedCompletions","c","returnOrThrowCompletion","kind","r","evaluate","Value","createErrorThrowCompletion","intrinsics","SyntaxError","newLabelSet"],"mappings":";;;;;;;AAaA;;AAEA;;AAOA;;;;AAtBA;;;;;;;;AAwBA;AACA,SAASA,kBAAT,CACEC,QADF,EAEEC,GAFF,EAGEC,UAHF,EAIEC,GAJF,EAKEC,KALF,EAMS;AACP;AACA,UAAQH,GAAG,CAACI,IAAZ;AACE,SAAK,kBAAL;AACE,UAAIC,UAAU,GAAKL,GAAnB,CADF,CAEE;;AACA,UAAIM,KAAK,GAAGD,UAAU,CAACC,KAAX,CAAiBC,IAA7B,CAHF,CAKE;;AACAR,MAAAA,QAAQ,CAACS,IAAT,CAAcF,KAAd,EANF,CAQE;;AACA,UAAIG,0BAAJ;;AACA,UAAI;AACFA,QAAAA,0BAA0B,GAAGX,kBAAkB,CAACC,QAAD,EAAWM,UAAU,CAACK,IAAtB,EAA4BT,UAA5B,EAAwCC,GAAxC,EAA6CC,KAA7C,CAA/C;AACD,OAFD,CAEE,OAAOQ,UAAP,EAAmB;AACnB;AACA,YAAIA,UAAU,YAAYC,4BAAtB,IAAyCD,UAAU,CAACE,MAAX,KAAsBP,KAAnE,EAA0E;AACxE;AACAG,UAAAA,0BAA0B,GAAGE,UAAU,CAACG,KAAxC;AACD,SAHD,MAGO,IACLH,UAAU,YAAYI,oCAAtB,IACAJ,UAAU,YAAYK,6CAFjB,EAGL;AACA,cAAIC,EAAE,GAAGC,wBAAWC,4BAAX,CACPC,CAAC,IAAIA,CAAC,YAAYR,4BAAb,IAAgCQ,CAAC,CAACP,MAAF,KAAaP,KAD3C,EAEPK,UAFO,CAAT;;AAIA,iBAAOR,KAAK,CAACkB,uBAAN,CAA8BJ,EAA9B,CAAP;AACD,SATM,MASA;AACL;AACA,gBAAMN,UAAN;AACD;AACF,OA9BH,CA+BE;;;AACA,aAAOF,0BAAP;;AAEF,SAAK,qBAAL;AACE,UAAMT,GAAF,CAA2CsB,IAA3C,KAAoD,KAAxD,EAA+D;AAC7D,YAAIC,CAAC,GAAGrB,GAAG,CAACsB,QAAJ,CAAaxB,GAAb,EAAkBC,UAAlB,CAAR;AACA,gCAAUsB,CAAC,YAAYE,YAAvB;AACA,eAAOF,CAAP;AACD;;AACH;;AACA,SAAK,qBAAL;AACA,SAAK,kBAAL;AACE,YAAMpB,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBC,WAAlD,EAA+D5B,GAAG,CAACI,IAAJ,GAAW,uBAA1E,CAAN;;AAEF;AACE,UAAImB,CAAC,GAAGrB,GAAG,CAACsB,QAAJ,CAAaxB,GAAb,EAAkBC,UAAlB,EAA8BF,QAA9B,CAAR;AACA,8BAAUwB,CAAC,YAAYE,YAAvB;AACA,aAAOF,CAAP;AAjDJ;AAmDD,C,CAED;;;AACe,kBACbvB,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKM;AACnB;AACA,MAAI0B,WAAW,GAAG,EAAlB,CAFmB,CAInB;;AACA,SAAO/B,kBAAkB,CAAC+B,WAAD,EAAc7B,GAAd,EAAmBC,UAAnB,EAA+BC,GAA/B,EAAoCC,KAApC,CAAzB;AACD","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Value } from \"../values/index.js\";\nimport type { Reference } from \"../environment.js\";\nimport {\n  BreakCompletion,\n  Completion,\n  JoinedAbruptCompletions,\n  JoinedNormalAndAbruptCompletions,\n} from \"../completions.js\";\nimport type { BabelNode, BabelNodeLabeledStatement, BabelNodeVariableDeclaration } from \"@babel/types\";\nimport invariant from \"../invariant.js\";\n\n// ECMA262 13.13.14\nfunction LabelledEvaluation(\n  labelSet: Array<string>,\n  ast: BabelNode,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // LabelledStatement:LabelIdentifier:LabelledItem\n  switch (ast.type) {\n    case \"LabeledStatement\":\n      let labeledAst = ((ast: any): BabelNodeLabeledStatement);\n      // 1. Let label be the StringValue of LabelIdentifier.\n      let label = labeledAst.label.name;\n\n      // 2. Append label as an element of labelSet.\n      labelSet.push(label);\n\n      // 3. Let stmtResult be LabelledEvaluation of LabelledItem with argument labelSet.\n      let normalCompletionStmtResult;\n      try {\n        normalCompletionStmtResult = LabelledEvaluation(labelSet, labeledAst.body, strictCode, env, realm);\n      } catch (stmtResult) {\n        // 4. If stmtResult.[[Type]] is break and SameValue(stmtResult.[[Target]], label) is true, then\n        if (stmtResult instanceof BreakCompletion && stmtResult.target === label) {\n          // a. Let stmtResult be NormalCompletion(stmtResult.[[Value]]).\n          normalCompletionStmtResult = stmtResult.value;\n        } else if (\n          stmtResult instanceof JoinedAbruptCompletions ||\n          stmtResult instanceof JoinedNormalAndAbruptCompletions\n        ) {\n          let nc = Completion.normalizeSelectedCompletions(\n            c => c instanceof BreakCompletion && c.target === label,\n            stmtResult\n          );\n          return realm.returnOrThrowCompletion(nc);\n        } else {\n          // 5. Return Completion(stmtResult).\n          throw stmtResult;\n        }\n      }\n      // 5. Return Completion(stmtResult).\n      return normalCompletionStmtResult;\n\n    case \"VariableDeclaration\":\n      if (((ast: any): BabelNodeVariableDeclaration).kind === \"var\") {\n        let r = env.evaluate(ast, strictCode);\n        invariant(r instanceof Value);\n        return r;\n      }\n    // fall through to throw\n    case \"FunctionDeclaration\":\n    case \"ClassDeclaration\":\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, ast.type + \" may not have a label\");\n\n    default:\n      let r = env.evaluate(ast, strictCode, labelSet);\n      invariant(r instanceof Value);\n      return r;\n  }\n}\n\n// ECMA262 13.13.15\nexport default function(\n  ast: BabelNodeLabeledStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value | Reference {\n  //1. Let newLabelSet be a new empty List.\n  let newLabelSet = [];\n\n  //2. Return LabelledEvaluation of this LabelledStatement with argument newLabelSet.\n  return LabelledEvaluation(newLabelSet, ast, strictCode, env, realm);\n}\n"],"file":"LabeledStatement.js"}