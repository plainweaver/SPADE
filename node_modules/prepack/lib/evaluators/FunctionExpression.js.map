{"version":3,"sources":["../../src/evaluators/FunctionExpression.js"],"names":["ast","strictCode","env","realm","id","generator","strict","body","scope","funcEnv","Environment","NewDeclarativeEnvironment","envRec","environmentRecord","name","CreateImmutableBinding","closure","Functions","GeneratorFunctionCreate","params","loc","prototype","Create","ObjectCreate","intrinsics","GeneratorPrototype","originalConstructor","Properties","DefinePropertyOrThrow","PropertyDescriptor","value","writable","enumerable","configurable","SetFunctionName","StringValue","InitializeBinding","FunctionCreate"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { Value } from \"../values/index.js\";\nimport { MakeConstructor } from \"../methods/index.js\";\nimport { Create, Environment, Functions, Properties } from \"../singletons.js\";\nimport { StringValue } from \"../values/index.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport type { BabelNodeFunctionExpression } from \"@babel/types\";\nimport invariant from \"../invariant.js\";\nimport { PropertyDescriptor } from \"../descriptors.js\";\n\nexport default function(\n  ast: BabelNodeFunctionExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // ECMA262 14.1.21\n\n  if (ast.id) {\n    if (ast.generator === true) {\n      // 1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(ast.body);\n\n      // 2. Let scope be the running execution context's LexicalEnvironment.\n      let scope = env;\n\n      // 3. Let funcEnv be NewDeclarativeEnvironment(scope).\n      let funcEnv = Environment.NewDeclarativeEnvironment(realm, scope);\n\n      // 4. Let envRec be funcEnv's EnvironmentRecord.\n      let envRec = funcEnv.environmentRecord;\n\n      // 5. Let name be StringValue of BindingIdentifier.\n      invariant(ast.id);\n      let name = ast.id.name;\n\n      // 6. Perform envRec.CreateImmutableBinding(name, false).\n      envRec.CreateImmutableBinding(name, false);\n\n      // 7. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, funcEnv, strict).\n      let closure = Functions.GeneratorFunctionCreate(realm, \"normal\", ast.params, ast.body, funcEnv, strict);\n      closure.loc = ast.loc;\n\n      // 8. Let prototype be ObjectCreate(%GeneratorPrototype%).\n      let prototype = Create.ObjectCreate(realm, realm.intrinsics.GeneratorPrototype);\n      prototype.originalConstructor = closure;\n\n      // 9. Perform DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).\n      Properties.DefinePropertyOrThrow(\n        realm,\n        closure,\n        \"prototype\",\n        new PropertyDescriptor({\n          value: prototype,\n          writable: true,\n          enumerable: false,\n          configurable: false,\n        })\n      );\n\n      // 10. Perform SetFunctionName(closure, name).\n      Functions.SetFunctionName(realm, closure, new StringValue(realm, name));\n\n      // 11. Perform envRec.InitializeBinding(name, closure).\n      envRec.InitializeBinding(name, closure);\n\n      // 12. Return closure.\n      return closure;\n    } else {\n      // 1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(ast.body);\n\n      // 2. Let scope be the running execution context's LexicalEnvironment.\n      let scope = env;\n\n      // 3. Let funcEnv be NewDeclarativeEnvironment(scope).\n      let funcEnv = Environment.NewDeclarativeEnvironment(realm, scope, false);\n\n      // 4. Let envRec be funcEnv's EnvironmentRecord.\n      let envRec = funcEnv.environmentRecord;\n\n      // 5. Let name be StringValue of BindingIdentifier.\n      invariant(ast.id);\n      let name = ast.id.name;\n\n      // 6. Perform envRec.CreateImmutableBinding(name, false).\n      envRec.CreateImmutableBinding(name, false, false, true);\n      // I don't think this gets deleted anywhere else\n      //if (realm.modifiedBindings) realm.modifiedBindings.delete(name);\n\n      // 7. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, funcEnv, strict).\n      let closure = Functions.FunctionCreate(realm, \"normal\", ast.params, ast.body, funcEnv, strict);\n      closure.loc = ast.loc;\n\n      // 8. Perform MakeConstructor(closure).\n      MakeConstructor(realm, closure);\n\n      // 9. Perform SetFunctionName(closure, name).\n      Functions.SetFunctionName(realm, closure, new StringValue(realm, name));\n\n      // 10. Perform envRec.InitializeBinding(name, closure).\n      envRec.InitializeBinding(name, closure, true);\n\n      // 11. Return closure.\n      return closure;\n    }\n  } else {\n    if (ast.generator === true) {\n      // 1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(ast.body);\n\n      // 2. Let scope be the LexicalEnvironment of the running execution context.\n      let scope = env;\n\n      // 3. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, strict).\n      let closure = Functions.GeneratorFunctionCreate(realm, \"normal\", ast.params, ast.body, scope, strict);\n\n      // 4. Let prototype be ObjectCreate(%GeneratorPrototype%).\n      let prototype = Create.ObjectCreate(realm, realm.intrinsics.GeneratorPrototype);\n      prototype.originalConstructor = closure;\n\n      // 5. Perform DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).\n      Properties.DefinePropertyOrThrow(\n        realm,\n        closure,\n        \"prototype\",\n        new PropertyDescriptor({\n          value: prototype,\n          writable: true,\n          enumerable: false,\n          configurable: false,\n        })\n      );\n\n      // 6. Return closure.\n      return closure;\n    } else {\n      // 1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(ast.body);\n\n      // 2. Let scope be the LexicalEnvironment of the running execution context.\n      let scope = env;\n\n      // 3. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, strict).\n      let closure = Functions.FunctionCreate(realm, \"normal\", ast.params, ast.body, scope, strict);\n      closure.loc = ast.loc;\n\n      // 4. Perform MakeConstructor(closure).\n      MakeConstructor(realm, closure);\n\n      // 5. Return closure.\n      return closure;\n    }\n  }\n}\n"],"file":"FunctionExpression.js"}