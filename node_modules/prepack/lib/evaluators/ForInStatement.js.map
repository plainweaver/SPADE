{"version":3,"sources":["../../src/evaluators/ForInStatement.js"],"names":["reportError","realm","loc","error","CompilerDiagnostic","handleError","FatalError","ast","strictCode","env","labelSet","left","right","body","reportErrorAndThrowIfNotConcrete","val","AbstractValue","type","kind","keyResult","isPartialObject","isSimpleObject","emitResidualLoopIfSafe","ObjectValue","declarations","id","Environment","BoundNames","e","BreakCompletion","target","intrinsics","undefined","value","lh","obexpr","ob","oldEnv","getRunningContext","lexicalEnvironment","blockEnv","NewDeclarativeEnvironment","envRec","environmentRecord","DeclarativeEnvironmentRecord","absStr","createFromType","StringValue","boundName","n","t","identifier","CreateMutableBinding","InitializeBinding","result","generator","gen","modifiedBindings","modifiedProperties","createdObjects","evaluateNodeForEffects","SimpleNormalCompletion","empty","size","targetObject","sourceObject","forEach","desc","key","map","object","unknownProperty","sourceValue","throwIfNotConcrete","cond","args","falseVal","mem","condition","o","AbstractObjectValue","values","isTop","getElements","oe","makeSimple","makePartial","keyValPairs","keyVal","ArrayValue","$Get","$Set","emitForInStatement","onDestroyScope"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { BreakCompletion, SimpleNormalCompletion } from \"../completions.js\";\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { ForInOfHeadEvaluation, ForInOfBodyEvaluation } from \"./ForOfStatement.js\";\nimport { EnumerableOwnProperties, UpdateEmpty } from \"../methods/index.js\";\nimport { Environment } from \"../singletons.js\";\nimport { AbstractValue, AbstractObjectValue, ArrayValue, ObjectValue, StringValue, Value } from \"../values/index.js\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeForInStatement,\n  BabelNodeSourceLocation,\n  BabelNodeStatement,\n  BabelNodeVariableDeclaration,\n} from \"@babel/types\";\nimport invariant from \"../invariant.js\";\nimport * as t from \"@babel/types\";\n\n// helper func to report error\nfunction reportError(realm: Realm, loc: ?BabelNodeSourceLocation) {\n  let error = new CompilerDiagnostic(\n    \"for in loops over unknown objects are not yet supported\",\n    loc,\n    \"PP0013\",\n    \"FatalError\"\n  );\n  realm.handleError(error);\n  throw new FatalError();\n}\n\n// ECMA262 13.7.5.11\nexport default function(\n  ast: BabelNodeForInStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  let { left, right, body } = ast;\n\n  function reportErrorAndThrowIfNotConcrete(val: Value, loc: ?BabelNodeSourceLocation) {\n    if (val instanceof AbstractValue) reportError(realm, loc);\n  }\n\n  try {\n    if (left.type === \"VariableDeclaration\") {\n      if (left.kind === \"var\") {\n        // for (var ForBinding in Expression) Statement\n        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).\n        let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"enumerate\", strictCode);\n        if (keyResult.isPartialObject() && keyResult.isSimpleObject()) {\n          return emitResidualLoopIfSafe(ast, strictCode, env, realm, left, right, keyResult, body);\n        }\n        reportErrorAndThrowIfNotConcrete(keyResult, right.loc);\n        invariant(keyResult instanceof ObjectValue);\n\n        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, varBinding, labelSet).\n        return ForInOfBodyEvaluation(\n          realm,\n          env,\n          left.declarations[0].id,\n          body,\n          keyResult,\n          \"varBinding\",\n          labelSet,\n          strictCode\n        );\n      } else {\n        // for (ForDeclaration in Expression) Statement\n        // 1. Let keyResult be the result of performing ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, Expression, enumerate).\n        let keyResult = ForInOfHeadEvaluation(\n          realm,\n          env,\n          Environment.BoundNames(realm, left),\n          right,\n          \"enumerate\",\n          strictCode\n        );\n        reportErrorAndThrowIfNotConcrete(keyResult, right.loc);\n        invariant(keyResult instanceof ObjectValue);\n\n        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, lexicalBinding, labelSet).\n        return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"lexicalBinding\", labelSet, strictCode);\n      }\n    } else {\n      // for (LeftHandSideExpression in Expression) Statement\n      // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).\n      let keyResult = ForInOfHeadEvaluation(realm, env, [], right, \"enumerate\", strictCode);\n      reportErrorAndThrowIfNotConcrete(keyResult, right.loc);\n      invariant(keyResult instanceof ObjectValue);\n\n      // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, assignment, labelSet).\n      return ForInOfBodyEvaluation(realm, env, left, body, keyResult, \"assignment\", labelSet, strictCode);\n    }\n  } catch (e) {\n    if (e instanceof BreakCompletion) {\n      if (!e.target) return (UpdateEmpty(realm, e, realm.intrinsics.undefined): any).value;\n    }\n    throw e;\n  }\n}\n\nfunction emitResidualLoopIfSafe(\n  ast: BabelNodeForInStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  lh: BabelNodeVariableDeclaration,\n  obexpr: BabelNodeExpression,\n  ob: ObjectValue | AbstractObjectValue,\n  body: BabelNodeStatement\n) {\n  invariant(ob.isSimpleObject());\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n  let blockEnv = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n  realm.getRunningContext().lexicalEnvironment = blockEnv;\n  try {\n    let envRec = blockEnv.environmentRecord;\n    invariant(envRec instanceof DeclarativeEnvironmentRecord, \"expected declarative environment record\");\n    let absStr = AbstractValue.createFromType(realm, StringValue);\n    let boundName;\n    for (let n of Environment.BoundNames(realm, lh)) {\n      invariant(boundName === undefined);\n      boundName = t.identifier(n);\n      envRec.CreateMutableBinding(n, false);\n      envRec.InitializeBinding(n, absStr);\n    }\n    let { result, generator: gen, modifiedBindings, modifiedProperties, createdObjects } = realm.evaluateNodeForEffects(\n      body,\n      strictCode,\n      blockEnv\n    );\n    if (\n      result instanceof SimpleNormalCompletion &&\n      gen.empty() &&\n      modifiedBindings.size === 0 &&\n      modifiedProperties.size === 1\n    ) {\n      invariant(createdObjects.size === 0); // or there will be more than one property\n      let targetObject;\n      let sourceObject;\n      modifiedProperties.forEach((desc, key, map) => {\n        if (key.object.unknownProperty === key) {\n          targetObject = key.object;\n          invariant(desc !== undefined);\n          let sourceValue = desc.throwIfNotConcrete(realm).value;\n          if (sourceValue instanceof AbstractValue) {\n            // because sourceValue was written to key.object.unknownProperty it must be that\n            let cond = sourceValue.args[0];\n            // and because the write always creates a value of this shape\n            invariant(cond instanceof AbstractValue && cond.kind === \"template for property name condition\");\n            let falseVal = sourceValue.args[2];\n            if (falseVal instanceof AbstractValue && falseVal.kind === \"template for prototype member expression\") {\n              // check that the value that was assigned itself came from\n              // an expression of the form sourceObject[absStr].\n              let mem = sourceValue.args[1];\n              while (mem instanceof AbstractValue) {\n                if (\n                  mem.kind === \"sentinel member expression\" &&\n                  mem.args[0] instanceof ObjectValue &&\n                  mem.args[1] === absStr\n                ) {\n                  sourceObject = mem.args[0];\n                  break;\n                }\n                // check if mem is a test for absStr being equal to a known property\n                // if so skip over it until we get to the expression of the form sourceObject[absStr].\n                let condition = mem.args[0];\n                if (condition instanceof AbstractValue && condition.kind === \"check for known property\") {\n                  if (condition.args[0] === absStr) {\n                    mem = mem.args[2];\n                    continue;\n                  }\n                }\n                break;\n              }\n            }\n          }\n        }\n      });\n      if (targetObject instanceof ObjectValue && sourceObject !== undefined) {\n        let o = ob;\n        if (ob instanceof AbstractObjectValue && !ob.values.isTop() && ob.values.getElements().size === 1) {\n          // Note that it is not safe, in general, to extract a concrete object from the values domain of\n          // an abstract object. We can get away with it here only because the concrete object does not\n          // escape the code below and is thus never referenced directly in generated code because of this logic.\n          for (let oe of ob.values.getElements()) {\n            invariant(oe instanceof ObjectValue);\n            o = oe;\n          }\n        }\n        let generator = realm.generator;\n        invariant(generator !== undefined);\n        // make target object simple and partial, so that it returns a fully\n        // abstract value for every property it is queried for.\n        targetObject.makeSimple();\n        targetObject.makePartial();\n        if (sourceObject === o) {\n          // Known enumerable properties of sourceObject can become known properties of targetObject.\n          invariant(sourceObject.isPartialObject());\n          // EnumerableOwnProperties is sufficient because sourceObject is simple\n          let keyValPairs = EnumerableOwnProperties(realm, sourceObject, \"key+value\", true);\n          for (let keyVal of keyValPairs) {\n            invariant(keyVal instanceof ArrayValue);\n            let key = keyVal.$Get(\"0\", keyVal);\n            let val = keyVal.$Get(\"1\", keyVal);\n            invariant(key instanceof StringValue); // sourceObject is simple\n            targetObject.$Set(key, val, targetObject);\n          }\n        }\n        // add loop to generator\n        invariant(boundName != null);\n        generator.emitForInStatement(o, lh, sourceObject, targetObject, boundName);\n        return realm.intrinsics.undefined;\n      }\n    }\n  } finally {\n    // 6. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n    realm.onDestroyScope(blockEnv);\n  }\n\n  reportError(realm, obexpr.loc);\n  invariant(false);\n}\n"],"file":"ForInStatement.js"}