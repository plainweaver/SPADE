{"version":3,"sources":["../../src/evaluators/BlockStatement.js"],"names":["ast","strictCode","env","realm","oldEnv","getRunningContext","lexicalEnvironment","blockEnv","Environment","NewDeclarativeEnvironment","BlockDeclarationInstantiation","body","blockValue","directives","directive","StringValue","value","Functions","EvaluateStatements","onDestroyScope"],"mappings":";;;;;;;AAeA;;AACA;;AAhBA;;;;;;;;;AASA;AASA;AACe,kBACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKN;AACP;AACA,MAAIC,MAAM,GAAGD,KAAK,CAACE,iBAAN,GAA0BC,kBAAvC,CAFO,CAIP;;AACA,MAAIC,QAAQ,GAAGC,wBAAYC,yBAAZ,CAAsCN,KAAtC,EAA6CC,MAA7C,CAAf,CALO,CAOP;;;AACAI,0BAAYE,6BAAZ,CAA0CP,KAA1C,EAAiDF,UAAjD,EAA6DD,GAAG,CAACW,IAAjE,EAAuEJ,QAAvE,EARO,CAUP;;;AACAJ,EAAAA,KAAK,CAACE,iBAAN,GAA0BC,kBAA1B,GAA+CC,QAA/C;;AAEA,MAAI;AACF;AACA,QAAIK,UAAJ;;AAEA,QAAIZ,GAAG,CAACa,UAAR,EAAoB;AAClB,WAAK,IAAIC,SAAT,IAAsBd,GAAG,CAACa,UAA1B,EAAsC;AACpCD,QAAAA,UAAU,GAAG,IAAIG,kBAAJ,CAAgBZ,KAAhB,EAAuBW,SAAS,CAACE,KAAV,CAAgBA,KAAvC,CAAb;AACD;AACF;;AAED,WAAOC,sBAAUC,kBAAV,CAA6BlB,GAAG,CAACW,IAAjC,EAAuCC,UAAvC,EAAmDX,UAAnD,EAA+DM,QAA/D,EAAyEJ,KAAzE,CAAP;AACD,GAXD,SAWU;AACR;AACAA,IAAAA,KAAK,CAACE,iBAAN,GAA0BC,kBAA1B,GAA+CF,MAA/C;AACAD,IAAAA,KAAK,CAACgB,cAAN,CAAqBZ,QAArB;AACD;AACF","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { BabelNodeBlockStatement } from \"@babel/types\";\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\n\nimport { StringValue, Value } from \"../values/index.js\";\nimport { Environment, Functions } from \"../singletons.js\";\n\n// ECMA262 13.2.13\nexport default function(\n  ast: BabelNodeBlockStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 2. Let blockEnv be NewDeclarativeEnvironment(oldEnv).\n  let blockEnv = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n  // 3. Perform BlockDeclarationInstantiation(StatementList, blockEnv).\n  Environment.BlockDeclarationInstantiation(realm, strictCode, ast.body, blockEnv);\n\n  // 4. Set the running execution context's LexicalEnvironment to blockEnv.\n  realm.getRunningContext().lexicalEnvironment = blockEnv;\n\n  try {\n    // 5. Let blockValue be the result of evaluating StatementList.\n    let blockValue: void | Value;\n\n    if (ast.directives) {\n      for (let directive of ast.directives) {\n        blockValue = new StringValue(realm, directive.value.value);\n      }\n    }\n\n    return Functions.EvaluateStatements(ast.body, blockValue, strictCode, blockEnv, realm);\n  } finally {\n    // 6. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n    realm.onDestroyScope(blockEnv);\n  }\n}\n"],"file":"BlockStatement.js"}