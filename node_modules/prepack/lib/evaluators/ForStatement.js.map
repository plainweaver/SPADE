{"version":3,"sources":["../../src/evaluators/ForStatement.js"],"names":["CreatePerIterationEnvironment","realm","perIterationBindings","length","lastIterationEnv","getRunningContext","lexicalEnvironment","lastIterationEnvRec","environmentRecord","outer","parent","thisIterationEnv","Environment","NewDeclarativeEnvironment","onDestroyScope","thisIterationEnvRec","bn","CreateMutableBinding","lastValue","GetBindingValue","InitializeBinding","intrinsics","undefined","ForBodyEvaluation","test","increment","stmt","labelSet","strictCode","V","env","possibleInfiniteLoopIterations","result","testRef","evaluate","testValue","GetValue","To","ToBooleanPartial","Functions","incorporateSavedCompletion","JoinedNormalAndAbruptCompletions","selector","c","BreakCompletion","target","Completion","normalizeSelectedCompletions","composeWithSavedCompletion","evaluateCompletion","Value","AbruptCompletion","SimpleNormalCompletion","value","JoinedAbruptCompletions","containsSelectedCompletion","returnOrThrowCompletion","ContinueCompletion","resultValue","EmptyValue","incRef","useAbstractInterpretation","failIfContainsBreakOrReturnOrThrowCompletion","savedCompletion","ThrowCompletion","ReturnCompletion","diagnostic","CompilerDiagnostic","location","handleError","FatalError","consequent","alternate","BailOutWrapperClosureRefVisitor","ReferencedIdentifier","path","state","node","name","usesArguments","ThisExpression","usesThis","label","usesGotoToLabel","ReturnStatement","usesReturn","ThrowStatement","usesThrow","VariableDeclaration","kind","t","isForOfStatement","parentPath","isForInStatement","declarations","init","id","isIdentifier","varPatternUnsupported","replaceWith","needsExpressionWrapper","isForStatement","getConvertedDeclarator","index","identifier","assignmentExpression","convertedNodeOrUndefined","expressionStatement","expressions","i","push","sequenceExpression","generateRuntimeForStatement","ast","wrapperFunction","ECMAScriptSourceFunctionValue","body","cloneDeep","blockStatement","initialize","$Environment","functionInfo","file","program","functionExpression","traverse","cache","clear","currentLocation","args","thisRef","thisExpression","thisVal","Leak","wrapperValue","AbstractValue","createTemporalFromBuildFunction","tryToEvaluateForStatementOrLeaveAsAbstract","instantRender","enabled","effects","savedSuppressDiagnostics","suppressDiagnostics","evaluateForEffects","evaluateForStatement","error","evaluateWithPossibleThrowCompletion","TypesDomain","topVal","ValuesDomain","applyEffects","isInPureScope","update","type","varDcl","oldEnv","loopEnv","loopEnvRec","isConst","boundNames","BoundNames","dn","CreateImmutableBinding","forDcl","currentEnv","destroyed","perIterationLets","bodyResult","exprRef"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Realm } from \"../realm.js\";\nimport {\n  AbstractValue,\n  Value,\n  EmptyValue,\n  ECMAScriptSourceFunctionValue,\n  type UndefinedValue,\n} from \"../values/index.js\";\nimport {\n  AbruptCompletion,\n  BreakCompletion,\n  Completion,\n  ContinueCompletion,\n  JoinedAbruptCompletions,\n  JoinedNormalAndAbruptCompletions,\n  ReturnCompletion,\n  ThrowCompletion,\n  SimpleNormalCompletion,\n} from \"../completions.js\";\nimport traverse from \"@babel/traverse\";\nimport type { BabelTraversePath } from \"@babel/traverse\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport { LoopContinues, InternalGetResultValue } from \"./ForOfStatement.js\";\nimport { Environment, Functions, Leak, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport * as t from \"@babel/types\";\nimport type { BabelNodeExpression, BabelNodeForStatement, BabelNodeBlockStatement } from \"@babel/types\";\nimport { createOperationDescriptor } from \"../utils/generator.js\";\n\ntype BailOutWrapperInfo = {\n  usesArguments: boolean,\n  usesThis: boolean,\n  usesReturn: boolean,\n  usesGotoToLabel: boolean,\n  usesThrow: boolean,\n  varPatternUnsupported: boolean,\n};\n\n// ECMA262 13.7.4.9\nexport function CreatePerIterationEnvironment(realm: Realm, perIterationBindings: Array<string>): UndefinedValue {\n  // 1. If perIterationBindings has any elements, then\n  if (perIterationBindings.length > 0) {\n    // a. Let lastIterationEnv be the running execution context's LexicalEnvironment.\n    let lastIterationEnv = realm.getRunningContext().lexicalEnvironment;\n    // b. Let lastIterationEnvRec be lastIterationEnv's EnvironmentRecord.\n    let lastIterationEnvRec = lastIterationEnv.environmentRecord;\n    // c. Let outer be lastIterationEnv's outer environment reference.\n    let outer = lastIterationEnv.parent;\n    // d. Assert: outer is not null.\n    invariant(outer !== null);\n    // e. Let thisIterationEnv be NewDeclarativeEnvironment(outer).\n    let thisIterationEnv = Environment.NewDeclarativeEnvironment(realm, outer);\n    // f. Let thisIterationEnvRec be thisIterationEnv's EnvironmentRecord.\n    realm.onDestroyScope(lastIterationEnv);\n    let thisIterationEnvRec = thisIterationEnv.environmentRecord;\n    // g. For each element bn of perIterationBindings do,\n    for (let bn of perIterationBindings) {\n      // i. Perform ! thisIterationEnvRec.CreateMutableBinding(bn, false).\n      thisIterationEnvRec.CreateMutableBinding(bn, false);\n      // ii. Let lastValue be ? lastIterationEnvRec.GetBindingValue(bn, true).\n      let lastValue = lastIterationEnvRec.GetBindingValue(bn, true);\n      // iii.Perform thisIterationEnvRec.InitializeBinding(bn, lastValue).\n      thisIterationEnvRec.InitializeBinding(bn, lastValue);\n    }\n    // h. Set the running execution context's LexicalEnvironment to thisIterationEnv.\n    realm.getRunningContext().lexicalEnvironment = thisIterationEnv;\n  }\n  // 2. Return undefined.\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 13.7.4.8\nfunction ForBodyEvaluation(\n  realm: Realm,\n  test,\n  increment,\n  stmt,\n  perIterationBindings: Array<string>,\n  labelSet: ?Array<string>,\n  strictCode: boolean\n): Value {\n  // 1. Let V be undefined.\n  let V: Value = realm.intrinsics.undefined;\n\n  // 2. Perform ? CreatePerIterationEnvironment(perIterationBindings).\n  CreatePerIterationEnvironment(realm, perIterationBindings);\n  let env = realm.getRunningContext().lexicalEnvironment;\n  let possibleInfiniteLoopIterations = 0;\n\n  // 3. Repeat\n  while (true) {\n    let result;\n    // a. If test is not [empty], then\n    if (test) {\n      // i. Let testRef be the result of evaluating test.\n      let testRef = env.evaluate(test, strictCode);\n\n      // ii. Let testValue be ? GetValue(testRef).\n      let testValue = Environment.GetValue(realm, testRef);\n\n      // iii. If ToBoolean(testValue) is false, return NormalCompletion(V).\n      if (!To.ToBooleanPartial(realm, testValue)) {\n        result = Functions.incorporateSavedCompletion(realm, V);\n        if (result instanceof JoinedNormalAndAbruptCompletions) {\n          let selector = c => c instanceof BreakCompletion && !c.target;\n          result = Completion.normalizeSelectedCompletions(selector, result);\n          result = realm.composeWithSavedCompletion(result);\n        }\n        return V;\n      }\n    }\n\n    // b. Let result be the result of evaluating stmt.\n    result = env.evaluateCompletion(stmt, strictCode);\n    invariant(result instanceof Value || result instanceof AbruptCompletion);\n\n    // this is a join point for break and continue completions\n    result = Functions.incorporateSavedCompletion(realm, result);\n    invariant(result !== undefined);\n    if (result instanceof Value) result = new SimpleNormalCompletion(result);\n\n    // c. If LoopContinues(result, labelSet) is false, return Completion(UpdateEmpty(result, V)).\n    if (!LoopContinues(realm, result, labelSet)) {\n      invariant(result instanceof AbruptCompletion);\n      // ECMA262 13.1.7\n      if (result instanceof BreakCompletion) {\n        if (!result.target) return (UpdateEmpty(realm, result, V): any).value;\n      } else if (result instanceof JoinedAbruptCompletions) {\n        let selector = c => c instanceof BreakCompletion && !c.target;\n        if (result.containsSelectedCompletion(selector)) {\n          result = Completion.normalizeSelectedCompletions(selector, result);\n        }\n      }\n      return realm.returnOrThrowCompletion(result);\n    }\n    if (result instanceof JoinedNormalAndAbruptCompletions) {\n      result = Completion.normalizeSelectedCompletions(c => c instanceof ContinueCompletion, result);\n    }\n    invariant(result instanceof Completion);\n    result = realm.composeWithSavedCompletion(result);\n\n    // d. If result.[[Value]] is not empty, let V be result.[[Value]].\n    let resultValue = InternalGetResultValue(realm, result);\n    if (!(resultValue instanceof EmptyValue)) V = resultValue;\n\n    // e. Perform ? CreatePerIterationEnvironment(perIterationBindings).\n    CreatePerIterationEnvironment(realm, perIterationBindings);\n    env = realm.getRunningContext().lexicalEnvironment;\n\n    // f. If increment is not [empty], then\n    if (increment) {\n      // i. Let incRef be the result of evaluating increment.\n      let incRef = env.evaluate(increment, strictCode);\n\n      // ii. Perform ? GetValue(incRef).\n      Environment.GetValue(realm, incRef);\n    } else if (realm.useAbstractInterpretation) {\n      // If we have no increment and we've hit 6 iterations of trying to evaluate\n      // this loop body, then see if we have a break, return or throw completion in a\n      // guarded condition and fail if it does. We already have logic to guard\n      // against loops that are actually infinite. However, because there may be so\n      // many forked execution paths, and they're non linear, then it might\n      // computationally lead to a something that seems like an infinite loop.\n      possibleInfiniteLoopIterations++;\n      if (possibleInfiniteLoopIterations > 6) {\n        failIfContainsBreakOrReturnOrThrowCompletion(realm.savedCompletion);\n      }\n    }\n  }\n  invariant(false);\n\n  function failIfContainsBreakOrReturnOrThrowCompletion(c: void | Completion | Value) {\n    if (c === undefined) return;\n    if (c instanceof ThrowCompletion || c instanceof BreakCompletion || c instanceof ReturnCompletion) {\n      let diagnostic = new CompilerDiagnostic(\n        \"break, throw or return cannot be guarded by abstract condition\",\n        c.location,\n        \"PP0035\",\n        \"FatalError\"\n      );\n      realm.handleError(diagnostic);\n      throw new FatalError();\n    }\n    if (c instanceof JoinedAbruptCompletions || c instanceof JoinedNormalAndAbruptCompletions) {\n      failIfContainsBreakOrReturnOrThrowCompletion(c.consequent);\n      failIfContainsBreakOrReturnOrThrowCompletion(c.alternate);\n    }\n  }\n}\n\nlet BailOutWrapperClosureRefVisitor = {\n  ReferencedIdentifier(path: BabelTraversePath, state: BailOutWrapperInfo) {\n    if (path.node.name === \"arguments\") {\n      state.usesArguments = true;\n    }\n  },\n  ThisExpression(path: BabelTraversePath, state: BailOutWrapperInfo) {\n    state.usesThis = true;\n  },\n  \"BreakStatement|ContinueStatement\"(path: BabelTraversePath, state: BailOutWrapperInfo) {\n    if (path.node.label !== null) {\n      state.usesGotoToLabel = true;\n    }\n  },\n  ReturnStatement(path: BabelTraversePath, state: BailOutWrapperInfo) {\n    state.usesReturn = true;\n  },\n  ThrowStatement(path: BabelTraversePath, state: BailOutWrapperInfo) {\n    state.usesThrow = true;\n  },\n  VariableDeclaration(path: BabelTraversePath, state: BailOutWrapperInfo) {\n    let node = path.node;\n\n    // `let` and `const` are lexically scoped. We only need to change `var`s into assignments. Since we hoist the loop\n    // into its own function `var`s (which are function scoped) need to be made available outside the loop.\n    if (node.kind !== \"var\") return;\n\n    if (t.isForOfStatement(path.parentPath.node) || t.isForInStatement(path.parentPath.node)) {\n      // For-of and for-in variable declarations behave a bit differently. There is only one declarator and there is\n      // never an initializer. Furthermore we can’t replace with an expression or statement, only a\n      // `LeftHandSideExpression`. However, that `LeftHandSideExpression` will perform a `DestructuringAssignment`\n      // operation which is what we want.\n\n      invariant(node.declarations.length === 1);\n      invariant(node.declarations[0].init == null);\n\n      const { id } = node.declarations[0];\n\n      if (!t.isIdentifier(id)) {\n        // We do not currently support ObjectPattern, SpreadPattern and ArrayPattern\n        // see: https://github.com/babel/babylon/blob/master/ast/spec.md#patterns\n        state.varPatternUnsupported = true;\n        return;\n      }\n\n      // Replace with the id directly since it is a `LeftHandSideExpression`.\n      path.replaceWith(id);\n    } else {\n      // Change all variable declarations into assignment statements. We assign to capture variables made available\n      // outside of this scope.\n\n      // If our parent is a `for (var x; x < y; x++)` loop we do not need a wrapper.\n      // i.e. for (var x of y) for (var x in y) for (var x; x < y; x++)\n      let needsExpressionWrapper = !t.isForStatement(path.parentPath.node);\n\n      const getConvertedDeclarator = index => {\n        let { id, init } = node.declarations[index];\n\n        if (t.isIdentifier(id)) {\n          // If init is undefined, then we need to ensure we provide\n          // an actual Babel undefined node for it.\n          if (init === null) {\n            init = t.identifier(\"undefined\");\n          }\n          return t.assignmentExpression(\"=\", id, init);\n        } else {\n          // We do not currently support ObjectPattern, SpreadPattern and ArrayPattern\n          // see: https://github.com/babel/babylon/blob/master/ast/spec.md#patterns\n          state.varPatternUnsupported = true;\n        }\n      };\n\n      if (node.declarations.length === 1) {\n        let convertedNodeOrUndefined = getConvertedDeclarator(0);\n        if (convertedNodeOrUndefined === undefined) {\n          // Do not continue as we don't support this\n          return;\n        }\n        path.replaceWith(\n          needsExpressionWrapper ? t.expressionStatement(convertedNodeOrUndefined) : convertedNodeOrUndefined\n        );\n      } else {\n        // convert to sequence, so: `var x = 1, y = 2;` becomes `x = 1, y = 2;`\n        let expressions = [];\n        for (let i = 0; i < node.declarations.length; i++) {\n          let convertedNodeOrUndefined = getConvertedDeclarator(i);\n          if (convertedNodeOrUndefined === undefined) {\n            // Do not continue as we don't support this\n            return;\n          }\n          expressions.push(convertedNodeOrUndefined);\n        }\n        let sequenceExpression = t.sequenceExpression(((expressions: any): Array<BabelNodeExpression>));\n        path.replaceWith(needsExpressionWrapper ? t.expressionStatement(sequenceExpression) : sequenceExpression);\n      }\n    }\n  },\n};\n\nfunction generateRuntimeForStatement(\n  ast: BabelNodeForStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): AbstractValue {\n  let wrapperFunction = new ECMAScriptSourceFunctionValue(realm);\n  let body = ((t.cloneDeep(t.blockStatement([ast])): any): BabelNodeBlockStatement);\n  wrapperFunction.initialize([], body);\n  wrapperFunction.$Environment = env;\n  // We need to scan to AST looking for \"this\", \"return\", \"throw\", labels and \"arguments\"\n  let functionInfo = {\n    usesArguments: false,\n    usesThis: false,\n    usesReturn: false,\n    usesGotoToLabel: false,\n    usesThrow: false,\n    varPatternUnsupported: false,\n  };\n\n  traverse(\n    t.file(t.program([t.expressionStatement(t.functionExpression(null, [], body))])),\n    BailOutWrapperClosureRefVisitor,\n    null,\n    functionInfo\n  );\n  traverse.cache.clear();\n  let { usesReturn, usesThrow, usesArguments, usesGotoToLabel, varPatternUnsupported, usesThis } = functionInfo;\n\n  if (usesReturn || usesThrow || usesArguments || usesGotoToLabel || varPatternUnsupported) {\n    // We do not have support for these yet\n    let diagnostic = new CompilerDiagnostic(\n      `failed to recover from a for/while loop bail-out due to unsupported logic in loop body`,\n      realm.currentLocation,\n      \"PP0037\",\n      \"FatalError\"\n    );\n    realm.handleError(diagnostic);\n    throw new FatalError();\n  }\n  let args = [wrapperFunction];\n\n  if (usesThis) {\n    let thisRef = env.evaluate(t.thisExpression(), strictCode);\n    let thisVal = Environment.GetValue(realm, thisRef);\n    Leak.value(realm, thisVal);\n    args.push(thisVal);\n  }\n\n  // We leak the wrapping function value, which in turn invokes the leak\n  // logic which is transitive. The leaking logic should recursively visit\n  // all bindings/objects in the loop and its body and mark the associated\n  // bindings/objects as leaked\n  Leak.value(realm, wrapperFunction);\n\n  let wrapperValue = AbstractValue.createTemporalFromBuildFunction(\n    realm,\n    Value,\n    args,\n    createOperationDescriptor(\"FOR_STATEMENT_FUNC\", { usesThis })\n  );\n  invariant(wrapperValue instanceof AbstractValue);\n  return wrapperValue;\n}\n\nfunction tryToEvaluateForStatementOrLeaveAsAbstract(\n  ast: BabelNodeForStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  invariant(!realm.instantRender.enabled);\n  let effects;\n  let savedSuppressDiagnostics = realm.suppressDiagnostics;\n  try {\n    realm.suppressDiagnostics = true;\n    effects = realm.evaluateForEffects(\n      () => evaluateForStatement(ast, strictCode, env, realm, labelSet),\n      undefined,\n      \"tryToEvaluateForStatementOrLeaveAsAbstract\"\n    );\n  } catch (error) {\n    if (error instanceof FatalError) {\n      realm.suppressDiagnostics = savedSuppressDiagnostics;\n      return realm.evaluateWithPossibleThrowCompletion(\n        () => generateRuntimeForStatement(ast, strictCode, env, realm, labelSet),\n        TypesDomain.topVal,\n        ValuesDomain.topVal\n      );\n    } else {\n      throw error;\n    }\n  } finally {\n    realm.suppressDiagnostics = savedSuppressDiagnostics;\n  }\n  realm.applyEffects(effects);\n  return realm.returnOrThrowCompletion(effects.result);\n}\n\n// ECMA262 13.7.4.7\nexport default function(\n  ast: BabelNodeForStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  if (realm.isInPureScope() && !realm.instantRender.enabled) {\n    return tryToEvaluateForStatementOrLeaveAsAbstract(ast, strictCode, env, realm, labelSet);\n  } else {\n    return evaluateForStatement(ast, strictCode, env, realm, labelSet);\n  }\n}\n\nfunction evaluateForStatement(\n  ast: BabelNodeForStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  let { init, test, update, body } = ast;\n\n  if (init && init.type === \"VariableDeclaration\") {\n    if (init.kind === \"var\") {\n      // for (var VariableDeclarationList; Expression; Expression) Statement\n      // 1. Let varDcl be the result of evaluating VariableDeclarationList.\n      let varDcl = env.evaluate(init, strictCode);\n\n      // 2. ReturnIfAbrupt(varDcl).\n      varDcl;\n\n      // 3. Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement, « », labelSet).\n      return ForBodyEvaluation(realm, test, update, body, [], labelSet, strictCode);\n    } else {\n      // for (LexicalDeclaration Expression; Expression) Statement\n      // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n      let oldEnv = env;\n\n      // 2. Let loopEnv be NewDeclarativeEnvironment(oldEnv).\n      let loopEnv = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n      // 3. Let loopEnvRec be loopEnv's EnvironmentRecord.\n      let loopEnvRec = loopEnv.environmentRecord;\n\n      // 4. Let isConst be the result of performing IsConstantDeclaration of LexicalDeclaration.\n      let isConst = init.kind === \"const\";\n\n      // 5. Let boundNames be the BoundNames of LexicalDeclaration.\n      let boundNames = Environment.BoundNames(realm, init);\n\n      // 6. For each element dn of boundNames do\n      for (let dn of boundNames) {\n        // a. If isConst is true, then\n        if (isConst) {\n          // i. Perform ! loopEnvRec.CreateImmutableBinding(dn, true).\n          loopEnvRec.CreateImmutableBinding(dn, true);\n        } else {\n          // b. Else,\n          // i. Perform ! loopEnvRec.CreateMutableBinding(dn, false).\n          loopEnvRec.CreateMutableBinding(dn, false);\n        }\n      }\n\n      // 7. Set the running execution context's LexicalEnvironment to loopEnv.\n      realm.getRunningContext().lexicalEnvironment = loopEnv;\n\n      // 8. Let forDcl be the result of evaluating LexicalDeclaration.\n      let forDcl = loopEnv.evaluateCompletion(init, strictCode);\n\n      // 9. If forDcl is an abrupt completion, then\n      if (forDcl instanceof AbruptCompletion) {\n        // a. Set the running execution context's LexicalEnvironment to oldEnv.\n        let currentEnv = realm.getRunningContext().lexicalEnvironment;\n        realm.onDestroyScope(currentEnv);\n        if (currentEnv !== loopEnv) invariant(loopEnv.destroyed);\n        realm.getRunningContext().lexicalEnvironment = oldEnv;\n\n        // b. Return Completion(forDcl).\n        throw forDcl;\n      }\n\n      // 10. If isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be « ».\n      let perIterationLets = !isConst ? boundNames : [];\n\n      let bodyResult;\n      try {\n        // 11. Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet).\n        bodyResult = ForBodyEvaluation(realm, test, update, body, perIterationLets, labelSet, strictCode);\n      } finally {\n        // 12. Set the running execution context's LexicalEnvironment to oldEnv.\n        let currentEnv = realm.getRunningContext().lexicalEnvironment;\n        realm.onDestroyScope(currentEnv);\n        if (currentEnv !== loopEnv) invariant(loopEnv.destroyed);\n        realm.getRunningContext().lexicalEnvironment = oldEnv;\n      }\n      // 13. Return Completion(bodyResult).\n      return bodyResult;\n    }\n  } else {\n    // for (Expression; Expression; Expression) Statement\n    // 1. If the first Expression is present, then\n    if (init) {\n      // a. Let exprRef be the result of evaluating the first Expression.\n      let exprRef = env.evaluate(init, strictCode);\n\n      // b. Perform ? GetValue(exprRef).\n      Environment.GetValue(realm, exprRef);\n    }\n\n    // 2. Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement, « », labelSet).\n    return ForBodyEvaluation(realm, test, update, body, [], labelSet, strictCode);\n  }\n}\n"],"file":"ForStatement.js"}