{"version":3,"sources":["../../src/evaluators/IfStatement.js"],"names":["evaluate","ast","strictCode","env","realm","exprRef","test","exprValue","Environment","GetConditionValue","ConcreteValue","stmtCompletion","To","ToBoolean","evaluateCompletion","consequent","alternate","intrinsics","undefined","Reference","AbruptCompletion","Value","AbstractValue","mightNotBeTrue","mightNotBeFalse","evaluateWithAbstractConditional","evaluateNodeForEffects"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { AbruptCompletion } from \"../completions.js\";\nimport type { Realm } from \"../realm.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbstractValue, ConcreteValue, Value } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport type { BabelNodeIfStatement } from \"@babel/types\";\nimport invariant from \"../invariant.js\";\nimport { Environment, To } from \"../singletons.js\";\n\nexport function evaluate(ast: BabelNodeIfStatement, strictCode: boolean, env: LexicalEnvironment, realm: Realm): Value {\n  // 1. Let exprRef be the result of evaluating Expression\n  let exprRef = env.evaluate(ast.test, strictCode);\n  // 2. Let exprValue be ToBoolean(? GetValue(exprRef))\n  let exprValue: Value = Environment.GetConditionValue(realm, exprRef);\n\n  if (exprValue instanceof ConcreteValue) {\n    let stmtCompletion;\n    if (To.ToBoolean(realm, exprValue)) {\n      // 3.a. Let stmtCompletion be the result of evaluating the first Statement\n      stmtCompletion = env.evaluateCompletion(ast.consequent, strictCode);\n    } else {\n      if (ast.alternate) {\n        // 4.a. Let stmtCompletion be the result of evaluating the second Statement\n        stmtCompletion = env.evaluateCompletion(ast.alternate, strictCode);\n      } else {\n        // 3 (of the if only statement). Return NormalCompletion(undefined)\n        stmtCompletion = realm.intrinsics.undefined;\n      }\n    }\n    // 5. Return Completion(UpdateEmpty(stmtCompletion, undefined)\n    //if (stmtCompletion instanceof Reference) return stmtCompletion;\n    invariant(!(stmtCompletion instanceof Reference));\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    if (stmtCompletion instanceof AbruptCompletion) {\n      throw stmtCompletion;\n    }\n    invariant(stmtCompletion instanceof Value);\n    return stmtCompletion;\n  }\n  invariant(exprValue instanceof AbstractValue);\n\n  if (!exprValue.mightNotBeTrue()) {\n    let stmtCompletion = env.evaluate(ast.consequent, strictCode);\n    invariant(!(stmtCompletion instanceof Reference));\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    if (stmtCompletion instanceof AbruptCompletion) {\n      throw stmtCompletion;\n    }\n    invariant(stmtCompletion instanceof Value);\n    return stmtCompletion;\n  } else if (!exprValue.mightNotBeFalse()) {\n    let stmtCompletion;\n    if (ast.alternate) stmtCompletion = env.evaluate(ast.alternate, strictCode);\n    else stmtCompletion = realm.intrinsics.undefined;\n    invariant(!(stmtCompletion instanceof Reference));\n    stmtCompletion = UpdateEmpty(realm, stmtCompletion, realm.intrinsics.undefined);\n    if (stmtCompletion instanceof AbruptCompletion) {\n      throw stmtCompletion;\n    }\n    invariant(stmtCompletion instanceof Value);\n    return stmtCompletion;\n  } else {\n    invariant(exprValue instanceof AbstractValue);\n    return realm.evaluateWithAbstractConditional(\n      exprValue,\n      () => realm.evaluateNodeForEffects(ast.consequent, strictCode, env),\n      () =>\n        ast.alternate ? realm.evaluateNodeForEffects(ast.alternate, strictCode, env) : construct_empty_effects(realm)\n    );\n  }\n}\n"],"file":"IfStatement.js"}