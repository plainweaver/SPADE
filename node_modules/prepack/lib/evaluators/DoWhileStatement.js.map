{"version":3,"sources":["../../src/evaluators/DoWhileStatement.js"],"names":["ast","strictCode","env","realm","labelSet","body","test","V","intrinsics","undefined","resultOrDiagnostic","evaluateWithUndoForDiagnostic","stmt","evaluateCompletion","Value","AbruptCompletion","BreakCompletion","target","value","resultValue","EmptyValue","exprRef","evaluate","exprValue","Environment","GetConditionValue","To","ToBooleanPartial","iteration","bodyResult","SimpleNormalCompletion","testResult","result","evaluateForFixpointEffects","outsideEffects","insideEffects","cond","rval","bodyGenerator","generator","applyEffects","emitDoWhileStatement","handleError","FatalError"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport { Value } from \"../values/index.js\";\nimport { EmptyValue } from \"../values/index.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport { LoopContinues, InternalGetResultValue } from \"./ForOfStatement.js\";\nimport { AbruptCompletion, BreakCompletion, SimpleNormalCompletion } from \"../completions.js\";\nimport { Environment, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeDoWhileStatement } from \"@babel/types\";\n\nexport default function(\n  ast: BabelNodeDoWhileStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: ?Array<string>\n): Value {\n  let { body, test } = ast;\n\n  // 1. Let V be undefined.\n  let V = realm.intrinsics.undefined;\n\n  // 2. Repeat\n  let resultOrDiagnostic = realm.evaluateWithUndoForDiagnostic(() => {\n    while (true) {\n      // a. Let stmt be the result of evaluating Statement.\n      let stmt = env.evaluateCompletion(body, strictCode);\n      //todo: check if stmt is JoinedNormalAndAbruptCompletions and defer to fixpoint computation below\n      invariant(stmt instanceof Value || stmt instanceof AbruptCompletion);\n\n      // b. If LoopContinues(stmt, labelSet) is false, return Completion(UpdateEmpty(stmt, V)).\n      if (LoopContinues(realm, stmt, labelSet) === false) {\n        invariant(stmt instanceof AbruptCompletion);\n        // ECMA262 13.1.7\n        if (stmt instanceof BreakCompletion) {\n          if (!stmt.target) return (UpdateEmpty(realm, stmt, V): any).value;\n        }\n        throw UpdateEmpty(realm, stmt, V);\n      }\n\n      // c. If stmt.[[Value]] is not empty, let V be stmt.[[Value]].\n      let resultValue = InternalGetResultValue(realm, stmt);\n      if (!(resultValue instanceof EmptyValue)) V = resultValue;\n\n      // d. Let exprRef be the result of evaluating Expression.\n      let exprRef = env.evaluate(test, strictCode);\n\n      // e. Let exprValue be ? GetValue(exprRef).\n      let exprValue = Environment.GetConditionValue(realm, exprRef);\n\n      // f. If ToBoolean(exprValue) is false, return NormalCompletion(V).\n      if (To.ToBooleanPartial(realm, exprValue) === false) return V;\n    }\n    invariant(false);\n  });\n  if (resultOrDiagnostic instanceof Value) return resultOrDiagnostic;\n\n  // If we get here then unrolling the loop did not work, possibly because the value of the loop condition is not known,\n  // so instead try to compute a fixpoint for it\n  let iteration = () => {\n    let bodyResult = env.evaluateCompletion(body, strictCode);\n    if (bodyResult instanceof Value) bodyResult = new SimpleNormalCompletion(bodyResult);\n    let exprRef = env.evaluate(test, strictCode);\n    let testResult = Environment.GetConditionValue(realm, exprRef);\n    return [testResult, bodyResult];\n  };\n  let result = realm.evaluateForFixpointEffects(iteration);\n  if (result !== undefined) {\n    let [outsideEffects, insideEffects, cond] = result;\n    let rval = outsideEffects.result;\n    let bodyGenerator = insideEffects.generator;\n    realm.applyEffects(outsideEffects);\n    let generator = realm.generator;\n    invariant(generator !== undefined);\n    generator.emitDoWhileStatement(cond, bodyGenerator);\n    invariant(rval instanceof SimpleNormalCompletion, \"todo: handle loops that throw exceptions or return\");\n    return rval.value;\n  }\n\n  // If we get here the fixpoint computation failed as well. Report the diagnostic from the unrolling and throw.\n  realm.handleError(resultOrDiagnostic);\n  throw new FatalError();\n}\n"],"file":"DoWhileStatement.js"}