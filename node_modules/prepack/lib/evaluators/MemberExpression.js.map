{"version":3,"sources":["../../src/evaluators/MemberExpression.js"],"names":["ast","strictCode","env","realm","object","type","baseReference","evaluate","baseValue","Environment","GetValue","propertyNameValue","computed","propertyNameReference","property","StringValue","name","bv","loc","propertyKey","To","ToPropertyKeyPartial","strict","Reference"],"mappings":";;;;;;;AAaA;;AACA;;AACA;;AACA;;AAEA;;;;AAlBA;;;;;;;;;AASA;AAWA;AACe,kBACbA,GADa,EAEbC,UAFa,EAGbC,GAHa,EAIbC,KAJa,EAKF;AACX,MAAIH,GAAG,CAACI,MAAJ,CAAWC,IAAX,KAAoB,OAAxB,EAAiC;AAC/B,WAAO,4BAAcL,GAAd,EAAmBC,UAAnB,EAA+BC,GAA/B,EAAoCC,KAApC,CAAP;AACD,GAHU,CAKX;;;AACA,MAAIG,aAAa,GAAGJ,GAAG,CAACK,QAAJ,CAAaP,GAAG,CAACI,MAAjB,EAAyBH,UAAzB,CAApB,CANW,CAQX;;AACA,MAAIO,SAAS,GAAGC,wBAAYC,QAAZ,CAAqBP,KAArB,EAA4BG,aAA5B,CAAhB;;AAEA,MAAIK,iBAAJ;;AACA,MAAIX,GAAG,CAACY,QAAJ,KAAiB,IAArB,EAA2B;AACzB;AACA,QAAIC,qBAAqB,GAAGX,GAAG,CAACK,QAAJ,CAAaP,GAAG,CAACc,QAAjB,EAA2Bb,UAA3B,CAA5B,CAFyB,CAIzB;;AACAU,IAAAA,iBAAiB,GAAGF,wBAAYC,QAAZ,CAAqBP,KAArB,EAA4BU,qBAA5B,CAApB;AACD,GAND,MAMO;AACL;AACAF,IAAAA,iBAAiB,GAAG,IAAII,kBAAJ,CAAgBZ,KAAhB,EAAuBH,GAAG,CAACc,QAAJ,CAAaE,IAApC,CAApB;AACD,GArBU,CAuBX;;;AACA,MAAIC,EAAE,GAAG,oCAAuBd,KAAvB,EAA8BK,SAA9B,EAAyCR,GAAG,CAACI,MAAJ,CAAWc,GAApD,CAAT,CAxBW,CA0BX;;AACA,MAAIC,WAAW,GAAGC,eAAGC,oBAAH,CAAwBlB,KAAxB,EAA+BQ,iBAA/B,CAAlB,CA3BW,CA6BX;;;AACA,MAAIW,MAAM,GAAGrB,UAAb,CA9BW,CAgCX;;AACA,SAAO,IAAIsB,sBAAJ,CAAcN,EAAd,EAAkBE,WAAlB,EAA+BG,MAA/B,CAAP;AACD","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Reference } from \"../environment.js\";\nimport { StringValue } from \"../values/index.js\";\nimport { RequireObjectCoercible } from \"../methods/index.js\";\nimport { Environment, To } from \"../singletons.js\";\nimport type { BabelNodeMemberExpression } from \"@babel/types\";\nimport SuperProperty from \"./SuperProperty\";\n\n// ECMA262 12.3.2.1\nexport default function(\n  ast: BabelNodeMemberExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Reference {\n  if (ast.object.type === \"Super\") {\n    return SuperProperty(ast, strictCode, env, realm);\n  }\n\n  // 1. Let baseReference be the result of evaluating MemberExpression.\n  let baseReference = env.evaluate(ast.object, strictCode);\n\n  // 2. Let baseValue be ? GetValue(baseReference).\n  let baseValue = Environment.GetValue(realm, baseReference);\n\n  let propertyNameValue;\n  if (ast.computed === true) {\n    // 3. Let propertyNameReference be the result of evaluating Expression.\n    let propertyNameReference = env.evaluate(ast.property, strictCode);\n\n    // 4. Let propertyNameValue be ? GetValue(propertyNameReference).\n    propertyNameValue = Environment.GetValue(realm, propertyNameReference);\n  } else {\n    // 3. Let propertyNameString be StringValue of IdentifierName.\n    propertyNameValue = new StringValue(realm, ast.property.name);\n  }\n\n  // 5. Let bv be ? RequireObjectCoercible(baseValue).\n  let bv = RequireObjectCoercible(realm, baseValue, ast.object.loc);\n\n  // 6. Let propertyKey be ? ToPropertyKey(propertyNameValue).\n  let propertyKey = To.ToPropertyKeyPartial(realm, propertyNameValue);\n\n  // 7. If the code matched by the syntactic production that is being evaluated is strict mode code, let strict be true, else let strict be false.\n  let strict = strictCode;\n\n  // 8. Return a value of type Reference whose base value is bv, whose referenced name is propertyKey, and whose strict reference flag is strict.\n  return new Reference(bv, propertyKey, strict);\n}\n"],"file":"MemberExpression.js"}