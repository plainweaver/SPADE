{"version":3,"sources":["../../src/evaluators/ClassDeclaration.js"],"names":["EvaluateClassHeritage","realm","ClassHeritage","strictCode","ref","getRunningContext","lexicalEnvironment","evaluate","val","Environment","GetValue","AbstractValue","error","CompilerDiagnostic","loc","handleError","FatalError","ObjectValue","ClassDefinitionEvaluation","ast","className","env","lex","classScope","NewDeclarativeEnvironment","F","classScopeEnvRec","environmentRecord","undefined","CreateImmutableBinding","protoParent","constructorParent","superClass","intrinsics","ObjectPrototype","FunctionPrototype","superclass","null","createErrorThrowCompletion","TypeError","ECMAScriptFunctionValue","$FunctionKind","NullValue","proto","Create","ObjectCreate","$IsClassPrototype","constructor","emptyConstructor","ClassBody","elem","body","type","push","length","empty","EmptyValue","constructorFile","program","classDeclaration","constructorInfo","Functions","DefineMethod","$Closure","$HasEmptyConstructor","$ConstructorKind","CreateMethodProperty","methods","m","Properties","PropertyDefinitionEvaluation","InitializeBinding","onDestroyScope","BindingClassDeclarationEvaluation","id","name","value","hasNameProperty","SetFunctionName","InitializeBoundName"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbstractValue, Value, type ECMAScriptSourceFunctionValue } from \"../values/index.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { NullValue, EmptyValue, ObjectValue, ECMAScriptFunctionValue } from \"../values/index.js\";\nimport type {\n  BabelNodeClassDeclaration,\n  BabelNodeClassExpression,\n  BabelNodeClassMethod,\n  BabelNodeExpression,\n} from \"@babel/types\";\nimport parse from \"../utils/parse.js\";\nimport {\n  HasOwnProperty,\n  IsConstructor,\n  Get,\n  MakeConstructor,\n  MakeClassConstructor,\n  ConstructorMethod,\n  IsStatic,\n  NonConstructorMethodDefinitions,\n} from \"../methods/index.js\";\nimport { Create, Environment, Functions, Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\n\nfunction EvaluateClassHeritage(\n  realm: Realm,\n  ClassHeritage: BabelNodeExpression,\n  strictCode: boolean\n): ObjectValue | null {\n  let ref = realm.getRunningContext().lexicalEnvironment.evaluate(ClassHeritage, strictCode);\n  let val = Environment.GetValue(realm, ref);\n  if (val instanceof AbstractValue) {\n    let error = new CompilerDiagnostic(\"unknown super class\", ClassHeritage.loc, \"PP0009\", \"RecoverableError\");\n    if (realm.handleError(error) === \"Fail\") throw new FatalError();\n  }\n  if (!(val instanceof ObjectValue)) {\n    return null;\n  }\n  return val;\n}\n\n// ECMA262 14.5.14\nexport function ClassDefinitionEvaluation(\n  realm: Realm,\n  ast: BabelNodeClassDeclaration | BabelNodeClassExpression,\n  className: string | void,\n  strictCode: boolean,\n  env: LexicalEnvironment\n): ECMAScriptSourceFunctionValue {\n  // 1. Let lex be the LexicalEnvironment of the running execution context.\n  let lex = env;\n\n  // 2. Let classScope be NewDeclarativeEnvironment(lex).\n  let classScope = Environment.NewDeclarativeEnvironment(realm, lex);\n  let F;\n\n  try {\n    // 3. Let classScopeEnvRec be classScope’s EnvironmentRecord.\n    let classScopeEnvRec = classScope.environmentRecord;\n\n    // 4. If className is not undefined, then\n    if (className !== undefined) {\n      // a. Perform classScopeEnvRec.CreateImmutableBinding(className, true).\n      classScopeEnvRec.CreateImmutableBinding(className, true);\n    }\n\n    let protoParent;\n    let constructorParent;\n    // 5. If ClassHeritage opt is not present, then\n    let ClassHeritage = ast.superClass;\n    if (!ClassHeritage) {\n      // a. Let protoParent be the intrinsic object %ObjectPrototype%.\n      protoParent = realm.intrinsics.ObjectPrototype;\n\n      // b. Let constructorParent be the intrinsic object %FunctionPrototype%.\n      constructorParent = realm.intrinsics.FunctionPrototype;\n    } else {\n      // 6. Else\n      // a. Set the running execution context’s LexicalEnvironment to classScope.\n      realm.getRunningContext().lexicalEnvironment = classScope;\n      let superclass = null;\n      try {\n        // b. Let superclass be the result of evaluating ClassHeritage.\n        superclass = EvaluateClassHeritage(realm, ClassHeritage, strictCode);\n      } finally {\n        // c. Set the running execution context’s LexicalEnvironment to lex.\n        realm.getRunningContext().lexicalEnvironment = lex;\n      }\n\n      // d. ReturnIfAbrupt(superclass).\n\n      // e. If superclass is null, then\n      if (superclass === null) {\n        // i. Let protoParent be null.\n        protoParent = realm.intrinsics.null;\n\n        // ii. Let constructorParent be the intrinsic object %FunctionPrototype%.\n        constructorParent = realm.intrinsics.FunctionPrototype;\n      } else if (!IsConstructor(realm, superclass)) {\n        // f. Else if IsConstructor(superclass) is false, throw a TypeError exception.\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"superclass must be a constructor\");\n      } else {\n        // g. Else\n        // i. If superclass has a [[FunctionKind]] internal slot whose value is \"generator\", throw a TypeError exception.\n        if (superclass instanceof ECMAScriptFunctionValue && superclass.$FunctionKind === \"generator\") {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"superclass cannot be a generator\");\n        }\n\n        // ii. Let protoParent be Get(superclass, \"prototype\").\n        protoParent = Get(realm, superclass, \"prototype\");\n\n        // iii. ReturnIfAbrupt(protoParent).\n\n        // iv. If Type(protoParent) is neither Object nor Null, throw a TypeError exception.\n        if (!(protoParent instanceof ObjectValue || protoParent instanceof NullValue)) {\n          if (protoParent instanceof AbstractValue) {\n            let error = new CompilerDiagnostic(\n              \"unknown super class prototype\",\n              ClassHeritage.loc,\n              \"PP0010\",\n              \"RecoverableError\"\n            );\n            if (realm.handleError(error) === \"Fail\") throw new FatalError();\n            protoParent = realm.intrinsics.ObjectPrototype;\n          } else {\n            throw realm.createErrorThrowCompletion(\n              realm.intrinsics.TypeError,\n              \"protoParent must be an instance of Object or Null\"\n            );\n          }\n        }\n\n        // v. Let constructorParent be superclass.\n        constructorParent = superclass;\n      }\n    }\n\n    // 7. Let proto be ObjectCreate(protoParent).\n    let proto = Create.ObjectCreate(realm, protoParent);\n\n    // Provide a hint that this prototype is that of a class\n    proto.$IsClassPrototype = true;\n\n    let constructor;\n    let emptyConstructor = false;\n    let ClassBody: Array<BabelNodeClassMethod> = [];\n    for (let elem of ast.body.body) {\n      if (elem.type === \"ClassMethod\") {\n        ClassBody.push(elem);\n      }\n    }\n    // 8. If ClassBody opt is not present, let constructor be empty.\n    if (ClassBody.length === 0) {\n      emptyConstructor = true;\n      constructor = realm.intrinsics.empty;\n    } else {\n      // 9. Else, let constructor be ConstructorMethod of ClassBody.\n      constructor = ConstructorMethod(realm, ClassBody);\n    }\n\n    // 10. If constructor is empty, then,\n    if (constructor instanceof EmptyValue) {\n      emptyConstructor = true;\n      let constructorFile;\n      // a. If ClassHeritage opt is present, then\n      if (ast.superClass) {\n        // i. Let constructor be the result of parsing the source text\n        //     constructor(... args){ super (...args);}\n        // using the syntactic grammar with the goal symbol MethodDefinition.\n        constructorFile = parse(realm, \"class NeedClassForParsing { constructor(... args){ super (...args);} }\", \"\");\n      } else {\n        // b. Else,\n        // i. Let constructor be the result of parsing the source text\n        //     constructor( ){ }\n        // using the syntactic grammar with the goal symbol MethodDefinition.\n        constructorFile = parse(realm, \"class NeedClassForParsing { constructor( ){ } }\", \"\");\n      }\n\n      let {\n        program: {\n          body: [classDeclaration],\n        },\n      } = constructorFile;\n      invariant(classDeclaration.type === \"ClassDeclaration\");\n      let { body } = ((classDeclaration: any): BabelNodeClassDeclaration);\n      invariant(body.body[0].type === \"ClassMethod\");\n      constructor = ((body.body[0]: any): BabelNodeClassMethod);\n    }\n\n    // 11. Set the running execution context’s LexicalEnvironment to classScope.\n    realm.getRunningContext().lexicalEnvironment = classScope;\n\n    try {\n      // 12. Let constructorInfo be the result of performing DefineMethod for constructor with arguments proto and constructorParent as the optional functionPrototype argument.\n      let constructorInfo = Functions.DefineMethod(realm, constructor, proto, env, strictCode, constructorParent);\n\n      // 13. Assert: constructorInfo is not an abrupt completion.\n\n      // 14. Let F be constructorInfo.[[closure]]\n      F = constructorInfo.$Closure;\n\n      // Assign the empty constructor boolean\n      F.$HasEmptyConstructor = emptyConstructor;\n\n      // 15. If ClassHeritage opt is present, set F’s [[ConstructorKind]] internal slot to \"derived\".\n      if (ast.superClass) {\n        F.$ConstructorKind = \"derived\";\n      }\n\n      // 16. Perform MakeConstructor(F, false, proto).\n      MakeConstructor(realm, F, false, proto);\n\n      // 17. Perform MakeClassConstructor(F).\n      MakeClassConstructor(realm, F);\n\n      // 18. Perform CreateMethodProperty(proto, \"constructor\", F).\n      Create.CreateMethodProperty(realm, proto, \"constructor\", F);\n\n      let methods;\n      // 19. If ClassBody opt is not present, let methods be a new empty List.\n      if (ClassBody.length === 0) {\n        methods = [];\n      } else {\n        // 20. Else, let methods be NonConstructorMethodDefinitions of ClassBody.\n        methods = NonConstructorMethodDefinitions(realm, ClassBody);\n      }\n\n      // 21. For each ClassElement m in order from methods\n      for (let m of methods) {\n        // a. If IsStatic of m is false, then\n        if (!IsStatic(m)) {\n          // Let status be the result of performing PropertyDefinitionEvaluation for m with arguments proto and false.\n          Properties.PropertyDefinitionEvaluation(realm, m, proto, (env: any), strictCode, false);\n        } else {\n          // Else,\n          // Let status be the result of performing PropertyDefinitionEvaluation for m with arguments F and false.\n          Properties.PropertyDefinitionEvaluation(realm, m, F, (env: any), strictCode, false);\n        }\n        // c. If status is an abrupt completion, then\n        // i. Set the running execution context's LexicalEnvironment to lex.\n        // ii. Return Completion(status).\n      }\n    } finally {\n      // 22. Set the running execution context’s LexicalEnvironment to lex.\n      realm.getRunningContext().lexicalEnvironment = lex;\n    }\n\n    // 23. If className is not undefined, then\n    if (className !== undefined) {\n      // Perform classScopeEnvRec.InitializeBinding(className, F).\n      classScopeEnvRec.InitializeBinding(className, F);\n    }\n  } finally {\n    realm.onDestroyScope(classScope);\n  }\n  // Return F.\n  return F;\n}\n\n// ECMA2 14.5.15\nfunction BindingClassDeclarationEvaluation(\n  realm: Realm,\n  ast: BabelNodeClassDeclaration,\n  strictCode: boolean,\n  env: LexicalEnvironment\n) {\n  // ClassDeclaration : class BindingIdentifier ClassTail\n  if (ast.id) {\n    // 1. Let className be StringValue of BindingIdentifier.\n    let className = ast.id.name;\n\n    // 2. Let value be the result of ClassDefinitionEvaluation of ClassTail with argument className.\n    let value = ClassDefinitionEvaluation(realm, ast, className, strictCode, env);\n\n    // 3. ReturnIfAbrupt(value).\n\n    // 4. Let hasNameProperty be HasOwnProperty(value, \"name\").\n    let hasNameProperty = HasOwnProperty(realm, value, \"name\");\n\n    // 5. ReturnIfAbrupt(hasNameProperty).\n\n    // 6. If hasNameProperty is false, then perform SetFunctionName(value, className).\n    if (hasNameProperty === false) {\n      Functions.SetFunctionName(realm, value, className);\n    }\n\n    // 7. Let env be the running execution context’s LexicalEnvironment.\n\n    // 8. Let status be InitializeBoundName(className, value, env).\n    Environment.InitializeBoundName(realm, className, value, env);\n\n    // 9. ReturnIfAbrupt(status).\n\n    // 10. Return value.\n    return value;\n  } else {\n    // ClassDeclaration : class ClassTail\n    // 1. Return the result of ClassDefinitionEvaluation of ClassTail with argument undefined.\n    return ClassDefinitionEvaluation(realm, ast, undefined, strictCode, env);\n  }\n}\n\n// ECMA262 14.5.16\nexport default function(\n  ast: BabelNodeClassDeclaration,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // 1. Let status be the result of BindingClassDeclarationEvaluation of this ClassDeclaration.\n  BindingClassDeclarationEvaluation(realm, ast, strictCode, env);\n\n  // 2. ReturnIfAbrupt(status).\n\n  // 3. Return NormalCompletion(empty).\n  return realm.intrinsics.empty;\n}\n"],"file":"ClassDeclaration.js"}