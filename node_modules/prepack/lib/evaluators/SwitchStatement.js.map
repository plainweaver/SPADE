{"version":3,"sources":["../../src/evaluators/SwitchStatement.js"],"names":["CaseSelectorEvaluation","expression","strictCode","env","realm","exprRef","evaluate","Environment","GetValue","AbstractCaseBlockEvaluation","cases","defaultCaseIndex","input","useAbstractInterpretation","DefiniteCaseEvaluation","caseIndex","result","intrinsics","undefined","length","c","i","consequent","node","r","evaluateCompletionDeref","JoinedNormalAndAbruptCompletions","composeWithSavedCompletion","Completion","sc","Functions","incorporateSavedCompletion","JoinedAbruptCompletions","selector","BreakCompletion","target","jc","AbstractValue","createJoinConditionForSelectedCompletions","jv","createFromConditionalOp","empty","value","normalizeSelectedCompletions","AbruptCompletion","Value","AbstractCaseEvaluation","test","selectionResult","Path","implies","impliesNot","trueEffects","withCondition","evaluateForEffects","e","InfeasiblePathError","falseEffects","withInverseCondition","joinedEffects","Join","joinEffects","applyEffects","returnOrThrowCompletion","CaseBlockEvaluation","EvaluateCase","res","evaluateCompletion","EmptyValue","EvaluateCaseClauses","A","V","found","C","clauseSelector","R","val","default_case_num","findIndex","clause","slice","foundInB","B","ast","labelSet","discriminant","switchValue","values","isTop","elems","getElements","n","size","mapAndJoin","concreteSwitchValue","createFromBinaryOp","evaluationHelper","oldEnv","getRunningContext","lexicalEnvironment","blockEnv","NewDeclarativeEnvironment","CaseBlock","forEach","push","BlockDeclarationInstantiation","onDestroyScope"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { InfeasiblePathError } from \"../errors.js\";\nimport { computeBinary } from \"./BinaryExpression.js\";\nimport {\n  AbruptCompletion,\n  BreakCompletion,\n  Completion,\n  JoinedAbruptCompletions,\n  JoinedNormalAndAbruptCompletions,\n} from \"../completions.js\";\nimport { InternalGetResultValue } from \"./ForOfStatement.js\";\nimport { EmptyValue, AbstractValue, Value } from \"../values/index.js\";\nimport { StrictEqualityComparisonPartial, UpdateEmpty } from \"../methods/index.js\";\nimport { Environment, Functions, Join, Path } from \"../singletons.js\";\nimport type { BabelNodeSwitchStatement, BabelNodeSwitchCase, BabelNodeExpression } from \"@babel/types\";\nimport invariant from \"../invariant.js\";\n\n// 13.12.10 Runtime Semantics: CaseSelectorEvaluation\nfunction CaseSelectorEvaluation(\n  expression: BabelNodeExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  // 1. Let exprRef be the result of evaluating Expression.\n  let exprRef = env.evaluate(expression, strictCode);\n\n  // 2. Return ? GetValue(exprRef).\n  return Environment.GetValue(realm, exprRef);\n}\n\nfunction AbstractCaseBlockEvaluation(\n  cases: Array<BabelNodeSwitchCase>,\n  defaultCaseIndex: number,\n  input: Value,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  invariant(realm.useAbstractInterpretation);\n\n  let DefiniteCaseEvaluation = (caseIndex: number): Value => {\n    let result = realm.intrinsics.undefined;\n    // we start at the case we've been asked to evaluate, and process statements\n    // until there is either a break statement or exception thrown (this means we\n    // implicitly fall through correctly in the absence of a break statement).\n    while (caseIndex < cases.length) {\n      let c = cases[caseIndex];\n      for (let i = 0; i < c.consequent.length; i += 1) {\n        let node = c.consequent[i];\n        let r = env.evaluateCompletionDeref(node, strictCode);\n\n        if (r instanceof JoinedNormalAndAbruptCompletions) {\n          r = realm.composeWithSavedCompletion(r);\n        }\n\n        result = UpdateEmpty(realm, r, result);\n        if (result instanceof Completion) break;\n      }\n\n      if (result instanceof Completion) break;\n      caseIndex++;\n    }\n    let sc = Functions.incorporateSavedCompletion(realm, result);\n    invariant(sc !== undefined);\n    result = sc;\n\n    if (result instanceof JoinedAbruptCompletions || result instanceof JoinedNormalAndAbruptCompletions) {\n      let selector = c => c instanceof BreakCompletion && !c.target;\n      let jc = AbstractValue.createJoinConditionForSelectedCompletions(selector, result);\n      let jv = AbstractValue.createFromConditionalOp(realm, jc, realm.intrinsics.empty, result.value);\n      result = Completion.normalizeSelectedCompletions(selector, result);\n      realm.composeWithSavedCompletion(result);\n      return jv;\n    } else if (result instanceof BreakCompletion) {\n      return result.value;\n    } else if (result instanceof AbruptCompletion) {\n      throw result;\n    } else {\n      invariant(result instanceof Value);\n      return result;\n    }\n  };\n\n  let AbstractCaseEvaluation = (caseIndex: number): Value => {\n    if (caseIndex === defaultCaseIndex) {\n      // skip the default case until we've exhausted all other options\n      return AbstractCaseEvaluation(caseIndex + 1);\n    } else if (caseIndex >= cases.length) {\n      // this is the stop condition for our recursive search for a matching case.\n      // we tried every available case index and since nothing matches we return\n      // the default (and if none exists....just empty)\n      if (defaultCaseIndex !== -1) {\n        return DefiniteCaseEvaluation(defaultCaseIndex);\n      } else {\n        return realm.intrinsics.empty;\n      }\n    }\n    // else we have a normal in-range case index\n\n    let c = cases[caseIndex];\n    let test = c.test;\n    invariant(test);\n\n    let selector = CaseSelectorEvaluation(test, strictCode, env, realm);\n    let selectionResult = computeBinary(realm, \"===\", input, selector);\n\n    if (Path.implies(selectionResult)) {\n      //  we have a winning result for the switch case, bubble it back up!\n      return DefiniteCaseEvaluation(caseIndex);\n    } else if (Path.impliesNot(selectionResult)) {\n      // we have a case that is definitely *not* taken\n      // so we go and look at the next one in the hope of finding a match\n      return AbstractCaseEvaluation(caseIndex + 1);\n    } else {\n      // we can't be sure whether the case selector evaluates true or not\n      // so we evaluate the case in the abstract as an if-else with the else\n      // leading to the next case statement\n      let trueEffects;\n      try {\n        trueEffects = Path.withCondition(selectionResult, () => {\n          return realm.evaluateForEffects(\n            () => {\n              return DefiniteCaseEvaluation(caseIndex);\n            },\n            undefined,\n            \"AbstractCaseEvaluation/1\"\n          );\n        });\n      } catch (e) {\n        if (e instanceof InfeasiblePathError) {\n          // selectionResult cannot be true in this path, after all.\n          return AbstractCaseEvaluation(caseIndex + 1);\n        }\n        throw e;\n      }\n\n      let falseEffects;\n      try {\n        falseEffects = Path.withInverseCondition(selectionResult, () => {\n          return realm.evaluateForEffects(\n            () => {\n              return AbstractCaseEvaluation(caseIndex + 1);\n            },\n            undefined,\n            \"AbstractCaseEvaluation/2\"\n          );\n        });\n      } catch (e) {\n        if (e instanceof InfeasiblePathError) {\n          // selectionResult cannot be false in this path, after all.\n          return DefiniteCaseEvaluation(caseIndex);\n        }\n        throw e;\n      }\n\n      invariant(trueEffects !== undefined);\n      invariant(falseEffects !== undefined);\n      let joinedEffects = Join.joinEffects(selectionResult, trueEffects, falseEffects);\n      realm.applyEffects(joinedEffects);\n\n      return realm.returnOrThrowCompletion(joinedEffects.result);\n    }\n  };\n\n  // let the recursive search for a matching case begin!\n  return AbstractCaseEvaluation(0);\n}\n\nfunction CaseBlockEvaluation(\n  cases: Array<BabelNodeSwitchCase>,\n  input: Value,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value {\n  let EvaluateCase = (c: BabelNodeSwitchCase): Value | AbruptCompletion => {\n    let r = realm.intrinsics.empty;\n    for (let node of c.consequent) {\n      let res = env.evaluateCompletion(node, strictCode);\n      if (res instanceof AbruptCompletion) return (UpdateEmpty(realm, res, r): any);\n      if (!(res instanceof EmptyValue)) r = res;\n    }\n    return r;\n  };\n\n  let EvaluateCaseClauses = (A: Array<BabelNodeSwitchCase>, V: Value): [boolean, Value] => {\n    // 2. Let A be the List of CaseClause items in CaseClauses, in source text order.\n    // A is passed in\n\n    // 3. Let found be false.\n    let found = false;\n\n    // 4. Repeat for each CaseClause C in A,\n    for (let C of A) {\n      // a. If found is false, then\n      if (!found) {\n        // i. Let clauseSelector be the result of CaseSelectorEvaluation of C.\n        let test = C.test;\n        invariant(test);\n        let clauseSelector = CaseSelectorEvaluation(test, strictCode, env, realm);\n\n        // ii. ReturnIfAbrupt(clauseSelector).\n        // above will throw a Completion which will return\n\n        // iii. Let found be the result of performing Strict Equality Comparison input === clauseSelector.[[Value]].\n        found = StrictEqualityComparisonPartial(realm, input, clauseSelector);\n      }\n      if (found) {\n        // b. If found is true, then\n        // i. Let R be the result of evaluating C.\n        let R = EvaluateCase(C);\n\n        // ii. If R.[[Value]] is not empty, let V be R.[[Value]].\n        let val = InternalGetResultValue(realm, R);\n        if (!(val instanceof EmptyValue)) V = val;\n\n        // iii. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).\n        if (R instanceof AbruptCompletion) {\n          throw UpdateEmpty(realm, R, V);\n        }\n      }\n    }\n    return [found, V];\n  };\n\n  // CaseBlock:{}\n  // 1. Return NormalCompletion(undefined).\n  if (cases.length === 0) return realm.intrinsics.undefined;\n\n  // CaseBlock:{CaseClauses DefaultClause CaseClauses}\n  let default_case_num = cases.findIndex(clause => {\n    return clause.test === null;\n  });\n\n  // Abstract interpretation of case blocks is a significantly different process\n  // from regular interpretation, so we fork off early to keep things tidily separated.\n  if (input instanceof AbstractValue && cases.length < 6) {\n    return AbstractCaseBlockEvaluation(cases, default_case_num, input, strictCode, env, realm);\n  }\n\n  if (default_case_num !== -1) {\n    // 2. Let A be the List of CaseClause items in the first CaseClauses, in source text order. If the first CaseClauses is not present, A is « ».\n    let A = cases.slice(0, default_case_num);\n\n    let V = realm.intrinsics.undefined;\n\n    // 4. Repeat for each CaseClause C in A\n    [, V] = EvaluateCaseClauses(A, V);\n\n    // 5. Let foundInB be false.\n    let foundInB = false;\n\n    // 6. Let B be the List containing the CaseClause items in the second CaseClauses, in source text order. If the second CaseClauses is not present, B is « ».\n    let B = cases.slice(default_case_num + 1);\n\n    [foundInB, V] = EvaluateCaseClauses(B, V);\n\n    // 8. If foundInB is true, return NormalCompletion(V).\n    if (foundInB) return V;\n\n    // 9. Let R be the result of evaluating DefaultClause.\n    let R = EvaluateCase(cases[default_case_num]);\n\n    // 10. If R.[[Value]] is not empty, let V be R.[[Value]].\n    let val = InternalGetResultValue(realm, R);\n    if (!(val instanceof EmptyValue)) V = val;\n\n    // 11. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).\n    if (R instanceof AbruptCompletion) {\n      throw UpdateEmpty(realm, R, V);\n    }\n\n    // 12: Repeat for each CaseClause C in B (NOTE this is another complete iteration of the second CaseClauses)\n    for (let C of B) {\n      // a. Let R be the result of evaluating CaseClause C.\n      R = EvaluateCase(C);\n\n      // b. If R.[[Value]] is not empty, let V be R.[[Value]].\n      let value = InternalGetResultValue(realm, R);\n      if (!(value instanceof EmptyValue)) V = value;\n\n      // c. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).\n      if (R instanceof AbruptCompletion) {\n        throw UpdateEmpty(realm, R, V);\n      }\n    }\n\n    // 13. Return NormalCompletion(V).\n    return V;\n  } else {\n    // CaseBlock:{CaseClauses}\n    let V;\n    [, V] = EvaluateCaseClauses(cases, realm.intrinsics.undefined);\n    return V;\n  }\n}\n\n// 13.12.11\nexport default function(\n  ast: BabelNodeSwitchStatement,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: Array<string>\n): Value {\n  let expression = ast.discriminant;\n\n  // 1. Let exprRef be the result of evaluating Expression.\n  let exprRef = env.evaluate(expression, strictCode);\n\n  // 2. Let switchValue be ? GetValue(exprRef).\n  let switchValue = Environment.GetValue(realm, exprRef);\n  if (switchValue instanceof AbstractValue && !switchValue.values.isTop()) {\n    let elems = switchValue.values.getElements();\n    let n = elems.size;\n    if (n > 1 && n < 10) {\n      return Join.mapAndJoin(\n        realm,\n        elems,\n        concreteSwitchValue => AbstractValue.createFromBinaryOp(realm, \"===\", switchValue, concreteSwitchValue),\n        concreteSwitchValue => evaluationHelper(ast, concreteSwitchValue, strictCode, env, realm, labelSet)\n      );\n    }\n  }\n\n  return evaluationHelper(ast, switchValue, strictCode, env, realm, labelSet);\n}\n\nfunction evaluationHelper(\n  ast: BabelNodeSwitchStatement,\n  switchValue: Value,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm,\n  labelSet: Array<string>\n): Value {\n  let cases: Array<BabelNodeSwitchCase> = ast.cases;\n\n  // 3. Let oldEnv be the running execution context's LexicalEnvironment.\n  let oldEnv = realm.getRunningContext().lexicalEnvironment;\n\n  // 4. Let blockEnv be NewDeclarativeEnvironment(oldEnv).\n  let blockEnv = Environment.NewDeclarativeEnvironment(realm, oldEnv);\n\n  // 5. Perform BlockDeclarationInstantiation(CaseBlock, blockEnv).\n  let CaseBlock = [];\n  cases.forEach(c => CaseBlock.push(...c.consequent));\n  Environment.BlockDeclarationInstantiation(realm, strictCode, CaseBlock, blockEnv);\n\n  // 6. Set the running execution context's LexicalEnvironment to blockEnv.\n  realm.getRunningContext().lexicalEnvironment = blockEnv;\n\n  let R;\n  try {\n    // 7. Let R be the result of performing CaseBlockEvaluation of CaseBlock with argument switchValue.\n    R = CaseBlockEvaluation(cases, switchValue, strictCode, blockEnv, realm);\n\n    // 9. Return R.\n    return R;\n  } catch (e) {\n    if (e instanceof BreakCompletion) {\n      if (!e.target) return (UpdateEmpty(realm, e, realm.intrinsics.undefined): any).value;\n    }\n    throw e;\n  } finally {\n    // 8. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.getRunningContext().lexicalEnvironment = oldEnv;\n    realm.onDestroyScope(blockEnv);\n  }\n}\n"],"file":"SwitchStatement.js"}