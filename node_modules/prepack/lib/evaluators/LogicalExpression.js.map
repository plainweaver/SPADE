{"version":3,"sources":["../../src/evaluators/LogicalExpression.js"],"names":["ast","strictCode","env","realm","lref","evaluate","left","lval","Environment","GetValue","ConcreteValue","lbool","To","ToBoolean","operator","rref","right","AbstractValue","lcond","GetConditionValue","mightNotBeFalse","mightNotBeTrue","result","result1","generator","generator1","modifiedBindings","modifiedBindings1","modifiedProperties","modifiedProperties1","createdObjects","createdObjects1","result2","generator2","modifiedBindings2","modifiedProperties2","createdObjects2","wrapper","Path","withCondition","withInverseCondition","evaluateNodeForEffects","e","InfeasiblePathError","joinedEffects","Join","joinEffects","Effects","SimpleNormalCompletion","applyEffects","completion","returnOrThrowCompletion","Value","value","createFromLogicalOp","loc"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../realm.js\";\nimport { Effects } from \"../realm.js\";\nimport { SimpleNormalCompletion } from \"../completions.js\";\nimport { InfeasiblePathError } from \"../errors.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { AbstractValue, ConcreteValue, Value } from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { Environment } from \"../singletons.js\";\nimport type { BabelNodeLogicalExpression } from \"@babel/types\";\nimport invariant from \"../invariant.js\";\nimport { Join, Path, To } from \"../singletons.js\";\n\nexport default function(\n  ast: BabelNodeLogicalExpression,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  realm: Realm\n): Value | Reference {\n  let lref = env.evaluate(ast.left, strictCode);\n  let lval = Environment.GetValue(realm, lref);\n\n  if (lval instanceof ConcreteValue) {\n    let lbool = To.ToBoolean(realm, lval);\n\n    if (ast.operator === \"&&\") {\n      // ECMA262 12.13.3\n      if (lbool === false) return lval;\n    } else {\n      invariant(ast.operator === \"||\");\n      // ECMA262 12.13.3\n      if (lbool === true) return lval;\n    }\n\n    let rref = env.evaluate(ast.right, strictCode);\n    return Environment.GetValue(realm, rref);\n  }\n  invariant(lval instanceof AbstractValue);\n  let lcond = Environment.GetConditionValue(realm, lref);\n\n  if (!lcond.mightNotBeFalse()) return ast.operator === \"||\" ? env.evaluate(ast.right, strictCode) : lval;\n  if (!lcond.mightNotBeTrue()) return ast.operator === \"&&\" ? env.evaluate(ast.right, strictCode) : lval;\n  invariant(lcond instanceof AbstractValue);\n\n  // Create empty effects for the case where ast.right is not evaluated\n  let {\n    result: result1,\n    generator: generator1,\n    modifiedBindings: modifiedBindings1,\n    modifiedProperties: modifiedProperties1,\n    createdObjects: createdObjects1,\n  } = construct_empty_effects(realm);\n  result1; // ignore\n\n  // Evaluate ast.right in a sandbox to get its effects\n  let result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2;\n  try {\n    let wrapper = ast.operator === \"&&\" ? Path.withCondition : Path.withInverseCondition;\n    ({\n      result: result2,\n      generator: generator2,\n      modifiedBindings: modifiedBindings2,\n      modifiedProperties: modifiedProperties2,\n      createdObjects: createdObjects2,\n    } = wrapper(lcond, () => realm.evaluateNodeForEffects(ast.right, strictCode, env)));\n  } catch (e) {\n    if (e instanceof InfeasiblePathError) {\n      // if && then lcond cannot be true on this path else lcond cannot be false on this path.\n      // Either way, we need to return just lval and not evaluate ast.right\n      return lval;\n    }\n    throw e;\n  }\n\n  // Join the effects, creating an abstract view of what happened, regardless\n  // of the actual value of lval.\n  // Note that converting a value to boolean never has a side effect, so we can\n  // use lval as is for the join condition.\n  let joinedEffects;\n  if (ast.operator === \"&&\") {\n    joinedEffects = Join.joinEffects(\n      lcond,\n      new Effects(result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2),\n      new Effects(new SimpleNormalCompletion(lval), generator1, modifiedBindings1, modifiedProperties1, createdObjects1)\n    );\n  } else {\n    joinedEffects = Join.joinEffects(\n      lcond,\n      new Effects(\n        new SimpleNormalCompletion(lval),\n        generator1,\n        modifiedBindings1,\n        modifiedProperties1,\n        createdObjects1\n      ),\n      new Effects(result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2)\n    );\n  }\n\n  realm.applyEffects(joinedEffects);\n  let completion = realm.returnOrThrowCompletion(joinedEffects.result);\n  if (lval instanceof Value && result2.value instanceof Value) {\n    // joinEffects does the right thing for the side effects of the second expression but for the result the join\n    // produces a conditional expressions of the form (a ? b : a) for a && b and (a ? a : b) for a || b\n    // Rather than look for this pattern everywhere, we override this behavior and replace the completion with\n    // the actual logical operator. This helps with simplification and reasoning when dealing with path conditions.\n    completion = AbstractValue.createFromLogicalOp(realm, ast.operator, lval, result2.value, ast.loc);\n  }\n  return completion;\n}\n"],"file":"LogicalExpression.js"}