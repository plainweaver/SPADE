"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  prepackStdin: true,
  prepackFile: true,
  prepackFileSync: true
};
exports.prepackStdin = prepackStdin;
exports.prepackFile = prepackFile;
exports.prepackFileSync = prepackFileSync;

var _options = require("./options");

var _errors = require("./errors.js");

var _prepackStandalone = require("./prepack-standalone.js");

var _types = require("./types.js");

var _DebugChannel = require("./debugger/server/channel/DebugChannel.js");

var _FileIOWrapper = require("./debugger/common/channel/FileIOWrapper.js");

var _statistics = require("./serializer/statistics.js");

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _prepackStandalone2 = require("./prepack-standalone");

Object.keys(_prepackStandalone2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _prepackStandalone2[key];
    }
  });
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*
 Prepack API functions that require Node as the execution environment for Prepack.
 */
function createStatistics(options) {
  let gc = global.gc; // eslint-disable-line no-undef

  return options.profile !== undefined ? new _statistics.SerializerStatistics(() => Date.now(), () => {
    if (gc) gc();
    return process.memoryUsage().heapUsed;
  }, !!gc) : new _statistics.SerializerStatistics();
}

function prepackStdin(options = _options.defaultOptions, processSerializedCode, printDiagnostics) {
  let sourceMapFilename = options.inputSourceMapFilenames && options.inputSourceMapFilenames.length > 0 ? options.inputSourceMapFilenames[0] : "";
  process.stdin.setEncoding("utf8");
  process.stdin.resume();
  process.stdin.on("data", function (code) {
    _fs.default.readFile(sourceMapFilename, "utf8", function (mapErr, sourceMap = "") {
      if (mapErr) {
        //if no sourcemap was provided we silently ignore
        if (sourceMapFilename !== "") console.warn(`No sourcemap found at ${sourceMapFilename}.`);
      }

      let filename = "no-filename-specified";
      let serialized;
      let success;

      try {
        serialized = (0, _prepackStandalone.prepackSources)([{
          filePath: filename,
          fileContents: code,
          sourceMapContents: sourceMap
        }], options, createStatistics(options));
        processSerializedCode(serialized);
        success = printDiagnostics(false);
      } catch (err) {
        printDiagnostics(err instanceof _errors.FatalError);

        if (!(err instanceof _errors.FatalError)) {
          // if it is not a FatalError, it means prepack failed, and we should display the Prepack stack trace.
          console.error(err.stack);
        }

        success = false;
      }

      if (!success) process.exit(1);
    });
  });
}

function getSourceMapFilename(filename, options) {
  if (options.inputSourceMapFilenames !== undefined) {
    // The convention is that the source map has the same basename as the javascript
    // source file, except that .map is appended. We look for a match with the
    // supplied source file names.
    for (let sourceMapFilename of options.inputSourceMapFilenames) {
      if (_path.default.basename(filename) + ".map" === _path.default.basename(sourceMapFilename)) {
        return [sourceMapFilename, true];
      }
    }
  }

  return [filename + ".map", false];
}

function prepackFile(filename, options = _options.defaultOptions, callback, fileErrorHandler) {
  let [sourceMapFilename] = getSourceMapFilename(filename, options);

  _fs.default.readFile(filename, "utf8", function (fileErr, code) {
    if (fileErr) {
      if (fileErrorHandler) fileErrorHandler(fileErr);
      return;
    }

    _fs.default.readFile(sourceMapFilename, "utf8", function (mapErr, _sourceMap) {
      let sourceMap = _sourceMap;

      if (mapErr) {
        console.warn(`No sourcemap found at ${sourceMapFilename}.`);
        sourceMap = "";
      }

      let serialized;

      try {
        serialized = (0, _prepackStandalone.prepackSources)([{
          filePath: filename,
          fileContents: code,
          sourceMapContents: sourceMap
        }], options, createStatistics(options));
      } catch (err) {
        callback(err, null);
        return;
      }

      callback(null, serialized);
    });
  });
}

function getSourceFileCollection(filenames, options) {
  const sourceFiles = filenames.map(filename => {
    let code = _fs.default.readFileSync(filename, "utf8");

    let sourceMap = "";
    let [sourceMapFilename, matchedSourceMapFilename] = getSourceMapFilename(filename, options);

    try {
      sourceMap = _fs.default.readFileSync(sourceMapFilename, "utf8");
      if (matchedSourceMapFilename) console.info(`Matching sourcemap found at ${sourceMapFilename}.`);
    } catch (_e) {
      if (matchedSourceMapFilename) console.warn(`No sourcemap found at ${sourceMapFilename}.`);
    }

    return {
      filePath: filename,
      fileContents: code,
      sourceMapContents: sourceMap,
      sourceMapFilename: sourceMapFilename
    };
  });
  return new _types.SourceFileCollection(sourceFiles);
}

function prepackFileSync(filenames, options = _options.defaultOptions) {
  let sourceFileCollection = getSourceFileCollection(filenames, options); // Filter to not include sourcemaps that weren't found

  let filterValidSourceMaps = a => a.filter(sf => sf.sourceMapContents !== ""); // The existence of debug[In/Out]FilePath represents the desire to use the debugger.


  if (options.debugInFilePath !== undefined && options.debugOutFilePath !== undefined) {
    if (options.debuggerConfigArgs === undefined) options.debuggerConfigArgs = {};
    let debuggerConfigArgs = options.debuggerConfigArgs;
    let ioWrapper = new _FileIOWrapper.FileIOWrapper(false, options.debugInFilePath, options.debugOutFilePath);
    debuggerConfigArgs.debugChannel = new _DebugChannel.DebugChannel(ioWrapper);
    debuggerConfigArgs.sourcemaps = filterValidSourceMaps(sourceFileCollection.toArray());
  }

  let debugReproArgs = options.debugReproArgs;
  if (debugReproArgs) debugReproArgs.sourcemaps = filterValidSourceMaps(sourceFileCollection.toArray());
  return (0, _prepackStandalone.prepackSources)(sourceFileCollection, options, createStatistics(options));
}
//# sourceMappingURL=prepack-node.js.map