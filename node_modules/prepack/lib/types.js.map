{"version":3,"sources":["../src/types.js"],"names":["ElementSize","Float32","Float64","Int8","Int16","Int32","Uint8","Uint16","Uint32","Uint8Clamped","SourceFileCollection","constructor","sourceFiles","_sourceFiles","toArray","undefined","destroy","PathConditions","add","c","implies","e","depth","impliesNot","isEmpty","isReadOnly","getLength","getAssumedConditions","Set","refineBaseConditons","realm"],"mappings":";;;;;;;AA6BA;;AACA;;AAEA;;AAaA;;AAGA;;;;AAhDA;;;;;;;;AAkDO,MAAMA,WAAW,GAAG;AACzBC,EAAAA,OAAO,EAAE,CADgB;AAEzBC,EAAAA,OAAO,EAAE,CAFgB;AAGzBC,EAAAA,IAAI,EAAE,CAHmB;AAIzBC,EAAAA,KAAK,EAAE,CAJkB;AAKzBC,EAAAA,KAAK,EAAE,CALkB;AAMzBC,EAAAA,KAAK,EAAE,CANkB;AAOzBC,EAAAA,MAAM,EAAE,CAPiB;AAQzBC,EAAAA,MAAM,EAAE,CARiB;AASzBC,EAAAA,YAAY,EAAE;AATW,CAApB;;;AAyCA,MAAMC,oBAAN,CAA2B;AAChCC,EAAAA,WAAW,CAACC,WAAD,EAAiC;AAC1C,SAAKC,YAAL,GAAoBD,WAApB;AACD;;AAEDE,EAAAA,OAAO,GAAsB;AAC3B,4BAAU,KAAKD,YAAL,KAAsBE,SAAhC;AACA,WAAO,KAAKF,YAAZ;AACD;;AACDG,EAAAA,OAAO,GAAS;AACd,SAAKH,YAAL,GAAoBE,SAApB;AACD;;AAX+B;;;;AAmR3B,MAAME,cAAN,CAAqB;AAC1BC,EAAAA,GAAG,CAACC,CAAD,EAAyB,CAAE,CADJ,CAG1B;;;AACAC,EAAAA,OAAO,CAACC,CAAD,EAAWC,KAAa,GAAG,CAA3B,EAAuC;AAC5C,WAAO,KAAP;AACD,GANyB,CAQ1B;;;AACAC,EAAAA,UAAU,CAACF,CAAD,EAAWC,KAAa,GAAG,CAA3B,EAAuC;AAC/C,WAAO,KAAP;AACD;;AAEDE,EAAAA,OAAO,GAAY;AACjB,WAAO,KAAP;AACD;;AAEDC,EAAAA,UAAU,GAAY;AACpB,WAAO,KAAP;AACD;;AAEDC,EAAAA,SAAS,GAAW;AAClB,WAAO,CAAP;AACD;;AAEDC,EAAAA,oBAAoB,GAAuB;AACzC,WAAO,IAAIC,GAAJ,EAAP;AACD;;AAEDC,EAAAA,mBAAmB,CAACC,KAAD,EAAeR,KAAc,GAAG,CAAhC,EAAyC,CAAE;;AA7BpC","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  AbstractObjectValue,\n  AbstractValue,\n  ArrayValue,\n  BooleanValue,\n  ConcreteValue,\n  ECMAScriptFunctionValue,\n  ECMAScriptSourceFunctionValue,\n  EmptyValue,\n  FunctionValue,\n  NativeFunctionValue,\n  NullValue,\n  NumberValue,\n  PrimitiveValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n} from \"./values/index.js\";\nimport { Value } from \"./values/index.js\";\nimport { Completion } from \"./completions.js\";\nimport type { Descriptor as DescriptorClass } from \"./descriptors.js\";\nimport { EnvironmentRecord, LexicalEnvironment, Reference } from \"./environment.js\";\nimport { ObjectValue } from \"./values/index.js\";\nimport type {\n  BabelNode,\n  BabelNodeBlockStatement,\n  BabelNodeClassMethod,\n  BabelNodeLVal,\n  BabelNodeObjectMethod,\n  BabelNodePattern,\n  BabelNodeVariableDeclaration,\n  BabelNodeSourceLocation,\n} from \"@babel/types\";\nimport type { Effects, Realm } from \"./realm.js\";\nimport { CompilerDiagnostic } from \"./errors.js\";\nimport type { Severity } from \"./errors.js\";\nimport type { DebugChannel } from \"./debugger/server/channel/DebugChannel.js\";\nimport invariant from \"./invariant.js\";\n\nexport const ElementSize = {\n  Float32: 4,\n  Float64: 8,\n  Int8: 1,\n  Int16: 2,\n  Int32: 4,\n  Uint8: 1,\n  Uint16: 2,\n  Uint32: 4,\n  Uint8Clamped: 1,\n};\n\nexport type ConsoleMethodTypes =\n  | \"assert\"\n  | \"clear\"\n  | \"count\"\n  | \"dir\"\n  | \"dirxml\"\n  | \"error\"\n  | \"group\"\n  | \"groupCollapsed\"\n  | \"groupEnd\"\n  | \"info\"\n  | \"log\"\n  | \"table\"\n  | \"time\"\n  | \"timeEnd\"\n  | \"trace\"\n  | \"warn\";\n\nexport type IterationKind = \"key+value\" | \"value\" | \"key\";\n\nexport type SourceType = \"module\" | \"script\";\n\nexport type SourceFile = {\n  filePath: string,\n  fileContents: string,\n  sourceMapContents?: string,\n  sourceMapFilename?: string,\n};\n\nexport class SourceFileCollection {\n  constructor(sourceFiles: Array<SourceFile>) {\n    this._sourceFiles = sourceFiles;\n  }\n  _sourceFiles: void | Array<SourceFile>;\n  toArray(): Array<SourceFile> {\n    invariant(this._sourceFiles !== undefined);\n    return this._sourceFiles;\n  }\n  destroy(): void {\n    this._sourceFiles = undefined;\n  }\n}\nexport type SourceMap = {\n  sources: Array<string>,\n  names: Array<string>,\n  mappings: string,\n  sourcesContent: Array<string>,\n};\n\nexport type AbstractTime = \"early\" | \"late\";\n\nexport type ElementType =\n  | \"Float32\"\n  | \"Float64\"\n  | \"Int8\"\n  | \"Int16\"\n  | \"Int32\"\n  | \"Uint8\"\n  | \"Uint16\"\n  | \"Uint32\"\n  | \"Uint8Clamped\";\n\n//\n\ndeclare class _CallableObjectValue extends ObjectValue {\n  $Call: void | ((thisArgument: Value, argsList: Array<Value>) => Value);\n}\nexport type CallableObjectValue = _CallableObjectValue | FunctionValue | NativeFunctionValue;\n\n//\n\nexport type DataBlock = Uint8Array;\n\n//\n\nexport type Descriptor = DescriptorClass;\n\nexport type FunctionBodyAstNode = {\n  // Function body ast node will have uniqueOrderedTag after being interpreted.\n  // This tag value is unique and sorted in ast DFS traversal ordering.\n  uniqueOrderedTag?: number,\n};\n\nexport type PropertyBinding = {\n  descriptor?: Descriptor,\n  object: ObjectValue,\n  key: void | string | SymbolValue | AbstractValue, // where an abstract value must be of type String or Number or Symbol\n  // contains a operation descriptor that produces a member expression that resolves to this property binding (location)\n  pathNode?: AbstractValue,\n  internalSlot?: boolean,\n};\n\nexport type LexicalEnvironmentTypes = \"global\" | \"module\" | \"script\" | \"function\" | \"block\" | \"catch\" | \"loop\" | \"with\";\n\nexport type PropertyKeyValue = string | StringValue | SymbolValue;\n\nexport type Intrinsics = {\n  undefined: UndefinedValue,\n  empty: EmptyValue,\n  null: NullValue,\n  false: BooleanValue,\n  true: BooleanValue,\n  NaN: NumberValue,\n  Infinity: NumberValue,\n  negativeInfinity: NumberValue,\n  zero: NumberValue,\n  negativeZero: NumberValue,\n  emptyString: StringValue,\n\n  SymbolHasInstance: SymbolValue,\n  SymbolIsConcatSpreadable: SymbolValue,\n  SymbolSpecies: SymbolValue,\n  SymbolReplace: SymbolValue,\n  SymbolIterator: SymbolValue,\n  SymbolSplit: SymbolValue,\n  SymbolToPrimitive: SymbolValue,\n  SymbolToStringTag: SymbolValue,\n  SymbolMatch: SymbolValue,\n  SymbolSearch: SymbolValue,\n  SymbolUnscopables: SymbolValue,\n\n  ObjectPrototype: ObjectValue,\n  FunctionPrototype: NativeFunctionValue,\n  ArrayPrototype: ObjectValue,\n  RegExpPrototype: ObjectValue,\n  DatePrototype: ObjectValue,\n  Boolean: NativeFunctionValue,\n  BooleanPrototype: ObjectValue,\n\n  Error: NativeFunctionValue,\n  ErrorPrototype: ObjectValue,\n  ReferenceError: NativeFunctionValue,\n  ReferenceErrorPrototype: ObjectValue,\n  SyntaxError: NativeFunctionValue,\n  SyntaxErrorPrototype: ObjectValue,\n  TypeError: NativeFunctionValue,\n  TypeErrorPrototype: ObjectValue,\n  URIError: NativeFunctionValue,\n  URIErrorPrototype: ObjectValue,\n  EvalError: NativeFunctionValue,\n  EvalErrorPrototype: ObjectValue,\n  JSON: ObjectValue,\n  Reflect: ObjectValue,\n  Proxy: NativeFunctionValue,\n  RangeError: NativeFunctionValue,\n  RangeErrorPrototype: ObjectValue,\n  ArrayIteratorPrototype: ObjectValue,\n  StringIteratorPrototype: ObjectValue,\n  IteratorPrototype: ObjectValue,\n  SetIteratorPrototype: ObjectValue,\n  MapIteratorPrototype: ObjectValue,\n  Number: NativeFunctionValue,\n  NumberPrototype: ObjectValue,\n  Symbol: NativeFunctionValue,\n  SymbolPrototype: ObjectValue,\n  StringPrototype: ObjectValue,\n  Object: NativeFunctionValue,\n  Function: NativeFunctionValue,\n  Array: NativeFunctionValue,\n  RegExp: NativeFunctionValue,\n  Date: NativeFunctionValue,\n  String: NativeFunctionValue,\n  Math: ObjectValue,\n  isNaN: NativeFunctionValue,\n  parseInt: NativeFunctionValue,\n  parseFloat: NativeFunctionValue,\n  isFinite: NativeFunctionValue,\n  decodeURI: NativeFunctionValue,\n  decodeURIComponent: NativeFunctionValue,\n  encodeURI: NativeFunctionValue,\n  encodeURIComponent: NativeFunctionValue,\n  ThrowTypeError: NativeFunctionValue,\n  ArrayProto_values: NativeFunctionValue,\n  ArrayProto_toString: NativeFunctionValue,\n  ObjectProto_toString: NativeFunctionValue,\n  TypedArrayProto_values: NativeFunctionValue,\n  eval: NativeFunctionValue,\n  console: ObjectValue,\n  document: ObjectValue,\n  process: ObjectValue,\n\n  DataView: NativeFunctionValue,\n  DataViewPrototype: ObjectValue,\n  TypedArray: NativeFunctionValue,\n  TypedArrayPrototype: ObjectValue,\n  Float32Array: NativeFunctionValue,\n  Float32ArrayPrototype: ObjectValue,\n  Float64Array: NativeFunctionValue,\n  Float64ArrayPrototype: ObjectValue,\n  Int8Array: NativeFunctionValue,\n  Int8ArrayPrototype: ObjectValue,\n  Int16Array: NativeFunctionValue,\n  Int16ArrayPrototype: ObjectValue,\n  Int32Array: NativeFunctionValue,\n  Int32ArrayPrototype: ObjectValue,\n  Map: NativeFunctionValue,\n  MapPrototype: ObjectValue,\n  WeakMap: NativeFunctionValue,\n  WeakMapPrototype: ObjectValue,\n  Set: NativeFunctionValue,\n  SetPrototype: ObjectValue,\n  Promise: NativeFunctionValue,\n  PromisePrototype: ObjectValue,\n  Uint8Array: NativeFunctionValue,\n  Uint8ArrayPrototype: ObjectValue,\n  Uint8ClampedArray: NativeFunctionValue,\n  Uint8ClampedArrayPrototype: ObjectValue,\n  Uint16Array: NativeFunctionValue,\n  Uint16ArrayPrototype: ObjectValue,\n  Uint32Array: NativeFunctionValue,\n  Uint32ArrayPrototype: ObjectValue,\n  WeakSet: NativeFunctionValue,\n  WeakSetPrototype: ObjectValue,\n  ArrayBuffer: NativeFunctionValue,\n  ArrayBufferPrototype: ObjectValue,\n\n  Generator: ObjectValue,\n  GeneratorPrototype: ObjectValue,\n  GeneratorFunction: NativeFunctionValue,\n\n  __IntrospectionError: NativeFunctionValue,\n  __IntrospectionErrorPrototype: ObjectValue,\n  __topValue: AbstractValue,\n  __bottomValue: AbstractValue,\n};\n\nexport type PromiseCapability = {\n  promise: ObjectValue | UndefinedValue,\n  resolve: Value,\n  reject: Value,\n};\n\nexport type PromiseReaction = {\n  capabilities: PromiseCapability,\n  handler: Value,\n};\n\nexport type ResolvingFunctions = {\n  resolve: Value,\n  reject: Value,\n};\n\nexport type TypedArrayKind =\n  | \"Float32Array\"\n  | \"Float64Array\"\n  | \"Int8Array\"\n  | \"Int16Array\"\n  | \"Int32Array\"\n  | \"Uint8Array\"\n  | \"Uint16Array\"\n  | \"Uint32Array\"\n  | \"Uint8ClampedArray\";\n\nexport type ObjectKind =\n  | \"Object\"\n  | \"Array\"\n  | \"Function\"\n  | \"Symbol\"\n  | \"String\"\n  | \"Number\"\n  | \"Boolean\"\n  | \"Date\"\n  | \"RegExp\"\n  | \"Set\"\n  | \"Map\"\n  | \"DataView\"\n  | \"ArrayBuffer\"\n  | \"WeakMap\"\n  | \"WeakSet\"\n  | TypedArrayKind\n  | \"ReactElement\";\n// TODO #26 #712: Promises. All kinds of iterators. Generators.\n\nexport type ClassComponentMetadata = {\n  instanceProperties: Set<string>,\n  instanceSymbols: Set<SymbolValue>,\n};\n\nexport type ReactHint = {| firstRenderValue: Value, object: ObjectValue, propertyName: string, args: Array<Value> |};\n\nexport type ReactComponentTreeConfig = {\n  firstRenderOnly: boolean,\n  isRoot: boolean,\n  modelString: void | string,\n};\n\nexport type DebugServerType = {\n  checkForActions: BabelNode => void,\n  handlePrepackError: CompilerDiagnostic => void,\n  shouldStopForSeverity: Severity => boolean,\n  shutdown: () => void,\n};\n\nexport type PathType = {\n  // this => val. A false value does not imply that !(this => val).\n  implies(condition: Value, depth?: number): boolean,\n  // this => !val. A false value does not imply that !(this => !val).\n  impliesNot(condition: Value, depth?: number): boolean,\n  withCondition<T>(condition: Value, evaluate: () => T): T,\n  withInverseCondition<T>(condition: Value, evaluate: () => T): T,\n  pushAndRefine(condition: Value): void,\n  pushInverseAndRefine(condition: Value): void,\n};\n\nexport class PathConditions {\n  add(c: AbstractValue): void {}\n\n  // this => val. A false value does not imply that !(this => val).\n  implies(e: Value, depth: number = 0): boolean {\n    return false;\n  }\n\n  // this => !val. A false value does not imply that !(this => !val).\n  impliesNot(e: Value, depth: number = 0): boolean {\n    return false;\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  isReadOnly(): boolean {\n    return false;\n  }\n\n  getLength(): number {\n    return 0;\n  }\n\n  getAssumedConditions(): Set<AbstractValue> {\n    return new Set();\n  }\n\n  refineBaseConditons(realm: Realm, depth?: number = 0): void {}\n}\n\nexport type LeakType = {\n  value(realm: Realm, value: Value, loc: ?BabelNodeSourceLocation): void,\n};\n\nexport type MaterializeType = {\n  materializeObject(realm: Realm, object: ObjectValue): void,\n  computeReachableObjects(realm: Realm, value: Value): Set<ObjectValue>,\n};\n\nexport type PropertiesType = {\n  // ECMA262 9.1.9.1\n  OrdinarySet(realm: Realm, O: ObjectValue, P: PropertyKeyValue, V: Value, Receiver: Value): boolean,\n  OrdinarySetPartial(\n    realm: Realm,\n    O: ObjectValue,\n    P: AbstractValue | PropertyKeyValue,\n    V: Value,\n    Receiver: Value\n  ): boolean,\n\n  // ECMA262 6.2.4.4\n  FromPropertyDescriptor(realm: Realm, Desc: ?Descriptor): Value,\n\n  //\n  OrdinaryDelete(realm: Realm, O: ObjectValue, P: PropertyKeyValue): boolean,\n\n  // ECMA262 7.3.8\n  DeletePropertyOrThrow(realm: Realm, O: ObjectValue, P: PropertyKeyValue): boolean,\n\n  // ECMA262 6.2.4.6\n  CompletePropertyDescriptor(realm: Realm, Desc: Descriptor): Descriptor,\n\n  // ECMA262 9.1.6.2\n  IsCompatiblePropertyDescriptor(realm: Realm, extensible: boolean, Desc: Descriptor, current: ?Descriptor): boolean,\n\n  // ECMA262 9.1.6.3\n  ValidateAndApplyPropertyDescriptor(\n    realm: Realm,\n    O: void | ObjectValue,\n    P: void | PropertyKeyValue,\n    extensible: boolean,\n    Desc: Descriptor,\n    current: ?Descriptor\n  ): boolean,\n\n  // ECMA262 9.1.6.1\n  OrdinaryDefineOwnProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue, Desc: Descriptor): boolean,\n\n  // ECMA262 19.1.2.3.1\n  ObjectDefineProperties(realm: Realm, O: Value, Properties: Value): ObjectValue | AbstractObjectValue,\n\n  // ECMA262 7.3.3\n  Set(realm: Realm, O: ObjectValue | AbstractObjectValue, P: PropertyKeyValue, V: Value, Throw: boolean): boolean,\n\n  // ECMA262 7.3.7\n  DefinePropertyOrThrow(\n    realm: Realm,\n    O: ObjectValue | AbstractObjectValue,\n    P: PropertyKeyValue,\n    desc: Descriptor\n  ): boolean,\n\n  // ECMA262 6.2.3.2\n  PutValue(realm: Realm, V: Value | Reference, W: Value): void | boolean | Value,\n\n  // ECMA262 9.4.2.4\n  ArraySetLength(realm: Realm, A: ArrayValue, Desc: Descriptor): boolean,\n\n  // ECMA262 9.1.5.1\n  OrdinaryGetOwnProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue): Descriptor | void,\n\n  // ECMA262 9.1.2.1\n  OrdinarySetPrototypeOf(realm: Realm, O: ObjectValue, V: ObjectValue | NullValue): boolean,\n\n  // ECMA262 13.7.5.15\n  EnumerateObjectProperties(realm: Realm, O: ObjectValue): ObjectValue,\n\n  ThrowIfMightHaveBeenDeleted(desc: Descriptor): void,\n\n  ThrowIfInternalSlotNotWritable<T: ObjectValue>(realm: Realm, object: T, key: string): T,\n\n  // ECMA 14.3.9\n  PropertyDefinitionEvaluation(\n    realm: Realm,\n    MethodDefinition: BabelNodeObjectMethod | BabelNodeClassMethod,\n    object: ObjectValue,\n    env: LexicalEnvironment,\n    strictCode: boolean,\n    enumerable: boolean\n  ): boolean,\n\n  GetOwnPropertyKeysArray(\n    realm: Realm,\n    O: ObjectValue,\n    allowAbstractKeys: boolean,\n    getOwnPropertyKeysEvenIfPartial: boolean\n  ): Array<string>,\n};\n\nexport type FunctionType = {\n  FindVarScopedDeclarations(ast_node: BabelNode): Array<BabelNode>,\n\n  // ECMA262 9.2.12\n  FunctionDeclarationInstantiation(\n    realm: Realm,\n    func: ECMAScriptSourceFunctionValue,\n    argumentsList: Array<Value>\n  ): EmptyValue,\n\n  // ECMA262 9.2.11\n  SetFunctionName(realm: Realm, F: ObjectValue, name: PropertyKeyValue | AbstractValue, prefix?: string): boolean,\n\n  // ECMA262 9.2.3\n  FunctionInitialize(\n    realm: Realm,\n    F: ECMAScriptSourceFunctionValue,\n    kind: \"normal\" | \"method\" | \"arrow\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment\n  ): ECMAScriptSourceFunctionValue,\n\n  // ECMA262 9.2.6\n  GeneratorFunctionCreate(\n    realm: Realm,\n    kind: \"normal\" | \"method\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment,\n    Strict: boolean\n  ): ECMAScriptSourceFunctionValue,\n\n  // ECMA262 9.2.7\n  AddRestrictedFunctionProperties(F: FunctionValue, realm: Realm): boolean,\n\n  // ECMA262 9.2.1\n  $Call(realm: Realm, F: ECMAScriptFunctionValue, thisArgument: Value, argsList: Array<Value>): Value,\n\n  // ECMA262 9.2.2\n  $Construct(\n    realm: Realm,\n    F: ECMAScriptFunctionValue,\n    argumentsList: Array<Value>,\n    newTarget: ObjectValue\n  ): ObjectValue | AbstractObjectValue,\n\n  // ECMA262 9.2.3\n  FunctionAllocate(\n    realm: Realm,\n    functionPrototype: ObjectValue | AbstractObjectValue,\n    strict: boolean,\n    functionKind: \"normal\" | \"non-constructor\" | \"generator\"\n  ): ECMAScriptSourceFunctionValue,\n\n  // ECMA262 9.4.1.3\n  BoundFunctionCreate(\n    realm: Realm,\n    targetFunction: ObjectValue,\n    boundThis: Value,\n    boundArgs: Array<Value>\n  ): ObjectValue,\n\n  // ECMA262 18.2.1.1\n  PerformEval(realm: Realm, x: Value, evalRealm: Realm, strictCaller: boolean, direct: boolean): Value,\n\n  // Composes realm.savedCompletion with c, clears realm.savedCompletion and return the composition.\n  // Call this only when a join point has been reached.\n  incorporateSavedCompletion(realm: Realm, c: void | Completion | Value): void | Completion | Value,\n\n  EvaluateStatements(\n    body: Array<BabelNodeStatement>,\n    initialBlockValue: void | Value,\n    strictCode: boolean,\n    blockEnv: LexicalEnvironment,\n    realm: Realm\n  ): Value,\n\n  // ECMA262 9.2.5\n  FunctionCreate(\n    realm: Realm,\n    kind: \"normal\" | \"arrow\" | \"method\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment,\n    Strict: boolean,\n    prototype?: ObjectValue\n  ): ECMAScriptSourceFunctionValue,\n\n  // ECMA262 18.2.1.2\n  EvalDeclarationInstantiation(\n    realm: Realm,\n    body: BabelNodeBlockStatement,\n    varEnv: LexicalEnvironment,\n    lexEnv: LexicalEnvironment,\n    strict: boolean\n  ): Value,\n\n  // ECMA 9.2.10\n  MakeMethod(realm: Realm, F: ECMAScriptSourceFunctionValue, homeObject: ObjectValue): Value,\n\n  // ECMA 14.3.8\n  DefineMethod(\n    realm: Realm,\n    prop: BabelNodeObjectMethod | BabelNodeClassMethod,\n    obj: ObjectValue,\n    env: LexicalEnvironment,\n    strictCode: boolean,\n    functionPrototype?: ObjectValue\n  ): { $Key: PropertyKeyValue, $Closure: ECMAScriptSourceFunctionValue },\n};\n\nexport type EnvironmentType = {\n  // ECMA262 6.2.3\n  // IsSuperReference(V). Returns true if this reference has a thisValue component.\n  IsSuperReference(realm: Realm, V: Reference): boolean,\n\n  // ECMA262 6.2.3\n  // HasPrimitiveBase(V). Returns true if Type(base) is Boolean, String, Symbol, or Number.\n  HasPrimitiveBase(realm: Realm, V: Reference): boolean,\n\n  // ECMA262 6.2.3\n  // GetReferencedName(V). Returns the referenced name component of the reference V.\n  GetReferencedName(realm: Realm, V: Reference): string | SymbolValue,\n\n  GetReferencedNamePartial(realm: Realm, V: Reference): AbstractValue | string | SymbolValue,\n\n  // ECMA262 6.2.3.1\n  GetValue(realm: Realm, V: Reference | Value): Value,\n  GetConditionValue(realm: Realm, V: Reference | Value): Value,\n\n  // ECMA262 6.2.3\n  // IsStrictReference(V). Returns the strict reference flag component of the reference V.\n  IsStrictReference(realm: Realm, V: Reference): boolean,\n\n  // ECMA262 6.2.3\n  // IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.\n  IsPropertyReference(realm: Realm, V: Reference): boolean,\n\n  // ECMA262 6.2.3\n  // GetBase(V). Returns the base value component of the reference V.\n  GetBase(realm: Realm, V: Reference): void | Value | EnvironmentRecord,\n\n  // ECMA262 6.2.3\n  // IsUnresolvableReference(V). Returns true if the base value is undefined and false otherwise.\n  IsUnresolvableReference(realm: Realm, V: Reference): boolean,\n\n  // ECMA262 8.1.2.2\n  NewDeclarativeEnvironment(realm: Realm, E: LexicalEnvironment, active?: boolean): LexicalEnvironment,\n\n  BoundNames(realm: Realm, node: BabelNode): Array<string>,\n\n  // ECMA262 13.3.3.2\n  ContainsExpression(realm: Realm, node: ?BabelNode): boolean,\n\n  // ECMA262 8.3.2\n  ResolveBinding(realm: Realm, name: string, strict: boolean, env?: ?LexicalEnvironment): Reference,\n\n  // ECMA262 8.1.2.1\n  GetIdentifierReference(realm: Realm, lex: ?LexicalEnvironment, name: string, strict: boolean): Reference,\n\n  // ECMA262 6.2.3.4\n  InitializeReferencedBinding(realm: Realm, V: Reference, W: Value): Value,\n\n  // ECMA262 13.2.14\n  BlockDeclarationInstantiation(\n    realm: Realm,\n    strictCode: boolean,\n    body: Array<BabelNodeStatement>,\n    env: LexicalEnvironment\n  ): void,\n\n  // ECMA262 8.1.2.5\n  NewGlobalEnvironment(\n    realm: Realm,\n    G: ObjectValue | AbstractObjectValue,\n    thisValue: ObjectValue | AbstractObjectValue\n  ): LexicalEnvironment,\n\n  // ECMA262 8.1.2.3\n  NewObjectEnvironment(realm: Realm, O: ObjectValue | AbstractObjectValue, E: LexicalEnvironment): LexicalEnvironment,\n\n  // ECMA262 8.1.2.4\n  NewFunctionEnvironment(realm: Realm, F: ECMAScriptFunctionValue, newTarget?: ObjectValue): LexicalEnvironment,\n\n  // ECMA262 8.3.1\n  GetActiveScriptOrModule(realm: Realm): any,\n\n  // ECMA262 8.3.3\n  GetThisEnvironment(realm: Realm): EnvironmentRecord,\n\n  // ECMA262 8.3.4\n  ResolveThisBinding(realm: Realm): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue,\n\n  BindingInitialization(\n    realm: Realm,\n    node: BabelNodeLVal | BabelNodeVariableDeclaration,\n    value: Value,\n    strictCode: boolean,\n    environment: void | LexicalEnvironment\n  ): void | boolean | Value,\n\n  // ECMA262 13.3.3.6\n  // ECMA262 14.1.19\n  IteratorBindingInitialization(\n    realm: Realm,\n    formals: $ReadOnlyArray<BabelNodeLVal | null>,\n    iteratorRecord: { $Iterator: ObjectValue, $Done: boolean },\n    strictCode: boolean,\n    environment: void | LexicalEnvironment\n  ): void,\n\n  // ECMA262 12.1.5.1\n  InitializeBoundName(\n    realm: Realm,\n    name: string,\n    value: Value,\n    environment: void | LexicalEnvironment\n  ): void | boolean | Value,\n\n  // ECMA262 12.3.1.3 and 13.7.5.6\n  IsDestructuring(ast: BabelNode): boolean,\n\n  // ECMA262 13.3.3.7\n  KeyedBindingInitialization(\n    realm: Realm,\n    node: BabelNodeIdentifier | BabelNodePattern,\n    value: Value,\n    strictCode: boolean,\n    environment: ?LexicalEnvironment,\n    propertyName: PropertyKeyValue\n  ): void | boolean | Value,\n};\n\nexport type JoinType = {\n  composeCompletions(leftCompletion: void | Completion | Value, rightCompletion: Completion | Value): Completion,\n\n  composeWithEffects(completion: Completion, effects: Effects): Effects,\n\n  joinCompletions(joinCondition: Value, c1: Completion, c2: Completion): Completion,\n\n  joinEffects(joinCondition: Value, e1: Effects, e2: Effects): Effects,\n\n  joinDescriptors(\n    realm: Realm,\n    joinCondition: AbstractValue,\n    d1: void | Descriptor,\n    d2: void | Descriptor\n  ): void | Descriptor,\n\n  joinValuesOfSelectedCompletions(\n    selector: (Completion) => boolean,\n    completion: Completion,\n    keepInfeasiblePaths?: boolean\n  ): Value,\n\n  mapAndJoin(\n    realm: Realm,\n    values: Set<ConcreteValue>,\n    joinConditionFactory: (ConcreteValue) => Value,\n    functionToMap: (ConcreteValue) => Completion | Value\n  ): Value,\n};\n\nexport type CreateType = {\n  // ECMA262 9.4.3.3\n  StringCreate(realm: Realm, value: StringValue, prototype: ObjectValue | AbstractObjectValue): ObjectValue,\n\n  // B.2.3.2.1\n  CreateHTML(realm: Realm, string: Value, tag: string, attribute: string, value: string | Value): StringValue,\n\n  // ECMA262 9.4.4.8.1\n  MakeArgGetter(realm: Realm, name: string, env: EnvironmentRecord): NativeFunctionValue,\n\n  // ECMA262 9.4.4.8.1\n  MakeArgSetter(realm: Realm, name: string, env: EnvironmentRecord): NativeFunctionValue,\n\n  // ECMA262 21.1.5.1\n  CreateStringIterator(realm: Realm, string: StringValue): ObjectValue,\n\n  // ECMA262 9.4.2.3\n  ArraySpeciesCreate(realm: Realm, originalArray: ObjectValue, length: number): ObjectValue,\n\n  // ECMA262 7.4.7\n  CreateIterResultObject(realm: Realm, value: Value, done: boolean): ObjectValue,\n\n  // ECMA262 22.1.5.1\n  CreateArrayIterator(realm: Realm, array: ObjectValue, kind: IterationKind): ObjectValue,\n\n  // ECMA262 9.4.2.2\n  ArrayCreate(realm: Realm, length: number, proto?: ObjectValue | AbstractObjectValue): ArrayValue,\n\n  // ECMA262 7.3.16\n  CreateArrayFromList(realm: Realm, elems: Array<Value>): ArrayValue,\n\n  // ECMA262 9.4.4.7\n  CreateUnmappedArgumentsObject(realm: Realm, argumentsList: Array<Value>): ObjectValue,\n\n  // ECMA262 9.4.4.8\n  CreateMappedArgumentsObject(\n    realm: Realm,\n    func: FunctionValue,\n    formals: Array<BabelNodeLVal>,\n    argumentsList: Array<Value>,\n    env: EnvironmentRecord\n  ): ObjectValue,\n\n  // ECMA262 7.3.23 (sec-copydataproperties)\n  CopyDataProperties(realm: Realm, target: ObjectValue, source: Value, excluded: Array<PropertyKeyValue>): ObjectValue,\n\n  // ECMA262 7.3.4\n  CreateDataProperty(realm: Realm, O: ObjectValue | AbstractObjectValue, P: PropertyKeyValue, V: Value): boolean,\n\n  // ECMA262 7.3.5\n  CreateMethodProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue, V: Value): boolean,\n\n  // ECMA262 7.3.6\n  CreateDataPropertyOrThrow(realm: Realm, O: Value, P: PropertyKeyValue, V: Value): boolean,\n\n  // ECMA262 9.1.12\n  ObjectCreate(\n    realm: Realm,\n    proto: ObjectValue | AbstractObjectValue | NullValue,\n    internalSlotsList?: { [key: string]: void }\n  ): ObjectValue,\n\n  // ECMA262 9.1.13\n  OrdinaryCreateFromConstructor(\n    realm: Realm,\n    constructor: ObjectValue,\n    intrinsicDefaultProto: string,\n    internalSlotsList?: { [key: string]: void }\n  ): ObjectValue,\n\n  // ECMA262 7.3.17\n  CreateListFromArrayLike(realm: Realm, obj: Value, elementTypes?: Array<string>): Array<Value>,\n\n  // ECMA262 19.2.1.1.1\n  CreateDynamicFunction(\n    realm: Realm,\n    constructor: ObjectValue,\n    newTarget: void | ObjectValue,\n    kind: \"normal\" | \"generator\",\n    args: Array<Value>\n  ): Value,\n};\n\nexport type WidenType = {\n  // Returns a new effects summary that includes both e1 and e2.\n  widenEffects(realm: Realm, e1: Effects, e2: Effects): Effects,\n\n  // Returns an abstract value that includes both v1 and v2 as potential values.\n  widenValues(\n    realm: Realm,\n    v1: Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n    v2: Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>\n  ): Value | Array<Value> | Array<{ $Key: void | Value, $Value: void | Value }>,\n\n  containsArraysOfValue(realm: Realm, a1: void | Array<Value>, a2: void | Array<Value>): boolean,\n\n  // If e2 is the result of a loop iteration starting with effects e1 and it has a subset of elements of e1,\n  // then we have reached a fixed point and no further calls to widen are needed. e1/e2 represent a general\n  // summary of the loop, regardless of how many iterations will be performed at runtime.\n  containsEffects(e1: Effects, e2: Effects): boolean,\n};\n\nexport type numberOrValue = number | Value;\n\nexport type ElementConvType = {\n  Int8: (Realm, numberOrValue) => number,\n  Int16: (Realm, numberOrValue) => number,\n  Int32: (Realm, numberOrValue) => number,\n  Uint8: (Realm, numberOrValue) => number,\n  Uint16: (Realm, numberOrValue) => number,\n  Uint32: (Realm, numberOrValue) => number,\n  Uint8Clamped: (Realm, numberOrValue) => number,\n};\n\nexport type ToType = {\n  ElementConv: ElementConvType,\n\n  // ECMA262 7.1.5\n  ToInt32(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 7.1.6\n  ToUint32(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 7.1.7\n  ToInt16(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 7.1.8\n  ToUint16(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 7.1.9\n  ToInt8(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 7.1.10\n  ToUint8(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 7.1.11\n  ToUint8Clamp(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 19.3.3.1\n  thisBooleanValue(realm: Realm, value: Value): BooleanValue,\n\n  // ECMA262 20.1.3\n  thisNumberValue(realm: Realm, value: Value): NumberValue,\n\n  // ECMA262 21.1.3\n  thisStringValue(realm: Realm, value: Value): StringValue,\n\n  // ECMA262 6.2.4.5\n  ToPropertyDescriptor(realm: Realm, Obj: Value): Descriptor,\n\n  // ECMA262 7.1.13\n  ToObject(realm: Realm, arg: Value): ObjectValue | AbstractObjectValue,\n\n  // ECMA262 7.1.15\n  ToLength(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 7.1.4\n  ToInteger(realm: Realm, argument: numberOrValue): number,\n\n  // ECMA262 7.1.17\n  ToIndex(realm: Realm, value: number | ConcreteValue): number,\n\n  ToIndexPartial(realm: Realm, value: numberOrValue): number,\n\n  // ECMA262 7.1.3\n  ToNumber(realm: Realm, val: numberOrValue): number,\n\n  ToNumberOrAbstract(realm: Realm, val: numberOrValue): number | AbstractValue,\n\n  IsToNumberPure(realm: Realm, val: numberOrValue): boolean,\n\n  // ECMA262 7.1.1\n  ToPrimitive(realm: Realm, input: ConcreteValue, hint?: \"default\" | \"string\" | \"number\"): PrimitiveValue,\n\n  ToPrimitiveOrAbstract(\n    realm: Realm,\n    input: ConcreteValue,\n    hint?: \"default\" | \"string\" | \"number\"\n  ): AbstractValue | PrimitiveValue,\n\n  // Returns result type of ToPrimitive if it is pure (terminates, does not throw exception, does not read or write heap), otherwise undefined.\n  GetToPrimitivePureResultType(realm: Realm, input: Value): void | typeof Value,\n\n  IsToPrimitivePure(realm: Realm, input: Value): boolean,\n\n  // ECMA262 7.1.1\n  OrdinaryToPrimitive(realm: Realm, input: ObjectValue, hint: \"string\" | \"number\"): PrimitiveValue,\n\n  OrdinaryToPrimitiveOrAbstract(\n    realm: Realm,\n    input: ObjectValue,\n    hint: \"string\" | \"number\"\n  ): AbstractValue | PrimitiveValue,\n\n  IsToStringPure(realm: Realm, input: string | Value): boolean,\n\n  // ECMA262 7.1.12\n  ToString(realm: Realm, val: string | ConcreteValue): string,\n\n  ToStringPartial(realm: Realm, val: string | Value): string,\n\n  ToStringValue(realm: Realm, val: Value): Value,\n\n  ToStringAbstract(realm: Realm, val: AbstractValue): AbstractValue,\n\n  // ECMA262 7.1.2\n  ToBoolean(realm: Realm, val: ConcreteValue): boolean,\n\n  ToBooleanPartial(realm: Realm, val: Value): boolean,\n\n  // ECMA262 7.1.14\n  ToPropertyKey(realm: Realm, arg: ConcreteValue): SymbolValue | string /* but not StringValue */,\n\n  ToPropertyKeyPartial(realm: Realm, arg: Value): AbstractValue | SymbolValue | string /* but not StringValue */,\n\n  // ECMA262 7.1.16\n  CanonicalNumericIndexString(realm: Realm, argument: StringValue): number | void,\n};\n\nexport type ConcretizeType = (realm: Realm, val: Value) => ConcreteValue;\n\nexport type DisplayResult = {} | string;\n\nexport type UtilsType = {|\n  typeToString: (typeof Value) => void | string,\n  getTypeFromName: string => void | typeof Value,\n  describeValue: Value => string,\n  jsonToDisplayString: <T: { toDisplayJson(number): DisplayResult }>(T, number) => string,\n  verboseToDisplayJson: ({}, number) => DisplayResult,\n  createModelledFunctionCall: (Realm, FunctionValue, void | string | ArgModel, void | Value) => void => Value,\n|};\n\nexport type DebuggerConfigArguments = {\n  diagnosticSeverity?: Severity,\n  sourcemaps?: Array<SourceFile>,\n  buckRoot?: string,\n  debugChannel?: DebugChannel,\n};\n\nexport type SupportedGraphQLGetters =\n  | \"bool\"\n  | \"double\"\n  | \"int\"\n  | \"time\"\n  | \"string\"\n  | \"tree\"\n  | \"bool_list\"\n  | \"double_list\"\n  | \"int_list\"\n  | \"time_list\"\n  | \"string_list\"\n  | \"tree_list\";\n\nexport interface ShapeInformationInterface {\n  getPropertyShape(key: string): void | ShapeInformationInterface;\n  getGetter(): void | SupportedGraphQLGetters;\n  getAbstractType(): typeof Value;\n}\n\ntype ECMAScriptType =\n  | \"void\"\n  | \"null\"\n  | \"boolean\"\n  | \"string\"\n  | \"symbol\"\n  | \"number\"\n  | \"object\"\n  | \"array\"\n  | \"function\"\n  | \"integral\";\n\ntype ShapeDescriptorCommon = {\n  jsType: ECMAScriptType,\n  graphQLType?: string,\n};\n\nexport type ShapePropertyDescriptor = {\n  shape: ShapeDescriptor,\n  optional: boolean,\n};\n\ntype ShapeDescriptorOfObject = ShapeDescriptorCommon & {\n  kind: \"object\",\n  properties: { [string]: void | ShapePropertyDescriptor },\n};\n\ntype ShapeDescriptorOfArray = ShapeDescriptorCommon & {\n  kind: \"array\",\n  elementShape: void | ShapePropertyDescriptor,\n};\n\ntype ShapeDescriptorOfLink = ShapeDescriptorCommon & {\n  kind: \"link\",\n  shapeName: string,\n};\n\ntype ShapeDescriptorOfPrimitive = ShapeDescriptorCommon & {\n  kind: \"scalar\",\n};\n\ntype ShapeDescriptorOfEnum = ShapeDescriptorCommon & {\n  kind: \"enum\",\n};\n\nexport type ShapeDescriptorNonLink =\n  | ShapeDescriptorOfObject\n  | ShapeDescriptorOfArray\n  | ShapeDescriptorOfPrimitive\n  | ShapeDescriptorOfEnum;\n\nexport type ShapeDescriptor = ShapeDescriptorNonLink | ShapeDescriptorOfLink;\n\nexport type ShapeUniverse = { [string]: ShapeDescriptor };\n\nexport type ArgModel = {\n  universe: ShapeUniverse,\n  arguments: { [string]: string },\n};\n\nexport type DebugReproManagerType = {\n  construct(configArgs: DebugReproArguments): void,\n  addSourceFile(fileName: string): void,\n  getSourceFilePaths(): Array<{ absolute: string, relative: string }>,\n  getSourceMapPaths(): Array<string>,\n};\n\nexport type DebugReproArguments = {\n  sourcemaps?: Array<SourceFile>,\n  buckRoot?: string,\n};\n"],"file":"types.js"}