{"version":3,"sources":["../../src/methods/environment.js"],"names":["EnvironmentImplementation","RestBindingInitialization","realm","property","value","excludedNames","strictCode","environment","BindingIdentifier","argument","restObj","Create","ObjectCreate","intrinsics","ObjectPrototype","CopyDataProperties","bindingId","name","lhs","ResolveBinding","undefined","Properties","PutValue","InitializeReferencedBinding","PropertyBindingInitialization","properties","length","BindingProperty","slice","BindingPropertyList","boundNames","nextNames","env","getRunningContext","lexicalEnvironment","P","KeyedBindingInitialization","concat","IsSuperReference","V","thisValue","HasPrimitiveBase","base","GetBase","EnvironmentRecord","type","getType","BooleanValue","StringValue","SymbolValue","NumberValue","IntegralValue","GetReferencedName","referencedName","AbstractValue","reportIntrospectionError","FatalError","GetReferencedNamePartial","GetValue","val","_dereference","simplifyAndRefineAbstractValue","GetConditionValue","simplifyAndRefineAbstractCondition","_dereferenceConditional","ref","condValue","consequentVal","alternateVal","evaluateWithAbstractConditional","evaluateForEffects","consequentRef","Reference","strict","alternateRef","deferenceConditionals","IsUnresolvableReference","createErrorThrowCompletion","ReferenceError","toString","IsPropertyReference","AbstractObjectValue","kind","args","leftValue","rightValue","To","ToObject","Value","UndefinedValue","NullValue","ObjectValue","$GetPartial","GetBindingValue","IsStrictReference","NewDeclarativeEnvironment","E","active","LexicalEnvironment","activeLexicalEnvironments","add","envRec","DeclarativeEnvironmentRecord","environmentRecord","parent","BoundNames","node","Object","keys","t","getOuterBindingIdentifiers","ContainsExpression","prop","elem","elements","GetIdentifierReference","lex","exists","HasBinding","outer","W","InitializeBinding","BlockDeclarationInstantiation","body","declarations","push","d","dn","SyntaxError","CreateImmutableBinding","CreateMutableBinding","fn","fo","evaluate","NewGlobalEnvironment","G","objRec","ObjectEnvironmentRecord","dclRec","globalRec","GlobalEnvironmentRecord","$ObjectRecord","$GlobalThisValue","$DeclarativeRecord","$VarNames","NewObjectEnvironment","O","NewFunctionEnvironment","F","newTarget","ECMAScriptFunctionValue","FunctionEnvironmentRecord","$FunctionObject","$ThisMode","$ThisBindingStatus","home","$HomeObject","$NewTarget","$Environment","GetActiveScriptOrModule","contextStack","ec","i","function","$ScriptOrModule","ScriptOrModule","GetThisEnvironment","HasThisBinding","ResolveThisBinding","GetThisBinding","BindingInitialization","iterator","iteratorRecord","$Iterator","$Done","result","IteratorBindingInitialization","error","AbruptCompletion","completion","SimpleNormalCompletion","BindingRestElement","empty","InitializeBoundName","decl","id","formals","restEl","lastFormal","param","next","e","Initializer","right","left","v","defaultValue","hasNameProperty","Functions","SetFunctionName","A","ArrayCreate","n","nextValue","status","CreateDataProperty","IsDestructuring","ast","propertyName"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport invariant from \"../invariant.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  BooleanValue,\n  ECMAScriptFunctionValue,\n  IntegralValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  Value,\n  UndefinedValue,\n} from \"../values/index.js\";\nimport {\n  DeclarativeEnvironmentRecord,\n  EnvironmentRecord,\n  FunctionEnvironmentRecord,\n  GlobalEnvironmentRecord,\n  isValidBaseValue,\n  LexicalEnvironment,\n  ObjectEnvironmentRecord,\n  Reference,\n  type BaseValue,\n} from \"../environment.js\";\nimport { AbruptCompletion, SimpleNormalCompletion } from \"../completions.js\";\nimport { FatalError } from \"../errors.js\";\nimport { EvalPropertyName } from \"../evaluators/ObjectExpression.js\";\nimport {\n  GetV,\n  GetThisValue,\n  HasSomeCompatibleType,\n  GetIterator,\n  IteratorStep,\n  IteratorValue,\n  IteratorClose,\n  IsAnonymousFunctionDefinition,\n  HasOwnProperty,\n  RequireObjectCoercible,\n} from \"./index.js\";\nimport { Create, Functions, Properties, To } from \"../singletons.js\";\nimport type {\n  BabelNode,\n  BabelNodeVariableDeclaration,\n  BabelNodeIdentifier,\n  BabelNodeRestElement,\n  BabelNodeObjectProperty,\n  BabelNodeObjectPattern,\n  BabelNodeArrayPattern,\n  BabelNodeStatement,\n  BabelNodeLVal,\n  BabelNodePattern,\n} from \"@babel/types\";\nimport * as t from \"@babel/types\";\n\nexport class EnvironmentImplementation {\n  // 2.6 RestBindingInitialization (please suggest an appropriate section name)\n  RestBindingInitialization(\n    realm: Realm,\n    property: BabelNodeRestElement,\n    value: Value,\n    excludedNames: Array<PropertyKeyValue>,\n    strictCode: boolean,\n    environment: ?LexicalEnvironment\n  ): void | boolean | Value {\n    let BindingIdentifier = ((property.argument: any): BabelNodeIdentifier);\n\n    // 1. Let restObj be ObjectCreate(%ObjectPrototype%).\n    let restObj = Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n    // 2. Let assignStatus be CopyDataProperties(restObj, value, excludedNames).\n    /* let assignStatus = */ Create.CopyDataProperties(realm, restObj, value, excludedNames);\n\n    // 3. ReturnIfAbrupt(assignStatus).\n\n    // 4. Let bindingId be StringValue of BindingIdentifier.\n    let bindingId = BindingIdentifier.name;\n\n    // 5. Let lhs be ResolveBinding(bindingId, environment).\n    let lhs = this.ResolveBinding(realm, bindingId, strictCode, environment);\n\n    // 6. ReturnIfAbrupt(lhs).\n\n    // 7. If environment is undefined, return PutValue(lhs, restObj).\n    if (environment === undefined) {\n      return Properties.PutValue(realm, lhs, restObj);\n    }\n\n    // 8. Return InitializeReferencedBinding(lhs, restObj).\n    return this.InitializeReferencedBinding(realm, lhs, restObj);\n  }\n\n  // 2.5  PropertyBindingInitialization (please suggest an appropriate section name)\n  PropertyBindingInitialization(\n    realm: Realm,\n    properties: Array<BabelNodeObjectProperty>,\n    value: Value,\n    strictCode: boolean,\n    environment: ?LexicalEnvironment\n  ): Array<PropertyKeyValue> {\n    // Base condition for recursive call below\n    if (properties.length === 0) {\n      return [];\n    }\n\n    let BindingProperty = properties.slice(-1)[0];\n    let BindingPropertyList = properties.slice(0, -1);\n\n    // 1. Let boundNames be the result of performing PropertyBindingInitialization for BindingPropertyList using value and environment as arguments.\n    let boundNames = this.PropertyBindingInitialization(realm, BindingPropertyList, value, strictCode, environment);\n\n    // 2. ReturnIfAbrupt(status boundNames).\n\n    // 3. Let nextNames be the result of performing PropertyBindingInitialization for BindingProperty using value and environment as arguments.\n    let nextNames;\n\n    // SingleNameBinding\n    // PropertyName : BindingElement\n    // 1. Let P be the result of evaluating PropertyName.\n    let env = environment ? environment : realm.getRunningContext().lexicalEnvironment;\n    let P = EvalPropertyName(BindingProperty, env, realm, strictCode);\n    // 2. ReturnIfAbrupt(P).\n\n    // 3. Let status be the result of performing KeyedBindingInitialization of BindingElement with value, environment, and P as the arguments.\n    /* let status = */ this.KeyedBindingInitialization(\n      realm,\n      ((BindingProperty.value: any): BabelNodeIdentifier | BabelNodePattern),\n      value,\n      strictCode,\n      environment,\n      P\n    );\n\n    // 4. ReturnIfAbrupt(status).\n\n    // 5. Return a new List containing P.\n    nextNames = [P];\n\n    // 4. ReturnIfAbrupt(nextNames).\n\n    // 5. Append each item in nextNames to the end of boundNames.\n    boundNames = boundNames.concat(nextNames);\n\n    return boundNames;\n  }\n\n  // ECMA262 6.2.3\n  // IsSuperReference(V). Returns true if this reference has a thisValue component.\n  IsSuperReference(realm: Realm, V: Reference): boolean {\n    return V.thisValue !== undefined;\n  }\n\n  // ECMA262 6.2.3\n  // HasPrimitiveBase(V). Returns true if Type(base) is Boolean, String, Symbol, or Number.\n  HasPrimitiveBase(realm: Realm, V: Reference): boolean {\n    let base = this.GetBase(realm, V);\n    // void | ObjectValue | BooleanValue | StringValue | SymbolValue | NumberValue | EnvironmentRecord | AbstractValue;\n    if (!base || base instanceof EnvironmentRecord) return false;\n    let type = base.getType();\n    return (\n      type === BooleanValue ||\n      type === StringValue ||\n      type === SymbolValue ||\n      type === NumberValue ||\n      type === IntegralValue\n    );\n  }\n\n  // ECMA262 6.2.3\n  // GetReferencedName(V). Returns the referenced name component of the reference V.\n  GetReferencedName(realm: Realm, V: Reference): string | SymbolValue {\n    if (V.referencedName instanceof AbstractValue) {\n      AbstractValue.reportIntrospectionError(V.referencedName);\n      throw new FatalError();\n    }\n    return V.referencedName;\n  }\n\n  GetReferencedNamePartial(realm: Realm, V: Reference): AbstractValue | string | SymbolValue {\n    return V.referencedName;\n  }\n\n  // ECMA262 6.2.3.1\n  GetValue(realm: Realm, V: Reference | Value): Value {\n    let val = this._dereference(realm, V);\n    if (val instanceof AbstractValue) return realm.simplifyAndRefineAbstractValue(val);\n    return val;\n  }\n\n  GetConditionValue(realm: Realm, V: Reference | Value): Value {\n    let val = this._dereference(realm, V);\n    if (val instanceof AbstractValue) return realm.simplifyAndRefineAbstractCondition(val);\n    return val;\n  }\n\n  _dereferenceConditional(\n    realm: Realm,\n    ref: Reference,\n    condValue: AbstractValue,\n    consequentVal: Value,\n    alternateVal: Value\n  ): Value {\n    return realm.evaluateWithAbstractConditional(\n      condValue,\n      () => {\n        return realm.evaluateForEffects(\n          () => {\n            if (isValidBaseValue(consequentVal)) {\n              let consequentRef = new Reference(\n                ((consequentVal: any): BaseValue),\n                ref.referencedName,\n                ref.strict,\n                ref.thisValue\n              );\n              return this._dereference(realm, consequentRef);\n            }\n            return this._dereference(realm, ref, false);\n          },\n          null,\n          \"_dereferenceConditional consequent\"\n        );\n      },\n      () => {\n        return realm.evaluateForEffects(\n          () => {\n            if (isValidBaseValue(alternateVal)) {\n              let alternateRef = new Reference(\n                ((alternateVal: any): BaseValue),\n                ref.referencedName,\n                ref.strict,\n                ref.thisValue\n              );\n              return this._dereference(realm, alternateRef);\n            }\n            return this._dereference(realm, ref, false);\n          },\n          null,\n          \"_dereferenceConditional alternate\"\n        );\n      }\n    );\n  }\n\n  _dereference(realm: Realm, V: Reference | Value, deferenceConditionals?: boolean = true): Value {\n    // This step is not necessary as we propagate completions with exceptions.\n    // 1. ReturnIfAbrupt(V).\n\n    // 2. If Type(V) is not Reference, return V.\n    if (!(V instanceof Reference)) return V;\n\n    // 3. Let base be GetBase(V).\n    let base = this.GetBase(realm, V);\n\n    // 4. If IsUnresolvableReference(V) is true, throw a ReferenceError exception.\n    if (this.IsUnresolvableReference(realm, V)) {\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.ReferenceError,\n        `${V.referencedName.toString()} is not defined`\n      );\n    }\n\n    // 5. If IsPropertyReference(V) is true, then\n    if (this.IsPropertyReference(realm, V)) {\n      if (base instanceof AbstractValue) {\n        if (deferenceConditionals && !(base instanceof AbstractObjectValue)) {\n          if (base.kind === \"conditional\") {\n            let [condValue, consequentVal, alternateVal] = base.args;\n            invariant(condValue instanceof AbstractValue);\n            if (isValidBaseValue(consequentVal) || isValidBaseValue(alternateVal)) {\n              return this._dereferenceConditional(realm, V, condValue, consequentVal, alternateVal);\n            }\n          } else if (base.kind === \"||\") {\n            let [leftValue, rightValue] = base.args;\n            invariant(leftValue instanceof AbstractValue);\n            return this._dereferenceConditional(realm, V, leftValue, leftValue, rightValue);\n          } else if (base.kind === \"&&\") {\n            let [leftValue, rightValue] = base.args;\n            invariant(leftValue instanceof AbstractValue);\n            return this._dereferenceConditional(realm, V, leftValue, rightValue, leftValue);\n          }\n        }\n        // Ensure that abstract values are coerced to objects. This might yield\n        // an operation that might throw.\n        base = To.ToObject(realm, base);\n      }\n      // a. If HasPrimitiveBase(V) is true, then\n      if (this.HasPrimitiveBase(realm, V)) {\n        // i. Assert: In this case, base will never be null or undefined.\n        invariant(base instanceof Value && !HasSomeCompatibleType(base, UndefinedValue, NullValue));\n\n        // ii. Let base be To.ToObject(base).\n        base = To.ToObject(realm, base);\n      }\n      invariant(base instanceof ObjectValue || base instanceof AbstractObjectValue);\n\n      // b. Return ? base.[[Get]](GetReferencedName(V), GetThisValue(V)).\n      return base.$GetPartial(this.GetReferencedNamePartial(realm, V), GetThisValue(realm, V));\n    }\n\n    // 6. Else base must be an Environment Record,\n    if (base instanceof EnvironmentRecord) {\n      // a. Return ? base.GetBindingValue(GetReferencedName(V), IsStrictReference(V)) (see 8.1.1).\n      let referencedName = this.GetReferencedName(realm, V);\n      invariant(typeof referencedName === \"string\");\n      return base.GetBindingValue(referencedName, this.IsStrictReference(realm, V));\n    }\n\n    invariant(false);\n  }\n\n  // ECMA262 6.2.3\n  // IsStrictReference(V). Returns the strict reference flag component of the reference V.\n  IsStrictReference(realm: Realm, V: Reference): boolean {\n    return V.strict;\n  }\n\n  // ECMA262 6.2.3\n  // IsPropertyReference(V). Returns true if either the base value is an object or HasPrimitiveBase(V) is true; otherwise returns false.\n  IsPropertyReference(realm: Realm, V: Reference): boolean {\n    // V.base is AbstractValue | void | ObjectValue | BooleanValue | StringValue | SymbolValue | NumberValue | EnvironmentRecord;\n    return V.base instanceof AbstractValue || V.base instanceof ObjectValue || this.HasPrimitiveBase(realm, V);\n  }\n\n  // ECMA262 6.2.3\n  // GetBase(V). Returns the base value component of the reference V.\n  GetBase(realm: Realm, V: Reference): void | Value | EnvironmentRecord {\n    return V.base;\n  }\n\n  // ECMA262 6.2.3\n  // IsUnresolvableReference(V). Returns true if the base value is undefined and false otherwise.\n  IsUnresolvableReference(realm: Realm, V: Reference): boolean {\n    return !V.base;\n  }\n\n  // ECMA262 8.1.2.2\n  NewDeclarativeEnvironment(realm: Realm, E: LexicalEnvironment, active: boolean = true): LexicalEnvironment {\n    // 1. Let env be a new Lexical Environment.\n    let env = new LexicalEnvironment(realm);\n    if (active) realm.activeLexicalEnvironments.add(env);\n\n    // 2. Let envRec be a new declarative Environment Record containing no bindings.\n    let envRec = new DeclarativeEnvironmentRecord(realm);\n\n    // 3. Set env's EnvironmentRecord to envRec.\n    env.environmentRecord = envRec;\n\n    // 4. Set the outer lexical environment reference of env to E.\n    env.parent = E;\n\n    // 5. Return env.\n    return env;\n  }\n\n  BoundNames(realm: Realm, node: BabelNode): Array<string> {\n    return Object.keys(t.getOuterBindingIdentifiers(node));\n  }\n\n  // ECMA262 13.3.3.2\n  ContainsExpression(realm: Realm, node: ?BabelNode): boolean {\n    if (!node) {\n      return false;\n    }\n    switch (node.type) {\n      case \"ObjectPattern\":\n        for (let prop of ((node: any): BabelNodeObjectPattern).properties) {\n          if (this.ContainsExpression(realm, prop)) return true;\n        }\n        return false;\n      case \"ArrayPattern\":\n        for (let elem of ((node: any): BabelNodeArrayPattern).elements) {\n          if (this.ContainsExpression(realm, elem)) return true;\n        }\n        return false;\n      case \"RestElement\":\n        return this.ContainsExpression(realm, ((node: any): BabelNodeRestElement).argument);\n      case \"AssignmentPattern\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // ECMA262 8.3.2\n  ResolveBinding(realm: Realm, name: string, strict: boolean, env?: ?LexicalEnvironment): Reference {\n    // 1. If env was not passed or if env is undefined, then\n    if (!env) {\n      // a. Let env be the running execution context's LexicalEnvironment.\n      env = realm.getRunningContext().lexicalEnvironment;\n    }\n\n    // 2. Assert: env is a Lexical Environment.\n    invariant(env instanceof LexicalEnvironment, \"expected lexical environment\");\n\n    // 3. If the code matching the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let strict be false.\n\n    // 4. Return ? GetIdentifierReference(env, name, strict).\n    return this.GetIdentifierReference(realm, env, name, strict);\n  }\n\n  // ECMA262 8.1.2.1\n  GetIdentifierReference(realm: Realm, lex: ?LexicalEnvironment, name: string, strict: boolean): Reference {\n    // 1. If lex is the value null, then\n    if (!lex) {\n      // a. Return a value of type Reference whose base value is undefined, whose referenced name is name, and whose strict reference flag is strict.\n      return new Reference(undefined, name, strict);\n    }\n\n    // 2. Let envRec be lex's EnvironmentRecord.\n    let envRec = lex.environmentRecord;\n\n    // 3. Let exists be ? envRec.HasBinding(name).\n    let exists = envRec.HasBinding(name);\n\n    // 4. If exists is true, then\n    if (exists) {\n      // a. Return a value of type Reference whose base value is envRec, whose referenced name is name, and whose strict reference flag is strict.\n      return new Reference(envRec, name, strict);\n    } else {\n      // 5. Else,\n      // a. Let outer be the value of lex's outer environment reference.\n      let outer = lex.parent;\n\n      // b. Return ? GetIdentifierReference(outer, name, strict).\n      return this.GetIdentifierReference(realm, outer, name, strict);\n    }\n  }\n\n  // ECMA262 6.2.3.4\n  InitializeReferencedBinding(realm: Realm, V: Reference, W: Value): Value {\n    // 1. ReturnIfAbrupt(V).\n    // 2. ReturnIfAbrupt(W).\n\n    // 3. Assert: Type(V) is Reference.\n    invariant(V instanceof Reference, \"expected reference\");\n\n    // 4. Assert: IsUnresolvableReference(V) is false.\n    invariant(!this.IsUnresolvableReference(realm, V), \"expected resolvable reference\");\n\n    // 5. Let base be GetBase(V).\n    let base = this.GetBase(realm, V);\n\n    // 6. Assert: base is an Environment Record.\n    invariant(base instanceof EnvironmentRecord, \"expected environment record\");\n\n    // 7. Return base.InitializeBinding(GetReferencedName(V), W).\n    let referencedName = this.GetReferencedName(realm, V);\n    invariant(typeof referencedName === \"string\");\n    return base.InitializeBinding(referencedName, W);\n  }\n\n  // ECMA262 13.2.14\n  BlockDeclarationInstantiation(\n    realm: Realm,\n    strictCode: boolean,\n    body: Array<BabelNodeStatement>,\n    env: LexicalEnvironment\n  ): void {\n    // 1. Let envRec be env's EnvironmentRecord.\n    let envRec = env.environmentRecord;\n\n    // 2. Assert: envRec is a declarative Environment Record.\n    invariant(envRec instanceof DeclarativeEnvironmentRecord, \"expected declarative environment record\");\n\n    // 3. Let declarations be the LexicallyScopedDeclarations of code.\n    let declarations = [];\n    for (let node of body) {\n      if (\n        node.type === \"ClassDeclaration\" ||\n        node.type === \"FunctionDeclaration\" ||\n        (node.type === \"VariableDeclaration\" && node.kind !== \"var\")\n      ) {\n        declarations.push(node);\n      }\n    }\n\n    // 4. For each element d in declarations do\n    for (let d of declarations) {\n      // a. For each element dn of the BoundNames of d do\n      for (let dn of this.BoundNames(realm, d)) {\n        if (envRec.HasBinding(dn)) {\n          //ECMA262 13.2.1\n          throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, dn + \" already declared\");\n        }\n        // i. If IsConstantDeclaration of d is true, then\n        if (d.type === \"VariableDeclaration\" && d.kind === \"const\") {\n          // 1. Perform ! envRec.CreateImmutableBinding(dn, true).\n          envRec.CreateImmutableBinding(dn, true);\n        } else {\n          // ii. Else,\n          // 1. Perform ! envRec.CreateMutableBinding(dn, false).\n          envRec.CreateMutableBinding(dn, false);\n        }\n      }\n\n      // b. If d is a GeneratorDeclaration production or a FunctionDeclaration production, then\n      if (d.type === \"FunctionDeclaration\") {\n        // i. Let fn be the sole element of the BoundNames of d.\n        let fn = this.BoundNames(realm, d)[0];\n\n        // ii. Let fo be the result of performing InstantiateFunctionObject for d with argument env.\n        let fo = env.evaluate(d, strictCode);\n        invariant(fo instanceof Value);\n\n        // iii. Perform envRec.InitializeBinding(fn, fo).\n        envRec.InitializeBinding(fn, fo);\n      }\n    }\n  }\n\n  // ECMA262 8.1.2.5\n  NewGlobalEnvironment(\n    realm: Realm,\n    G: ObjectValue | AbstractObjectValue,\n    thisValue: ObjectValue | AbstractObjectValue\n  ): LexicalEnvironment {\n    // 1. Let env be a new Lexical Environment.\n    let env = new LexicalEnvironment(realm);\n\n    // 2. Let objRec be a new object Environment Record containing G as the binding object.\n    let objRec = new ObjectEnvironmentRecord(realm, G);\n\n    // 3. Let dclRec be a new declarative Environment Record containing no bindings.\n    let dclRec = new DeclarativeEnvironmentRecord(realm);\n\n    // 4. Let globalRec be a new global Environment Record.\n    let globalRec = new GlobalEnvironmentRecord(realm);\n\n    // 5. Set globalRec.[[ObjectRecord]] to objRec.\n    globalRec.$ObjectRecord = objRec;\n\n    // 6. Set globalRec.[[GlobalThisValue]] to thisValue.\n    globalRec.$GlobalThisValue = thisValue;\n\n    // 7. Set globalRec.[[DeclarativeRecord]] to dclRec.\n    globalRec.$DeclarativeRecord = dclRec;\n\n    // 8. Set globalRec.[[VarNames]] to a new empty List.\n    globalRec.$VarNames = [];\n\n    // 9. Set env's EnvironmentRecord to globalRec.\n    env.environmentRecord = globalRec;\n    realm.activeLexicalEnvironments.add(env);\n\n    // 10. Set the outer lexical environment reference of env to null.\n    env.parent = null;\n\n    // 11. Return env.\n    return env;\n  }\n\n  // ECMA262 8.1.2.3\n  NewObjectEnvironment(realm: Realm, O: ObjectValue | AbstractObjectValue, E: LexicalEnvironment): LexicalEnvironment {\n    // 1. Let env be a new Lexical Environment.\n    let env = new LexicalEnvironment(realm);\n    realm.activeLexicalEnvironments.add(env);\n\n    // 2. Let envRec be a new object Environment Record containing O as the binding object.\n    let envRec = new ObjectEnvironmentRecord(realm, O);\n\n    // 3. Set env's EnvironmentRecord to envRec.\n    env.environmentRecord = envRec;\n\n    // 4. Set the outer lexical environment reference of env to E.\n    env.parent = E;\n\n    // 5. Return env.\n    return env;\n  }\n\n  // ECMA262 8.1.2.4\n  NewFunctionEnvironment(realm: Realm, F: ECMAScriptFunctionValue, newTarget?: ObjectValue): LexicalEnvironment {\n    // 1. Assert: F is an ECMAScript function.\n    invariant(F instanceof ECMAScriptFunctionValue, \"expected a function\");\n\n    // 2. Assert: Type(newTarget) is Undefined or Object.\n    invariant(\n      newTarget === undefined || newTarget instanceof ObjectValue,\n      \"expected undefined or object value for new target\"\n    );\n\n    // 3. Let env be a new Lexical Environment.\n    let env = new LexicalEnvironment(realm);\n    realm.activeLexicalEnvironments.add(env);\n\n    // 4. Let envRec be a new function Environment Record containing no bindings.\n    let envRec = new FunctionEnvironmentRecord(realm);\n\n    // 5. Set envRec.[[FunctionObject]] to F.\n    envRec.$FunctionObject = F;\n\n    // 6. If F's [[ThisMode]] internal slot is lexical, set envRec.[[ThisBindingStatus]] to \"lexical\".\n    if (F.$ThisMode === \"lexical\") {\n      envRec.$ThisBindingStatus = \"lexical\";\n    } else {\n      // 7. Else, set envRec.[[ThisBindingStatus]] to \"uninitialized\".\n      envRec.$ThisBindingStatus = \"uninitialized\";\n    }\n\n    // 8. Let home be the value of F's [[HomeObject]] internal slot.\n    let home = F.$HomeObject;\n\n    // 9. Set envRec.[[HomeObject]] to home.\n    envRec.$HomeObject = home;\n\n    // 10. Set envRec.[[NewTarget]] to newTarget.\n    envRec.$NewTarget = newTarget;\n\n    // 11. Set env's EnvironmentRecord to envRec.\n    env.environmentRecord = envRec;\n\n    // 12. Set the outer lexical environment reference of env to the value of F's [[Environment]] internal slot.\n    env.parent = F.$Environment;\n\n    // 13. Return env.\n    return env;\n  }\n\n  // ECMA262 8.3.1\n  GetActiveScriptOrModule(realm: Realm): any {\n    // The GetActiveScriptOrModule abstract operation is used to determine the running script or module, based on the active function object.\n    // GetActiveScriptOrModule performs the following steps:\n    //\n    // If the execution context stack is empty, return null.\n    if (realm.contextStack.length === 0) return null;\n    // Let ec be the topmost execution context on the execution context stack whose Function component's [[ScriptOrModule]] component is not null.\n    // If such an execution context exists, return ec's Function component's [[ScriptOrModule]] slot's value.\n    let ec;\n    for (let i = realm.contextStack.length - 1; i >= 0; i--) {\n      ec = realm.contextStack[i];\n      let F = ec.function;\n      if (F == null) continue;\n      if (F.$ScriptOrModule instanceof Object) {\n        return F.$ScriptOrModule;\n      }\n    }\n    // Otherwise, let ec be the running execution context.\n    ec = realm.getRunningContext();\n    // Assert: ec's ScriptOrModule component is not null.\n    invariant(ec.ScriptOrModule !== null);\n    // Return ec's ScriptOrModule component.\n    return ec.ScriptOrModule;\n  }\n\n  // ECMA262 8.3.3\n  GetThisEnvironment(realm: Realm): EnvironmentRecord {\n    // 1. Let lex be the running execution context's LexicalEnvironment.\n    let lex = realm.getRunningContext().lexicalEnvironment;\n\n    // 2. Repeat\n    while (true) {\n      // a. Let envRec be lex's EnvironmentRecord.\n      let envRec = lex.environmentRecord;\n\n      // b. Let exists be envRec.HasThisBinding().\n      let exists = envRec.HasThisBinding();\n\n      // c. If exists is true, return envRec.\n      if (exists) return envRec;\n\n      // d. Let outer be the value of lex's outer environment reference.\n      let outer = lex.parent;\n      invariant(outer);\n\n      // e. Let lex be outer.\n      lex = outer;\n    }\n\n    invariant(false);\n  }\n\n  // ECMA262 8.3.4\n  ResolveThisBinding(realm: Realm): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    // 1. Let envRec be GetThisEnvironment( ).\n    let envRec = this.GetThisEnvironment(realm);\n\n    // 2. Return ? envRec.GetThisBinding().\n    return envRec.GetThisBinding();\n  }\n\n  BindingInitialization(\n    realm: Realm,\n    node: BabelNodeLVal | BabelNodeVariableDeclaration,\n    value: Value,\n    strictCode: boolean,\n    environment: void | LexicalEnvironment\n  ): void | boolean | Value {\n    if (node.type === \"ArrayPattern\") {\n      // ECMA262 13.3.3.5\n      // 1. Let iterator be ? GetIterator(value).\n      let iterator = GetIterator(realm, value);\n\n      // 2. Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.\n      let iteratorRecord = {\n        $Iterator: iterator,\n        $Done: false,\n      };\n\n      let result;\n\n      // 3. Let result be IteratorBindingInitialization for ArrayBindingPattern using iteratorRecord and environment as arguments.\n      try {\n        result = this.IteratorBindingInitialization(realm, node.elements, iteratorRecord, strictCode, environment);\n      } catch (error) {\n        // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).\n        if (iteratorRecord.$Done === false && error instanceof AbruptCompletion) {\n          throw IteratorClose(realm, iterator, error);\n        }\n        throw error;\n      }\n\n      // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).\n      if (iteratorRecord.$Done === false) {\n        let completion = IteratorClose(realm, iterator, new SimpleNormalCompletion(realm.intrinsics.undefined));\n        if (completion instanceof AbruptCompletion) {\n          throw completion;\n        }\n      }\n\n      // 5. Return result.\n      return result;\n    } else if (node.type === \"ObjectPattern\") {\n      RequireObjectCoercible(realm, value);\n\n      let BindingPropertyList = [],\n        BindingRestElement = null;\n\n      for (let property of node.properties) {\n        if (property.type === \"RestElement\") {\n          BindingRestElement = property;\n        } else {\n          BindingPropertyList.push(property);\n        }\n      }\n\n      // ObjectBindingPattern:\n      //   { BindingPropertyList }\n      //   { BindingPropertyList, }\n\n      if (!BindingRestElement) {\n        // 1. Let excludedNames be the result of performing PropertyBindingInitialization for BindingPropertyList using value and environment as the argument.\n        /* let excludedNames = */ this.PropertyBindingInitialization(\n          realm,\n          BindingPropertyList,\n          value,\n          strictCode,\n          environment\n        );\n\n        // 2. ReturnIfAbrupt(excludedNames).\n\n        // 3. Return NormalCompletion(empty).\n        return realm.intrinsics.empty;\n      }\n\n      // ObjectBindingPattern : { BindingRestElement }\n      if (BindingPropertyList.length === 0) {\n        // 1. Let excludedNames be a new empty List.\n        let excludedNames = [];\n\n        // 2. Return the result of performing RestBindingInitialization of BindingRestElement with value, environment and excludedNames as the arguments.\n        return this.RestBindingInitialization(realm, BindingRestElement, value, excludedNames, strictCode, environment);\n      } else {\n        // ObjectBindingPattern : { BindingPropertyList, BindingRestElement }\n\n        // 1. Let excludedNames be the result of performing PropertyBindingInitialization of BindingPropertyList using value and environment as arguments.\n        let excludedNames = this.PropertyBindingInitialization(\n          realm,\n          BindingPropertyList,\n          value,\n          strictCode,\n          environment\n        );\n\n        // 2. ReturnIfAbrupt(excludedNames).\n\n        // 3. Return the result of performing RestBindingInitialization of BindingRestElement with value, environment and excludedNames as the arguments.\n        return this.RestBindingInitialization(realm, BindingRestElement, value, excludedNames, strictCode, environment);\n      }\n    } else if (node.type === \"Identifier\") {\n      // ECMA262 12.1.5\n      // 1. Let name be StringValue of Identifier.\n      let name = ((node: any): BabelNodeIdentifier).name;\n\n      // 2. Return ? InitializeBoundName(name, value, environment).\n      return this.InitializeBoundName(realm, name, value, environment);\n    } else {\n      invariant(node.type === \"VariableDeclaration\");\n      // ECMA262 13.7.5.9\n      for (let decl of ((node: any): BabelNodeVariableDeclaration).declarations) {\n        this.BindingInitialization(realm, decl.id, value, strictCode, environment);\n      }\n    }\n  }\n\n  // ECMA262 13.3.3.6\n  // ECMA262 14.1.19\n  IteratorBindingInitialization(\n    realm: Realm,\n    formals: $ReadOnlyArray<BabelNodeLVal | null>,\n    iteratorRecord: { $Iterator: ObjectValue, $Done: boolean },\n    strictCode: boolean,\n    environment: void | LexicalEnvironment\n  ): void {\n    let env = environment ? environment : realm.getRunningContext().lexicalEnvironment;\n\n    // Check if the last formal is a rest element. If so then we want to save the\n    // element and handle it separately after we iterate through the other\n    // formals. This also enforces that a rest element may only ever be in the\n    // last position.\n    let restEl;\n    if (formals.length > 0) {\n      let lastFormal = formals[formals.length - 1];\n      if (lastFormal !== null && lastFormal.type === \"RestElement\") {\n        restEl = lastFormal;\n        formals = formals.slice(0, -1);\n      }\n    }\n\n    for (let param of formals) {\n      if (param === null) {\n        // Elision handling in IteratorDestructuringAssignmentEvaluation\n\n        // 1. If iteratorRecord.[[Done]] is false, then\n        if (iteratorRecord.$Done === false) {\n          // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n          let next;\n          try {\n            next = IteratorStep(realm, iteratorRecord.$Iterator);\n          } catch (e) {\n            // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n            if (e instanceof AbruptCompletion) {\n              iteratorRecord.$Done = true;\n            }\n            // c. ReturnIfAbrupt(next).\n            throw e;\n          }\n          // d. If next is false, set iteratorRecord.[[Done]] to true.\n          if (next === false) {\n            iteratorRecord.$Done = true;\n          }\n        }\n        // 2. Return NormalCompletion(empty).\n        continue;\n      }\n\n      let Initializer;\n      if (param.type === \"AssignmentPattern\") {\n        Initializer = param.right;\n        param = param.left;\n      }\n\n      if (param.type === \"Identifier\") {\n        // SingleNameBinding : BindingIdentifier Initializer\n\n        // 1. Let bindingId be StringValue of BindingIdentifier.\n        let bindingId = param.name;\n\n        // 2. Let lhs be ? ResolveBinding(bindingId, environment).\n        let lhs = this.ResolveBinding(realm, param.name, strictCode, environment);\n\n        // Initialized later in the algorithm.\n        let v;\n\n        // 3. If iteratorRecord.[[Done]] is false, then\n        if (iteratorRecord.$Done === false) {\n          // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n          let next: ObjectValue | false;\n          try {\n            next = IteratorStep(realm, iteratorRecord.$Iterator);\n          } catch (e) {\n            // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n            if (e instanceof AbruptCompletion) {\n              iteratorRecord.$Done = true;\n            }\n            // c. ReturnIfAbrupt(next).\n            throw e;\n          }\n\n          // d. If next is false, set iteratorRecord.[[Done]] to true.\n          if (next === false) {\n            iteratorRecord.$Done = true;\n            // Normally this assignment would be done in step 4, but we do it\n            // here so that Flow knows `v` will always be initialized by step 5.\n            v = realm.intrinsics.undefined;\n          } else {\n            // e. Else,\n            // i. Let v be IteratorValue(next).\n            try {\n              v = IteratorValue(realm, next);\n            } catch (e) {\n              // ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.\n              if (e instanceof AbruptCompletion) {\n                iteratorRecord.$Done = true;\n              }\n              // iii. ReturnIfAbrupt(v).\n              throw e;\n            }\n          }\n        } else {\n          // 4. If iteratorRecord.[[Done]] is true, let v be undefined.\n          v = realm.intrinsics.undefined;\n        }\n\n        // 5. If Initializer is present and v is undefined, then\n        if (Initializer && v instanceof UndefinedValue) {\n          // a. Let defaultValue be the result of evaluating Initializer.\n          let defaultValue = env.evaluate(Initializer, strictCode);\n\n          // b. Let v be ? GetValue(defaultValue).\n          v = this.GetValue(realm, defaultValue);\n\n          // c. If IsAnonymousFunctionDefinition(Initializer) is true, then\n          if (IsAnonymousFunctionDefinition(realm, Initializer) && v instanceof ObjectValue) {\n            // i. Let hasNameProperty be ? HasOwnProperty(v, \"name\").\n            let hasNameProperty = HasOwnProperty(realm, v, \"name\");\n\n            // ii. If hasNameProperty is false, perform SetFunctionName(v, bindingId).\n            if (hasNameProperty === false) {\n              Functions.SetFunctionName(realm, v, bindingId);\n            }\n          }\n        }\n\n        // 6. If environment is undefined, return ? PutValue(lhs, v).\n        if (!environment) {\n          Properties.PutValue(realm, lhs, v);\n          continue;\n        }\n\n        // 7. Return InitializeReferencedBinding(lhs, v).\n        this.InitializeReferencedBinding(realm, lhs, v);\n        continue;\n      } else {\n        invariant(param.type === \"ObjectPattern\" || param.type === \"ArrayPattern\");\n        // BindingElement : BindingPatternInitializer\n\n        // Initialized later in the algorithm.\n        let v;\n\n        // 1. If iteratorRecord.[[Done]] is false, then\n        if (iteratorRecord.$Done === false) {\n          // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n          let next;\n          try {\n            next = IteratorStep(realm, iteratorRecord.$Iterator);\n          } catch (e) {\n            // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n            if (e instanceof AbruptCompletion) {\n              iteratorRecord.$Done = true;\n            }\n            // c. ReturnIfAbrupt(next).\n            throw e;\n          }\n\n          // d. If next is false, set iteratorRecord.[[Done]] to true.\n          if (next === false) {\n            iteratorRecord.$Done = true;\n            // Normally this assignment would be done in step 2, but we do it\n            // here so that Flow knows `v` will always be initialized by step 3.\n            v = realm.intrinsics.undefined;\n          } else {\n            // e. Else,\n            // i. Let v be IteratorValue(next).\n            try {\n              v = IteratorValue(realm, next);\n            } catch (e) {\n              // ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.\n              if (e instanceof AbruptCompletion) {\n                iteratorRecord.$Done = true;\n              }\n              // iii. ReturnIfAbrupt(v).\n              throw e;\n            }\n          }\n        } else {\n          // 2. If iteratorRecord.[[Done]] is true, let v be undefined.\n          v = realm.intrinsics.undefined;\n        }\n\n        // 3. If Initializer is present and v is undefined, then\n        if (Initializer && v instanceof UndefinedValue) {\n          // a. Let defaultValue be the result of evaluating Initializer.\n          let defaultValue = env.evaluate(Initializer, strictCode);\n\n          // b. Let v be ? GetValue(defaultValue).\n          v = this.GetValue(realm, defaultValue);\n        }\n\n        // 4. Return the result of performing BindingInitialization of BindingPattern with v and environment as the arguments.\n        this.BindingInitialization(realm, param, v, strictCode, environment);\n        continue;\n      }\n    }\n\n    // Handle the rest element if we have one.\n    if (restEl && restEl.argument.type === \"Identifier\") {\n      // BindingRestElement : ...BindingIdentifier\n\n      // 1. Let lhs be ? ResolveBinding(StringValue of BindingIdentifier, environment).\n      let lhs = this.ResolveBinding(realm, restEl.argument.name, strictCode, environment);\n\n      // 2. Let A be ArrayCreate(0).\n      let A = Create.ArrayCreate(realm, 0);\n\n      // 3. Let n be 0.\n      let n = 0;\n\n      // 4. Repeat,\n      while (true) {\n        // Initialized later in the algorithm.\n        let next: ObjectValue | false;\n\n        // a. If iteratorRecord.[[Done]] is false, then\n        if (iteratorRecord.$Done === false) {\n          // i. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n          try {\n            next = IteratorStep(realm, iteratorRecord.$Iterator);\n          } catch (e) {\n            // ii. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n            if (e instanceof AbruptCompletion) {\n              iteratorRecord.$Done = true;\n            }\n            // iii. ReturnIfAbrupt(next).\n            throw e;\n          }\n          // iv. If next is false, set iteratorRecord.[[Done]] to true.\n          if (next === false) {\n            iteratorRecord.$Done = true;\n          }\n        }\n\n        // b. If iteratorRecord.[[Done]] is true, then\n        if (iteratorRecord.$Done === true) {\n          // i. If environment is undefined, return ? PutValue(lhs, A).\n          if (!environment) {\n            Properties.PutValue(realm, lhs, A);\n            break;\n          }\n\n          // ii. Return InitializeReferencedBinding(lhs, A).\n          this.InitializeReferencedBinding(realm, lhs, A);\n          break;\n        }\n\n        // Given the nature of the algorithm this should always be true, however\n        // it is difficult to arrange the code in such a way where Flow's control\n        // flow analysis will pick that up, so we add an invariant here.\n        invariant(next instanceof ObjectValue);\n\n        // c. Let nextValue be IteratorValue(next).\n        let nextValue;\n        try {\n          nextValue = IteratorValue(realm, next);\n        } catch (e) {\n          // d. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // e. ReturnIfAbrupt(nextValue).\n          throw e;\n        }\n\n        // f. Let status be CreateDataProperty(A, ! To.ToString(n), nextValue).\n        let status = Create.CreateDataProperty(realm, A, n.toString(), nextValue);\n\n        // g. Assert: status is true.\n        invariant(status, \"expected to create data property\");\n\n        // h. Increment n by 1.\n        n += 1;\n      }\n    } else if (restEl) {\n      invariant(restEl.argument.type === \"ArrayPattern\" || restEl.argument.type === \"ObjectPattern\");\n      // 1. Let A be ArrayCreate(0).\n      let A = Create.ArrayCreate(realm, 0);\n\n      // 2. Let n be 0.\n      let n = 0;\n\n      // 3. Repeat,\n      while (true) {\n        // Initialized later in the algorithm.\n        let next;\n\n        // a. If iteratorRecord.[[Done]] is false, then\n        if (iteratorRecord.$Done === false) {\n          // i. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n          try {\n            next = IteratorStep(realm, iteratorRecord.$Iterator);\n          } catch (e) {\n            // ii. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n            if (e instanceof AbruptCompletion) {\n              iteratorRecord.$Done = true;\n            }\n            // iii. ReturnIfAbrupt(next).\n            throw e;\n          }\n          // iv. If next is false, set iteratorRecord.[[Done]] to true.\n          if (next === false) {\n            iteratorRecord.$Done = true;\n          }\n        }\n\n        // b. If iteratorRecord.[[Done]] is true, then\n        if (iteratorRecord.$Done === true) {\n          // i. Return the result of performing BindingInitialization of BindingPattern with A and environment as the arguments.\n          this.BindingInitialization(realm, restEl.argument, A, strictCode, environment);\n          break;\n        }\n\n        // Given the nature of the algorithm this should always be true, however\n        // it is difficult to arrange the code in such a way where Flow's control\n        // flow analysis will pick that up, so we add an invariant here.\n        invariant(next instanceof ObjectValue);\n\n        // c. Let nextValue be IteratorValue(next).\n        let nextValue;\n        try {\n          nextValue = IteratorValue(realm, next);\n        } catch (e) {\n          // d. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // e. ReturnIfAbrupt(nextValue).\n          throw e;\n        }\n\n        // f. Let status be CreateDataProperty(A, ! To.ToString(n), nextValue).\n        let status = Create.CreateDataProperty(realm, A, n.toString(), nextValue);\n\n        // g. Assert: status is true.\n        invariant(status, \"expected to create data property\");\n\n        // h. Increment n by 1.\n        n += 1;\n      }\n    }\n  }\n\n  // ECMA262 12.1.5.1\n  InitializeBoundName(\n    realm: Realm,\n    name: string,\n    value: Value,\n    environment: void | LexicalEnvironment\n  ): void | boolean | Value {\n    // 1. Assert: Type(name) is String.\n    invariant(typeof name === \"string\", \"expected name to be a string\");\n\n    // 2. If environment is not undefined, then\n    if (environment) {\n      // a. Let env be the EnvironmentRecord component of environment.\n      let env = environment.environmentRecord;\n\n      // b. Perform env.InitializeBinding(name, value).\n      env.InitializeBinding(name, value);\n\n      // c. Return NormalCompletion(undefined).\n      return realm.intrinsics.undefined;\n    } else {\n      // 3. Else,\n      // a. Let lhs be ResolveBinding(name).\n      // Note that the undefined environment implies non-strict.\n      let lhs = this.ResolveBinding(realm, name, false);\n\n      // b. Return ? PutValue(lhs, value).\n      return Properties.PutValue(realm, lhs, value);\n    }\n  }\n\n  // ECMA262 12.3.1.3 and 13.7.5.6\n  IsDestructuring(ast: BabelNode): boolean {\n    switch (ast.type) {\n      case \"VariableDeclaration\":\n        for (let decl of ((ast: any): BabelNodeVariableDeclaration).declarations) {\n          switch (decl.type) {\n            case \"VariableDeclarator\":\n              switch (decl.id.type) {\n                case \"ArrayPattern\":\n                case \"AssignmentPattern\":\n                case \"ObjectPattern\":\n                  return true;\n                default:\n                  break;\n              }\n              break;\n            default:\n              break;\n          }\n        }\n        return false;\n      case \"ArrayLiteral\":\n      case \"ObjectLiteral\":\n        return true;\n      case \"ArrayPattern\":\n      case \"ObjectPattern\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // ECMA262 13.3.3.7\n  KeyedBindingInitialization(\n    realm: Realm,\n    node: BabelNodeIdentifier | BabelNodePattern,\n    value: Value,\n    strictCode: boolean,\n    environment: ?LexicalEnvironment,\n    propertyName: PropertyKeyValue\n  ): void | boolean | Value {\n    let env = environment ? environment : realm.getRunningContext().lexicalEnvironment;\n\n    let Initializer;\n    if (node.type === \"AssignmentPattern\") {\n      Initializer = node.right;\n      node = node.left;\n    }\n\n    if (node.type === \"Identifier\") {\n      // SingleNameBinding : BindingIdentifier Initializer\n\n      // 1. Let bindingId be StringValue of BindingIdentifier.\n      let bindingId = node.name;\n\n      // 2. Let lhs be ? ResolveBinding(bindingId, environment).\n      let lhs = this.ResolveBinding(realm, bindingId, strictCode, environment);\n\n      // 3. Let v be ? GetV(value, propertyName).\n      let v = GetV(realm, value, propertyName);\n\n      // 4. If Initializer is present and v is undefined, then\n      if (Initializer && v instanceof UndefinedValue) {\n        // a. Let defaultValue be the result of evaluating Initializer.\n        let defaultValue = env.evaluate(Initializer, strictCode);\n\n        // b. Let v be ? GetValue(defaultValue).\n        v = this.GetValue(realm, defaultValue);\n\n        // c. If IsAnonymousFunctionDefinition(Initializer) is true, then\n        if (IsAnonymousFunctionDefinition(realm, Initializer) && v instanceof ObjectValue) {\n          // i. Let hasNameProperty be ? HasOwnProperty(v, \"name\").\n          let hasNameProperty = HasOwnProperty(realm, v, \"name\");\n          // ii. If hasNameProperty is false, perform SetFunctionName(v, bindingId).\n          if (hasNameProperty === false) {\n            Functions.SetFunctionName(realm, v, bindingId);\n          }\n        }\n      }\n\n      // 5. If environment is undefined, return ? PutValue(lhs, v).\n      if (!environment) return Properties.PutValue(realm, lhs, v);\n\n      // 6. Return InitializeReferencedBinding(lhs, v).\n      return this.InitializeReferencedBinding(realm, lhs, v);\n    } else if (node.type === \"ObjectPattern\" || node.type === \"ArrayPattern\") {\n      // BindingElement : BindingPattern Initializer\n\n      // 1. Let v be ? GetV(value, propertyName).\n      let v = GetV(realm, value, propertyName);\n\n      // 2. If Initializer is present and v is undefined, then\n      if (Initializer && v instanceof UndefinedValue) {\n        // a. Let defaultValue be the result of evaluating Initializer.\n        let defaultValue = env.evaluate(Initializer, strictCode);\n\n        // b. Let v be ? GetValue(defaultValue).\n        v = this.GetValue(realm, defaultValue);\n      }\n\n      // 3. Return the result of performing BindingInitialization for BindingPattern passing v and environment as arguments.\n      return this.BindingInitialization(realm, node, v, strictCode, env);\n    }\n  }\n}\n"],"file":"environment.js"}