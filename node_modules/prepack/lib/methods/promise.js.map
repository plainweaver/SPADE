{"version":3,"sources":["../../src/methods/promise.js"],"names":["EnqueueJob","realm","queueName","job","args","NewPromiseCapability","C","createErrorThrowCompletion","intrinsics","TypeError","ObjectValue","promiseCapability","promise","undefined","resolve","reject","executor","NativeFunctionValue","context","$Capability","mightBeUndefined","throwIfNotConcrete","throwIfNotConcreteObject","createResolveElementFunction","resolveElement","x","alreadyCalled","$AlreadyCalled","value","myIndex","$Index","values","$Values","Array","$Capabilities","remainingElementsCount","$RemainingElements","valuesArray","Create","CreateArrayFromList","PerformPromiseAll","iteratorRecord","constructor","resultCapability","FunctionValue","index","next","$Iterator","e","AbruptCompletion","$Done","nextValue","push","nextPromise","PerformPromiseRace","PerformPromiseThen","onFulfilled","onRejected","StringValue","fulfillReaction","capabilities","handler","rejectReaction","$PromiseState","Properties","ThrowIfInternalSlotNotWritable","$PromiseFulfillReactions","$PromiseRejectReactions","$PromiseResult","PromiseReactionJob","reason","$PromiseIsHandled","HostPromiseRejectionTracker","reaction","argument","createResolveFunction","resolution","$Promise","alreadyResolved","$AlreadyResolved","selfResolutionError","RejectPromise","FulfillPromise","then","thenAction","PromiseResolveThenableJob","createRejectFunction","CreateResolvingFunctions","reactions","TriggerPromiseReactions","operation","promiseToResolve","thenable"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { ResolvingFunctions, PromiseCapability, PromiseReaction } from \"../types.js\";\nimport { AbruptCompletion } from \"../completions.js\";\nimport {\n  Value,\n  ObjectValue,\n  StringValue,\n  NativeFunctionValue,\n  FunctionValue,\n  type UndefinedValue,\n} from \"../values/index.js\";\nimport { SameValue } from \"./abstract.js\";\nimport { Construct } from \"./construct.js\";\nimport { Get } from \"./get.js\";\nimport { Invoke, Call } from \"./call.js\";\nimport { IsCallable, IsConstructor, IsPromise } from \"./is.js\";\nimport { IteratorStep, IteratorValue } from \"./iterator.js\";\nimport { Create, Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\n\n// ECMA262 8.4.1\nexport function EnqueueJob(realm: Realm, queueName: string, job: Function, args: Array<any>): void {}\n\n// ECMA262 25.4.1.5\nexport function NewPromiseCapability(realm: Realm, C: Value): PromiseCapability {\n  // 1. If IsConstructor(C) is false, throw a TypeError exception.\n  if (IsConstructor(realm, C) === false) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"IsConstructor(C) is false\");\n  }\n  invariant(C instanceof ObjectValue);\n\n  // 2. NOTE C is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see 25.4.3.1).\n\n  // 3. Let promiseCapability be a new PromiseCapability { [[Promise]]: undefined, [[Resolve]]: undefined, [[Reject]]: undefined }.\n  let promiseCapability = {\n    promise: realm.intrinsics.undefined,\n    resolve: realm.intrinsics.undefined,\n    reject: realm.intrinsics.undefined,\n  };\n\n  // 4. Let executor be a new built-in function object as defined in GetCapabilitiesExecutor Functions (25.4.1.5.1).\n  let executor = new NativeFunctionValue(\n    realm,\n    undefined,\n    undefined,\n    2,\n    (context, [resolve, reject]) => {\n      // 1. Assert: F has a [[Capability]] internal slot whose value is a PromiseCapability Record.\n      invariant(executor.$Capability, \"F has a [[Capability]] internal slot whose value is a PromiseCapability Record\");\n\n      // 2. Let promiseCapability be the value of F's [[Capability]] internal slot.\n      invariant(promiseCapability === executor.$Capability);\n\n      // 3. If promiseCapability.[[Resolve]] is not undefined, throw a TypeError exception.\n      if (!promiseCapability.resolve.mightBeUndefined()) {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"promiseCapability.[[Resolve]] is not undefined\"\n        );\n      }\n      promiseCapability.resolve.throwIfNotConcrete();\n\n      // 4. If promiseCapability.[[Reject]] is not undefined, throw a TypeError exception.\n      if (!promiseCapability.reject.mightBeUndefined()) {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"promiseCapability.[[Reject]] is not undefined\"\n        );\n      }\n      promiseCapability.reject.throwIfNotConcrete();\n\n      // 5. Set promiseCapability.[[Resolve]] to resolve.\n      promiseCapability.resolve = resolve;\n\n      // 6. Set promiseCapability.[[Reject]] to reject.\n      promiseCapability.reject = reject;\n\n      // 7. Return undefined.\n      return realm.intrinsics.undefined;\n    },\n    false\n  );\n\n  // 5. Set the [[Capability]] internal slot of executor to promiseCapability.\n  executor.$Capability = promiseCapability;\n\n  // 6. Let promise be ? Construct(C, « executor »).\n  let promise = Construct(realm, C, [executor]).throwIfNotConcreteObject();\n\n  // 7. If IsCallable(promiseCapability.[[Resolve]]) is false, throw a TypeError exception.\n  if (IsCallable(realm, promiseCapability.resolve) === false) {\n    throw realm.createErrorThrowCompletion(\n      realm.intrinsics.TypeError,\n      \"IsCallable(promiseCapability.[[Resolve]]) is false\"\n    );\n  }\n\n  // 8. If IsCallable(promiseCapability.[[Reject]]) is false, throw a TypeError exception.\n  if (IsCallable(realm, promiseCapability.reject) === false) {\n    throw realm.createErrorThrowCompletion(\n      realm.intrinsics.TypeError,\n      \"IsCallable(promiseCapability.[[Reject]]) is false\"\n    );\n  }\n\n  // 9. Set promiseCapability.[[Promise]] to promise.\n  promiseCapability.promise = promise;\n\n  // 10. Return promiseCapability.\n  return promiseCapability;\n}\n\n// ECMA262 25.4.4.1.1j\nfunction createResolveElementFunction(realm) {\n  let resolveElement = new NativeFunctionValue(\n    realm,\n    undefined,\n    undefined,\n    1,\n    (context, [x]) => {\n      // 1. Let alreadyCalled be the value of F's [[AlreadyCalled]] internal slot.\n      let alreadyCalled = resolveElement.$AlreadyCalled;\n      invariant(alreadyCalled);\n\n      // 2. If alreadyCalled.[[Value]] is true, return undefined.\n      if (alreadyCalled.value === true) {\n        return realm.intrinsics.undefined;\n      }\n\n      // 3. Set alreadyCalled.[[Value]] to true.\n      alreadyCalled.value = true;\n\n      // 4. Let index be the value of F's [[Index]] internal slot.\n      let myIndex = resolveElement.$Index;\n      invariant(typeof myIndex === \"number\");\n\n      // 5. Let values be the value of F's [[Values]] internal slot.\n      let values = resolveElement.$Values;\n      invariant(values instanceof Array);\n\n      // 6. Let promiseCapability be the value of F's [[Capabilities]] internal slot.\n      let promiseCapability = resolveElement.$Capabilities;\n      invariant(promiseCapability);\n\n      // 7. Let remainingElementsCount be the value of F's [[RemainingElements]] internal slot.\n      let remainingElementsCount = resolveElement.$RemainingElements;\n      invariant(remainingElementsCount);\n\n      // 8. Set values[index] to x.\n      values[myIndex] = x;\n\n      // 9. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.\n      remainingElementsCount.value = remainingElementsCount.value - 1;\n\n      // 10. If remainingElementsCount.[[Value]] is 0, then\n      if (remainingElementsCount.value === 0) {\n        // a. Let valuesArray be CreateArrayFromList(values).\n        let valuesArray = Create.CreateArrayFromList(realm, values);\n\n        // b. Return ? Call(promiseCapability.[[Resolve]], undefined, « valuesArray »).\n        Call(realm, promiseCapability.resolve, realm.intrinsics.undefined, [valuesArray]);\n      }\n\n      // 11. Return undefined.\n      return realm.intrinsics.undefined;\n    },\n    false\n  );\n  return resolveElement;\n}\n\n// ECMA262 25.4.4.1.1\nexport function PerformPromiseAll(\n  realm: Realm,\n  iteratorRecord: { $Iterator: ObjectValue, $Done: boolean },\n  constructor: FunctionValue,\n  resultCapability: PromiseCapability\n): Value {\n  // 1. Assert: constructor is a constructor function.\n  invariant(\n    constructor instanceof FunctionValue && IsConstructor(realm, constructor),\n    \"constructor is a constructor function\"\n  );\n\n  // 2. Assert: resultCapability is a PromiseCapability record.\n  resultCapability;\n\n  // 3. Let values be a new empty List.\n  let values = [];\n\n  // 4. Let remainingElementsCount be a new Record { [[Value]]: 1 }.\n  let remainingElementsCount = { value: 1 };\n\n  // 5. Let index be 0.\n  let index = 0;\n\n  // 6. Repeat\n  while (true) {\n    // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n    let next;\n    try {\n      next = IteratorStep(realm, iteratorRecord.$Iterator);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        iteratorRecord.$Done = true;\n      }\n\n      // c. ReturnIfAbrupt(next).\n      throw e;\n    }\n\n    // d. If next is false, then\n    if (next === false) {\n      // i. Set iteratorRecord.[[Done]] to true.\n      iteratorRecord.$Done = true;\n\n      // ii. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.\n      remainingElementsCount.value = remainingElementsCount.value - 1;\n\n      // iii. If remainingElementsCount.[[Value]] is 0, then\n      if (remainingElementsCount.value === 0) {\n        // 1. Let valuesArray be CreateArrayFromList(values).\n        let valuesArray = Create.CreateArrayFromList(realm, values);\n\n        // 2. Perform ? Call(resultCapability.[[Resolve]], undefined, « valuesArray »).\n        Call(realm, resultCapability.resolve, realm.intrinsics.undefined, [valuesArray]);\n      }\n\n      // iv. Return resultCapability.[[Promise]].\n      return resultCapability.promise;\n    }\n\n    // e. Let nextValue be IteratorValue(next).\n    let nextValue;\n    try {\n      nextValue = IteratorValue(realm, next);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        // f. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        iteratorRecord.$Done = true;\n      }\n\n      // g. ReturnIfAbrupt(nextValue).\n      throw e;\n    }\n\n    // h. Append undefined to values.\n    values.push(realm.intrinsics.undefined);\n\n    // i. Let nextPromise be ? Invoke(constructor, \"resolve\", « nextValue »).\n    let nextPromise = Invoke(realm, constructor, \"resolve\", [nextValue]);\n\n    // j. Let resolveElement be a new built-in function object as defined in Promise.all Resolve Element Functions.\n    let resolveElement = createResolveElementFunction(realm);\n\n    // k. Set the [[AlreadyCalled]] internal slot of resolveElement to a new Record {[[Value]]: false }.\n    resolveElement.$AlreadyCalled = { value: false };\n\n    // l. Set the [[Index]] internal slot of resolveElement to index.\n    resolveElement.$Index = index;\n\n    // m. Set the [[Values]] internal slot of resolveElement to values.\n    resolveElement.$Values = values;\n\n    // n. Set the [[Capabilities]] internal slot of resolveElement to resultCapability.\n    resolveElement.$Capabilities = resultCapability;\n\n    // o. Set the [[RemainingElements]] internal slot of resolveElement to remainingElementsCount.\n    resolveElement.$RemainingElements = remainingElementsCount;\n\n    // p. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] + 1.\n    remainingElementsCount.value = remainingElementsCount.value + 1;\n\n    // q. Perform ? Invoke(nextPromise, \"then\", « resolveElement, resultCapability.[[Reject]] »).\n    Invoke(realm, nextPromise, \"then\", [resolveElement, resultCapability.reject]);\n\n    // r. Set index to index + 1.\n    index = index + 1;\n  }\n  invariant(false);\n}\n\n// ECMA262 25.4.4.3.1\nexport function PerformPromiseRace(\n  realm: Realm,\n  iteratorRecord: { $Iterator: ObjectValue, $Done: boolean },\n  resultCapability: PromiseCapability,\n  C: ObjectValue\n): ObjectValue {\n  // 1. Assert: constructor is a constructor function.\n  invariant(IsConstructor(realm, C), \"constructor is a constructor function\");\n\n  // 2. Assert: resultCapability is a PromiseCapability Record.\n  resultCapability;\n\n  // 3. Repeat\n  while (true) {\n    // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n    let next;\n    try {\n      next = IteratorStep(realm, iteratorRecord.$Iterator);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        iteratorRecord.$Done = true;\n      }\n\n      // c. ReturnIfAbrupt(next).\n      throw e;\n    }\n\n    // d. If next is false, then\n    if (next === false) {\n      // i. Set iteratorRecord.[[Done]] to true.\n      iteratorRecord.$Done = true;\n\n      // ii. Return resultCapability.[[Promise]].\n      invariant(resultCapability.promise instanceof ObjectValue);\n      return resultCapability.promise;\n    }\n\n    // e. Let nextValue be IteratorValue(next).\n    let nextValue;\n    try {\n      nextValue = IteratorValue(realm, next);\n    } catch (e) {\n      if (e instanceof AbruptCompletion) {\n        // f. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        iteratorRecord.$Done = true;\n      }\n\n      // g. ReturnIfAbrupt(nextValue).\n      throw e;\n    }\n\n    // h. Let nextPromise be ? Invoke(C, \"resolve\", « nextValue »).\n    let nextPromise = Invoke(realm, C, \"resolve\", [nextValue]);\n\n    // i. Perform ? Invoke(nextPromise, \"then\", « resultCapability.[[Resolve]], resultCapability.[[Reject]] »).\n    Invoke(realm, nextPromise, \"then\", [resultCapability.resolve, resultCapability.reject]);\n  }\n  invariant(false);\n}\n\n// ECMA262 25.4.5.3.1\nexport function PerformPromiseThen(\n  realm: Realm,\n  promise: ObjectValue,\n  onFulfilled: Value,\n  onRejected: Value,\n  resultCapability: PromiseCapability\n): ObjectValue {\n  // 1. Assert: IsPromise(promise) is true.\n  invariant(IsPromise(realm, promise), \"IsPromise(promise) is true\");\n\n  // 2. Assert: resultCapability is a PromiseCapability record.\n  resultCapability;\n\n  // 3. If IsCallable(onFulfilled) is false, then\n  if (IsCallable(realm, onFulfilled) === false) {\n    // a. Let onFulfilled be \"Identity\".\n    onFulfilled = new StringValue(realm, \"Identity\");\n  }\n\n  // 4. If IsCallable(onRejected) is false, then\n  if (IsCallable(realm, onRejected)) {\n    // a. Let onRejected be \"Thrower\".\n    onRejected = new StringValue(realm, \"Thrower\");\n  }\n\n  // 5. Let fulfillReaction be the PromiseReaction { [[Capabilities]]: resultCapability, [[Handler]]: onFulfilled }.\n  let fulfillReaction = { capabilities: resultCapability, handler: onFulfilled };\n\n  // 6. Let rejectReaction be the PromiseReaction { [[Capabilities]]: resultCapability, [[Handler]]: onRejected}.\n  let rejectReaction = { capabilities: resultCapability, handler: onRejected };\n\n  // 7. If the value of promise's [[PromiseState]] internal slot is \"pending\", then\n  if (promise.$PromiseState === \"pending\") {\n    // a. Append fulfillReaction as the last element of the List that is the value of promise's [[PromiseFulfillReactions]] internal slot.\n    Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseFulfillReactions\");\n    invariant(promise.$PromiseFulfillReactions);\n    promise.$PromiseFulfillReactions.push(fulfillReaction);\n    // b. Append rejectReaction as the last element of the List that is the value of promise's [[PromiseRejectReactions]] internal slot.\n    Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseRejectReactions\");\n    invariant(promise.$PromiseRejectReactions);\n    promise.$PromiseRejectReactions.push(rejectReaction);\n  } else if (promise.$PromiseState === \"fulfilled\") {\n    // 8. Else if the value of promise's [[PromiseState]] internal slot is \"fulfilled\", then\n    // a. Let value be the value of promise's [[PromiseResult]] internal slot.\n    let value = promise.$PromiseResult;\n    // b. Perform EnqueueJob(\"PromiseJobs\", PromiseReactionJob, « fulfillReaction, value »).\n    EnqueueJob(realm, \"PromiseJobs\", PromiseReactionJob, [fulfillReaction, value]);\n  } else {\n    // 9. Else,\n    // a. Assert: The value of promise's [[PromiseState]] internal slot is \"rejected\".\n    invariant(promise.$PromiseState === \"rejected\");\n\n    // b. Let reason be the value of promise's [[PromiseResult]] internal slot.\n    let reason = promise.$PromiseResult;\n\n    // c. If the value of promise's [[PromiseIsHandled]] internal slot is false, perform HostPromiseRejectionTracker(promise, \"handle\").\n    if (promise.$PromiseIsHandled === false) HostPromiseRejectionTracker(realm, promise, \"handle\");\n\n    // d. Perform EnqueueJob(\"PromiseJobs\", PromiseReactionJob, « rejectReaction, reason »).\n    EnqueueJob(realm, \"PromiseJobs\", PromiseReactionJob, [rejectReaction, reason]);\n  }\n\n  // 10. Set promise's [[PromiseIsHandled]] internal slot to true.\n  Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseIsHandled\").$PromiseIsHandled = true;\n\n  // 11. Return resultCapability.[[Promise]].\n  invariant(resultCapability.promise instanceof ObjectValue);\n  return resultCapability.promise;\n}\n\n// ECMA262 25.4.2.1\nexport function PromiseReactionJob(realm: Realm, reaction: Function, argument: Value): Value {\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 25.4.1.3.2\nfunction createResolveFunction(realm) {\n  // 2. Let resolve be a new built-in function object as defined in Promise Resolve Functions (25.4.1.3.2).\n  let resolve = new NativeFunctionValue(\n    realm,\n    undefined,\n    undefined,\n    1,\n    (context, [resolution]) => {\n      // 1. Assert: F has a [[Promise]] internal slot whose value is an Object.\n      invariant(resolve.$Promise instanceof ObjectValue, \"F has a [[Promise]] internal slot whose value is an Object\");\n\n      // 2. Let promise be the value of F's [[Promise]] internal slot.\n      let promise = resolve.$Promise;\n\n      // 3. Let alreadyResolved be the value of F's [[AlreadyResolved]] internal slot.\n      let alreadyResolved = resolve.$AlreadyResolved;\n      invariant(alreadyResolved !== undefined);\n\n      // 4. If alreadyResolved.[[Value]] is true, return undefined.\n      if (alreadyResolved.value === true) return realm.intrinsics.undefined;\n\n      // 5. Set alreadyResolved.[[Value]] to true.\n      alreadyResolved.value = true;\n\n      // 6. If SameValue(resolution, promise) is true, then\n      if (SameValue(realm, resolution.throwIfNotConcrete(), promise)) {\n        // a. Let selfResolutionError be a newly created TypeError object.\n        let selfResolutionError = Construct(realm, realm.intrinsics.TypeError, [new StringValue(realm, \"resolve\")]);\n\n        // b. Return RejectPromise(promise, selfResolutionError).\n        return RejectPromise(realm, promise, selfResolutionError);\n      }\n      // 7. If Type(resolution) is not Object, then\n      if (!(resolution instanceof ObjectValue)) {\n        // a. Return FulfillPromise(promise, resolution).\n        return FulfillPromise(realm, promise, resolution);\n      }\n\n      // 8. Let then be Get(resolution, \"then\").\n      let then;\n      try {\n        then = Get(realm, resolution, \"then\");\n      } catch (e) {\n        // 9. If then is an abrupt completion, then\n        if (e instanceof AbruptCompletion) {\n          // a. Return RejectPromise(promise, then.[[Value]]).\n          return RejectPromise(realm, promise, e);\n        } else throw e;\n      }\n\n      // 10. Let thenAction be then.[[Value]].\n      let thenAction = then;\n\n      // 11. If IsCallable(thenAction) is false, then\n      if (IsCallable(realm, thenAction)) {\n        // a. Return FulfillPromise(promise, resolution).\n        return FulfillPromise(realm, promise, resolution);\n      }\n\n      // 12. Perform EnqueueJob(\"PromiseJobs\", PromiseResolveThenableJob, « promise, resolution, thenAction »).\n      EnqueueJob(realm, \"PromiseJobs\", PromiseResolveThenableJob, [promise, resolution, thenAction]);\n\n      // 13. Return undefined.\n      return realm.intrinsics.undefined;\n    },\n    false\n  );\n  return resolve;\n}\n\n// ECMA262 25.4.1.3.1\nfunction createRejectFunction(realm) {\n  // 5. Let reject be a new built-in function object as defined in Promise Reject Functions (25.4.1.3.1).\n  let reject = new NativeFunctionValue(\n    realm,\n    undefined,\n    undefined,\n    1,\n    (context, [reason]) => {\n      // 1. Assert: F has a [[Promise]] internal slot whose value is an Object.\n      invariant(reject.$Promise instanceof ObjectValue, \"F has a [[Promise]] internal slot whose value is an Object\");\n\n      // 2. Let promise be the value of F's [[Promise]] internal slot.\n      let promise = reject.$Promise;\n\n      // 3. Let alreadyResolved be the value of F's [[AlreadyResolved]] internal slot.\n      let alreadyResolved = reject.$AlreadyResolved;\n      invariant(alreadyResolved !== undefined);\n\n      // 4. If alreadyResolved.[[Value]] is true, return undefined.\n      if (alreadyResolved.value === true) return realm.intrinsics.undefined;\n\n      // 5. Set alreadyResolved.[[Value]] to true.\n      alreadyResolved.value = true;\n\n      // 6. Return RejectPromise(promise, reason).\n      return RejectPromise(realm, promise, reason);\n    },\n    false\n  );\n  return reject;\n}\n\n// ECMA262 25.4.1.3\nexport function CreateResolvingFunctions(realm: Realm, promise: ObjectValue): ResolvingFunctions {\n  // 1. Let alreadyResolved be a new Record { [[Value]]: false }.\n  let alreadyResolved = { value: false };\n\n  // 2. Let resolve be a new built-in function object as defined in Promise Resolve Functions (25.4.1.3.2).\n  let resolve = createResolveFunction(realm);\n\n  // 3. Set the [[Promise]] internal slot of resolve to promise.\n  resolve.$Promise = promise;\n\n  // 4. Set the [[AlreadyResolved]] internal slot of resolve to alreadyResolved.\n  resolve.$AlreadyResolved = alreadyResolved;\n\n  // 5. Let reject be a new built-in function object as defined in Promise Reject Functions (25.4.1.3.1).\n  let reject = createRejectFunction(realm);\n\n  // 6. Set the [[Promise]] internal slot of reject to promise.\n  reject.$Promise = promise;\n\n  // 7. Set the [[AlreadyResolved]] internal slot of reject to alreadyResolved.\n  reject.$AlreadyResolved = alreadyResolved;\n\n  // 8. Return a new Record { [[Resolve]]: resolve, [[Reject]]: reject }.\n  return { resolve: resolve, reject: reject };\n}\n\n// ECMA262 25.4.1.4\nexport function FulfillPromise(realm: Realm, promise: ObjectValue, value: Value): Value {\n  // 1. Assert: The value of promise.[[PromiseState]] is \"pending\".\n  invariant(promise.$PromiseState === \"pending\");\n\n  // 2. Let reactions be promise.[[PromiseFulfillReactions]].\n  let reactions = promise.$PromiseFulfillReactions;\n  invariant(reactions);\n\n  // 3. Set promise.[[PromiseResult]] to value.\n  Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseResult\").$PromiseResult = value;\n\n  // 4. Set promise.[[PromiseFulfillReactions]] to undefined.\n  Properties.ThrowIfInternalSlotNotWritable(\n    realm,\n    promise,\n    \"$PromiseFulfillReactions\"\n  ).$PromiseFulfillReactions = undefined;\n\n  // 5. Set promise.[[PromiseRejectReactions]] to undefined.\n  Properties.ThrowIfInternalSlotNotWritable(\n    realm,\n    promise,\n    \"$PromiseRejectReactions\"\n  ).$PromiseRejectReactions = undefined;\n\n  // 6. Set promise.[[PromiseState]] to \"fulfilled\".\n  Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseState\").$PromiseState = \"fulfilled\";\n\n  // 7. Return TriggerPromiseReactions(reactions, value).\n  return TriggerPromiseReactions(realm, reactions, value);\n}\n\n// ECMA262 25.4.1.7\nexport function RejectPromise(realm: Realm, promise: ObjectValue, reason: Value): Value {\n  // 1. Assert: The value of promise.[[PromiseState]] is \"pending\".\n  invariant(promise.$PromiseState === \"pending\");\n\n  // 2. Let reactions be promise.[[PromiseRejectReactions]].\n  let reactions = promise.$PromiseFulfillReactions;\n  invariant(reactions);\n\n  // 3. Set promise.[[PromiseResult]] to reason.\n  Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseResult\").$PromiseResult = reason;\n\n  // 4. Set promise.[[PromiseFulfillReactions]] to undefined.\n  Properties.ThrowIfInternalSlotNotWritable(\n    realm,\n    promise,\n    \"$PromiseFulfillReactions\"\n  ).$PromiseFulfillReactions = undefined;\n\n  // 5. Set promise.[[PromiseRejectReactions]] to undefined.\n  Properties.ThrowIfInternalSlotNotWritable(\n    realm,\n    promise,\n    \"$PromiseRejectReactions\"\n  ).$PromiseRejectReactions = undefined;\n\n  // 6. Set promise.[[PromiseState]] to \"rejected\".\n  Properties.ThrowIfInternalSlotNotWritable(realm, promise, \"$PromiseState\").$PromiseState = \"rejected\";\n\n  // 7. If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, \"reject\").\n  if (promise.$PromiseIsHandled === false) HostPromiseRejectionTracker(realm, promise, \"reject\");\n\n  // 8. Return TriggerPromiseReactions(reactions, reason).\n  return TriggerPromiseReactions(realm, reactions, reason);\n}\n\n// ECMA262 25.4.1.8\nexport function TriggerPromiseReactions(\n  realm: Realm,\n  reactions: Array<PromiseReaction>,\n  argument: Value\n): UndefinedValue {\n  // 1. Repeat for each reaction in reactions, in original insertion order\n  for (let reaction of reactions) {\n    // a. Perform EnqueueJob(\"PromiseJobs\", PromiseReactionJob, « reaction, argument »).\n    EnqueueJob(realm, \"PromiseJobs\", PromiseReactionJob, [reaction, argument]);\n  }\n  // 2. Return undefined.\n  return realm.intrinsics.undefined;\n}\n\n// ECMA262 25.4.1.9\nexport function HostPromiseRejectionTracker(realm: Realm, promise: ObjectValue, operation: \"reject\" | \"handle\"): void {}\n\n// ECMA262 25.4.2.2\nexport function PromiseResolveThenableJob(\n  realm: Realm,\n  promiseToResolve: ObjectValue,\n  thenable: Value,\n  then: Value\n): void {}\n"],"file":"promise.js"}