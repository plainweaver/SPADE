{"version":3,"sources":["../../src/methods/generator.js"],"names":["GeneratorStart","realm","generator","generatorBody","isNewObject","ObjectValue","$GeneratorState","undefined","genContext","getRunningContext","$GeneratorContext","intrinsics","GeneratorValidate","createErrorThrowCompletion","SyntaxError","state","GeneratorResume","value","Create","CreateIterResultObject","methodContext","suspend","Properties","ThrowIfInternalSlotNotWritable","pushContext","result","resume","GeneratorResumeAbrupt","abruptCompletion","GeneratorYield","iterNextObj"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Realm } from \"../realm.js\";\nimport { AbruptCompletion } from \"../completions.js\";\nimport { Value, ObjectValue, UndefinedValue } from \"../values/index.js\";\nimport { Create, Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeBlockStatement } from \"@babel/types\";\n\n// ECMA26225.3.3.1\nexport function GeneratorStart(\n  realm: Realm,\n  generator: ObjectValue,\n  generatorBody: BabelNodeBlockStatement\n): UndefinedValue {\n  // Note that generator is a new object, and we can thus write to internal slots\n  invariant(realm.isNewObject(generator));\n\n  // 1. Assert: The value of generator.[[GeneratorState]] is undefined.\n  invariant(\n    generator instanceof ObjectValue && generator.$GeneratorState === undefined,\n    \"The value of generator.[[GeneratorState]] is undefined\"\n  );\n\n  // 2. Let genContext be the running execution context.\n  let genContext = realm.getRunningContext();\n\n  // 3. Set the Generator component of genContext to generator.\n\n  // 4. Set the code evaluation state of genContext such that when evaluation is resumed for that execution context the following steps will be performed:\n  // a. Let result be the result of evaluating generatorBody.\n  // b. Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.\n  // c. Remove genContext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n  // d. Set generator.[[GeneratorState]] to \"completed\".\n  // e. Once a generator enters the \"completed\" state it never leaves it and its associated execution context is never resumed. Any execution state associated with generator can be discarded at this point.\n  // f. If result is a normal completion, let resultValue be undefined.\n  // g. Else,\n  // i. If result.[[Type]] is return, let resultValue be result.[[Value]].\n  // ii. Else, return Completion(result).\n  // h. Return CreateIterResultObject(resultValue, true).\n\n  // 5. Set generator.[[GeneratorContext]] to genContext.\n  generator.$GeneratorContext = genContext;\n\n  // 6. Set generator.[[GeneratorState]] to \"suspendedStart\".\n  generator.$GeneratorState = \"suspendedStart\";\n\n  // 7. Return NormalCompletion(undefined).\n  return realm.intrinsics.undefined;\n}\n\n// ECMA26225.3.3.2\nexport function GeneratorValidate(realm: Realm, generator: Value): void | \"suspendedStart\" {\n  // 1. If Type(generator) is not Object, throw a TypeError exception.\n  if (!(generator instanceof ObjectValue)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"Type(generator) is not Object\");\n  }\n\n  // 2. If generator does not have a [[GeneratorState]] internal slot, throw a TypeError exception.\n  if (!(\"$GeneratorState\" in generator)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"Type(generator) is not Object\");\n  }\n\n  // 3. Assert: generator also has a [[GeneratorContext]] internal slot.\n  invariant(\"$GeneratorContext\" in generator);\n\n  // 4. Let state be generator.[[GeneratorState]].\n  let state = generator.$GeneratorState;\n\n  // 5. If state is \"executing\", throw a TypeError exception.\n  if (state === \"executing\") {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"Type(generator) is not Object\");\n  }\n\n  // 6. Return state.\n  return state;\n}\n\n// ECMA26225.3.3.3\nexport function GeneratorResume(realm: Realm, generator: Value, value: Value): Value {\n  // 1. Let state be ? GeneratorValidate(generator).\n  let state = GeneratorValidate(realm, generator);\n  invariant(generator instanceof ObjectValue);\n\n  // 2. If state is \"completed\", return CreateIterResultObject(undefined, true).\n  if (state === \"completed\") return Create.CreateIterResultObject(realm, realm.intrinsics.undefined, true);\n\n  // 3. Assert: state is either \"suspendedStart\" or \"suspendedYield\".\n  invariant(\n    state === \"suspendedStart\" || state === \"suspendedYield\",\n    \"state is either 'suspendedStart' or 'suspendedYield'\"\n  );\n\n  // 4. Let genContext be generator.[[GeneratorContext]].\n  let genContext = generator.$GeneratorContext;\n  invariant(genContext);\n\n  // 5. Let methodContext be the running execution context.\n  let methodContext = realm.getRunningContext();\n\n  // 6. Suspend methodContext.\n  methodContext.suspend();\n\n  // 7. Set generator.[[GeneratorState]] to \"executing\".\n  Properties.ThrowIfInternalSlotNotWritable(realm, generator, \"$GeneratorState\").$GeneratorState = \"executing\";\n\n  // 8. Push genContext onto the execution context stack; genContext is now the running execution context.\n  realm.pushContext(genContext);\n\n  // 9. Resume the suspended evaluation of genContext using NormalCompletion(value) as the result of the operation that suspended it. Let result be the value returned by the resumed computation.\n  let result = genContext.resume();\n\n  // 10. Assert: When we return here, genContext has already been removed from the execution context stack and methodContext is the currently running execution context.\n  invariant(realm.getRunningContext() === methodContext);\n\n  // 11. Return Completion(result).\n  return result;\n}\n\n// ECMA26225.3.3.4\nexport function GeneratorResumeAbrupt(realm: Realm, generator: Value, abruptCompletion: AbruptCompletion): Value {\n  // 1. Let state be ? GeneratorValidate(generator).\n  // 2. If state is \"suspendedStart\", then\n  // a. Set generator.[[GeneratorState]] to \"completed\".\n  // b. Once a generator enters the \"completed\" state it never leaves it and its associated execution context is never resumed. Any execution state associated with generator can be discarded at this point.\n  // c. Let state be \"completed\".\n  // 3. If state is \"completed\", then\n  // a. If abruptCompletion.[[Type]] is return, then\n  // i. Return CreateIterResultObject(abruptCompletion.[[Value]], true).\n  // b. Return Completion(abruptCompletion).\n  // 4. Assert: state is \"suspendedYield\".\n  // 5. Let genContext be generator.[[GeneratorContext]].\n  // 6. Let methodContext be the running execution context.\n  // 7. Suspend methodContext.\n  // 8. Set generator.[[GeneratorState]] to \"executing\".\n  // 9. Push genContext onto the execution context stack; genContext is now the running execution context.\n  // 10. Resume the suspended evaluation of genContext using abruptCompletion as the result of the operation that suspended it. Let result be the completion record returned by the resumed computation.\n  // 11. Assert: When we return here, genContext has already been removed from the execution context stack and methodContext is the currently running execution context.\n  // 12. Return Completion(result).\n  return realm.intrinsics.undefined;\n}\n\n// ECMA26225.3.3.5\nexport function GeneratorYield(realm: Realm, iterNextObj: ObjectValue): Value {\n  // 1. Assert: iterNextObj is an Object that implements the IteratorResult interface.\n\n  // 2. Let genContext be the running execution context.\n  // 3. Assert: genContext is the execution context of a generator.\n  // 4. Let generator be the value of the Generator component of genContext.\n  // 5. Set generator.[[GeneratorState]] to \"suspendedYield\".\n  // 6. Remove genContext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n  // 7. Set the code evaluation state of genContext such that when evaluation is resumed with a Completion resumptionValue the following steps will be performed:\n  // a.  Return resumptionValue.\n  // b. NOTE: This returns to the evaluation of the YieldExpression production that originally called this abstract operation.\n  // 8. Return NormalCompletion(iterNextObj).\n  return realm.intrinsics.undefined;\n\n  // 9. NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of genContext.\n}\n"],"file":"generator.js"}