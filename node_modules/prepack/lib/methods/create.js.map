{"version":3,"sources":["../../src/methods/create.js"],"names":["allElementTypes","CreateImplementation","StringCreate","realm","value","prototype","StringValue","S","StringExotic","$StringData","$Prototype","setExtensible","length","Properties","DefinePropertyOrThrow","PropertyDescriptor","NumberValue","writable","enumerable","configurable","CreateHTML","string","tag","attribute","str","To","ToStringPartial","p1","V","escapedV","replace","p2","p3","p4","MakeArgGetter","name","env","NativeFunctionValue","undefined","context","GetBindingValue","MakeArgSetter","SetMutableBinding","CreateStringIterator","iterator","ObjectCreate","intrinsics","StringIteratorPrototype","$IteratedString","$StringIteratorNextIndex","ArraySpeciesCreate","originalArray","Object","is","C","isArray","ObjectValue","thisRealm","realmC","Array","mightBeObject","mightNotBeObject","throwIfNotConcrete","AbstractObjectValue","SymbolSpecies","NullValue","UndefinedValue","ArrayCreate","createErrorThrowCompletion","TypeError","throwIfNotConcreteObject","CreateIterResultObject","done","obj","ObjectPrototype","CreateDataProperty","BooleanValue","CreateArrayIterator","array","kind","ArrayIteratorPrototype","$IteratedObject","$ArrayIteratorNextIndex","$ArrayIterationKind","proto","Math","pow","RangeError","ArrayPrototype","A","ArrayValue","OrdinaryDefineOwnProperty","CreateArrayFromList","elems","elem","Value","arr","n","status","CreateUnmappedArgumentsObject","argumentsList","len","$ParameterMap","index","val","SymbolIterator","ArrayProto_values","get","ThrowTypeError","set","CreateMappedArgumentsObject","func","formals","param","type","ArgumentsExotic","map","parameterNames","push","numberOfParameters","mappedNames","indexOf","g","p","$DefineOwnProperty","O","P","newDesc","CopyDataProperties","target","source","excluded","null","from","ToObject","keys","$OwnPropertyKeys","nextKey","found","e","mightBeFalse","desc","$GetOwnProperty","propValue","CreateMethodProperty","CreateDataPropertyOrThrow","success","internalSlotsList","assign","OrdinaryCreateFromConstructor","constructor","intrinsicDefaultProto","CreateListFromArrayLike","elementTypes","ToLength","list","indexName","next","CreateDynamicFunction","newTarget","args","fallbackProto","argCount","bodyText","emptyString","firstArg","k","nextArg","nextArgString","ast","SyntaxError","program","body","functionDeclaration","params","strict","containsYield","node","F","Functions","FunctionAllocate","realmF","$Realm","scope","$GlobalEnv","FunctionInitialize","GeneratorPrototype","originalConstructor","SetFunctionName"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport type { EnvironmentRecord } from \"../environment.js\";\nimport type { PropertyKeyValue, IterationKind } from \"../types.js\";\nimport {\n  AbstractObjectValue,\n  ArrayValue,\n  ArgumentsExotic,\n  BooleanValue,\n  FunctionValue,\n  NativeFunctionValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  StringExotic,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { GetPrototypeFromConstructor } from \"./get.js\";\nimport { IsConstructor, IsPropertyKey, IsArray } from \"./is.js\";\nimport { Type, SameValue, RequireObjectCoercible } from \"./abstract.js\";\nimport { Get, GetFunctionRealm } from \"./get.js\";\nimport { Construct, MakeConstructor } from \"./construct.js\";\nimport { Functions, Properties, To } from \"../singletons.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport invariant from \"../invariant.js\";\nimport parse from \"../utils/parse.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport type { BabelNodeIdentifier, BabelNodeLVal, BabelNodeFunctionDeclaration } from \"@babel/types\";\nimport { PropertyDescriptor } from \"../descriptors.js\";\n\nconst allElementTypes = [\"Undefined\", \"Null\", \"Boolean\", \"String\", \"Symbol\", \"Number\", \"Object\"];\n\nexport class CreateImplementation {\n  // ECMA262 9.4.3.3\n  StringCreate(realm: Realm, value: StringValue, prototype: ObjectValue | AbstractObjectValue): ObjectValue {\n    // 1. Assert: Type(value) is String.\n    invariant(value instanceof StringValue, \"expected string value\");\n\n    // 2. Let S be a newly created String exotic object.\n    let S = new StringExotic(realm);\n\n    // 3. Set the [[StringData]] internal slot of S to value.\n    S.$StringData = value;\n\n    // 4. Set S's essential internal methods to the default ordinary object definitions specified in 9.1.\n\n    // 5. Set the [[GetOwnProperty]] internal method of S as specified in 9.4.3.1.\n\n    // 6. Set the [[OwnPropertyKeys]] internal method of S as specified in 9.4.3.2.\n\n    // 7. Set the [[Prototype]] internal slot of S to prototype.\n    S.$Prototype = prototype;\n\n    // 8. Set the [[Extensible]] internal slot of S to true.\n    S.setExtensible(true);\n\n    // 9. Let length be the number of code unit elements in value.\n    let length = value.value.length;\n\n    // 10. Perform ! DefinePropertyOrThrow(S, \"length\", PropertyDescriptor{[[Value]]: length, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }).\n    Properties.DefinePropertyOrThrow(\n      realm,\n      S,\n      \"length\",\n      new PropertyDescriptor({\n        value: new NumberValue(realm, length),\n        writable: false,\n        enumerable: false,\n        configurable: false,\n      })\n    );\n\n    // 11. Return S.\n    return S;\n  }\n\n  // B.2.3.2.1\n  CreateHTML(realm: Realm, string: Value, tag: string, attribute: string, value: string | Value): StringValue {\n    // 1. Let str be ? RequireObjectCoercible(string).\n    let str = RequireObjectCoercible(realm, string);\n\n    // 2. Let S be ? ToString(str).\n    let S = To.ToStringPartial(realm, str);\n\n    // 3. Let p1 be the String value that is the concatenation of \"<\" and tag.\n    let p1 = `<${tag}`;\n\n    // 4. If attribute is not the empty String, then\n    if (attribute) {\n      // a. Let V be ? ToString(value).\n      let V = To.ToStringPartial(realm, value);\n\n      // b. Let escapedV be the String value that is the same as V except that each occurrence of the code unit\n      //    0x0022 (QUOTATION MARK) in V has been replaced with the six code unit sequence \"&quot;\".\n      let escapedV = V.replace(/\"/g, \"&quot;\");\n\n      // c. Let p1 be the String value that is the concatenation of the following String values:\n      // - The String value of p1\n      // - Code unit 0x0020 (SPACE)\n      // - The String value of attribute\n      // - Code unit 0x003D (EQUALS SIGN)\n      // - Code unit 0x0022 (QUOTATION MARK)\n      // - The String value of escapedV\n      // - Code unit 0x0022 (QUOTATION MARK)\n      p1 = `${p1} ${attribute}=\"${escapedV}\"`;\n    }\n\n    // 5. Let p2 be the String value that is the concatenation of p1 and \">\".\n    let p2 = `${p1}>`;\n\n    // 6. Let p3 be the String value that is the concatenation of p2 and S.\n    let p3 = `${p2}${S}`;\n\n    // 7. Let p4 be the String value that is the concatenation of p3, \"</\", tag, and \">\".\n    let p4 = `${p3}</${tag}>`;\n\n    // 8. Return p4.\n    return new StringValue(realm, p4);\n  }\n\n  // ECMA262 9.4.4.8.1\n  MakeArgGetter(realm: Realm, name: string, env: EnvironmentRecord): NativeFunctionValue {\n    return new NativeFunctionValue(\n      realm,\n      undefined,\n      undefined,\n      0,\n      context => {\n        return env.GetBindingValue(name, false);\n      },\n      false\n    );\n  }\n\n  // ECMA262 9.4.4.8.1\n  MakeArgSetter(realm: Realm, name: string, env: EnvironmentRecord): NativeFunctionValue {\n    return new NativeFunctionValue(\n      realm,\n      undefined,\n      undefined,\n      1,\n      (context, [value]) => {\n        return env.SetMutableBinding(name, value, false);\n      },\n      false\n    );\n  }\n\n  // ECMA262 21.1.5.1\n  CreateStringIterator(realm: Realm, string: StringValue): ObjectValue {\n    // 1. Assert: Type(string) is String.\n    invariant(string instanceof StringValue, \"expected string to be a string value\");\n\n    // 2. Let iterator be ObjectCreate(%StringIteratorPrototype%, « [[IteratedString]], [[StringIteratorNextIndex]] »).\n    let iterator = this.ObjectCreate(realm, realm.intrinsics.StringIteratorPrototype, {\n      $IteratedString: undefined,\n      $StringIteratorNextIndex: undefined,\n    });\n\n    // 3. Set iterator's [[IteratedString]] internal slot to string.\n    iterator.$IteratedString = string;\n\n    // 4. Set iterator's [[StringIteratorNextIndex]] internal slot to 0.\n    iterator.$StringIteratorNextIndex = 0;\n\n    // 5. Return iterator.\n    return iterator;\n  }\n\n  // ECMA262 9.4.2.3\n  ArraySpeciesCreate(realm: Realm, originalArray: ObjectValue, length: number): ObjectValue {\n    // 1. Assert: length is an integer Number ≥ 0.\n    invariant(length >= 0, \"expected length >= 0\");\n\n    // 2. If length is -0, let length be +0.\n    if (Object.is(length, -0)) length = +0;\n\n    // 3. Let C be undefined.\n    let C = realm.intrinsics.undefined;\n\n    // 4. Let isArray be ? IsArray(originalArray).\n    let isArray = IsArray(realm, originalArray);\n\n    // 5. If isArray is true, then\n    if (isArray) {\n      // a. Let C be ? Get(originalArray, \"constructor\").\n      C = Get(realm, originalArray, \"constructor\");\n\n      // b. If IsConstructor(C) is true, then\n      if (IsConstructor(realm, C)) {\n        invariant(C instanceof ObjectValue);\n        // i. Let thisRealm be the current Realm Record.\n        let thisRealm = realm;\n\n        // ii. Let realmC be ? GetFunctionRealm(C).\n        let realmC = GetFunctionRealm(realm, C);\n\n        // iii. If thisRealm and realmC are not the same Realm Record, then\n        if (thisRealm !== realmC) {\n          // 1. If SameValue(C, realmC.[[Intrinsics]].[[%Array%]]) is true, let C be undefined.\n          if (SameValue(realm, C, realmC.intrinsics.Array)) {\n            C = realm.intrinsics.undefined;\n          }\n        }\n      }\n\n      // c. If Type(C) is Object, then\n      if (C.mightBeObject()) {\n        if (C.mightNotBeObject()) C.throwIfNotConcrete();\n        invariant(C instanceof ObjectValue || C instanceof AbstractObjectValue);\n        // i. Let C be ? Get(C, @@species).\n        C = Get(realm, C, realm.intrinsics.SymbolSpecies);\n\n        // ii. If C is null, let C be undefined.\n        if (C instanceof NullValue) C = realm.intrinsics.undefined;\n      }\n    }\n\n    // 6. If C is undefined, return ? ArrayCreate(length).\n    if (C instanceof UndefinedValue) return this.ArrayCreate(realm, length);\n\n    // 7. If IsConstructor(C) is false, throw a TypeError exception.\n    if (!IsConstructor(realm, C)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a constructor\");\n    }\n\n    // 8. Return ? Construct(C, « length »).\n    return Construct(realm, C.throwIfNotConcreteObject(), [new NumberValue(realm, length)]).throwIfNotConcreteObject();\n  }\n\n  // ECMA262 7.4.7\n  CreateIterResultObject(realm: Realm, value: Value, done: boolean): ObjectValue {\n    // 1. Assert: Type(done) is Boolean.\n    invariant(typeof done === \"boolean\", \"expected done to be a boolean\");\n\n    // 2. Let obj be ObjectCreate(%ObjectPrototype%).\n    let obj = this.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n    // 3. Perform CreateDataProperty(obj, \"value\", value).\n    this.CreateDataProperty(realm, obj, \"value\", value);\n\n    // 4. Perform CreateDataProperty(obj, \"done\", done).\n    this.CreateDataProperty(realm, obj, \"done\", new BooleanValue(realm, done));\n\n    // 5. Return obj.\n    return obj;\n  }\n\n  // ECMA262 22.1.5.1\n  CreateArrayIterator(realm: Realm, array: ObjectValue, kind: IterationKind): ObjectValue {\n    // 1. Assert: Type(array) is Object.\n    invariant(array instanceof ObjectValue, \"expected object\");\n\n    // 2. Let iterator be ObjectCreate(%ArrayIteratorPrototype%, « [[IteratedObject]],\n    //    [[ArrayIteratorNextIndex]], [[ArrayIterationKind]] »).\n    let iterator = this.ObjectCreate(realm, realm.intrinsics.ArrayIteratorPrototype, {\n      $IteratedObject: undefined,\n      $ArrayIteratorNextIndex: undefined,\n      $ArrayIterationKind: undefined,\n    });\n\n    // 3. Set iterator's [[IteratedObject]] internal slot to array.\n    iterator.$IteratedObject = array;\n\n    // 4. Set iterator's [[ArrayIteratorNextIndex]] internal slot to 0.\n    iterator.$ArrayIteratorNextIndex = new NumberValue(realm, 0);\n\n    // 5. Set iterator's [[ArrayIterationKind]] internal slot to kind.\n    iterator.$ArrayIterationKind = kind;\n\n    // 6. Return iterator.\n    return iterator;\n  }\n\n  // ECMA262 9.4.2.2\n  ArrayCreate(realm: Realm, length: number, proto?: ObjectValue | AbstractObjectValue): ArrayValue {\n    // 1. Assert: length is an integer Number ≥ 0.\n    invariant(length >= 0);\n\n    // 2. If length is -0, let length be +0.\n    if (Object.is(length, -0)) length = +0;\n\n    // 3. If length>232-1, throw a RangeError exception.\n    if (length > Math.pow(2, 32) - 1) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"length>2^32-1\");\n    }\n\n    // 4. If the proto argument was not passed, let proto be the intrinsic object %ArrayPrototype%.\n    proto = proto || realm.intrinsics.ArrayPrototype;\n\n    // 5. Let A be a newly created Array exotic object.\n    let A = new ArrayValue(realm);\n\n    // 6. Set A's essential internal methods except for [[DefineOwnProperty]] to the default ordinary object definitions specified in 9.1.\n    // 7. Set the [[DefineOwnProperty]] internal method of A as specified in 9.4.2.1.\n\n    // 8. Set the [[Prototype]] internal slot of A to proto.\n    A.$Prototype = proto;\n\n    // 9. Set the [[Extensible]] internal slot of A to true.\n    A.setExtensible(true);\n\n    // 10. Perform ! OrdinaryDefineOwnProperty(A, \"length\", PropertyDescriptor{[[Value]]: length, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).\n    Properties.OrdinaryDefineOwnProperty(\n      realm,\n      A,\n      \"length\",\n      new PropertyDescriptor({\n        value: new NumberValue(realm, length),\n        writable: true,\n        enumerable: false,\n        configurable: false,\n      })\n    );\n\n    // 11. Return A.\n    return A;\n  }\n\n  // ECMA262 7.3.16\n  CreateArrayFromList(realm: Realm, elems: Array<Value>): ArrayValue {\n    // 1. Assert: elements is a List whose elements are all ECMAScript language values.\n    for (let elem of elems) invariant(elem instanceof Value, \"value expected\");\n\n    // 2. Let array be ArrayCreate(0) (see 9.4.2.2).\n    let arr = this.ArrayCreate(realm, 0);\n\n    // 3. Let n be 0.\n    let n = 0;\n\n    // 4. For each element e of elements\n    for (let elem of elems) {\n      // a. Let status be CreateDataProperty(array, ! ToString(n), e).\n      let status = this.CreateDataProperty(realm, arr, new StringValue(realm, n + \"\"), elem);\n\n      // b. Assert: status is true.\n      invariant(status, \"couldn't create data property\");\n\n      // c. Increment n by 1.\n      n++;\n    }\n\n    // 5. Return array.\n    return arr;\n  }\n\n  // ECMA262 9.4.4.7\n  CreateUnmappedArgumentsObject(realm: Realm, argumentsList: Array<Value>): ObjectValue {\n    // 1. Let len be the number of elements in argumentsList.\n    let len = argumentsList.length;\n\n    // 2. Let obj be ObjectCreate(%ObjectPrototype%, « [[ParameterMap]] »).\n    let obj = this.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n    // 3. Set obj's [[ParameterMap]] internal slot to undefined.\n    obj.$ParameterMap = obj; // The value is never used, but allows us to use undefined for \"not in\"\n\n    // 4. Perform DefinePropertyOrThrow(obj, \"length\", PropertyDescriptor{[[Value]]: len,\n    //    [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(\n      realm,\n      obj,\n      \"length\",\n      new PropertyDescriptor({\n        value: new NumberValue(realm, len),\n        writable: true,\n        enumerable: false,\n        configurable: true,\n      })\n    );\n\n    // 5. Let index be 0.\n    let index = 0;\n\n    // 6. Repeat while index < len,\n    while (index < len) {\n      // a. Let val be argumentsList[index].\n      let val = argumentsList[index];\n\n      // b. Perform CreateDataProperty(obj, ! ToString(index), val).\n      this.CreateDataProperty(realm, obj, new StringValue(realm, index + \"\"), val);\n\n      // c. Let index be index + 1.\n      index++;\n    }\n\n    // 7. Perform ! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor {[[Value]]:\n    //    %ArrayProto_values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(\n      realm,\n      obj,\n      realm.intrinsics.SymbolIterator,\n      new PropertyDescriptor({\n        value: realm.intrinsics.ArrayProto_values,\n        writable: true,\n        enumerable: false,\n        configurable: true,\n      })\n    );\n\n    // 8. Perform ! DefinePropertyOrThrow(obj, \"callee\", PropertyDescriptor {[[Get]]:\n    // %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: false, [[Configurable]]: false}).\n    Properties.DefinePropertyOrThrow(\n      realm,\n      obj,\n      \"callee\",\n      new PropertyDescriptor({\n        get: realm.intrinsics.ThrowTypeError,\n        set: realm.intrinsics.ThrowTypeError,\n        enumerable: false,\n        configurable: false,\n      })\n    );\n\n    // 10. Return obj.\n    return obj;\n  }\n\n  // ECMA262 9.4.4.8\n  CreateMappedArgumentsObject(\n    realm: Realm,\n    func: FunctionValue,\n    formals: Array<BabelNodeLVal>,\n    argumentsList: Array<Value>,\n    env: EnvironmentRecord\n  ): ObjectValue {\n    // 1. Assert: formals does not contain a rest parameter, any binding patterns, or any\n    //    initializers. It may contain duplicate identifiers.\n    for (let param of formals) {\n      invariant(param.type === \"Identifier\", \"expected only simple params\");\n    }\n\n    // 2. Let len be the number of elements in argumentsList.\n    let len = argumentsList.length;\n\n    // 3. Let obj be a newly created arguments exotic object with a [[ParameterMap]] internal slot.\n    let obj = new ArgumentsExotic(realm);\n\n    // 4. Set the [[GetOwnProperty]] internal method of obj as specified in 9.4.4.1.\n\n    // 5. Set the [[DefineOwnProperty]] internal method of obj as specified in 9.4.4.2.\n\n    // 6. Set the [[Get]] internal method of obj as specified in 9.4.4.3.\n\n    // 7. Set the [[Set]] internal method of obj as specified in 9.4.4.4.\n\n    // 8. Set the [[Delete]] internal method of obj as specified in 9.4.4.6.\n\n    // 9. Set the remainder of obj's essential internal methods to the default ordinary\n    //    object definitions specified in 9.1.\n\n    // 10. Set the [[Prototype]] internal slot of obj to %ObjectPrototype%.\n    obj.$Prototype = realm.intrinsics.ObjectPrototype;\n\n    // 11. Set the [[Extensible]] internal slot of obj to true.\n    obj.setExtensible(true);\n\n    // 12. Let map be ObjectCreate(null).\n    let map: ObjectValue = new ObjectValue(realm);\n\n    // 13. Set the [[ParameterMap]] internal slot of obj to map.\n    obj.$ParameterMap = map;\n\n    // 14. Let parameterNames be the BoundNames of formals.\n    let parameterNames = [];\n    for (let param of formals) {\n      parameterNames.push(((param: any): BabelNodeIdentifier).name);\n    }\n\n    // 15. Let numberOfParameters be the number of elements in parameterNames.\n    let numberOfParameters = parameterNames.length;\n\n    // 16. Let index be 0.\n    let index = 0;\n\n    // 17. Repeat while index < len,\n    while (index < len) {\n      // a. Let val be argumentsList[index].\n      let val = argumentsList[index];\n\n      // b. Perform CreateDataProperty(obj, ! ToString(index), val).\n      this.CreateDataProperty(realm, obj, new StringValue(realm, index + \"\"), val);\n\n      // c. Let index be index + 1.\n      index++;\n    }\n\n    // 18. Perform DefinePropertyOrThrow(obj, \"length\", PropertyDescriptor{[[Value]]: len,\n    //     [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(\n      realm,\n      obj,\n      \"length\",\n      new PropertyDescriptor({\n        value: new NumberValue(realm, len),\n        writable: true,\n        enumerable: false,\n        configurable: true,\n      })\n    );\n\n    // 19. Let mappedNames be an empty List.\n    let mappedNames = [];\n\n    // 20. Let index be numberOfParameters - 1.\n    index = numberOfParameters - 1;\n\n    // 21. Repeat while index ≥ 0,\n    while (index >= 0) {\n      // a. Let name be parameterNames[index].\n      let name = parameterNames[index];\n\n      // b. If name is not an element of mappedNames, then\n      if (mappedNames.indexOf(name) < 0) {\n        // i. Add name as an element of the list mappedNames.\n        mappedNames.push(name);\n\n        // ii. If index < len, then\n        if (index < len) {\n          // 1. Let g be MakeArgGetter(name, env).\n          let g = this.MakeArgGetter(realm, name, env);\n\n          // 2. Let p be MakeArgSetter(name, env).\n          let p = this.MakeArgSetter(realm, name, env);\n\n          // 3. Perform map.[[DefineOwnProperty]](! ToString(index), PropertyDescriptor{[[Set]]: p, [[Get]]: g,\n          //    [[Enumerable]]: false, [[Configurable]]: true}).\n          map.$DefineOwnProperty(\n            new StringValue(realm, index + \"\"),\n            new PropertyDescriptor({\n              set: p,\n              get: g,\n              enumerable: false,\n              configurable: true,\n            })\n          );\n        }\n      }\n\n      // c. Let index be index - 1.\n      index--;\n    }\n\n    // 22. Perform ! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor {[[Value]]:\n    //     %ArrayProto_values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(\n      realm,\n      obj,\n      realm.intrinsics.SymbolIterator,\n      new PropertyDescriptor({\n        value: realm.intrinsics.ArrayProto_values,\n        writable: true,\n        enumerable: false,\n        configurable: true,\n      })\n    );\n\n    // 23. Perform ! DefinePropertyOrThrow(obj, \"callee\", PropertyDescriptor {[[Value]]:\n    //     func, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(\n      realm,\n      obj,\n      \"callee\",\n      new PropertyDescriptor({\n        value: func,\n        writable: true,\n        enumerable: false,\n        configurable: true,\n      })\n    );\n\n    // 24. Return obj.\n    return obj;\n  }\n\n  // ECMA262 7.3.4\n  CreateDataProperty(realm: Realm, O: ObjectValue | AbstractObjectValue, P: PropertyKeyValue, V: Value): boolean {\n    // 1. Assert: Type(O) is Object.\n\n    // 2. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"Not a property key\");\n\n    // 3. Let newDesc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}.\n    let newDesc = new PropertyDescriptor({\n      value: V,\n      writable: true,\n      enumerable: true,\n      configurable: true,\n    });\n\n    // 4. Return ? O.[[DefineOwnProperty]](P, newDesc).\n    return O.$DefineOwnProperty(P, newDesc);\n  }\n\n  CopyDataProperties(realm: Realm, target: ObjectValue, source: Value, excluded: Array<PropertyKeyValue>): ObjectValue {\n    // Assert: Type(target) is Object.\n    invariant(target instanceof ObjectValue, \"Not an object value\");\n\n    // Assert: Type(excluded) is List.\n    invariant(excluded instanceof Array, \"Not an array\");\n\n    //   If source is undefined or null,\n    if (source === realm.intrinsics.null || source === realm.intrinsics.undefined) {\n      // let keys be a new empty List.\n    } else {\n      //   Else,\n      // Let from be ! ToObject(source).\n      let from = To.ToObject(realm, source);\n\n      // Let keys be ? from.[[OwnPropertyKeys]]().\n      let keys = from.$OwnPropertyKeys();\n\n      //   Repeat for each element nextKey of keys in List order,\n      for (let nextKey of keys) {\n        // Let found be false.\n        let found = false;\n\n        //   Repeat for each element e of excluded,\n        for (let e of excluded) {\n          // Seems necessary. Flow complained too. Did I go wrong somewhere else?\n          invariant(e instanceof StringValue);\n          invariant(nextKey instanceof StringValue);\n\n          // If e is not empty and SameValue(e, nextKey) is true, then\n          if (!e.mightBeFalse() && SameValue(realm, e, nextKey)) {\n            // Set found to true.\n            found = true;\n          }\n        }\n        // If found is false, then\n        if (found === false) {\n          // Let desc be ? from.[[GetOwnProperty]](nextKey).\n          let desc = from.$GetOwnProperty(nextKey);\n\n          // If desc is not undefined and desc.[[Enumerable]] is true, then\n          if (desc !== undefined && desc.throwIfNotConcrete(realm).enumerable === true) {\n            // Let propValue be ? Get(from, nextKey).\n            let propValue = Get(realm, from, nextKey);\n            // Perform ! CreateDataProperty(target, nextKey, propValue).\n            this.CreateDataProperty(realm, target, nextKey, propValue);\n          }\n        }\n      }\n    }\n\n    // Return target.\n    return target;\n  }\n\n  // ECMA262 7.3.5\n  CreateMethodProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue, V: Value): boolean {\n    // 1. Assert: Type(O) is Object.\n    invariant(O instanceof ObjectValue, \"Not an object value\");\n\n    // 2. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"Not a property key\");\n\n    // 3. Let newDesc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}.\n    let newDesc = new PropertyDescriptor({\n      value: V,\n      writable: true,\n      enumerable: false,\n      configurable: true,\n    });\n\n    // 4. Return ? O.[[DefineOwnProperty]](P, newDesc).\n    return O.$DefineOwnProperty(P, newDesc);\n  }\n\n  // ECMA262 7.3.6\n  CreateDataPropertyOrThrow(realm: Realm, O: Value, P: PropertyKeyValue, V: Value): boolean {\n    // 1. Assert: Type(O) is Object.\n    invariant(O instanceof ObjectValue, \"Not an object value\");\n\n    // 2. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"Not a property key\");\n\n    //3. Let success be ? CreateDataProperty(O, P, V).\n    let success = this.CreateDataProperty(realm, O, P, V);\n\n    // 4. If success is false, throw a TypeError exception.\n    if (success === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not a function\");\n    }\n\n    // 5. Return success.\n    return success;\n  }\n\n  // ECMA262 9.1.12\n  ObjectCreate(\n    realm: Realm,\n    proto: ObjectValue | AbstractObjectValue | NullValue,\n    internalSlotsList?: { [key: string]: void }\n  ): ObjectValue {\n    // 1. If internalSlotsList was not provided, let internalSlotsList be an empty List.\n    internalSlotsList = internalSlotsList || {};\n\n    // 2. Let obj be a newly created object with an internal slot for each name in internalSlotsList.\n    let obj = new ObjectValue(realm);\n    Object.assign(obj, internalSlotsList);\n\n    // 3. Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.\n\n    // 4. Set the [[Prototype]] internal slot of obj to proto.\n    obj.$Prototype = proto;\n\n    // 5. Set the [[Extensible]] internal slot of obj to true.\n    obj.setExtensible(true);\n\n    // 6. Return obj.\n    return obj;\n  }\n\n  // ECMA262 9.1.13\n  OrdinaryCreateFromConstructor(\n    realm: Realm,\n    constructor: ObjectValue,\n    intrinsicDefaultProto: string,\n    internalSlotsList?: { [key: string]: void }\n  ): ObjectValue {\n    // 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic\n    //    object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]]\n    //    value of an object.\n    invariant(realm.intrinsics[intrinsicDefaultProto], \"not a valid proto ref\");\n\n    // 2. Let proto be ? GetPrototypeFromConstructor(constructor, intrinsicDefaultProto).\n    let proto = GetPrototypeFromConstructor(realm, constructor, intrinsicDefaultProto);\n\n    // 3. Return ObjectCreate(proto, internalSlotsList).\n    return this.ObjectCreate(realm, proto, internalSlotsList);\n  }\n\n  // ECMA262 7.3.17\n  CreateListFromArrayLike(realm: Realm, obj: Value, elementTypes?: Array<string>): Array<Value> {\n    // 1. If elementTypes was not passed, let elementTypes be « Undefined, Null, Boolean, String, Symbol, Number, Object ».\n    elementTypes = elementTypes || allElementTypes;\n\n    // 2. If Type(obj) is not Object, throw a TypeError exception.\n    if (!(obj instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Not an object\");\n    }\n\n    // 3. Let len be ? ToLength(? Get(obj, \"length\")).\n    let len = To.ToLength(realm, Get(realm, obj, \"length\"));\n\n    // 4. Let list be a new empty List.\n    let list: Array<Value> = [];\n\n    // 5. Let index be 0.\n    let index = 0;\n\n    // 6. Repeat while index < len\n    while (index < len) {\n      // a. Let indexName be ! ToString(index).\n      let indexName = index + \"\";\n\n      // b. Let next be ? Get(obj, indexName).\n      let next = Get(realm, obj, indexName);\n\n      // c. If Type(next) is not an element of elementTypes, throw a TypeError exception.\n      if (elementTypes !== allElementTypes && elementTypes.indexOf(Type(realm, next)) < 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"invalid element type\");\n      }\n\n      // d. Append next as the last element of list.\n      list.push(next);\n\n      // e. Set index to index + 1.\n      index++;\n    }\n\n    // 7. Return list.\n    return list;\n  }\n\n  // ECMA262 19.2.1.1.1\n  CreateDynamicFunction(\n    realm: Realm,\n    constructor: ObjectValue,\n    newTarget: void | ObjectValue,\n    kind: \"normal\" | \"generator\",\n    args: Array<Value>\n  ): Value {\n    // 1. If newTarget is undefined, let newTarget be constructor.\n    newTarget = !newTarget ? constructor : newTarget;\n\n    let fallbackProto;\n    // 2. If kind is \"normal\", then\n    if (kind === \"normal\") {\n      // a. Let goal be the grammar symbol FunctionBody.\n\n      // b. Let parameterGoal be the grammar symbol FormalParameters.\n\n      // c. Let fallbackProto be \"%FunctionPrototype%\".\n      fallbackProto = \"FunctionPrototype\";\n    } else {\n      // 3. Else,\n      // a. Let goal be the grammar symbol GeneratorBody.\n\n      // b. Let parameterGoal be the grammar symbol FormalParameters[Yield].\n\n      // c. Let fallbackProto be \"%Generator%\".\n      fallbackProto = \"Generator\";\n    }\n\n    // 4. Let argCount be the number of elements in args.\n    let argCount = args.length;\n\n    // 5. Let P be the empty String.\n    let P = \"\";\n\n    let bodyText;\n    // 6. If argCount = 0, let bodyText be the empty String.\n    if (argCount === 0) {\n      bodyText = realm.intrinsics.emptyString;\n    } else if (argCount === 1) {\n      // 7. Else if argCount = 1, let bodyText be args[0].\n      bodyText = args[0];\n    } else {\n      // 8. Else argCount > 1,\n      // a. Let firstArg be args[0].\n      let firstArg = args[0];\n\n      // b. Let P be ? ToString(firstArg).\n      P = To.ToStringPartial(realm, firstArg);\n\n      // c. Let k be 1.\n      let k = 1;\n\n      // d. Repeat, while k < argCount-1\n      while (k < argCount - 1) {\n        // i. Let nextArg be args[k].\n        let nextArg = args[k];\n\n        // ii. Let nextArgString be ? ToString(nextArg).\n        let nextArgString = To.ToStringPartial(realm, nextArg);\n\n        // iii. Let P be the result of concatenating the previous value of P, the String \",\" (a comma), and nextArgString.\n        P = P + \",\" + nextArgString;\n\n        // iv. Increase k by 1.\n        k += 1;\n      }\n\n      // e. Let bodyText be args[k].\n      bodyText = args[k];\n    }\n\n    // 9. Let bodyText be ? ToString(bodyText).\n    bodyText = To.ToStringPartial(realm, bodyText);\n\n    // 10. Let parameters be the result of parsing P, interpreted as UTF-16 encoded Unicode text as described in 6.1.4, using parameterGoal as the goal symbol. Throw a SyntaxError exception if the parse fails.\n    // 11. Let body be the result of parsing bodyText, interpreted as UTF-16 encoded Unicode text as described in 6.1.4, using goal as the goal symbol. Throw a SyntaxError exception if the parse fails.\n    let ast;\n    try {\n      ast = parse(realm, \"function\" + (kind === \"generator\" ? \"*\" : \"\") + \" _(\" + P + \"){\" + bodyText + \"}\", \"eval\");\n    } catch (e) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"parse failed\");\n    }\n    let {\n      program: {\n        body: [functionDeclaration],\n      },\n    } = ast;\n    if (!functionDeclaration) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"parse failed\");\n    }\n    invariant(functionDeclaration.type === \"FunctionDeclaration\");\n    let { params, body } = ((functionDeclaration: any): BabelNodeFunctionDeclaration);\n\n    // 12. If bodyText is strict mode code, then let strict be true, else let strict be false.\n    let strict = IsStrict(body);\n\n    // 13. If any static semantics errors are detected for parameters or body, throw a SyntaxError or a ReferenceError exception, depending on the type of the error. If strict is true, the Early Error rules for StrictFormalParameters:FormalParameters are applied. Parsing and early error detection may be interweaved in an implementation dependent manner.\n\n    // 14. If ContainsUseStrict of body is true and IsSimpleParameterList of parameters is false, throw a SyntaxError exception.\n\n    // 15. If any element of the BoundNames of parameters also occurs in the LexicallyDeclaredNames of body, throw a SyntaxError exception.\n\n    // 16. If body Contains SuperCall is true, throw a SyntaxError exception.\n\n    // 17. If parameters Contains SuperCall is true, throw a SyntaxError exception.\n\n    // 18. If body Contains SuperProperty is true, throw a SyntaxError exception.\n\n    // 19. If parameters Contains SuperProperty is true, throw a SyntaxError exception.\n\n    // 20. If kind is \"generator\", then\n    if (kind === \"generator\") {\n      // a. If parameters Contains YieldExpression is true, throw a SyntaxError exception.\n      let containsYield = false;\n      for (let param of params) {\n        traverseFast(param, node => {\n          if (node.type === \"YieldExpression\") {\n            containsYield = true;\n            return true;\n          }\n          if (node.type === \"Identifier\" && ((node: any): BabelNodeIdentifier).name === \"yield\") {\n            containsYield = true;\n            return true;\n          }\n          return false;\n        });\n      }\n      if (containsYield) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"parse failed\");\n      }\n    }\n\n    // 21. If strict is true, then\n    if (strict === true) {\n      // a. If BoundNames of parameters contains any duplicate elements, throw a SyntaxError exception.\n    }\n\n    // 22. Let proto be ? GetPrototypeFromConstructor(newTarget, fallbackProto).\n    let proto = GetPrototypeFromConstructor(realm, newTarget, fallbackProto);\n\n    // 23. Let F be FunctionAllocate(proto, strict, kind).\n    let F = Functions.FunctionAllocate(realm, proto, strict, kind);\n\n    // 24. Let realmF be the value of F's [[Realm]] internal slot.\n    let realmF = F.$Realm;\n\n    // 25. Let scope be realmF.[[GlobalEnv]].\n    let scope = realmF.$GlobalEnv;\n\n    // 26. Perform FunctionInitialize(F, Normal, parameters, body, scope).\n    Functions.FunctionInitialize(realm, F, \"normal\", params, body, scope);\n\n    // 27. If kind is \"generator\", then\n    if (kind === \"generator\") {\n      // a. Let prototype be ObjectCreate(%GeneratorPrototype%).\n      let prototype = this.ObjectCreate(realm, realm.intrinsics.GeneratorPrototype);\n      prototype.originalConstructor = F;\n\n      // b. Perform DefinePropertyOrThrow(F, \"prototype\", PropertyDescriptor{[[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}).\n      Properties.DefinePropertyOrThrow(\n        realm,\n        F,\n        \"prototype\",\n        new PropertyDescriptor({\n          value: prototype,\n          writable: true,\n          enumerable: false,\n          configurable: false,\n        })\n      );\n    } else {\n      // 28. Else, perform MakeConstructor(F).\n      MakeConstructor(realm, F);\n    }\n\n    // 29. Perform SetFunctionName(F, \"anonymous\").\n    Functions.SetFunctionName(realm, F, \"anonymous\");\n\n    // 30. Return F.\n    return F;\n  }\n}\n"],"file":"create.js"}