{"version":3,"sources":["../../src/methods/has.js"],"names":["HasName","realm","ast","type","id","Error","HasProperty","O","P","$HasProperty","HasOwnProperty","desc","$GetOwnProperty","undefined","Properties","ThrowIfMightHaveBeenDeleted","OrdinaryHasProperty","hasOwn","parent","$GetPrototypeOf","NullValue","ObjectValue","HasCompatibleType","value","valueType","getType","Value","AbstractValue","reportIntrospectionError","FatalError","isTypeCompatibleWith","HasSomeCompatibleType","manyTypes","some","bind"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { FatalError } from \"../errors.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport { IsPropertyKey } from \"./index.js\";\nimport { Value, AbstractValue, ObjectValue, NullValue, AbstractObjectValue } from \"../values/index.js\";\nimport { Properties } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeExpression } from \"@babel/types\";\n\n// 12.2.1.2 Static Semantics: HasName\n// 14.1.9 Static Semantics: HasName\n// 14.2.7 Static Semantics: HasName\n// 14.5.6 Static Semantics: HasName\n// 14.2.7 Static Semantics: HasName\n\nexport function HasName(realm: Realm, ast: BabelNodeExpression): boolean {\n  // 12.2.1.2 Static Semantics: HasName\n  // CoverParenthesizedExpressionAndArrowParameterList\n\n  // 14.2.7 Static Semantics: HasName\n  if (ast.type === \"ArrowFunctionExpression\") return false;\n\n  // 14.1.9 Static Semantics: HasName\n  if (ast.type === \"FunctionExpression\") {\n    // FunctionExpression: function (FormalParameters) {FunctionBody}\n    if (ast.id === null)\n      // 1. Return false.\n      return false;\n    // FunctionExpression: functionBindingIdentifier (FormalParameters) {FunctionBody}\n    if (ast.id !== null)\n      // 2. Return true\n      return true;\n  }\n\n  // 14.5.6 Static Semantics: HasName\n  if (ast.type === \"ClassExpression\") {\n    // ClassExpression : class ClassTail\n    if (ast.id === null)\n      //1. Return false.\n      return false;\n    // ClassExpression : class BindingIdentifier ClassTail\n    if (ast.id !== null)\n      //1. return true;\n      return true;\n  }\n  // 14.4.7 Static Semantics: HasName\n  // GeneratorExpression\n  throw Error(\"Unexpected AST node type  : \" + ast.type);\n}\n\n// ECMA262 7.3.10\nexport function HasProperty(realm: Realm, O: ObjectValue | AbstractObjectValue, P: PropertyKeyValue): boolean {\n  // 1. Assert: Type(O) is Object.\n\n  // 2. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n  // 3. Return ? O.[[HasProperty]](P).\n  return O.$HasProperty(P);\n}\n\n// ECMA262 7.3.11\nexport function HasOwnProperty(realm: Realm, O: ObjectValue | AbstractObjectValue, P: PropertyKeyValue): boolean {\n  // 1. Assert: Type(O) is Object.\n\n  // 2. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"not a valid property key\");\n\n  // 3. Let desc be ? O.[[GetOwnProperty]](P).\n  let desc = O.$GetOwnProperty(P);\n\n  // 4. If desc is undefined, return false.\n  if (desc === undefined) return false;\n  Properties.ThrowIfMightHaveBeenDeleted(desc);\n\n  // 5. Return true.\n  return true;\n}\n\n// ECMA262 9.1.7.1\nexport function OrdinaryHasProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue): boolean {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(typeof P === \"string\" || IsPropertyKey(realm, P), \"expected property key\");\n\n  // 2. Let hasOwn be ? O.[[GetOwnProperty]](P).\n  let hasOwn = O.$GetOwnProperty(P);\n\n  // 3. If hasOwn is not undefined, return true.\n  if (hasOwn !== undefined) {\n    Properties.ThrowIfMightHaveBeenDeleted(hasOwn);\n    return true;\n  }\n\n  // 4. Let parent be ? O.[[GetPrototypeOf]]().\n  let parent = O.$GetPrototypeOf();\n\n  // 5. If parent is not null, then\n  if (!(parent instanceof NullValue)) {\n    invariant(parent instanceof ObjectValue);\n\n    // a. Return ? parent.[[HasProperty]](P).\n    return parent.$HasProperty(P);\n  }\n\n  // 6. Return false.\n  return false;\n}\n\n// Checks if the given value is equal to or a subtype of the given type.\n// If the value is an abstract value without precise type information,\n// an introspection error is thrown.\nexport function HasCompatibleType(value: Value, type: typeof Value): boolean {\n  let valueType = value.getType();\n  if (valueType === Value) {\n    invariant(value instanceof AbstractValue);\n    AbstractValue.reportIntrospectionError(value);\n    throw new FatalError();\n  }\n  return Value.isTypeCompatibleWith(valueType, type);\n}\n\nexport function HasSomeCompatibleType(value: Value, ...manyTypes: Array<typeof Value>): boolean {\n  let valueType = value.getType();\n  if (valueType === Value) {\n    invariant(value instanceof AbstractValue);\n    AbstractValue.reportIntrospectionError(value);\n    throw new FatalError();\n  }\n  return manyTypes.some(Value.isTypeCompatibleWith.bind(null, valueType));\n}\n"],"file":"has.js"}