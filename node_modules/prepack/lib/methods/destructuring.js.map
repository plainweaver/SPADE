{"version":3,"sources":["../../src/methods/destructuring.js"],"names":["RestDestructuringAssignmentEvaluation","realm","property","value","excludedNames","strictCode","env","DestructuringAssignmentTarget","argument","lref","type","evaluate","restObj","Create","ObjectCreate","intrinsics","ObjectPrototype","CopyDataProperties","Properties","PutValue","nestedAssignmentPattern","DestructuringAssignmentEvaluation","PropertyDestructuringAssignmentEvaluation","properties","length","AssignmentProperty","slice","AssignmentPropertyList","propertyNames","nextNames","key","name","left","computed","Initializer","right","P","Environment","ResolveBinding","v","undefined","UndefinedValue","defaultValue","GetValue","ObjectValue","hasNameProperty","Functions","SetFunctionName","StringValue","KeyedDestructuringAssignmentEvaluation","Array","concat","pattern","AssignmentRestElement","push","empty","iterator","iteratorRecord","$Iterator","$Done","result","IteratorDestructuringAssignmentEvaluation","elements","error","AbruptCompletion","completion","SimpleNormalCompletion","_elements","restEl","lastEl","element","next","e","Reference","GetReferencedName","A","ArrayCreate","n","nextValue","status","CreateDataProperty","toString","node","propertyName","rhsValue","assignmentPattern"],"mappings":";;;;;;;;;AAWA;;AAGA;;AAEA;;AACA;;AACA;;AACA;;AAWA;;;;AA9BA;;;;;;;;;AASA;AAgCA,SAASA,qCAAT,CACEC,KADF,EAEEC,QAFF,EAGEC,KAHF,EAIEC,aAJF,EAKEC,UALF,EAMEC,GANF,EAO0B;AACxB,MAAIC,6BAA6B,GAAGL,QAAQ,CAACM,QAA7C;AAEA,MAAIC,IAAJ,CAHwB,CAIxB;;AACA,MAAIF,6BAA6B,CAACG,IAA9B,KAAuC,eAAvC,IAA0DH,6BAA6B,CAACG,IAA9B,KAAuC,cAArG,EAAqH;AACnH;AACAD,IAAAA,IAAI,GAAGH,GAAG,CAACK,QAAJ,CAAaJ,6BAAb,EAA4CF,UAA5C,CAAP,CAFmH,CAInH;AACD,GAVuB,CAYxB;;;AACA,MAAIO,OAAO,GAAGC,mBAAOC,YAAP,CAAoBb,KAApB,EAA2BA,KAAK,CAACc,UAAN,CAAiBC,eAA5C,CAAd,CAbwB,CAexB;;AACA;;;AAAyBH,qBAAOI,kBAAP,CAA0BhB,KAA1B,EAAiCW,OAAjC,EAA0CT,KAA1C,EAAiDC,aAAjD,EAhBD,CAiBxB;AAEA;;;AACA,MAAIG,6BAA6B,CAACG,IAA9B,KAAuC,eAAvC,IAA0DH,6BAA6B,CAACG,IAA9B,KAAuC,cAArG,EAAqH;AACnH,4BAAUD,IAAV,EADmH,CAEnH;;AACA,WAAOS,uBAAWC,QAAX,CAAoBlB,KAApB,EAA2BQ,IAA3B,EAAiCG,OAAjC,CAAP;AACD,GAxBuB,CA0BxB;;;AACA,MAAIQ,uBAAuB,GAAGb,6BAA9B;AAEA,SAAOc,iCAAiC,CAACpB,KAAD,EAAQmB,uBAAR,EAAiCR,OAAjC,EAA0CP,UAA1C,EAAsDC,GAAtD,CAAxC;AACD;;AAED,SAASgB,yCAAT,CACErB,KADF,EAEEsB,UAFF,EAGEpB,KAHF,EAIEE,UAJF,EAKEC,GALF,EAM6C;AAC3C;AACA,MAAIiB,UAAU,CAACC,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,WAAO,EAAP;AACD;;AAED,MAAIC,kBAAkB,GAAGF,UAAU,CAACG,KAAX,CAAiB,CAAC,CAAlB,EAAqB,CAArB,CAAzB;AACA,MAAIC,sBAAsB,GAAGJ,UAAU,CAACG,KAAX,CAAiB,CAAjB,EAAoB,CAAC,CAArB,CAA7B,CAP2C,CAS3C;;AACA,MAAIE,aAAa,GAAGN,yCAAyC,CAACrB,KAAD,EAAQ0B,sBAAR,EAAgCxB,KAAhC,EAAuCE,UAAvC,EAAmDC,GAAnD,CAA7D,CAV2C,CAY3C;AAEA;;AACA,MAAIuB,SAAJ,CAf2C,CAiB3C;;AACA,MACEJ,kBAAkB,CAACK,GAAnB,CAAuBpB,IAAvB,KAAgC,YAAhC,KACEe,kBAAkB,CAACtB,KAAnB,CAAyBO,IAAzB,KAAkC,YAAlC,IACAe,kBAAkB,CAACtB,KAAnB,CAAyB4B,IAAzB,KAAkCN,kBAAkB,CAACK,GAAnB,CAAuBC,IAD1D,IAEEN,kBAAkB,CAACtB,KAAnB,CAAyBO,IAAzB,KAAkC,mBAAlC,IACCe,kBAAkB,CAACtB,KAAnB,CAAyB6B,IAAzB,CAA8BD,IAA9B,KAAuCN,kBAAkB,CAACK,GAAnB,CAAuBC,IAJlE,KAKAN,kBAAkB,CAACQ,QAAnB,KAAgC,KANlC,EAOE;AACA,QAAIC,WAAJ;;AAEA,QAAIT,kBAAkB,CAACtB,KAAnB,CAAyBO,IAAzB,KAAkC,mBAAtC,EAA2D;AACzDwB,MAAAA,WAAW,GAAIT,kBAAkB,CAACtB,KAApB,CAAuDgC,KAArE;AACD,KALD,CAOA;;;AACA,QAAIC,CAAC,GAAIX,kBAAkB,CAACK,GAApB,CAA8CC,IAAtD,CARA,CAUA;;AACA,QAAItB,IAAI,GAAG4B,wBAAYC,cAAZ,CAA2BrC,KAA3B,EAAkCmC,CAAlC,EAAqC/B,UAArC,EAAiDC,GAAjD,CAAX,CAXA,CAaA;;;AACA,QAAIiC,CAAC,GAAG,kBAAKtC,KAAL,EAAYE,KAAZ,EAAmBiC,CAAnB,CAAR,CAdA,CAgBA;;AACA,QAAIF,WAAW,KAAKM,SAAhB,IAA6BD,CAAC,YAAYE,qBAA9C,EAA8D;AAC5D;AACA,UAAIC,YAAY,GAAGpC,GAAG,CAACK,QAAJ,CAAauB,WAAb,EAA0B7B,UAA1B,CAAnB,CAF4D,CAI5D;;AACAkC,MAAAA,CAAC,GAAGF,wBAAYM,QAAZ,CAAqB1C,KAArB,EAA4ByC,YAA5B,CAAJ,CAL4D,CAO5D;;AACA,UAAI,2CAA8BzC,KAA9B,EAAqCiC,WAArC,CAAJ,EAAuD;AACrD,gCAAUK,CAAC,YAAYK,kBAAvB,EADqD,CAGrD;;AACA,YAAIC,eAAe,GAAG,4BAAe5C,KAAf,EAAsBsC,CAAtB,EAAyB,MAAzB,CAAtB,CAJqD,CAMrD;;AACA,YAAIM,eAAe,KAAK,KAAxB,EAA+B;AAC7BC,gCAAUC,eAAV,CAA0B9C,KAA1B,EAAiCsC,CAAjC,EAAoCH,CAApC;AACD;AACF;AACF,KApCD,CAsCA;;;AACAlB,2BAAWC,QAAX,CAAoBlB,KAApB,EAA2BQ,IAA3B,EAAiC8B,CAAjC,EAvCA,CAyCA;;;AACAV,IAAAA,SAAS,GAAG,CAAC,IAAImB,kBAAJ,CAAgB/C,KAAhB,EAAuBmC,CAAvB,CAAD,CAAZ;AACD,GAlDD,MAkDO;AACL;AAEA;AACA,QAAIL,IAAI,GAAG,wCAAiBN,kBAAjB,EAAqCnB,GAArC,EAA0CL,KAA1C,EAAiDI,UAAjD,CAAX,CAJK,CAML;AAEA;;AACA;;AAAmB4C,IAAAA,sCAAsC,CACvDhD,KADuD,EAEvD;AACAwB,IAAAA,kBAAkB,CAACtB,KAHoC,EAIvDA,KAJuD,EAKvD4B,IALuD,EAMvD1B,UANuD,EAOvDC,GAPuD,CAAtC,CATd,CAmBL;AAEA;;AACAuB,IAAAA,SAAS,GAAG,CAACE,IAAD,CAAZ;AACD,GA3F0C,CA6F3C;;;AAEA,0BAAUF,SAAS,YAAYqB,KAA/B,EA/F2C,CAgG3C;;AACAtB,EAAAA,aAAa,GAAGA,aAAa,CAACuB,MAAd,CAAqBtB,SAArB,CAAhB,CAjG2C,CAmG3C;;AACA,SAAOD,aAAP;AACD,C,CAED;;;AACO,SAASP,iCAAT,CACLpB,KADK,EAELmD,OAFK,EAGLjD,KAHK,EAILE,UAJK,EAKLC,GALK,EAMmB;AACxB,MAAI8C,OAAO,CAAC1C,IAAR,KAAiB,eAArB,EAAsC;AACpC,QAAIiB,sBAAsB,GAAG,EAA7B;AAAA,QACE0B,qBAAqB,GAAG,IAD1B;;AAGA,SAAK,IAAInD,QAAT,IAAqBkD,OAAO,CAAC7B,UAA7B,EAAyC;AACvC,UAAIrB,QAAQ,CAACQ,IAAT,KAAkB,aAAtB,EAAqC;AACnC2C,QAAAA,qBAAqB,GAAGnD,QAAxB;AACD,OAFD,MAEO;AACLyB,QAAAA,sBAAsB,CAAC2B,IAAvB,CAA4BpD,QAA5B;AACD;AACF,KAVmC,CAYpC;AACA;AACA;;;AACA,QAAI,CAACmD,qBAAL,EAA4B;AAC1B;AACA,0CAAuBpD,KAAvB,EAA8BE,KAA9B,EAF0B,CAI1B;;AACAmB,MAAAA,yCAAyC,CAACrB,KAAD,EAAQ0B,sBAAR,EAAgCxB,KAAhC,EAAuCE,UAAvC,EAAmDC,GAAnD,CAAzC,CAL0B,CAO1B;;AACA,aAAOL,KAAK,CAACc,UAAN,CAAiBwC,KAAxB;AACD,KAxBmC,CA0BpC;;;AACA,QAAI5B,sBAAsB,CAACH,MAAvB,KAAkC,CAAtC,EAAyC;AACvC;AACA,UAAIpB,aAAa,GAAG,EAApB,CAFuC,CAIvC;;AACA,aAAOJ,qCAAqC,CAACC,KAAD,EAAQoD,qBAAR,EAA+BlD,KAA/B,EAAsCC,aAAtC,EAAqDC,UAArD,EAAiEC,GAAjE,CAA5C;AACD,KAND,MAMO;AACL;AACA;AACA,UAAIF,aAAa,GAAGkB,yCAAyC,CAC3DrB,KAD2D,EAE3D0B,sBAF2D,EAG3DxB,KAH2D,EAI3DE,UAJ2D,EAK3DC,GAL2D,CAA7D,CAHK,CAWL;;AACA,aAAON,qCAAqC,CAACC,KAAD,EAAQoD,qBAAR,EAA+BlD,KAA/B,EAAsCC,aAAtC,EAAqDC,UAArD,EAAiEC,GAAjE,CAA5C;AACD;AACF,GA/CD,MA+CO,IAAI8C,OAAO,CAAC1C,IAAR,KAAiB,cAArB,EAAqC;AAC1C;AACA,QAAI8C,QAAQ,GAAG,yBAAYvD,KAAZ,EAAmBE,KAAnB,CAAf,CAF0C,CAI1C;;AACA,QAAIsD,cAAc,GAAG;AACnBC,MAAAA,SAAS,EAAEF,QADQ;AAEnBG,MAAAA,KAAK,EAAE;AAFY,KAArB,CAL0C,CAU1C;;AACA,QAAIC,MAAJ;;AACA,QAAI;AACFA,MAAAA,MAAM,GAAGC,yCAAyC,CAAC5D,KAAD,EAAQmD,OAAO,CAACU,QAAhB,EAA0BL,cAA1B,EAA0CpD,UAA1C,EAAsDC,GAAtD,CAAlD;AACD,KAFD,CAEE,OAAOyD,KAAP,EAAc;AACd;AACA,UAAIN,cAAc,CAACE,KAAf,KAAyB,KAAzB,IAAkCI,KAAK,YAAYC,6BAAvD,EAAyE;AACvE,cAAM,2BAAc/D,KAAd,EAAqBuD,QAArB,EAA+BO,KAA/B,CAAN;AACD;;AACD,YAAMA,KAAN;AACD,KApByC,CAsB1C;;;AACA,QAAIN,cAAc,CAACE,KAAf,KAAyB,KAA7B,EAAoC;AAClC,UAAIM,UAAU,GAAG,2BAAchE,KAAd,EAAqBuD,QAArB,EAA+B,IAAIU,mCAAJ,CAA2BjE,KAAK,CAACc,UAAN,CAAiByB,SAA5C,CAA/B,CAAjB;;AACA,UAAIyB,UAAU,YAAYD,6BAA1B,EAA4C;AAC1C,cAAMC,UAAN;AACD;AACF,KA5ByC,CA8B1C;;;AACA,WAAOL,MAAP;AACD;AACF,C,CAED;;;AACO,SAASC,yCAAT,CACL5D,KADK,EAELkE,SAFK,EAGLV,cAHK,EAILpD,UAJK,EAKLC,GALK,EAMmB;AACxB,MAAIwD,QAAQ,GAAGK,SAAf,CADwB,CAExB;AACA;AACA;AACA;;AACA,MAAIC,MAAJ;;AACA,MAAIN,QAAQ,CAACtC,MAAT,GAAkB,CAAtB,EAAyB;AACvB,QAAI6C,MAAM,GAAGP,QAAQ,CAACA,QAAQ,CAACtC,MAAT,GAAkB,CAAnB,CAArB;;AACA,QAAI6C,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAAC3D,IAAP,KAAgB,aAAvC,EAAsD;AACpD0D,MAAAA,MAAM,GAAGC,MAAT;AACAP,MAAAA,QAAQ,GAAGA,QAAQ,CAACpC,KAAT,CAAe,CAAf,EAAkB,CAAC,CAAnB,CAAX;AACD;AACF;;AAED,OAAK,IAAI4C,OAAT,IAAoBR,QAApB,EAA8B;AAC5B,QAAIQ,OAAO,KAAK,IAAhB,EAAsB;AACpB;AAEA;AACA,UAAIb,cAAc,CAACE,KAAf,KAAyB,KAA7B,EAAoC;AAClC;AACA,YAAIY,IAAJ;;AACA,YAAI;AACFA,UAAAA,IAAI,GAAG,0BAAatE,KAAb,EAAoBwD,cAAc,CAACC,SAAnC,CAAP;AACD,SAFD,CAEE,OAAOc,CAAP,EAAU;AACV;AACA,cAAIA,CAAC,YAAYR,6BAAjB,EAAmC;AACjCP,YAAAA,cAAc,CAACE,KAAf,GAAuB,IAAvB;AACD,WAJS,CAKV;;;AACA,gBAAMa,CAAN;AACD,SAZiC,CAalC;;;AACA,YAAID,IAAI,KAAK,KAAb,EAAoB;AAClBd,UAAAA,cAAc,CAACE,KAAf,GAAuB,IAAvB;AACD;AACF,OArBmB,CAsBpB;;;AACA;AACD,KAzB2B,CA2B5B;;;AAEA,QAAIpD,6BAAJ;AACA,QAAI2B,WAAJ;;AAEA,QAAIoC,OAAO,CAAC5D,IAAR,KAAiB,mBAArB,EAA0C;AACxCwB,MAAAA,WAAW,GAAGoC,OAAO,CAACnC,KAAtB;AACA5B,MAAAA,6BAA6B,GAAG+D,OAAO,CAACtC,IAAxC;AACD,KAHD,MAGO;AACLzB,MAAAA,6BAA6B,GAAG+D,OAAhC;AACD;;AAED,QAAI7D,IAAJ,CAvC4B,CAyC5B;AACA;AACA;AACA;AACA;;AACA,QACEF,6BAA6B,CAACG,IAA9B,KAAuC,eAAvC,IACAH,6BAA6B,CAACG,IAA9B,KAAuC,cAFzC,EAGE;AACA;AACAD,MAAAA,IAAI,GAAGH,GAAG,CAACK,QAAJ,CAAaJ,6BAAb,EAA4CF,UAA5C,CAAP,CAFA,CAIA;AACD;;AAED,QAAIF,KAAJ,CAxD4B,CA0D5B;;AACA,QAAIsD,cAAc,CAACE,KAAf,KAAyB,KAA7B,EAAoC;AAClC;AACA,UAAIY,IAAJ;;AACA,UAAI;AACFA,QAAAA,IAAI,GAAG,0BAAatE,KAAb,EAAoBwD,cAAc,CAACC,SAAnC,CAAP;AACD,OAFD,CAEE,OAAOc,CAAP,EAAU;AACV;AACA,YAAIA,CAAC,YAAYR,6BAAjB,EAAmC;AACjCP,UAAAA,cAAc,CAACE,KAAf,GAAuB,IAAvB;AACD,SAJS,CAKV;;;AACA,cAAMa,CAAN;AACD,OAZiC,CAclC;;;AACA,UAAID,IAAI,KAAK,KAAb,EAAoB;AAClBd,QAAAA,cAAc,CAACE,KAAf,GAAuB,IAAvB,CADkB,CAElB;AACA;;AACAxD,QAAAA,KAAK,GAAGF,KAAK,CAACc,UAAN,CAAiByB,SAAzB;AACD,OALD,MAKO;AACL;AACA;AACA,YAAI;AACFrC,UAAAA,KAAK,GAAG,2BAAcF,KAAd,EAAqBsE,IAArB,CAAR;AACD,SAFD,CAEE,OAAOC,CAAP,EAAU;AACV;AACA,cAAIA,CAAC,YAAYR,6BAAjB,EAAmC;AACjCP,YAAAA,cAAc,CAACE,KAAf,GAAuB,IAAvB;AACD,WAJS,CAKV;;;AACA,gBAAMa,CAAN;AACD;AACF;AACF,KAlCD,MAkCO;AACL;AACArE,MAAAA,KAAK,GAAGF,KAAK,CAACc,UAAN,CAAiByB,SAAzB;AACD;;AAED,QAAID,CAAJ,CAlG4B,CAoG5B;;AACA,QAAIL,WAAW,IAAI/B,KAAK,YAAYsC,qBAApC,EAAoD;AAClD;AACA,UAAIC,YAAY,GAAGpC,GAAG,CAACK,QAAJ,CAAauB,WAAb,EAA0B7B,UAA1B,CAAnB,CAFkD,CAIlD;;AACAkC,MAAAA,CAAC,GAAGF,wBAAYM,QAAZ,CAAqB1C,KAArB,EAA4ByC,YAA5B,CAAJ;AACD,KAND,MAMO;AACL;AACAH,MAAAA,CAAC,GAAGpC,KAAJ;AACD,KA9G2B,CAgH5B;AACA;AACA;AACA;AACA;;;AACA,QACEI,6BAA6B,CAACG,IAA9B,KAAuC,eAAvC,IACAH,6BAA6B,CAACG,IAA9B,KAAuC,cAFzC,EAGE;AACA;AACA,UAAIU,uBAAuB,GAAGb,6BAA9B,CAFA,CAIA;;AACAc,MAAAA,iCAAiC,CAACpB,KAAD,EAAQmB,uBAAR,EAAiCmB,CAAjC,EAAoClC,UAApC,EAAgDC,GAAhD,CAAjC;AACA;AACD,KA/H2B,CAiI5B;AACA;;;AACA,4BAAUG,IAAV,EAnI4B,CAqI5B;;AACA,QACEyB,WAAW,IACX/B,KAAK,YAAYsC,qBADjB,IAEA,2CAA8BxC,KAA9B,EAAqCiC,WAArC,CAFA,IAGA,6BAAgBjC,KAAhB,EAAuBM,6BAAvB,CAHA,IAIAgC,CAAC,YAAYK,kBALf,EAME;AACA;AACA,UAAIC,eAAe,GAAG,4BAAe5C,KAAf,EAAsBsC,CAAtB,EAAyB,MAAzB,CAAtB,CAFA,CAIA;;AACA,UAAIM,eAAe,KAAK,KAAxB,EAA+B;AAC7B;AACA;AACA;AACA,gCAAUpC,IAAI,YAAYgE,sBAA1B;;AAEA3B,8BAAUC,eAAV,CAA0B9C,KAA1B,EAAiCsC,CAAjC,EAAoCF,wBAAYqC,iBAAZ,CAA8BzE,KAA9B,EAAqCQ,IAArC,CAApC;AACD;AACF,KAzJ2B,CA2J5B;;;AACAS,2BAAWC,QAAX,CAAoBlB,KAApB,EAA2BQ,IAA3B,EAAiC8B,CAAjC;;AACA;AACD,GA7KuB,CA+KxB;;;AACA,MAAI6B,MAAJ,EAAY;AACV;AACA,QAAI7D,6BAA6B,GAAG6D,MAAM,CAAC5D,QAA3C;AAEA,QAAIC,IAAJ,CAJU,CAMV;AACA;AACA;AACA;AACA;;AACA,QACEF,6BAA6B,CAACG,IAA9B,KAAuC,eAAvC,IACAH,6BAA6B,CAACG,IAA9B,KAAuC,cAFzC,EAGE;AACA;AACAD,MAAAA,IAAI,GAAGH,GAAG,CAACK,QAAJ,CAAaJ,6BAAb,EAA4CF,UAA5C,CAAP,CAFA,CAIA;AACD,KAnBS,CAqBV;;;AACA,QAAIsE,CAAC,GAAG9D,mBAAO+D,WAAP,CAAmB3E,KAAnB,EAA0B,CAA1B,CAAR,CAtBU,CAwBV;;;AACA,QAAI4E,CAAC,GAAG,CAAR,CAzBU,CA2BV;;AACA,WAAOpB,cAAc,CAACE,KAAf,KAAyB,KAAhC,EAAuC;AACrC;AACA,UAAIY,IAAJ;;AACA,UAAI;AACFA,QAAAA,IAAI,GAAG,0BAAatE,KAAb,EAAoBwD,cAAc,CAACC,SAAnC,CAAP;AACD,OAFD,CAEE,OAAOc,CAAP,EAAU;AACV;AACA,YAAIA,CAAC,YAAYR,6BAAjB,EAAmC;AACjCP,UAAAA,cAAc,CAACE,KAAf,GAAuB,IAAvB;AACD,SAJS,CAKV;;;AACA,cAAMa,CAAN;AACD,OAZoC,CAcrC;;;AACA,UAAID,IAAI,KAAK,KAAb,EAAoB;AAClBd,QAAAA,cAAc,CAACE,KAAf,GAAuB,IAAvB;AACD,OAFD,MAEO;AACL;AACA;AACA,YAAImB,SAAJ;;AACA,YAAI;AACFA,UAAAA,SAAS,GAAG,2BAAc7E,KAAd,EAAqBsE,IAArB,CAAZ;AACD,SAFD,CAEE,OAAOC,CAAP,EAAU;AACV;AACA,cAAIA,CAAC,YAAYR,6BAAjB,EAAmC;AACjCP,YAAAA,cAAc,CAACE,KAAf,GAAuB,IAAvB;AACD,WAJS,CAKV;;;AACA,gBAAMa,CAAN;AACD,SAbI,CAeL;;;AACA,YAAIO,MAAM,GAAGlE,mBAAOmE,kBAAP,CAA0B/E,KAA1B,EAAiC0E,CAAjC,EAAoCE,CAAC,CAACI,QAAF,EAApC,EAAkDH,SAAlD,CAAb,CAhBK,CAkBL;;;AACA,gCAAUC,MAAV,EAAkB,kCAAlB,EAnBK,CAqBL;;AACAF,QAAAA,CAAC,IAAI,CAAL;AACD;AACF,KArES,CAuEV;;;AACA,QACEtE,6BAA6B,CAACG,IAA9B,KAAuC,eAAvC,IACAH,6BAA6B,CAACG,IAA9B,KAAuC,cAFzC,EAGE;AACA;AACA;AACA,8BAAUD,IAAV,EAHA,CAKA;;AACA,aAAOS,uBAAWC,QAAX,CAAoBlB,KAApB,EAA2BQ,IAA3B,EAAiCkE,CAAjC,CAAP;AACD,KAVD,MAUO;AACL;AACA,UAAIvD,uBAAuB,GAAGb,6BAA9B,CAFK,CAIL;;AACA,aAAOc,iCAAiC,CAACpB,KAAD,EAAQmB,uBAAR,EAAiCuD,CAAjC,EAAoCtE,UAApC,EAAgDC,GAAhD,CAAxC;AACD;AACF;AACF,C,CAED;;;AACO,SAAS2C,sCAAT,CACLhD,KADK,EAELiF,IAFK,EAGL/E,KAHK,EAILgF,YAJK,EAKL9E,UALK,EAMLC,GANK,EAOmB;AACxB,MAAIC,6BAAJ;AACA,MAAI2B,WAAJ;;AAEA,MAAIgD,IAAI,CAACxE,IAAL,KAAc,mBAAlB,EAAuC;AACrCwB,IAAAA,WAAW,GAAGgD,IAAI,CAAC/C,KAAnB;AACA5B,IAAAA,6BAA6B,GAAG2E,IAAI,CAAClD,IAArC;AACD,GAHD,MAGO;AACLzB,IAAAA,6BAA6B,GAAG2E,IAAhC;AACD;;AAED,MAAIzE,IAAJ,CAXwB,CAaxB;AACA;AACA;AACA;AACA;;AACA,MAAIF,6BAA6B,CAACG,IAA9B,KAAuC,eAAvC,IAA0DH,6BAA6B,CAACG,IAA9B,KAAuC,cAArG,EAAqH;AACnH;AACAD,IAAAA,IAAI,GAAGH,GAAG,CAACK,QAAJ,CAAaJ,6BAAb,EAA4CF,UAA5C,CAAP,CAFmH,CAInH;AACD;;AAED,MAAI+E,QAAJ,CAzBwB,CA2BxB;;AACA,MAAI7C,CAAC,GAAG,kBAAKtC,KAAL,EAAYE,KAAZ,EAAmBgF,YAAnB,CAAR,CA5BwB,CA8BxB;;AACA,MAAIjD,WAAW,IAAIK,CAAC,YAAYE,qBAAhC,EAAgD;AAC9C;AACA,QAAIC,YAAY,GAAGpC,GAAG,CAACK,QAAJ,CAAauB,WAAb,EAA0B7B,UAA1B,CAAnB,CAF8C,CAI9C;;AACA+E,IAAAA,QAAQ,GAAG/C,wBAAYM,QAAZ,CAAqB1C,KAArB,EAA4ByC,YAA5B,CAAX;AACD,GAND,MAMO;AACL;AACA0C,IAAAA,QAAQ,GAAG7C,CAAX;AACD,GAxCuB,CA0CxB;AACA;AACA;AACA;AACA;;;AACA,MAAIhC,6BAA6B,CAACG,IAA9B,KAAuC,eAAvC,IAA0DH,6BAA6B,CAACG,IAA9B,KAAuC,cAArG,EAAqH;AACnH;AACA,QAAI2E,iBAAiB,GAAG9E,6BAAxB,CAFmH,CAInH;;AACA,WAAOc,iCAAiC,CAACpB,KAAD,EAAQoF,iBAAR,EAA2BD,QAA3B,EAAqC/E,UAArC,EAAiDC,GAAjD,CAAxC;AACD,GArDuB,CAuDxB;AACA;;;AACA,0BAAUG,IAAV,EAzDwB,CA2DxB;;AACA,MACEyB,WAAW,IACXK,CAAC,YAAYE,qBADb,IAEA,2CAA8BxC,KAA9B,EAAqCiC,WAArC,CAFA,IAGA,6BAAgBjC,KAAhB,EAAuBM,6BAAvB,CAHA,IAIA6E,QAAQ,YAAYxC,kBALtB,EAME;AACA;AACA,QAAIC,eAAe,GAAG,4BAAe5C,KAAf,EAAsBmF,QAAtB,EAAgC,MAAhC,CAAtB,CAFA,CAIA;;AACA,QAAIvC,eAAe,KAAK,KAAxB,EAA+B;AAC7B;AACA;AACA;AACA,8BAAUpC,IAAI,YAAYgE,sBAA1B;;AAEA3B,4BAAUC,eAAV,CAA0B9C,KAA1B,EAAiCmF,QAAjC,EAA2C/C,wBAAYqC,iBAAZ,CAA8BzE,KAA9B,EAAqCQ,IAArC,CAA3C;AACD;AACF,GA/EuB,CAiFxB;;;AACA,SAAOS,uBAAWC,QAAX,CAAoBlB,KAApB,EAA2BQ,IAA3B,EAAiC2E,QAAjC,CAAP;AACD","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport invariant from \"../invariant.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Reference } from \"../environment.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport { Value, ObjectValue, UndefinedValue, StringValue, SymbolValue } from \"../values/index.js\";\nimport { AbruptCompletion, SimpleNormalCompletion } from \"../completions.js\";\nimport { EvalPropertyName } from \"../evaluators/ObjectExpression.js\";\nimport {\n  RequireObjectCoercible,\n  GetIterator,\n  IteratorClose,\n  IteratorStep,\n  IteratorValue,\n  IsAnonymousFunctionDefinition,\n  IsIdentifierRef,\n  HasOwnProperty,\n  GetV,\n} from \"./index.js\";\nimport { Create, Environment, Functions, Properties } from \"../singletons.js\";\nimport type {\n  BabelNodeIdentifier,\n  BabelNodeAssignmentPattern,\n  BabelNodeObjectProperty,\n  BabelNodeRestElement,\n  BabelNodeLVal,\n  BabelNodeArrayPattern,\n  BabelNodeObjectPattern,\n} from \"@babel/types\";\n\nfunction RestDestructuringAssignmentEvaluation(\n  realm: Realm,\n  property: BabelNodeRestElement,\n  value: Value,\n  excludedNames: Array<PropertyKeyValue>,\n  strictCode: boolean,\n  env: LexicalEnvironment\n): void | boolean | Value {\n  let DestructuringAssignmentTarget = property.argument;\n\n  let lref;\n  // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then\n  if (DestructuringAssignmentTarget.type !== \"ObjectPattern\" && DestructuringAssignmentTarget.type !== \"ArrayPattern\") {\n    // a. Let lref be the result of evaluating DestructuringAssignmentTarget.\n    lref = env.evaluate(DestructuringAssignmentTarget, strictCode);\n\n    // b. ReturnIfAbrupt(lref).\n  }\n\n  // 2. Let restObj be ObjectCreate(%ObjectPrototype%).\n  let restObj = Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n  // 3. Let assignStatus be CopyDataProperties(restObj, value, excludedNames).\n  /* let assignStatus = */ Create.CopyDataProperties(realm, restObj, value, excludedNames);\n  // 4. ReturnIfAbrupt(assignStatus).\n\n  // 5. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then\n  if (DestructuringAssignmentTarget.type !== \"ObjectPattern\" && DestructuringAssignmentTarget.type !== \"ArrayPattern\") {\n    invariant(lref);\n    // Return PutValue(lref, restObj).\n    return Properties.PutValue(realm, lref, restObj);\n  }\n\n  // 6. Let nestedAssignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern[?Yield, ?Await] as the goal symbol, adopting the parameter values from AssignmentRestElement.\n  let nestedAssignmentPattern = DestructuringAssignmentTarget;\n\n  return DestructuringAssignmentEvaluation(realm, nestedAssignmentPattern, restObj, strictCode, env);\n}\n\nfunction PropertyDestructuringAssignmentEvaluation(\n  realm: Realm,\n  properties: Array<BabelNodeObjectProperty>,\n  value: Value,\n  strictCode: boolean,\n  env: LexicalEnvironment\n): Array<string | StringValue | SymbolValue> {\n  // Base condition for recursive call below\n  if (properties.length === 0) {\n    return [];\n  }\n\n  let AssignmentProperty = properties.slice(-1)[0];\n  let AssignmentPropertyList = properties.slice(0, -1);\n\n  // 1. Let propertyNames be the result of performing PropertyDestructuringAssignmentEvaluation for AssignmentPropertyList using value as the argument.\n  let propertyNames = PropertyDestructuringAssignmentEvaluation(realm, AssignmentPropertyList, value, strictCode, env);\n\n  // 2. ReturnIfAbrupt(status propertyNames).\n\n  // Let nextNames be the result of performing PropertyDestructuringAssignmentEvaluation for AssignmentProperty using value as the argument.\n  let nextNames;\n\n  // AssignmentProperty : IdentifierReference Initializer\n  if (\n    AssignmentProperty.key.type === \"Identifier\" &&\n    ((AssignmentProperty.value.type === \"Identifier\" &&\n      AssignmentProperty.value.name === AssignmentProperty.key.name) ||\n      (AssignmentProperty.value.type === \"AssignmentPattern\" &&\n        AssignmentProperty.value.left.name === AssignmentProperty.key.name)) &&\n    AssignmentProperty.computed === false\n  ) {\n    let Initializer;\n\n    if (AssignmentProperty.value.type === \"AssignmentPattern\") {\n      Initializer = (AssignmentProperty.value: BabelNodeAssignmentPattern).right;\n    }\n\n    // 1. Let P be StringValue of IdentifierReference.\n    let P = (AssignmentProperty.key: BabelNodeIdentifier).name;\n\n    // 2. Let lref be ? ResolveBinding(P).\n    let lref = Environment.ResolveBinding(realm, P, strictCode, env);\n\n    // 3. Let v be ? GetV(value, P).\n    let v = GetV(realm, value, P);\n\n    // 4. If Initializer is present and v is undefined, then\n    if (Initializer !== undefined && v instanceof UndefinedValue) {\n      // 4a. Let defaultValue be the result of evaluating Initializer.\n      let defaultValue = env.evaluate(Initializer, strictCode);\n\n      // 4b. Let v be ? GetValue(defaultValue).\n      v = Environment.GetValue(realm, defaultValue);\n\n      // 4c. If IsAnonymousFunctionDefinition(Initializer) is true, then\n      if (IsAnonymousFunctionDefinition(realm, Initializer)) {\n        invariant(v instanceof ObjectValue);\n\n        // i. Let hasNameProperty be ? HasOwnProperty(v, \"name\").\n        let hasNameProperty = HasOwnProperty(realm, v, \"name\");\n\n        // j. If hasNameProperty is false, perform SetFunctionName(v, P).\n        if (hasNameProperty === false) {\n          Functions.SetFunctionName(realm, v, P);\n        }\n      }\n    }\n\n    // Perform ? PutValue(lref, v).\n    Properties.PutValue(realm, lref, v);\n\n    // Return a new List containing P.\n    nextNames = [new StringValue(realm, P)];\n  } else {\n    // AssignmentProperty : PropertyName:AssignmentElement\n\n    // 1. Let name be the result of evaluating PropertyName.\n    let name = EvalPropertyName(AssignmentProperty, env, realm, strictCode);\n\n    // 2. ReturnIfAbrupt(name).\n\n    // 3. Let status be the result of performing KeyedDestructuringAssignmentEvaluation of AssignmentElement with value and name as the arguments.\n    /* let status = */ KeyedDestructuringAssignmentEvaluation(\n      realm,\n      // $FlowFixMe\n      AssignmentProperty.value,\n      value,\n      name,\n      strictCode,\n      env\n    );\n\n    // 4. ReturnIfAbrupt(status).\n\n    // 5. Return a new List containing name.\n    nextNames = [name];\n  }\n\n  // 4. ReturnIfAbrupt(nextNames).\n\n  invariant(nextNames instanceof Array);\n  // 5. Append each item in nextNames to the end of propertyNames.\n  propertyNames = propertyNames.concat(nextNames);\n\n  // 6. Return propertyNames.\n  return propertyNames;\n}\n\n// 2.1 Object Rest/Spread Properties\nexport function DestructuringAssignmentEvaluation(\n  realm: Realm,\n  pattern: BabelNodeArrayPattern | BabelNodeObjectPattern,\n  value: Value,\n  strictCode: boolean,\n  env: LexicalEnvironment\n): void | boolean | Value {\n  if (pattern.type === \"ObjectPattern\") {\n    let AssignmentPropertyList = [],\n      AssignmentRestElement = null;\n\n    for (let property of pattern.properties) {\n      if (property.type === \"RestElement\") {\n        AssignmentRestElement = property;\n      } else {\n        AssignmentPropertyList.push(property);\n      }\n    }\n\n    // ObjectAssignmentPattern:\n    //   { AssignmentPropertyList }\n    //   { AssignmentPropertyList, }\n    if (!AssignmentRestElement) {\n      // 1. Perform ? RequireObjectCoercible(value).\n      RequireObjectCoercible(realm, value);\n\n      // 2. Perform ? PropertyDestructuringAssignmentEvaluation for AssignmentPropertyList using value as the argument.\n      PropertyDestructuringAssignmentEvaluation(realm, AssignmentPropertyList, value, strictCode, env);\n\n      // 3. Return NormalCompletion(empty).\n      return realm.intrinsics.empty;\n    }\n\n    // ObjectAssignmentPattern : { AssignmentRestElement }\n    if (AssignmentPropertyList.length === 0) {\n      // 1. Let excludedNames be a new empty List.\n      let excludedNames = [];\n\n      // 2. Return the result of performing RestDestructuringAssignmentEvaluation of AssignmentRestElement with value and excludedNames as the arguments.\n      return RestDestructuringAssignmentEvaluation(realm, AssignmentRestElement, value, excludedNames, strictCode, env);\n    } else {\n      // ObjectAssignmentPattern : { AssignmentPropertyList, AssignmentRestElement }\n      // 1. Let excludedNames be the result of performing ? PropertyDestructuringAssignmentEvaluation for AssignmentPropertyList using value as the argument.\n      let excludedNames = PropertyDestructuringAssignmentEvaluation(\n        realm,\n        AssignmentPropertyList,\n        value,\n        strictCode,\n        env\n      );\n\n      // 2. Return the result of performing RestDestructuringAssignmentEvaluation of AssignmentRestElement with value and excludedNames as the arguments.\n      return RestDestructuringAssignmentEvaluation(realm, AssignmentRestElement, value, excludedNames, strictCode, env);\n    }\n  } else if (pattern.type === \"ArrayPattern\") {\n    // 1. Let iterator be ? GetIterator(value).\n    let iterator = GetIterator(realm, value);\n\n    // 2. Let iteratorRecord be Record {[[Iterator]]: iterator, [[Done]]: false}.\n    let iteratorRecord = {\n      $Iterator: iterator,\n      $Done: false,\n    };\n\n    // 3. Let result be the result of performing IteratorDestructuringAssignmentEvaluation of AssignmentElementList using iteratorRecord as the argument.\n    let result;\n    try {\n      result = IteratorDestructuringAssignmentEvaluation(realm, pattern.elements, iteratorRecord, strictCode, env);\n    } catch (error) {\n      // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).\n      if (iteratorRecord.$Done === false && error instanceof AbruptCompletion) {\n        throw IteratorClose(realm, iterator, error);\n      }\n      throw error;\n    }\n\n    // 4. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iterator, result).\n    if (iteratorRecord.$Done === false) {\n      let completion = IteratorClose(realm, iterator, new SimpleNormalCompletion(realm.intrinsics.undefined));\n      if (completion instanceof AbruptCompletion) {\n        throw completion;\n      }\n    }\n\n    // 5. Return result.\n    return result;\n  }\n}\n\n// ECMA262 12.15.5.3\nexport function IteratorDestructuringAssignmentEvaluation(\n  realm: Realm,\n  _elements: $ReadOnlyArray<BabelNodeLVal | null>,\n  iteratorRecord: { $Iterator: ObjectValue, $Done: boolean },\n  strictCode: boolean,\n  env: LexicalEnvironment\n): void | boolean | Value {\n  let elements = _elements;\n  // Check if the last element is a rest element. If so then we want to save the\n  // element and handle it separately after we iterate through the other\n  // formals. This also enforces that a rest element may only ever be in the\n  // last position.\n  let restEl;\n  if (elements.length > 0) {\n    let lastEl = elements[elements.length - 1];\n    if (lastEl !== null && lastEl.type === \"RestElement\") {\n      restEl = lastEl;\n      elements = elements.slice(0, -1);\n    }\n  }\n\n  for (let element of elements) {\n    if (element === null) {\n      // Elision handling\n\n      // 1. If iteratorRecord.[[Done]] is false, then\n      if (iteratorRecord.$Done === false) {\n        // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n        let next;\n        try {\n          next = IteratorStep(realm, iteratorRecord.$Iterator);\n        } catch (e) {\n          // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // c. ReturnIfAbrupt(next).\n          throw e;\n        }\n        // d. If next is false, set iteratorRecord.[[Done]] to true.\n        if (next === false) {\n          iteratorRecord.$Done = true;\n        }\n      }\n      // 2. Return NormalCompletion(empty).\n      continue;\n    }\n\n    // AssignmentElement : DestructuringAssignmentTarget Initializer\n\n    let DestructuringAssignmentTarget;\n    let Initializer;\n\n    if (element.type === \"AssignmentPattern\") {\n      Initializer = element.right;\n      DestructuringAssignmentTarget = element.left;\n    } else {\n      DestructuringAssignmentTarget = element;\n    }\n\n    let lref;\n\n    // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then\n    //\n    // The spec assumes we haven't yet distinguished between literals and\n    // patterns, but our parser does that work for us. That means we check for\n    // \"*Pattern\" instead of \"*Literal\" like the spec text suggests.\n    if (\n      DestructuringAssignmentTarget.type !== \"ObjectPattern\" &&\n      DestructuringAssignmentTarget.type !== \"ArrayPattern\"\n    ) {\n      // a. Let lref be the result of evaluating DestructuringAssignmentTarget.\n      lref = env.evaluate(DestructuringAssignmentTarget, strictCode);\n\n      // b. ReturnIfAbrupt(lref).\n    }\n\n    let value;\n\n    // 2. If iteratorRecord.[[Done]] is false, then\n    if (iteratorRecord.$Done === false) {\n      // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n      let next;\n      try {\n        next = IteratorStep(realm, iteratorRecord.$Iterator);\n      } catch (e) {\n        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        if (e instanceof AbruptCompletion) {\n          iteratorRecord.$Done = true;\n        }\n        // c. ReturnIfAbrupt(next).\n        throw e;\n      }\n\n      // d. If next is false, set iteratorRecord.[[Done]] to true.\n      if (next === false) {\n        iteratorRecord.$Done = true;\n        // Normally this assignment would be done in step 3, but we do it\n        // here so that Flow knows `value` will always be initialized by step 4.\n        value = realm.intrinsics.undefined;\n      } else {\n        // e. Else,\n        // i. Let value be IteratorValue(next).\n        try {\n          value = IteratorValue(realm, next);\n        } catch (e) {\n          // ii. If value is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // iii. ReturnIfAbrupt(v).\n          throw e;\n        }\n      }\n    } else {\n      // 3. If iteratorRecord.[[Done]] is true, let value be undefined.\n      value = realm.intrinsics.undefined;\n    }\n\n    let v;\n\n    // 4. If Initializer is present and value is undefined, then\n    if (Initializer && value instanceof UndefinedValue) {\n      // a. Let defaultValue be the result of evaluating Initializer.\n      let defaultValue = env.evaluate(Initializer, strictCode);\n\n      // b. Let v be ? GetValue(defaultValue).\n      v = Environment.GetValue(realm, defaultValue);\n    } else {\n      // 5. Else, let v be value.\n      v = value;\n    }\n\n    // 6. If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, then\n    //\n    // The spec assumes we haven't yet distinguished between literals and\n    // patterns, but our parser does that work for us. That means we check for\n    // \"*Pattern\" instead of \"*Literal\" like the spec text suggests.\n    if (\n      DestructuringAssignmentTarget.type === \"ObjectPattern\" ||\n      DestructuringAssignmentTarget.type === \"ArrayPattern\"\n    ) {\n      // a. Let nestedAssignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern or AssignmentPattern[Yield] as the goal symbol depending upon whether this AssignmentElement has the [Yield] parameter.\n      let nestedAssignmentPattern = DestructuringAssignmentTarget;\n\n      // b. Return the result of performing DestructuringAssignmentEvaluation of nestedAssignmentPattern with v as the argument.\n      DestructuringAssignmentEvaluation(realm, nestedAssignmentPattern, v, strictCode, env);\n      continue;\n    }\n\n    // We know `lref` exists because of how the algorithm is setup, but tell\n    // Flow that `lref` exists with an `invariant()`.\n    invariant(lref);\n\n    // 7. If Initializer is present and value is undefined and IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of DestructuringAssignmentTarget are both true, then\n    if (\n      Initializer &&\n      value instanceof UndefinedValue &&\n      IsAnonymousFunctionDefinition(realm, Initializer) &&\n      IsIdentifierRef(realm, DestructuringAssignmentTarget) &&\n      v instanceof ObjectValue\n    ) {\n      // a. Let hasNameProperty be ? HasOwnProperty(v, \"name\").\n      let hasNameProperty = HasOwnProperty(realm, v, \"name\");\n\n      // b. If hasNameProperty is false, perform SetFunctionName(v, GetReferencedName(lref)).\n      if (hasNameProperty === false) {\n        // All of the nodes that may be evaluated to produce lref create\n        // references. Assert this with an invariant as GetReferencedName may\n        // not be called with a value.\n        invariant(lref instanceof Reference);\n\n        Functions.SetFunctionName(realm, v, Environment.GetReferencedName(realm, lref));\n      }\n    }\n\n    // 8. Return ? PutValue(lref, v).\n    Properties.PutValue(realm, lref, v);\n    continue;\n  }\n\n  // Handle the rest element if we have one.\n  if (restEl) {\n    // AssignmentRestElement : ...DestructuringAssignmentTarget\n    let DestructuringAssignmentTarget = restEl.argument;\n\n    let lref;\n\n    // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then\n    //\n    // The spec assumes we haven't yet distinguished between literals and\n    // patterns, but our parser does that work for us. That means we check for\n    // \"*Pattern\" instead of \"*Literal\" like the spec text suggests.\n    if (\n      DestructuringAssignmentTarget.type !== \"ObjectPattern\" &&\n      DestructuringAssignmentTarget.type !== \"ArrayPattern\"\n    ) {\n      // a. Let lref be the result of evaluating DestructuringAssignmentTarget.\n      lref = env.evaluate(DestructuringAssignmentTarget, strictCode);\n\n      // b. ReturnIfAbrupt(lref).\n    }\n\n    // 2. Let A be ArrayCreate(0).\n    let A = Create.ArrayCreate(realm, 0);\n\n    // 3. Let n be 0.\n    let n = 0;\n\n    // 4. Repeat while iteratorRecord.[[Done]] is false,\n    while (iteratorRecord.$Done === false) {\n      // a. Let next be IteratorStep(iteratorRecord.[[Iterator]]).\n      let next;\n      try {\n        next = IteratorStep(realm, iteratorRecord.$Iterator);\n      } catch (e) {\n        // b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        if (e instanceof AbruptCompletion) {\n          iteratorRecord.$Done = true;\n        }\n        // c. ReturnIfAbrupt(next).\n        throw e;\n      }\n\n      // d. If next is false, set iteratorRecord.[[Done]] to true.\n      if (next === false) {\n        iteratorRecord.$Done = true;\n      } else {\n        // e. Else,\n        // i. Let nextValue be IteratorValue(next).\n        let nextValue;\n        try {\n          nextValue = IteratorValue(realm, next);\n        } catch (e) {\n          // ii. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (e instanceof AbruptCompletion) {\n            iteratorRecord.$Done = true;\n          }\n          // iii. ReturnIfAbrupt(nextValue).\n          throw e;\n        }\n\n        // iv. Let status be CreateDataProperty(A, ! ToString(n), nextValue).\n        let status = Create.CreateDataProperty(realm, A, n.toString(), nextValue);\n\n        // v. Assert: status is true.\n        invariant(status, \"expected to create data property\");\n\n        // vi. Increment n by 1.\n        n += 1;\n      }\n    }\n\n    // 5. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then\n    if (\n      DestructuringAssignmentTarget.type !== \"ObjectPattern\" &&\n      DestructuringAssignmentTarget.type !== \"ArrayPattern\"\n    ) {\n      // `lref` will always be defined at this point. Let Flow know with an\n      // invariant.\n      invariant(lref);\n\n      // a. Return ? PutValue(lref, A).\n      return Properties.PutValue(realm, lref, A);\n    } else {\n      // 6. Let nestedAssignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern or AssignmentPattern[Yield] as the goal symbol depending upon whether this AssignmentElement has the [Yield] parameter.\n      let nestedAssignmentPattern = DestructuringAssignmentTarget;\n\n      // 7. Return the result of performing DestructuringAssignmentEvaluation of nestedAssignmentPattern with A as the argument.\n      return DestructuringAssignmentEvaluation(realm, nestedAssignmentPattern, A, strictCode, env);\n    }\n  }\n}\n\n// ECMA262 12.15.5.4\nexport function KeyedDestructuringAssignmentEvaluation(\n  realm: Realm,\n  node: BabelNodeLVal,\n  value: Value,\n  propertyName: PropertyKeyValue,\n  strictCode: boolean,\n  env: LexicalEnvironment\n): void | boolean | Value {\n  let DestructuringAssignmentTarget;\n  let Initializer;\n\n  if (node.type === \"AssignmentPattern\") {\n    Initializer = node.right;\n    DestructuringAssignmentTarget = node.left;\n  } else {\n    DestructuringAssignmentTarget = node;\n  }\n\n  let lref;\n\n  // 1. If DestructuringAssignmentTarget is neither an ObjectLiteral nor an ArrayLiteral, then\n  //\n  // The spec assumes we haven't yet distinguished between literals and\n  // patterns, but our parser does that work for us. That means we check for\n  // \"*Pattern\" instead of \"*Literal\" like the spec text suggests.\n  if (DestructuringAssignmentTarget.type !== \"ObjectPattern\" && DestructuringAssignmentTarget.type !== \"ArrayPattern\") {\n    // a. Let lref be the result of evaluating DestructuringAssignmentTarget.\n    lref = env.evaluate(DestructuringAssignmentTarget, strictCode);\n\n    // b. ReturnIfAbrupt(lref).\n  }\n\n  let rhsValue;\n\n  // 2. Let v be ? GetV(value, propertyName).\n  let v = GetV(realm, value, propertyName);\n\n  // 3. If Initializer is present and v is undefined, then\n  if (Initializer && v instanceof UndefinedValue) {\n    // a. Let defaultValue be the result of evaluating Initializer.\n    let defaultValue = env.evaluate(Initializer, strictCode);\n\n    // b. Let rhsValue be ? GetValue(defaultValue).\n    rhsValue = Environment.GetValue(realm, defaultValue);\n  } else {\n    // 4. Else, let rhsValue be v.\n    rhsValue = v;\n  }\n\n  // 5. If DestructuringAssignmentTarget is an ObjectLiteral or an ArrayLiteral, then\n  //\n  // The spec assumes we haven't yet distinguished between literals and\n  // patterns, but our parser does that work for us. That means we check for\n  // \"*Pattern\" instead of \"*Literal\" like the spec text suggests.\n  if (DestructuringAssignmentTarget.type === \"ObjectPattern\" || DestructuringAssignmentTarget.type === \"ArrayPattern\") {\n    // a. Let assignmentPattern be the parse of the source text corresponding to DestructuringAssignmentTarget using either AssignmentPattern or AssignmentPattern[Yield] as the goal symbol depending upon whether this AssignmentElement has the [Yield] parameter.\n    let assignmentPattern = DestructuringAssignmentTarget;\n\n    // b. Return the result of performing DestructuringAssignmentEvaluation of assignmentPattern with rhsValue as the argument.\n    return DestructuringAssignmentEvaluation(realm, assignmentPattern, rhsValue, strictCode, env);\n  }\n\n  // `lref` will always be defined at this point. Let Flow know with an\n  // invariant.\n  invariant(lref);\n\n  // 6. If Initializer is present and v is undefined and IsAnonymousFunctionDefinition(Initializer) and IsIdentifierRef of DestructuringAssignmentTarget are both true, then\n  if (\n    Initializer &&\n    v instanceof UndefinedValue &&\n    IsAnonymousFunctionDefinition(realm, Initializer) &&\n    IsIdentifierRef(realm, DestructuringAssignmentTarget) &&\n    rhsValue instanceof ObjectValue\n  ) {\n    // a. Let hasNameProperty be ? HasOwnProperty(rhsValue, \"name\").\n    let hasNameProperty = HasOwnProperty(realm, rhsValue, \"name\");\n\n    // b. If hasNameProperty is false, perform SetFunctionName(rhsValue, GetReferencedName(lref)).\n    if (hasNameProperty === false) {\n      // All of the nodes that may be evaluated to produce lref create\n      // references. Assert this with an invariant as GetReferencedName may\n      // not be called with a value.\n      invariant(lref instanceof Reference);\n\n      Functions.SetFunctionName(realm, rhsValue, Environment.GetReferencedName(realm, lref));\n    }\n  }\n\n  // 7. Return ? PutValue(lref, rhsValue).\n  return Properties.PutValue(realm, lref, rhsValue);\n}\n"],"file":"destructuring.js"}