{"version":3,"sources":["../../src/methods/properties.js"],"names":["StringKey","key","StringValue","value","FatalError","InternalDescriptorPropertyToValue","realm","undefined","intrinsics","BooleanValue","Value","InternalGetPropertiesKey","P","SymbolValue","InternalGetPropertiesMap","O","properties","symbols","InternalSetProperty","desc","map","propertyBinding","get","descriptor","object","set","recordModifiedProperty","InternalUpdatedProperty","oldDesc","generator","isIntrinsic","temporalAlias","mightBeLeakedObject","mightBeFinalObject","$GlobalObject","emitGlobalDelete","emitPropertyDelete","throwIfNotConcrete","descValue","configurable","enumerable","writable","emitGlobalDeclaration","emitGlobalAssignment","emitDefineProperty","emitPropertyAssignment","PropertyDescriptor","leakDescriptor","AbstractJoinedDescriptor","descriptor1","descriptor2","Leak","val","parentPermitsChildPropertyCreation","isSimpleObject","ownDesc","$GetOwnProperty","mightHaveBeenDeleted","parent","$GetPrototypeOf","NullValue","throwIfNotConcreteObject","ensureIsNotFinal","mightNotBeFinalObject","instantRender","enabled","instantRenderBailout","currentLocation","error","CompilerDiagnostic","handleError","isWidenedValue","v","AbstractValue","kind","a","args","PropertiesImplementation","OrdinarySet","V","Receiver","ignoreLeakLogic","weakDeletion","$Set","joinCondition","e1","Path","withCondition","evaluateForEffects","OrdinarySetHelper","result","result1","generator1","modifiedBindings","modifiedBindings1","modifiedProperties","modifiedProperties1","createdObjects","createdObjects1","e2","withInverseCondition","result2","generator2","modifiedBindings2","modifiedProperties2","createdObjects2","joinedEffects","Join","joinEffects","Effects","applyEffects","To","ToBooleanPartial","returnOrThrowCompletion","mightBeObject","ObjectValue","AbstractObjectValue","existingDescriptor","existingDescValue","reportIntrospectionError","valueDesc","$DefineOwnProperty","Create","CreateDataProperty","setter","UndefinedValue","OrdinarySetPartial","pIsLoopVar","pIsNumeric","isTypeCompatibleWith","getType","NumberValue","mightNotBeString","mightNotBeNumber","isInPureScope","evaluateWithPossibleThrowCompletion","TypesDomain","topVal","ValuesDomain","abstractOverO","values","isTop","elements","getElements","has","PrimitiveValue","ToStringAbstract","createTemplate","propName","createFromBinaryOp","prop","unknownProperty","newVal","cond","sentinel","createFromType","createFromConditionalOp","oldVal","savedUnknownProperty","delete","empty","d","FromPropertyDescriptor","Desc","obj","ObjectCreate","ObjectPrototype","getExtensible","size","success","OrdinaryDelete","isPartialObject","DeletePropertyOrThrow","$Delete","createErrorThrowCompletion","TypeError","CompletePropertyDescriptor","_Desc","like","IsCompatiblePropertyDescriptor","extensible","current","ValidateAndApplyPropertyDescriptor","_current","jc","implies","createFromUnaryOp","mightNotBeTrue","allAbsent","field","identical","dval","cval","ConcreteValue","currentValue","unknownEnumerable","unknownWritable","OrdinaryDefineOwnProperty","ObjectDefineProperties","Properties","mightNotBeObject","props","ToObject","keys","$OwnPropertyKeys","descriptors","nextKey","propDesc","ThrowIfMightHaveBeenDeleted","descObj","ToPropertyDescriptor","push","pair","DefinePropertyOrThrow","Set","Throw","PutValue","W","promoteEmptyToUndefined","Reference","ReferenceError","base","Environment","GetBase","IsUnresolvableReference","IsStrictReference","globalObj","GetReferencedName","IsPropertyReference","HasPrimitiveBase","succeeded","$SetPartial","GetReferencedNamePartial","EnvironmentRecord","referencedName","SetMutableBinding","ArraySetLength","A","DescValue","newLenDesc","newLen","ToUint32","numberLen","ToNumber","RangeError","oldLenDesc","OrdinaryGetOwnProperty","oldLen","newWritable","oldLenCopy","Array","from","x","parseInt","filter","sort","reverse","deleteSucceeded","existingBinding","absVal","createTemporalFromBuildFunction","_templateFor","isPure","useAbstractInterpretation","createAbstractPropertyValue","type","isTransitivelySimple","createFromBuildFunction","makeKind","skipInvariant","makeSimple","createAbstractConcreteUnion","null","invariantLevel","ArrayValue","isIntrinsicAndHasWidenedNumericProperty","realmGenerator","hasBindingBeenChecked","markPropertyAsChecked","emitPropertyInvariant","callReportPropertyAccess","D","X","savedUnion","operationDescriptor","functionResultType","deriveAbstract","types","concreteValues","e","length","emitFullInvariant","OrdinarySetPrototypeOf","$Prototype","p","done","usesOrdinaryObjectInternalPrototypeMethods","EnumerateObjectProperties","visited","global","index","iterator","defineNativeMethod","proto","CreateIterResultObject","add","$Realm","simplifyAndRefineAbstractValue","ThrowIfInternalSlotNotWritable","isNewObject","PropertyDefinitionEvaluation","MethodDefinition","env","strictCode","methodDef","Functions","DefineMethod","SetFunctionName","$Closure","$Key","$HasComputedName","computed","propKey","strict","body","scope","closure","GeneratorFunctionCreate","params","MakeMethod","prototype","GeneratorPrototype","originalConstructor","formalParameterList","FunctionCreate","GetOwnPropertyKeysArray","allowAbstractKeys","getOwnPropertyKeysEvenIfPartial","keyArray","pb","pv","callReportObjectGetOwnProperties"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { construct_empty_effects, type Realm, Effects } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding, PropertyKeyValue } from \"../types.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  ArrayValue,\n  BooleanValue,\n  ConcreteValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  PrimitiveValue,\n  Value,\n} from \"../values/index.js\";\nimport { EvalPropertyName } from \"../evaluators/ObjectExpression.js\";\nimport { EnvironmentRecord, Reference } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport invariant from \"../invariant.js\";\nimport {\n  Call,\n  Get,\n  GetGlobalObject,\n  GetThisValue,\n  HasCompatibleType,\n  HasSomeCompatibleType,\n  IsAccessorDescriptor,\n  IsDataDescriptor,\n  IsGenericDescriptor,\n  IsPropertyKey,\n  MakeConstructor,\n  SameValue,\n  SameValuePartial,\n} from \"./index.js\";\nimport { type BabelNodeObjectMethod, type BabelNodeClassMethod, isValidIdentifier } from \"@babel/types\";\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport { Create, Environment, Functions, Leak, Join, Path, To } from \"../singletons.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport { createOperationDescriptor } from \"../utils/generator.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { cloneDescriptor, equalDescriptors, PropertyDescriptor, AbstractJoinedDescriptor } from \"../descriptors.js\";\n\nfunction StringKey(key: PropertyKeyValue): string {\n  if (key instanceof StringValue) key = key.value;\n  if (typeof key !== \"string\") {\n    // The generator currently only supports string keys.\n    throw new FatalError();\n  }\n  return key;\n}\n\nfunction InternalDescriptorPropertyToValue(realm: Realm, value: void | boolean | Value) {\n  if (value === undefined) return realm.intrinsics.undefined;\n  if (typeof value === \"boolean\") return new BooleanValue(realm, value);\n  invariant(value instanceof Value);\n  return value;\n}\n\nfunction InternalGetPropertiesKey(P: PropertyKeyValue): string | SymbolValue | void {\n  if (typeof P === \"string\") {\n    return P;\n  } else if (P instanceof StringValue) {\n    return P.value;\n  } else if (P instanceof SymbolValue) {\n    return P;\n  }\n  // otherwise, undefined\n}\n\nfunction InternalGetPropertiesMap(O: ObjectValue, P: PropertyKeyValue): Map<any, PropertyBinding> {\n  if (typeof P === \"string\" || P instanceof StringValue) {\n    return O.properties;\n  } else if (P instanceof SymbolValue) {\n    return O.symbols;\n  } else {\n    invariant(false);\n  }\n}\n\nfunction InternalSetProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue, desc: Descriptor) {\n  let map = InternalGetPropertiesMap(O, P);\n  let key = InternalGetPropertiesKey(P);\n  let propertyBinding = map.get(key);\n  if (propertyBinding === undefined) {\n    propertyBinding = { descriptor: undefined, object: O, key: key };\n    map.set(key, propertyBinding);\n  }\n  realm.recordModifiedProperty(propertyBinding);\n  propertyBinding.descriptor = desc;\n}\n\nfunction InternalUpdatedProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue, oldDesc?: Descriptor) {\n  let generator = realm.generator;\n  if (!generator) return;\n  if (!O.isIntrinsic() && O.temporalAlias === undefined) return;\n  if (P instanceof SymbolValue) return;\n  if (P instanceof StringValue) P = P.value;\n  invariant(!O.mightBeLeakedObject()); // leaked objects are never updated\n  invariant(!O.mightBeFinalObject()); // final objects are never updated\n  invariant(typeof P === \"string\");\n  let propertyBinding = InternalGetPropertiesMap(O, P).get(P);\n  invariant(propertyBinding !== undefined); // The callers ensure this\n  let desc = propertyBinding.descriptor;\n  if (desc === undefined) {\n    // The property is being deleted\n    if (O === realm.$GlobalObject) {\n      generator.emitGlobalDelete(P);\n    } else {\n      generator.emitPropertyDelete(O, P);\n    }\n  } else {\n    desc = desc.throwIfNotConcrete(realm);\n    if (oldDesc === undefined) {\n      // The property is being created\n      if (O === realm.$GlobalObject) {\n        if (IsDataDescriptor(realm, desc)) {\n          let descValue = desc.value || realm.intrinsics.undefined;\n          if (isValidIdentifier(P) && !desc.configurable && desc.enumerable && desc.writable) {\n            generator.emitGlobalDeclaration(P, descValue);\n          } else if (desc.configurable && desc.enumerable && desc.writable) {\n            generator.emitGlobalAssignment(P, descValue);\n          } else {\n            generator.emitDefineProperty(O, P, desc);\n          }\n        } else {\n          generator.emitDefineProperty(O, P, desc);\n        }\n      } else {\n        if (IsDataDescriptor(realm, desc) && desc.configurable && desc.enumerable && desc.writable) {\n          let descValue = desc.value || realm.intrinsics.undefined;\n          generator.emitPropertyAssignment(O, P, descValue);\n        } else {\n          generator.emitDefineProperty(O, P, desc);\n        }\n      }\n    } else {\n      invariant(oldDesc instanceof PropertyDescriptor);\n      // The property is being modified\n      if (equalDescriptors(desc, oldDesc)) {\n        invariant(IsDataDescriptor(realm, desc));\n        let descValue = desc.value || realm.intrinsics.undefined;\n        // only the value is being modified\n        if (O === realm.$GlobalObject) {\n          generator.emitGlobalAssignment(P, descValue);\n        } else {\n          generator.emitPropertyAssignment(O, P, descValue);\n        }\n      } else {\n        generator.emitDefineProperty(O, P, desc, /*isDescChanged*/ true);\n      }\n    }\n  }\n}\n\nfunction leakDescriptor(realm: Realm, desc: Descriptor) {\n  if (desc instanceof AbstractJoinedDescriptor) {\n    if (desc.descriptor1) {\n      leakDescriptor(realm, desc.descriptor1);\n    }\n    if (desc.descriptor2) {\n      leakDescriptor(realm, desc.descriptor2);\n    }\n  }\n  invariant(desc instanceof PropertyDescriptor);\n\n  if (desc.value) {\n    if (desc.value instanceof Value) Leak.value(realm, desc.value);\n    else if (desc.value !== undefined) {\n      for (let val of desc.value) Leak.value(realm, val);\n    }\n  }\n  if (desc.get) {\n    Leak.value(realm, desc.get);\n  }\n  if (desc.set) {\n    Leak.value(realm, desc.set);\n  }\n}\n\n// Determines if an object with parent O may create its own property P.\nfunction parentPermitsChildPropertyCreation(realm: Realm, O: ObjectValue, P: PropertyKeyValue): boolean {\n  if (O.isSimpleObject()) {\n    // Simple object always allow property creation since there are no setters.\n    // Object.prototype is considered simple even though __proto__ is a setter.\n    // TODO: That is probably the incorrect assumption but that is implied everywhere.\n    return true;\n  }\n\n  let ownDesc = O.$GetOwnProperty(P);\n  if (!ownDesc || ownDesc.mightHaveBeenDeleted()) {\n    // O might not object, so first ask its parent\n    let parent = O.$GetPrototypeOf();\n    if (!(parent instanceof NullValue)) {\n      parent = parent.throwIfNotConcreteObject(); //TODO #1016: deal with abstract parents\n      if (!parentPermitsChildPropertyCreation(realm, parent, P)) return false;\n    }\n\n    // Parent is OK, so if O does not object return true\n    if (!ownDesc) return true; // O has no opinion of its ownDesc\n  }\n  invariant(ownDesc !== undefined);\n\n  // O might have a property P and so might object\n  if (IsDataDescriptor(realm, ownDesc)) {\n    if (ownDesc.writable) {\n      // The grand parent does not object so it is OK that parent does not have P\n      // If parent does have P, it is also OK because it is a writable data property\n      return true;\n    }\n  }\n  // If parent does not have property P, this is too pessimistic, but that is\n  // the caller's problem.\n  return false;\n}\n\nfunction ensureIsNotFinal(realm: Realm, O: ObjectValue, P: void | PropertyKeyValue) {\n  if (O.mightNotBeFinalObject()) {\n    return;\n  }\n\n  // We can't continue because this object is already in its final state\n  if (realm.instantRender.enabled) {\n    realm.instantRenderBailout(\n      \"Object mutations that require materialization are currently not supported by InstantRender\",\n      realm.currentLocation\n    );\n  } else {\n    let error = new CompilerDiagnostic(\n      \"Mutating a final object, or an object with unknown properties, after some of those \" +\n        \"properties have already been used, is not supported.\",\n      realm.currentLocation,\n      \"PP0026\",\n      \"FatalError\"\n    );\n    realm.handleError(error);\n    throw new FatalError();\n  }\n}\n\nfunction isWidenedValue(v: void | Value) {\n  if (!(v instanceof AbstractValue)) return false;\n  if (v.kind === \"widened\" || v.kind === \"widened property\") return true;\n  for (let a of v.args) {\n    if (isWidenedValue(a)) return true;\n  }\n  return false;\n}\n\nexport class PropertiesImplementation {\n  // ECMA262 9.1.9.1\n  OrdinarySet(realm: Realm, O: ObjectValue, P: PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    ensureIsNotFinal(realm, O, P);\n    if (!realm.ignoreLeakLogic && O.mightBeLeakedObject()) {\n      // Leaking is transitive, hence writing a value to a leaked object leaks the value\n      Leak.value(realm, V);\n      // The receiver might leak to a getter so if it's not already leaked, we need to leak it.\n      Leak.value(realm, Receiver);\n      if (realm.generator !== undefined) {\n        realm.generator.emitPropertyAssignment(Receiver, StringKey(P), V);\n      }\n      return true;\n    }\n\n    let weakDeletion = V.mightHaveBeenDeleted();\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let ownDesc be ? O.[[GetOwnProperty]](P).\n    let ownDesc = O.$GetOwnProperty(P);\n\n    // 3. If ownDesc is undefined (or might be), then\n    if (!ownDesc || ownDesc.mightHaveBeenDeleted()) {\n      // a. Let parent be ? O.[[GetPrototypeOf]]().\n      let parent = O.$GetPrototypeOf();\n\n      // b. If parent is not null, then\n      if (!(parent instanceof NullValue)) {\n        parent = parent.throwIfNotConcreteObject(); //TODO #1016: deal with abstract parents\n        if (!ownDesc) {\n          // i. Return ? parent.[[Set]](P, V, Receiver).\n          return parent.$Set(P, V, Receiver);\n        }\n        // But since we don't know if O has its own property P, the parent might\n        // actually have a say. Give up, unless the parent would be OK with it.\n        if (!parentPermitsChildPropertyCreation(realm, parent, P)) {\n          // TODO: Join the effects depending on if the property was deleted or not.\n          let error = new CompilerDiagnostic(\n            \"assignment might or might not invoke a setter\",\n            realm.currentLocation,\n            \"PP0043\",\n            \"RecoverableError\"\n          );\n          if (realm.handleError(error) !== \"Recover\") {\n            throw new FatalError();\n          }\n          // If we recover, we assume that the parent would've been fine creating the property.\n        }\n        // Since the parent is OK with us creating a local property for O\n        // we can carry on as if there were no parent.\n      }\n\n      // i. Let ownDesc be the PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}.\n      if (!ownDesc)\n        ownDesc = new PropertyDescriptor({\n          value: realm.intrinsics.undefined,\n          writable: true,\n          enumerable: true,\n          configurable: true,\n        });\n    }\n\n    // joined descriptors need special treatment\n    if (ownDesc instanceof AbstractJoinedDescriptor) {\n      let joinCondition = ownDesc.joinCondition;\n      let descriptor2 = ownDesc.descriptor2;\n      ownDesc = ownDesc.descriptor1;\n      let e1 = Path.withCondition(joinCondition, () => {\n        return ownDesc !== undefined\n          ? realm.evaluateForEffects(() => new BooleanValue(realm, OrdinarySetHelper()), undefined, \"OrdinarySet/1\")\n          : construct_empty_effects(realm);\n      });\n      let {\n        result: result1,\n        generator: generator1,\n        modifiedBindings: modifiedBindings1,\n        modifiedProperties: modifiedProperties1,\n        createdObjects: createdObjects1,\n      } = e1;\n      ownDesc = descriptor2;\n      let e2 = Path.withInverseCondition(joinCondition, () => {\n        return ownDesc !== undefined\n          ? realm.evaluateForEffects(() => new BooleanValue(realm, OrdinarySetHelper()), undefined, \"OrdinarySet/2\")\n          : construct_empty_effects(realm);\n      });\n      let {\n        result: result2,\n        generator: generator2,\n        modifiedBindings: modifiedBindings2,\n        modifiedProperties: modifiedProperties2,\n        createdObjects: createdObjects2,\n      } = e2;\n\n      // Join the effects, creating an abstract view of what happened, regardless\n      // of the actual value of ownDesc.joinCondition.\n      let joinedEffects = Join.joinEffects(\n        joinCondition,\n        new Effects(result1, generator1, modifiedBindings1, modifiedProperties1, createdObjects1),\n        new Effects(result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2)\n      );\n      realm.applyEffects(joinedEffects);\n      return To.ToBooleanPartial(realm, realm.returnOrThrowCompletion(joinedEffects.result));\n    }\n\n    return OrdinarySetHelper();\n\n    function OrdinarySetHelper(): boolean {\n      invariant(ownDesc !== undefined);\n      // 4. If IsDataDescriptor(ownDesc) is true, then\n      if (IsDataDescriptor(realm, ownDesc)) {\n        // a. If ownDesc.[[Writable]] is false, return false.\n        if (!ownDesc.writable && !weakDeletion) {\n          // The write will fail if the property actually exists\n          if (ownDesc.value && ownDesc.value.mightHaveBeenDeleted()) {\n            // But maybe it does not and thus would succeed.\n            // Since we don't know what will happen, give up for now.\n            // TODO: Join the effects depending on if the property was deleted or not.\n            let error = new CompilerDiagnostic(\n              \"assignment might or might not invoke a setter\",\n              realm.currentLocation,\n              \"PP0043\",\n              \"RecoverableError\"\n            );\n            if (realm.handleError(error) !== \"Recover\") {\n              throw new FatalError();\n            }\n            // If we recover we assume that the property was there.\n          }\n          return false;\n        }\n\n        // b. If Type(Receiver) is not Object, return false.\n        if (!Receiver.mightBeObject()) return false;\n        invariant(Receiver instanceof ObjectValue || Receiver instanceof AbstractObjectValue);\n\n        // c. Let existingDescriptor be ? Receiver.[[GetOwnProperty]](P).\n        let existingDescriptor = Receiver.$GetOwnProperty(P);\n        if (existingDescriptor instanceof AbstractJoinedDescriptor) {\n          if (existingDescriptor.descriptor1 === ownDesc) existingDescriptor = ownDesc;\n          else if (existingDescriptor.descriptor2 === ownDesc) existingDescriptor = ownDesc;\n        }\n        let existingDescValue = !existingDescriptor\n          ? realm.intrinsics.undefined\n          : existingDescriptor.value === undefined\n            ? realm.intrinsics.undefined\n            : existingDescriptor.value;\n        invariant(existingDescValue instanceof Value);\n\n        // d. If existingDescriptor is not undefined, then\n        if (existingDescriptor !== undefined) {\n          // i. If IsAccessorDescriptor(existingDescriptor) is true, return false.\n          if (IsAccessorDescriptor(realm, existingDescriptor)) {\n            invariant(\n              !existingDescValue.mightHaveBeenDeleted(),\n              \"should not fail until weak deletes of accessors are suppported\"\n            );\n            return false;\n          }\n\n          // ii. If existingDescriptor.[[Writable]] is false, return false.\n          if (!existingDescriptor.writable && !(weakDeletion && existingDescriptor.configurable)) {\n            // If we are not sure the receiver actually has a property P we can't just return false here.\n            if (existingDescValue.mightHaveBeenDeleted()) {\n              invariant(existingDescValue instanceof AbstractValue);\n              AbstractValue.reportIntrospectionError(existingDescValue);\n              throw new FatalError();\n            }\n            return false;\n          }\n\n          // iii. Let valueDesc be the PropertyDescriptor{[[Value]]: V}.\n          let valueDesc = new PropertyDescriptor({ value: V });\n\n          // iv. Return ? Receiver.[[DefineOwnProperty]](P, valueDesc).\n          if (weakDeletion || existingDescValue.mightHaveBeenDeleted()) {\n            // At this point we are not sure that Receiver actually has a property P.\n            // If, however, it has -> P. If, however, it has, we are sure that its a\n            // data property, and that redefining the property with valueDesc will not\n            // change the attributes of the property, so we can reuse the existing\n            // descriptor.\n            valueDesc = existingDescriptor;\n            valueDesc.throwIfNotConcrete(realm).value = V;\n          }\n          return Receiver.$DefineOwnProperty(P, valueDesc);\n        } else {\n          // e. Else Receiver does not currently have a property P,\n\n          // i. Return ? CreateDataProperty(Receiver, P, V).\n          return Create.CreateDataProperty(realm, Receiver, P, V);\n        }\n      }\n\n      // 5. Assert: IsAccessorDescriptor(ownDesc) is true.\n      invariant(IsAccessorDescriptor(realm, ownDesc), \"expected accessor\");\n\n      // 6. Let setter be ownDesc.[[Set]].\n      let setter = ownDesc.set;\n\n      // 7. If setter is undefined, return false.\n      if (!setter || setter instanceof UndefinedValue) return false;\n\n      // 8. Perform ? Call(setter, Receiver, « V »).\n      Call(realm, setter.throwIfNotConcrete(), Receiver, [V]);\n\n      // 9. Return true.\n      return true;\n    }\n  }\n\n  OrdinarySetPartial(\n    realm: Realm,\n    O: ObjectValue,\n    P: AbstractValue | PropertyKeyValue,\n    V: Value,\n    Receiver: Value\n  ): boolean {\n    if (!(P instanceof AbstractValue)) return O.$Set(P, V, Receiver);\n    let pIsLoopVar = isWidenedValue(P);\n    let pIsNumeric = Value.isTypeCompatibleWith(P.getType(), NumberValue);\n\n    // A string coercion might have side-effects.\n    // TODO #1682: We assume that simple objects mean that they don't have a\n    // side-effectful valueOf and toString but that's not enforced.\n    if (P.mightNotBeString() && P.mightNotBeNumber() && !P.isSimpleObject()) {\n      if (realm.isInPureScope()) {\n        // If we're in pure scope, we can leak the key and keep going.\n        // Coercion can only have effects on anything reachable from the key.\n        Leak.value(realm, P);\n      } else {\n        let error = new CompilerDiagnostic(\n          \"property key might not have a well behaved toString or be a symbol\",\n          realm.currentLocation,\n          \"PP0002\",\n          \"RecoverableError\"\n        );\n        if (realm.handleError(error) !== \"Recover\") {\n          throw new FatalError();\n        }\n      }\n    }\n\n    // We assume that simple objects have no getter/setter properties and\n    // that all properties are writable.\n    if (!O.isSimpleObject()) {\n      if (realm.isInPureScope()) {\n        // If we're in pure scope, we can leak the object and leave an\n        // assignment in place.\n        Leak.value(realm, Receiver);\n        // We also need to leak the value since it might leak to a setter.\n        Leak.value(realm, V);\n        realm.evaluateWithPossibleThrowCompletion(\n          () => {\n            let generator = realm.generator;\n            invariant(generator);\n            invariant(P instanceof AbstractValue);\n            generator.emitPropertyAssignment(Receiver, P, V);\n            return realm.intrinsics.undefined;\n          },\n          TypesDomain.topVal,\n          ValuesDomain.topVal\n        );\n        // The emitted assignment might throw at runtime but if it does, that\n        // is handled by evaluateWithPossibleThrowCompletion. Anything that\n        // happens after this, can assume we didn't throw and therefore,\n        // we return true here.\n        return true;\n      } else {\n        let error = new CompilerDiagnostic(\n          \"unknown property access might need to invoke a setter\",\n          realm.currentLocation,\n          \"PP0030\",\n          \"RecoverableError\"\n        );\n        if (realm.handleError(error) !== \"Recover\") {\n          throw new FatalError();\n        }\n      }\n    }\n\n    // We should never consult the prototype chain for unknown properties.\n    // If it was simple, it would've been an assignment to the receiver.\n    // The only case the Receiver isn't this, if this was a ToObject\n    // coercion from a PrimitiveValue.\n    let abstractOverO = false;\n    if (Receiver instanceof AbstractObjectValue && !Receiver.values.isTop()) {\n      let elements = Receiver.values.getElements();\n      invariant(elements);\n      if (elements.has(O)) {\n        abstractOverO = true;\n      }\n    }\n    invariant(O === Receiver || HasCompatibleType(Receiver, PrimitiveValue) || abstractOverO);\n\n    P = To.ToStringAbstract(realm, P);\n\n    function createTemplate(propName: AbstractValue) {\n      return AbstractValue.createFromBinaryOp(\n        realm,\n        \"===\",\n        propName,\n        new StringValue(realm, \"\"),\n        undefined,\n        \"template for property name condition\"\n      );\n    }\n\n    let prop;\n    if (O.unknownProperty === undefined) {\n      prop = {\n        descriptor: undefined,\n        object: O,\n        key: P,\n      };\n      O.unknownProperty = prop;\n    } else {\n      prop = O.unknownProperty;\n    }\n    realm.recordModifiedProperty(prop);\n    let desc = prop.descriptor;\n    if (desc === undefined) {\n      let newVal = V;\n      if (!(V instanceof UndefinedValue) && !isWidenedValue(P)) {\n        // join V with sentinel, using a property name test as the condition\n        let cond = createTemplate(P);\n        let sentinel = AbstractValue.createFromType(realm, Value, \"template for prototype member expression\", [\n          Receiver,\n          P,\n        ]);\n        newVal = AbstractValue.createFromConditionalOp(realm, cond, V, sentinel);\n      }\n      prop.descriptor = new PropertyDescriptor({\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: newVal,\n      });\n    } else {\n      invariant(\n        desc instanceof PropertyDescriptor,\n        \"unknown properties are only created with Set and have equal descriptors\"\n      );\n      // join V with current value of O.unknownProperty. I.e. weak update.\n      let oldVal = desc.value;\n      invariant(oldVal);\n      let newVal = oldVal;\n      if (!(V instanceof UndefinedValue)) {\n        if (isWidenedValue(P)) {\n          newVal = V; // It will be widened later on\n        } else {\n          let cond = createTemplate(P);\n          newVal = AbstractValue.createFromConditionalOp(realm, cond, V, oldVal);\n        }\n      }\n      desc.value = newVal;\n    }\n\n    // Since we don't know the name of the property we are writing to, we also need\n    // to perform weak updates of all of the known properties.\n    // First clear out O.unknownProperty so that helper routines know its OK to update the properties\n    let savedUnknownProperty = O.unknownProperty;\n    O.unknownProperty = undefined;\n    for (let [key, propertyBinding] of O.properties) {\n      if (pIsLoopVar && pIsNumeric) {\n        // Delete numeric properties and don't do weak updates on other properties.\n        if (key !== +key + \"\") continue;\n        O.properties.delete(key);\n        continue;\n      }\n      let oldVal = realm.intrinsics.empty;\n      if (propertyBinding.descriptor) {\n        let d = propertyBinding.descriptor.throwIfNotConcrete(realm);\n        if (d.value) {\n          oldVal = d.value;\n        }\n      }\n      let cond = AbstractValue.createFromBinaryOp(realm, \"===\", P, new StringValue(realm, key));\n      let newVal = AbstractValue.createFromConditionalOp(realm, cond, V, oldVal);\n      this.OrdinarySet(realm, O, key, newVal, Receiver);\n    }\n    O.unknownProperty = savedUnknownProperty;\n\n    return true;\n  }\n\n  // ECMA262 6.2.4.4\n  FromPropertyDescriptor(realm: Realm, Desc: ?Descriptor): Value {\n    // 1. If Desc is undefined, return undefined.\n    if (!Desc) return realm.intrinsics.undefined;\n\n    if (Desc instanceof AbstractJoinedDescriptor) {\n      return AbstractValue.createFromConditionalOp(\n        realm,\n        Desc.joinCondition,\n        this.FromPropertyDescriptor(realm, Desc.descriptor1),\n        this.FromPropertyDescriptor(realm, Desc.descriptor2)\n      );\n    }\n    invariant(Desc instanceof PropertyDescriptor);\n\n    // 2. Let obj be ObjectCreate(%ObjectPrototype%).\n    let obj = Create.ObjectCreate(realm, realm.intrinsics.ObjectPrototype);\n\n    // 3. Assert: obj is an extensible ordinary object with no own properties.\n    invariant(obj.getExtensible(), \"expected an extensible object\");\n    invariant(!obj.properties.size, \"expected an object with no own properties\");\n\n    // 4. If Desc has a [[Value]] field, then\n    let success = true;\n    if (Desc.value !== undefined) {\n      // a. Perform CreateDataProperty(obj, \"value\", Desc.[[Value]]).\n      success = Create.CreateDataProperty(realm, obj, \"value\", Desc.value) && success;\n    }\n\n    // 5. If Desc has a [[Writable]] field, then\n    if (Desc.writable !== undefined) {\n      // a. Perform CreateDataProperty(obj, \"writable\", Desc.[[Writable]]).\n      success = Create.CreateDataProperty(realm, obj, \"writable\", new BooleanValue(realm, Desc.writable)) && success;\n    }\n\n    // 6. If Desc has a [[Get]] field, then\n    if (Desc.get !== undefined) {\n      // a. Perform CreateDataProperty(obj, \"get\", Desc.[[Get]]).\n      success = Create.CreateDataProperty(realm, obj, \"get\", Desc.get) && success;\n    }\n\n    // 7. If Desc has a [[Set]] field, then\n    if (Desc.set !== undefined) {\n      // a. Perform CreateDataProperty(obj, \"set\", Desc.[[Set]]).\n      success = Create.CreateDataProperty(realm, obj, \"set\", Desc.set) && success;\n    }\n\n    // 8. If Desc has an [[Enumerable]] field, then\n    if (Desc.enumerable !== undefined) {\n      // a. Perform CreateDataProperty(obj, \"enumerable\", Desc.[[Enumerable]]).\n      success =\n        Create.CreateDataProperty(realm, obj, \"enumerable\", new BooleanValue(realm, Desc.enumerable)) && success;\n    }\n\n    // 9. If Desc has a [[Configurable]] field, then\n    if (Desc.configurable !== undefined) {\n      // a. Perform CreateDataProperty(obj, \"configurable\", Desc.[[Configurable]]).\n      success =\n        Create.CreateDataProperty(realm, obj, \"configurable\", new BooleanValue(realm, Desc.configurable)) && success;\n    }\n\n    // 10. Assert: all of the above CreateDataProperty operations return true.\n    invariant(success, \"fails to create data property\");\n\n    // 11. Return obj.\n    return obj;\n  }\n\n  //\n  OrdinaryDelete(realm: Realm, O: ObjectValue, P: PropertyKeyValue): boolean {\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected a property key\");\n\n    // 2. Let desc be ? O.[[GetOwnProperty]](P).\n    let desc = O.$GetOwnProperty(P);\n\n    // 3. If desc is undefined, return true.\n    if (!desc) {\n      ensureIsNotFinal(realm, O, P);\n      if (!realm.ignoreLeakLogic && O.mightBeLeakedObject()) {\n        if (realm.generator !== undefined) {\n          realm.generator.emitPropertyDelete(O, StringKey(P));\n        }\n      }\n      return true;\n    }\n\n    desc = desc.throwIfNotConcrete(realm);\n\n    // 4. If desc.[[Configurable]] is true, then\n    if (desc.configurable) {\n      ensureIsNotFinal(realm, O, P);\n      if (O.mightBeLeakedObject()) {\n        if (realm.generator !== undefined) {\n          realm.generator.emitPropertyDelete(O, StringKey(P));\n        }\n        return true;\n      }\n\n      // a. Remove the own property with name P from O.\n      let key = InternalGetPropertiesKey(P);\n      let map = InternalGetPropertiesMap(O, P);\n      let propertyBinding = map.get(key);\n      if (propertyBinding === undefined && O.isPartialObject() && O.isSimpleObject()) {\n        let generator = realm.generator;\n        if (generator) {\n          invariant(typeof key === \"string\" || key instanceof SymbolValue);\n          generator.emitPropertyDelete(O, StringKey(key));\n          return true;\n        }\n      }\n      invariant(propertyBinding !== undefined);\n      realm.recordModifiedProperty(propertyBinding);\n      propertyBinding.descriptor = undefined;\n      InternalUpdatedProperty(realm, O, P, desc);\n\n      // b. Return true.\n      return true;\n    }\n\n    // 5. Return false.\n    return false;\n  }\n\n  // ECMA262 7.3.8\n  DeletePropertyOrThrow(realm: Realm, O: ObjectValue, P: PropertyKeyValue): boolean {\n    // 1. Assert: Type(O) is Object.\n    invariant(O instanceof ObjectValue, \"expected an object\");\n\n    // 2. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected a property key\");\n\n    // 3. Let success be ? O.[[Delete]](P).\n    let success = O.$Delete(P);\n\n    // 4. If success is false, throw a TypeError exception.\n    if (!success) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"couldn't delete property\");\n    }\n\n    // 5. Return success.\n    return success;\n  }\n\n  // ECMA262 6.2.4.6\n  CompletePropertyDescriptor(realm: Realm, _Desc: Descriptor): Descriptor {\n    // 1. Assert: Desc is a Property Descriptor.\n    let Desc = _Desc.throwIfNotConcrete(realm);\n\n    // 2. Let like be Record{[[Value]]: undefined, [[Writable]]: false, [[Get]]: undefined, [[Set]]: undefined, [[Enumerable]]: false, [[Configurable]]: false}.\n    let like = {\n      value: realm.intrinsics.undefined,\n      get: realm.intrinsics.undefined,\n      set: realm.intrinsics.undefined,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    };\n\n    // 3. If either IsGenericDescriptor(Desc) or IsDataDescriptor(Desc) is true, then\n    if (IsGenericDescriptor(realm, Desc) || IsDataDescriptor(realm, Desc)) {\n      // a. If Desc does not have a [[Value]] field, set Desc.[[Value]] to like.[[Value]].\n      if (Desc.value === undefined) Desc.value = like.value;\n      // b. If Desc does not have a [[Writable]] field, set Desc.[[Writable]] to like.[[Writable]].\n      if (Desc.writable === undefined) Desc.writable = like.writable;\n    } else {\n      // 4. Else,\n      // a. If Desc does not have a [[Get]] field, set Desc.[[Get]] to like.[[Get]].\n      if (Desc.get === undefined) Desc.get = like.get;\n      // b. If Desc does not have a [[Set]] field, set Desc.[[Set]] to like.[[Set]].\n      if (Desc.set === undefined) Desc.set = like.set;\n    }\n\n    // 5. If Desc does not have an [[Enumerable]] field, set Desc.[[Enumerable]] to like.[[Enumerable]].\n    if (Desc.enumerable === undefined) Desc.enumerable = like.enumerable;\n\n    // 6. If Desc does not have a [[Configurable]] field, set Desc.[[Configurable]] to like.[[Configurable]].\n    if (Desc.configurable === undefined) Desc.configurable = like.configurable;\n\n    // 7. Return Desc.\n    return Desc;\n  }\n\n  // ECMA262 9.1.6.2\n  IsCompatiblePropertyDescriptor(realm: Realm, extensible: boolean, Desc: Descriptor, current: ?Descriptor): boolean {\n    // 1. Return ValidateAndApplyPropertyDescriptor(undefined, undefined, Extensible, Desc, Current).\n    return this.ValidateAndApplyPropertyDescriptor(realm, undefined, undefined, extensible, Desc, current);\n  }\n\n  // ECMA262 9.1.6.3\n  ValidateAndApplyPropertyDescriptor(\n    realm: Realm,\n    O: void | ObjectValue,\n    P: void | PropertyKeyValue,\n    extensible: boolean,\n    _Desc: Descriptor,\n    _current: ?Descriptor\n  ): boolean {\n    let Desc = _Desc;\n    let current = _current;\n\n    // 1. Assert: If O is not undefined, then IsPropertyKey(P) is true.\n    if (O !== undefined) {\n      invariant(P !== undefined);\n      invariant(IsPropertyKey(realm, P));\n    }\n\n    if (current instanceof AbstractJoinedDescriptor) {\n      let jc = current.joinCondition;\n      if (Path.implies(jc)) current = current.descriptor1;\n      else if (!AbstractValue.createFromUnaryOp(realm, \"!\", jc, true).mightNotBeTrue()) current = current.descriptor2;\n    }\n\n    // 2. If current is undefined, then\n    if (!current) {\n      // a. If extensible is false, return false.\n      if (!extensible) return false;\n\n      // b. Assert: extensible is true.\n      invariant(extensible === true, \"expected extensible to be true\");\n\n      if (O !== undefined && P !== undefined) {\n        ensureIsNotFinal(realm, O, P);\n        if (!realm.ignoreLeakLogic && O.mightBeLeakedObject()) {\n          leakDescriptor(realm, Desc);\n          if (realm.generator !== undefined) {\n            realm.generator.emitDefineProperty(O, StringKey(P), Desc.throwIfNotConcrete(realm));\n          }\n          return true;\n        }\n      }\n\n      // c. If IsGenericDescriptor(Desc) is true or IsDataDescriptor(Desc) is true, then\n      if (IsGenericDescriptor(realm, Desc) || IsDataDescriptor(realm, Desc)) {\n        // i. If O is not undefined, create an own data property named P of object O whose [[Value]],\n        //    [[Writable]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the\n        //    value of an attribute field of Desc is absent, the attribute of the newly created property is set\n        //    to its default value.\n        if (O !== undefined) {\n          invariant(P !== undefined);\n          InternalSetProperty(\n            realm,\n            O,\n            P,\n            new PropertyDescriptor({\n              value: Desc.value !== undefined ? Desc.value : realm.intrinsics.undefined,\n              writable: Desc.writable !== undefined ? Desc.writable : false,\n              enumerable: Desc.enumerable !== undefined ? Desc.enumerable : false,\n              configurable: Desc.configurable !== undefined ? Desc.configurable : false,\n            })\n          );\n          InternalUpdatedProperty(realm, O, P, undefined);\n        }\n      } else {\n        // d. Else Desc must be an accessor Property Descriptor,\n        // i. If O is not undefined, create an own accessor property named P of object O whose [[Get]],\n        //    [[Set]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the value\n        //    of an attribute field of Desc is absent, the attribute of the newly created property is set to its\n        //    default value.\n        if (O !== undefined) {\n          invariant(P !== undefined);\n          Desc = Desc.throwIfNotConcrete(realm);\n          InternalSetProperty(\n            realm,\n            O,\n            P,\n            new PropertyDescriptor({\n              get: Desc.get !== undefined ? Desc.get : realm.intrinsics.undefined,\n              set: Desc.set !== undefined ? Desc.set : realm.intrinsics.undefined,\n              enumerable: Desc.enumerable !== undefined ? Desc.enumerable : false,\n              configurable: Desc.configurable !== undefined ? Desc.configurable : false,\n            })\n          );\n          InternalUpdatedProperty(realm, O, P, undefined);\n        }\n      }\n\n      // e. Return true.\n      return true;\n    }\n\n    current = current.throwIfNotConcrete(realm);\n    Desc = Desc.throwIfNotConcrete(realm);\n\n    // 3. Return true, if every field in Desc is absent.\n    let allAbsent = true;\n    for (let field in Desc) {\n      if ((Desc: any)[field] !== undefined) {\n        allAbsent = false;\n        break;\n      }\n    }\n    if (allAbsent) return true;\n\n    // 4. Return true, if every field in Desc also occurs in current and the value of every field in Desc is the\n    // same value as the corresponding field in current when compared using the SameValue algorithm.\n    let identical = true;\n    for (let field in Desc) {\n      if ((Desc: any)[field] === undefined) {\n        continue;\n      }\n      if ((current: any)[field] === undefined) {\n        identical = false;\n      } else {\n        let dval = InternalDescriptorPropertyToValue(realm, (Desc: any)[field]);\n        let cval = InternalDescriptorPropertyToValue(realm, (current: any)[field]);\n        if (dval instanceof ConcreteValue && cval instanceof ConcreteValue) identical = SameValue(realm, dval, cval);\n        else {\n          identical = dval === cval;\n          // This might be false now but true at runtime. This does not\n          // matter because the logic for non identical values will still\n          // do the right thing in the cases below that does not blow up\n          // when dealing with an abstract value.\n        }\n      }\n      if (!identical) break;\n    }\n    // Only return here if the assigment is not temporal.\n    if (identical && (O === realm.$GlobalObject || (O !== undefined && !O.isIntrinsic()))) {\n      return true;\n    }\n\n    let mightHaveBeenDeleted = current.value instanceof Value && current.value.mightHaveBeenDeleted();\n\n    // 5. If the [[Configurable]] field of current is false, then\n    if (!current.configurable) {\n      invariant(!mightHaveBeenDeleted, \"a non-configurable property can't be deleted\");\n\n      // a. Return false, if the [[Configurable]] field of Desc is true.\n      if (Desc.configurable) return false;\n\n      // b. Return false, if the [[Enumerable]] field of Desc is present and the [[Enumerable]] fields of current and Desc are the Boolean negation of each other.\n      if (Desc.enumerable !== undefined && Desc.enumerable !== current.enumerable) {\n        return false;\n      }\n    }\n\n    current = current.throwIfNotConcrete(realm);\n    Desc = Desc.throwIfNotConcrete(realm);\n\n    if (O !== undefined && P !== undefined) {\n      ensureIsNotFinal(realm, O, P);\n      if (!realm.ignoreLeakLogic && O.mightBeLeakedObject()) {\n        leakDescriptor(realm, Desc);\n        if (realm.generator !== undefined) {\n          realm.generator.emitDefineProperty(O, StringKey(P), Desc);\n        }\n        return true;\n      }\n    }\n\n    let oldDesc = current;\n    current = cloneDescriptor(current);\n    invariant(current !== undefined);\n\n    // 6. If IsGenericDescriptor(Desc) is true, no further validation is required.\n    if (IsGenericDescriptor(realm, Desc)) {\n    } else if (IsDataDescriptor(realm, current) !== IsDataDescriptor(realm, Desc)) {\n      // 7. Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) have different results, then\n      // a. Return false, if the [[Configurable]] field of current is false.\n      if (!current.configurable) return false;\n\n      // b. If IsDataDescriptor(current) is true, then\n      if (IsDataDescriptor(realm, current)) {\n        // i. If O is not undefined, convert the property named P of object O from a data property to an accessor property.\n        // Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their default values.\n        if (O !== undefined) {\n          invariant(P !== undefined);\n          current.writable = undefined;\n          current.value = undefined;\n          current.get = realm.intrinsics.undefined;\n          current.set = realm.intrinsics.undefined;\n        }\n      } else {\n        // c. Else,\n        // i. If O is not undefined, convert the property named P of object O from an accessor property to a data property. Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their default values.\n        if (O !== undefined) {\n          invariant(P !== undefined);\n          current.get = undefined;\n          current.set = undefined;\n          current.writable = false;\n          current.value = realm.intrinsics.undefined;\n        }\n      }\n    } else if (IsDataDescriptor(realm, current) && IsDataDescriptor(realm, Desc)) {\n      // 8. Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) are both true, then\n      // a. If the [[Configurable]] field of current is false, then\n      if (!current.configurable) {\n        // i. Return false, if the [[Writable]] field of current is false and the [[Writable]] field of Desc is true.\n        if (!current.writable && Desc.writable) return false;\n\n        // ii. If the [[Writable]] field of current is false, then\n        if (!current.writable) {\n          // 1. Return false, if the [[Value]] field of Desc is present and SameValue(Desc.[[Value]], current.[[Value]]) is false.\n          let descValue = Desc.value || realm.intrinsics.undefined;\n          invariant(descValue instanceof Value);\n          let currentValue = current.value || realm.intrinsics.undefined;\n          invariant(currentValue instanceof Value);\n          if (Desc.value && !SameValuePartial(realm, descValue, currentValue)) {\n            return false;\n          }\n        }\n      } else {\n        // b. Else the [[Configurable]] field of current is true, so any change is acceptable.\n      }\n    } else {\n      // 9. Else IsAccessorDescriptor(current) and IsAccessorDescriptor(Desc) are both true,\n      // a. If the [[Configurable]] field of current is false, then\n      if (!current.configurable) {\n        // i. Return false, if the [[Set]] field of Desc is present and SameValue(Desc.[[Set]], current.[[Set]]) is false.\n        if (Desc.set && !SameValuePartial(realm, Desc.set, current.set || realm.intrinsics.undefined)) return false;\n\n        // ii. Return false, if the [[Get]] field of Desc is present and SameValue(Desc.[[Get]], current.[[Get]]) is false.\n        if (Desc.get && !SameValuePartial(realm, Desc.get, current.get || realm.intrinsics.undefined)) return false;\n      }\n    }\n\n    if (mightHaveBeenDeleted) {\n      // If the property might have been deleted, we need to ensure that either\n      // the new descriptor overrides any existing values, or always results in\n      // the default value.\n      let unknownEnumerable = Desc.enumerable === undefined && !!current.enumerable;\n      let unknownWritable = Desc.writable === undefined && !!current.writable;\n      if (unknownEnumerable || unknownWritable) {\n        let error = new CompilerDiagnostic(\n          \"unknown descriptor attributes on deleted property\",\n          realm.currentLocation,\n          \"PP0038\",\n          \"RecoverableError\"\n        );\n        if (realm.handleError(error) !== \"Recover\") {\n          throw new FatalError();\n        }\n      }\n    }\n\n    // 10. If O is not undefined, then\n    if (O !== undefined) {\n      invariant(P !== undefined);\n      let key = InternalGetPropertiesKey(P);\n      let map = InternalGetPropertiesMap(O, P);\n      let propertyBinding = map.get(key);\n      if (propertyBinding === undefined) {\n        propertyBinding = { descriptor: undefined, object: O, key: key };\n        realm.recordModifiedProperty(propertyBinding);\n        propertyBinding.descriptor = current;\n        map.set(key, propertyBinding);\n      } else if (propertyBinding.descriptor === undefined) {\n        realm.recordModifiedProperty(propertyBinding);\n        propertyBinding.descriptor = current;\n      } else {\n        realm.recordModifiedProperty(propertyBinding);\n        propertyBinding.descriptor = current;\n      }\n\n      // a. For each field of Desc that is present, set the corresponding attribute of the property named P of\n      //    object O to the value of the field.\n      for (let field in Desc) {\n        if ((Desc: any)[field] !== undefined) {\n          (current: any)[field] = (Desc: any)[field];\n        }\n      }\n      InternalUpdatedProperty(realm, O, P, oldDesc);\n    }\n\n    // 11. Return true.\n    return true;\n  }\n\n  // ECMA262 9.1.6.1\n  OrdinaryDefineOwnProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue, Desc: Descriptor): boolean {\n    invariant(O instanceof ObjectValue);\n\n    // 1. Let current be ? O.[[GetOwnProperty]](P).\n    let current = O.$GetOwnProperty(P);\n\n    // 2. Let extensible be the value of the [[Extensible]] internal slot of O.\n    let extensible = O.getExtensible();\n\n    // 3. Return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current).\n    return this.ValidateAndApplyPropertyDescriptor(realm, O, P, extensible, Desc, current);\n  }\n\n  // ECMA262 19.1.2.3.1\n  ObjectDefineProperties(realm: Realm, O: Value, Properties: Value): ObjectValue | AbstractObjectValue {\n    // 1. If Type(O) is not Object, throw a TypeError exception.\n    if (O.mightNotBeObject()) {\n      if (O.mightBeObject()) O.throwIfNotConcrete();\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n    invariant(O instanceof ObjectValue || O instanceof AbstractObjectValue);\n\n    // 2. Let props be ? ToObject(Properties).\n    let props = To.ToObject(realm, Properties);\n\n    // 3. Let keys be ? props.[[OwnPropertyKeys]]().\n    let keys = props.$OwnPropertyKeys();\n\n    // 4. Let descriptors be a new empty List.\n    let descriptors = [];\n\n    // 5. Repeat for each element nextKey of keys in List order,\n    for (let nextKey of keys) {\n      // a. Let propDesc be ? props.[[GetOwnProperty]](nextKey).\n      let propDesc = props.$GetOwnProperty(nextKey);\n\n      // b. If propDesc is not undefined and propDesc.[[Enumerable]] is true, then\n      if (propDesc && propDesc.throwIfNotConcrete(realm).enumerable) {\n        this.ThrowIfMightHaveBeenDeleted(propDesc);\n\n        // i. Let descObj be ? Get(props, nextKey).\n        let descObj = Get(realm, props, nextKey);\n\n        // ii. Let desc be ? ToPropertyDescriptor(descObj).\n        let desc = To.ToPropertyDescriptor(realm, descObj);\n\n        // iii. Append the pair (a two element List) consisting of nextKey and desc to the end of descriptors.\n        descriptors.push([nextKey, desc]);\n      }\n    }\n\n    // 6. For each pair from descriptors in list order,\n    for (let pair of descriptors) {\n      // a. Let P be the first element of pair.\n      let P = pair[0];\n\n      // b. Let desc be the second element of pair.\n      let desc = pair[1];\n\n      // c. Perform ? DefinePropertyOrThrow(O, P, desc).\n      this.DefinePropertyOrThrow(realm, O, P, desc);\n    }\n\n    // 7. Return O.\n    return O;\n  }\n\n  // ECMA262 7.3.3\n  Set(realm: Realm, O: ObjectValue | AbstractObjectValue, P: PropertyKeyValue, V: Value, Throw: boolean): boolean {\n    // 1. Assert: Type(O) is Object.\n\n    // 2. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 3. Assert: Type(Throw) is Boolean.\n    invariant(typeof Throw === \"boolean\", \"expected boolean\");\n\n    // 4. Let success be ? O.[[Set]](P, V, O).\n    let success = O.$Set(P, V, O);\n\n    // 5. If success is false and Throw is true, throw a TypeError exception.\n    if (success === false && Throw === true) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 6. Return success.\n    return success;\n  }\n\n  // ECMA262 7.3.7\n  DefinePropertyOrThrow(\n    realm: Realm,\n    O: ObjectValue | AbstractObjectValue,\n    P: PropertyKeyValue,\n    desc: Descriptor\n  ): boolean {\n    // 1. Assert: Type(O) is Object.\n\n    // 2. Assert: IsPropertyKey(P) is true.\n    invariant(typeof P === \"string\" || IsPropertyKey(realm, P), \"expected property key\");\n\n    // 3. Let success be ? O.[[DefineOwnProperty]](P, desc).\n    let success = O.$DefineOwnProperty(P, desc);\n\n    // 4. If success is false, throw a TypeError exception.\n    if (success === false) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 5. Return success.\n    return success;\n  }\n\n  // ECMA262 6.2.3.2\n  PutValue(realm: Realm, V: Value | Reference, W: Value): void | boolean | Value {\n    W = W.promoteEmptyToUndefined();\n    // The following two steps are not necessary as we propagate completions with exceptions.\n    // 1. ReturnIfAbrupt(V).\n    // 2. ReturnIfAbrupt(W).\n\n    // 3. If Type(V) is not Reference, throw a ReferenceError exception.\n    if (!(V instanceof Reference)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, \"can't put a value to a non-reference\");\n    }\n\n    // 4. Let base be GetBase(V).\n    let base = Environment.GetBase(realm, V);\n\n    // 5. If IsUnresolvableReference(V) is true, then\n    if (Environment.IsUnresolvableReference(realm, V)) {\n      // a. If IsStrictReference(V) is true, then\n      if (Environment.IsStrictReference(realm, V)) {\n        // i. Throw a ReferenceError exception.\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n      }\n\n      // b. Let globalObj be GetGlobalObject().\n      let globalObj = GetGlobalObject(realm);\n\n      // c. Return ? Set(globalObj, GetReferencedName(V), W, false).\n      return this.Set(realm, globalObj, Environment.GetReferencedName(realm, V), W, false);\n    }\n\n    // 6. Else if IsPropertyReference(V) is true, then\n    if (Environment.IsPropertyReference(realm, V)) {\n      if (base instanceof AbstractValue) {\n        // Ensure that abstract values are coerced to objects. This might yield\n        // an operation that might throw.\n        base = To.ToObject(realm, base);\n      }\n      // a. If HasPrimitiveBase(V) is true, then\n      if (Environment.HasPrimitiveBase(realm, V)) {\n        // i. Assert: In realm case, base will never be null or undefined.\n        invariant(base instanceof Value && !HasSomeCompatibleType(base, UndefinedValue, NullValue));\n\n        // ii. Set base to ToObject(base).\n        base = To.ToObject(realm, base);\n      }\n      invariant(base instanceof ObjectValue || base instanceof AbstractObjectValue);\n\n      // b. Let succeeded be ? base.[[Set]](GetReferencedName(V), W, GetThisValue(V)).\n      let succeeded = base.$SetPartial(Environment.GetReferencedNamePartial(realm, V), W, GetThisValue(realm, V));\n\n      // c. If succeeded is false and IsStrictReference(V) is true, throw a TypeError exception.\n      if (succeeded === false && Environment.IsStrictReference(realm, V)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // d. Return.\n      return;\n    }\n\n    // 7. Else base must be an Environment Record,\n    if (base instanceof EnvironmentRecord) {\n      // a. Return ? base.SetMutableBinding(GetReferencedName(V), W, IsStrictReference(V)) (see 8.1.1).\n      let referencedName = Environment.GetReferencedName(realm, V);\n      invariant(typeof referencedName === \"string\");\n      return base.SetMutableBinding(referencedName, W, Environment.IsStrictReference(realm, V));\n    }\n\n    invariant(false);\n  }\n\n  // ECMA262 9.4.2.4\n  ArraySetLength(realm: Realm, A: ArrayValue, _Desc: Descriptor): boolean {\n    let Desc = _Desc.throwIfNotConcrete(realm);\n\n    // 1. If the [[Value]] field of Desc is absent, then\n    let DescValue = Desc.value;\n    if (!DescValue) {\n      // a. Return OrdinaryDefineOwnProperty(A, \"length\", Desc).\n      return this.OrdinaryDefineOwnProperty(realm, A, \"length\", Desc);\n    }\n    invariant(DescValue instanceof Value);\n\n    // 2. Let newLenDesc be a copy of Desc.\n    let newLenDesc = new PropertyDescriptor(Desc);\n\n    // 3. Let newLen be ? ToUint32(Desc.[[Value]]).\n    let newLen = To.ToUint32(realm, DescValue);\n\n    // 4. Let numberLen be ? ToNumber(Desc.[[Value]]).\n    let numberLen = To.ToNumber(realm, DescValue);\n\n    // 5. If newLen ≠ numberLen, throw a RangeError exception.\n    if (newLen !== numberLen) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"should be a uint\");\n    }\n\n    // 6. Set newLenDesc.[[Value]] to newLen.\n    newLenDesc.value = new NumberValue(realm, newLen);\n\n    // 7. Let oldLenDesc be OrdinaryGetOwnProperty(A, \"length\").\n    let oldLenDesc = this.OrdinaryGetOwnProperty(realm, A, \"length\");\n\n    // 8. Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are created\n    //    with a length data property that cannot be deleted or reconfigured.\n    invariant(\n      oldLenDesc !== undefined && !IsAccessorDescriptor(realm, oldLenDesc),\n      \"cannot be undefined or an accessor descriptor\"\n    );\n    oldLenDesc = oldLenDesc.throwIfNotConcrete(realm);\n\n    // 9. Let oldLen be oldLenDesc.[[Value]].\n    let oldLen = oldLenDesc.value;\n    invariant(oldLen instanceof Value);\n    oldLen = oldLen.throwIfNotConcrete();\n    invariant(oldLen instanceof NumberValue, \"should be a number\");\n    oldLen = (oldLen.value: number);\n\n    // 10. If newLen ≥ oldLen, then\n    if (newLen >= oldLen) {\n      // a. Return OrdinaryDefineOwnProperty(A, \"length\", newLenDesc).\n      return this.OrdinaryDefineOwnProperty(realm, A, \"length\", newLenDesc);\n    }\n\n    // 11. If oldLenDesc.[[Writable]] is false, return false.\n    if (!oldLenDesc.writable) return false;\n\n    // 12. If newLenDesc.[[Writable]] is absent or has the value true, let newWritable be true.\n    let newWritable;\n    if (newLenDesc.writable === undefined || newLenDesc.writable === true) {\n      newWritable = true;\n    } else {\n      // 13. Else,\n      // a. Need to defer setting the [[Writable]] attribute to false in case any elements cannot be deleted.\n\n      // b. Let newWritable be false.\n      newWritable = false;\n\n      // c. Set newLenDesc.[[Writable]] to true.\n      newLenDesc.writable = true;\n    }\n\n    // 14. Let succeeded be ! OrdinaryDefineOwnProperty(A, \"length\", newLenDesc).\n    let succeeded = this.OrdinaryDefineOwnProperty(realm, A, \"length\", newLenDesc);\n\n    // 15. If succeeded is false, return false.\n    if (succeeded === false) return false;\n\n    // Here we diverge from the spec: instead of traversing all indices from\n    // oldLen to newLen, only the indices that are actually present are touched.\n    let oldLenCopy = oldLen;\n    let keys = Array.from(A.properties.keys())\n      .map(x => parseInt(x, 10))\n      .filter(x => newLen <= x && x <= oldLenCopy)\n      .sort()\n      .reverse();\n\n    // 16. While newLen < oldLen repeat,\n    for (let key of keys) {\n      // a. Set oldLen to oldLen - 1.\n      oldLen = key;\n\n      // b. Let deleteSucceeded be ! A.[[Delete]](! ToString(oldLen)).\n      let deleteSucceeded = A.$Delete(oldLen + \"\");\n\n      // c. If deleteSucceeded is false, then\n      if (deleteSucceeded === false) {\n        // i. Set newLenDesc.[[Value]] to oldLen + 1.\n        newLenDesc.value = new NumberValue(realm, oldLen + 1);\n\n        // ii. If newWritable is false, set newLenDesc.[[Writable]] to false.\n        if (newWritable === false) newLenDesc.writable = false;\n\n        // iii. Let succeeded be ! OrdinaryDefineOwnProperty(A, \"length\", newLenDesc).\n        succeeded = this.OrdinaryDefineOwnProperty(realm, A, \"length\", newLenDesc);\n\n        // iv. Return false.\n        return false;\n      }\n    }\n\n    // 17. If newWritable is false, then\n    if (!newWritable) {\n      // a. Return OrdinaryDefineOwnProperty(A, \"length\", PropertyDescriptor{[[Writable]]: false}). This call will always return true.\n      return this.OrdinaryDefineOwnProperty(\n        realm,\n        A,\n        \"length\",\n        new PropertyDescriptor({\n          writable: false,\n        })\n      );\n    }\n\n    // 18. Return true.\n    return true;\n  }\n\n  // ECMA262 9.1.5.1\n  OrdinaryGetOwnProperty(realm: Realm, O: ObjectValue, P: PropertyKeyValue): Descriptor | void {\n    // if the object is leaked and final, then it's still safe to read the value from the object\n    if (!realm.ignoreLeakLogic && O.mightBeLeakedObject()) {\n      if (!O.mightNotBeFinalObject()) {\n        let existingBinding = InternalGetPropertiesMap(O, P).get(InternalGetPropertiesKey(P));\n        if (existingBinding && existingBinding.descriptor) {\n          return existingBinding.descriptor;\n        } else {\n          return undefined;\n        }\n      }\n\n      let propName = P;\n      if (typeof propName === \"string\") {\n        propName = new StringValue(realm, propName);\n      }\n      let absVal = AbstractValue.createTemporalFromBuildFunction(\n        realm,\n        Value,\n        [O._templateFor || O, propName],\n        createOperationDescriptor(\"ABSTRACT_PROPERTY\"),\n        { isPure: true }\n      );\n      // TODO: We can't be sure what the descriptor will be, but the value will be abstract.\n      return new PropertyDescriptor({ configurable: true, enumerable: true, value: absVal, writable: true });\n    }\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected a property key\");\n\n    // 2. If O does not have an own property with key P, return undefined.\n    let existingBinding = InternalGetPropertiesMap(O, P).get(InternalGetPropertiesKey(P));\n    if (!existingBinding) {\n      if (O.isPartialObject()) {\n        invariant(realm.useAbstractInterpretation); // __makePartial will already have thrown an error if not\n        if (O.isSimpleObject()) {\n          if (P instanceof StringValue) P = P.value;\n          if (typeof P === \"string\") {\n            // In this case it is safe to defer the property access to runtime (at this point in time)\n            let absVal;\n            function createAbstractPropertyValue(type: typeof Value) {\n              invariant(typeof P === \"string\");\n              if (O.isTransitivelySimple()) {\n                return AbstractValue.createFromBuildFunction(\n                  realm,\n                  type,\n                  [O._templateFor || O, new StringValue(realm, P)],\n                  createOperationDescriptor(\"ABSTRACT_PROPERTY\"),\n                  { kind: AbstractValue.makeKind(\"property\", P) }\n                );\n              } else if (realm.generator !== undefined) {\n                return AbstractValue.createTemporalFromBuildFunction(\n                  realm,\n                  type,\n                  [O._templateFor || O, new StringValue(realm, P)],\n                  createOperationDescriptor(\"ABSTRACT_PROPERTY\"),\n                  { skipInvariant: true, isPure: true }\n                );\n              } else {\n                // During environment initialization we'll call Set and DefineOwnProperty\n                // to initialize objects. Since these needs to introspect the descriptor,\n                // we need some kind of value as its placeholder. This value should never\n                // leak to the serialized environment.\n                return AbstractValue.createFromBuildFunction(\n                  realm,\n                  type,\n                  [O._templateFor || O, new StringValue(realm, P)],\n                  createOperationDescriptor(\"ABSTRACT_PROPERTY\"),\n                  { kind: \"environment initialization expression\" }\n                );\n              }\n            }\n            if (O.isTransitivelySimple()) {\n              absVal = createAbstractPropertyValue(ObjectValue);\n              invariant(absVal instanceof AbstractObjectValue);\n              absVal.makeSimple(\"transitive\");\n              absVal = AbstractValue.createAbstractConcreteUnion(realm, absVal, [\n                realm.intrinsics.undefined,\n                realm.intrinsics.null,\n              ]);\n            } else {\n              absVal = createAbstractPropertyValue(Value);\n            }\n            return new PropertyDescriptor({ configurable: true, enumerable: true, value: absVal, writable: true });\n          } else {\n            invariant(P instanceof SymbolValue);\n            // Simple objects don't have symbol properties\n            return undefined;\n          }\n        }\n        AbstractValue.reportIntrospectionError(O, P);\n        throw new FatalError();\n      } else if (\n        realm.invariantLevel >= 2 &&\n        O.isIntrinsic() &&\n        !ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O)\n      ) {\n        let realmGenerator = realm.generator;\n        // TODO: Because global variables are special, checking for missing global object properties doesn't quite work yet.\n        if (\n          realmGenerator &&\n          typeof P === \"string\" &&\n          O !== realm.$GlobalObject &&\n          !realm.hasBindingBeenChecked(O, P)\n        ) {\n          realm.markPropertyAsChecked(O, P);\n          realmGenerator.emitPropertyInvariant(O, P, \"MISSING\");\n        }\n      }\n      return undefined;\n    }\n    realm.callReportPropertyAccess(existingBinding, false);\n    if (!existingBinding.descriptor) {\n      if (realm.invariantLevel >= 2 && O.isIntrinsic()) {\n        let realmGenerator = realm.generator;\n        // TODO: Because global variables are special, checking for missing global object properties doesn't quite work yet.\n        if (\n          realmGenerator &&\n          typeof P === \"string\" &&\n          O !== realm.$GlobalObject &&\n          !realm.hasBindingBeenChecked(O, P)\n        ) {\n          realm.markPropertyAsChecked(O, P);\n          realmGenerator.emitPropertyInvariant(O, P, \"MISSING\");\n        }\n      }\n      return undefined;\n    }\n\n    // 3. Let D be a newly created Property Descriptor with no fields.\n    let D = new PropertyDescriptor({});\n\n    // 4. Let X be O's own property whose key is P.\n    let X = existingBinding.descriptor;\n    invariant(X !== undefined);\n\n    if (X instanceof AbstractJoinedDescriptor) {\n      return new AbstractJoinedDescriptor(X.joinCondition, X.descriptor1, X.descriptor2);\n    }\n    invariant(X instanceof PropertyDescriptor);\n\n    // 5. If X is a data property, then\n    if (IsDataDescriptor(realm, X)) {\n      let value = X.value;\n      if (O.isIntrinsic() && O.isPartialObject()) {\n        if (value instanceof AbstractValue) {\n          let savedUnion;\n          if (value.kind === \"abstractConcreteUnion\") {\n            // TODO: Simplify this code by using helpers from the AbstractValue factory\n            // instead of deriving values directly.\n            savedUnion = value;\n            value = savedUnion.args[0];\n            invariant(value instanceof AbstractValue);\n          }\n          if (value.kind !== \"resolved\") {\n            let realmGenerator = realm.generator;\n            invariant(realmGenerator);\n            invariant(value.operationDescriptor);\n            const functionResultType = value instanceof AbstractObjectValue ? value.functionResultType : undefined;\n            value = realmGenerator.deriveAbstract(value.types, value.values, value.args, value.operationDescriptor, {\n              isPure: true,\n              kind: \"resolved\",\n              // We can't emit the invariant here otherwise it'll assume the AbstractValue's type not the union type\n              skipInvariant: true,\n            });\n            if (savedUnion !== undefined) {\n              invariant(value instanceof AbstractValue);\n              let concreteValues = (savedUnion.args.filter(e => e instanceof ConcreteValue): any);\n              invariant(concreteValues.length === savedUnion.args.length - 1);\n              value = AbstractValue.createAbstractConcreteUnion(realm, value, concreteValues);\n            }\n            if (functionResultType !== undefined) {\n              invariant(value instanceof AbstractObjectValue);\n              value.functionResultType = functionResultType;\n            }\n            if (realm.invariantLevel >= 1 && typeof P === \"string\" && !realm.hasBindingBeenChecked(O, P)) {\n              realm.markPropertyAsChecked(O, P);\n              realmGenerator.emitFullInvariant(O, P, value);\n            }\n            InternalSetProperty(\n              realm,\n              O,\n              P,\n              new PropertyDescriptor({\n                value: value,\n                writable: X.writable !== undefined ? X.writable : false,\n                enumerable: X.enumerable !== undefined ? X.enumerable : false,\n                configurable: X.configurable !== undefined ? X.configurable : false,\n              })\n            );\n          }\n        } else if (realm.invariantLevel >= 1 && value instanceof Value && !(value instanceof AbstractValue)) {\n          let realmGenerator = realm.generator;\n          invariant(realmGenerator);\n          if (typeof P === \"string\" && !realm.hasBindingBeenChecked(O, P)) {\n            realm.markPropertyAsChecked(O, P);\n            realmGenerator.emitFullInvariant(O, P, value);\n          }\n        }\n      } else {\n        // TODO: Because global variables are special, checking for global object properties doesn't quite work yet.\n        if (O !== realm.$GlobalObject && O.isIntrinsic() && realm.invariantLevel >= 2 && value instanceof Value) {\n          let realmGenerator = realm.generator;\n          if (realmGenerator && typeof P === \"string\" && !realm.hasBindingBeenChecked(O, P)) {\n            realm.markPropertyAsChecked(O, P);\n            realmGenerator.emitFullInvariant(O, P, value);\n          }\n        }\n      }\n\n      // a. Set D.[[Value]] to the value of X's [[Value]] attribute.\n      D.value = value;\n\n      // b. Set D.[[Writable]] to the value of X's [[Writable]] attribute.\n      D.writable = X.writable;\n    } else {\n      // 6. Else X is an accessor property,\n      invariant(IsAccessorDescriptor(realm, X), \"expected accessor property\");\n\n      // a. Set D.[[Get]] to the value of X's [[Get]] attribute.\n      D.get = X.get;\n\n      // b. Set D.[[Set]] to the value of X's [[Set]] attribute.\n      D.set = X.set;\n    }\n\n    // 7. Set D.[[Enumerable]] to the value of X's [[Enumerable]] attribute.\n    D.enumerable = X.enumerable;\n\n    // 8. Set D.[[Configurable]] to the value of X's [[Configurable]] attribute.\n    D.configurable = X.configurable;\n\n    // 9. Return D.\n    return D;\n  }\n\n  // ECMA262 9.1.2.1\n  OrdinarySetPrototypeOf(realm: Realm, O: ObjectValue, V: ObjectValue | NullValue): boolean {\n    ensureIsNotFinal(realm, O);\n    if (!realm.ignoreLeakLogic && O.mightBeLeakedObject()) {\n      throw new FatalError();\n    }\n\n    // 1. Assert: Either Type(V) is Object or Type(V) is Null.\n    invariant(V instanceof ObjectValue || V instanceof NullValue);\n\n    // 2. Let extensible be the value of the [[Extensible]] internal slot of O.\n    let extensible = O.getExtensible();\n\n    // 3. Let current be the value of the [[Prototype]] internal slot of O.\n    let current = O.$Prototype;\n\n    // 4. If SameValue(V, current) is true, return true.\n    if (SameValuePartial(realm, V, current)) return true;\n\n    // 5. If extensible is false, return false.\n    if (!extensible) return false;\n\n    // 6. Let p be V.\n    let p = V;\n\n    // 7. Let done be false.\n    let done = false;\n\n    // 8. Repeat while done is false,\n    while (!done) {\n      // a. If p is null, let done be true.\n      if (p instanceof NullValue) {\n        done = true;\n      } else if (SameValuePartial(realm, p, O)) {\n        // b. Else if SameValue(p, O) is true, return false.\n        return false;\n      } else {\n        // c. Else,\n        // If the [[GetPrototypeOf]] internal method of p is not the ordinary object internal method defined in 9.1.1, let done be true.\n        if (!p.usesOrdinaryObjectInternalPrototypeMethods()) {\n          done = true;\n        } else {\n          // ii. Else, let p be the value of p's [[Prototype]] internal slot.\n          p = p.$Prototype;\n          if (p instanceof AbstractObjectValue) {\n            AbstractValue.reportIntrospectionError(p);\n            throw new FatalError();\n          }\n        }\n      }\n    }\n\n    // 9. Set the value of the [[Prototype]] internal slot of O to V.\n    O.$Prototype = V;\n\n    // 10. Return true.\n    return true;\n  }\n\n  // ECMA262 13.7.5.15\n  EnumerateObjectProperties(realm: Realm, O: ObjectValue): ObjectValue {\n    /*global global*/\n    let visited = new global.Set();\n    let obj = O;\n    let keys = O.$OwnPropertyKeys();\n    let index = 0;\n\n    let iterator = new ObjectValue(realm);\n    iterator.defineNativeMethod(\"next\", 0, () => {\n      while (true) {\n        if (index >= keys.length) {\n          let proto = obj.$GetPrototypeOf();\n          if (proto instanceof NullValue) {\n            return Create.CreateIterResultObject(realm, realm.intrinsics.undefined, true);\n          }\n          obj = proto;\n          keys = obj.$OwnPropertyKeys();\n          index = 0;\n        }\n\n        let key = keys[index];\n\n        // Omit symbols.\n        if (!(key instanceof StringValue)) {\n          index += 1;\n          continue;\n        }\n\n        // Omit non-enumerable properties.\n        let desc = obj.$GetOwnProperty(key);\n        if (desc && !desc.throwIfNotConcrete(realm).enumerable) {\n          this.ThrowIfMightHaveBeenDeleted(desc);\n          index += 1;\n          visited.add(key.value);\n          continue;\n        }\n\n        // Omit duplicates.\n        if (visited.has(key.value)) {\n          index += 1;\n          continue;\n        }\n        visited.add(key.value);\n\n        // Yield the key.\n        return Create.CreateIterResultObject(realm, key, false);\n      }\n    });\n    return iterator;\n  }\n\n  ThrowIfMightHaveBeenDeleted(desc: Descriptor): void {\n    if (desc instanceof AbstractJoinedDescriptor) {\n      if (desc.descriptor1) {\n        this.ThrowIfMightHaveBeenDeleted(desc.descriptor1);\n      }\n      if (desc.descriptor2) {\n        this.ThrowIfMightHaveBeenDeleted(desc.descriptor2);\n      }\n    }\n    invariant(desc instanceof PropertyDescriptor, \"internal slots should never assert using this\");\n    let value = desc.value;\n    if (value === undefined) {\n      return;\n    }\n    if (!value.mightHaveBeenDeleted()) return;\n    invariant(value instanceof AbstractValue); // real empty values should never get here\n    let v = value.$Realm.simplifyAndRefineAbstractValue(value);\n    if (!v.mightHaveBeenDeleted()) return;\n    AbstractValue.reportIntrospectionError(value);\n    throw new FatalError();\n  }\n\n  ThrowIfInternalSlotNotWritable<T: ObjectValue>(realm: Realm, object: T, key: string): T {\n    if (!realm.isNewObject(object)) {\n      AbstractValue.reportIntrospectionError(object, key);\n      throw new FatalError();\n    }\n    return object;\n  }\n\n  // ECMA 14.3.9\n  PropertyDefinitionEvaluation(\n    realm: Realm,\n    MethodDefinition: BabelNodeObjectMethod | BabelNodeClassMethod,\n    object: ObjectValue,\n    env: LexicalEnvironment,\n    strictCode: boolean,\n    enumerable: boolean\n  ): boolean {\n    // MethodDefinition : PropertyName ( StrictFormalParameters ) { FunctionBody }\n    if (MethodDefinition.kind === \"method\") {\n      // 1. Let methodDef be DefineMethod of MethodDefinition with argument object.\n      let methodDef = Functions.DefineMethod(realm, MethodDefinition, object, env, strictCode);\n\n      // 2. ReturnIfAbrupt(methodDef).\n\n      // 3. Perform SetFunctionName(methodDef.[[closure]], methodDef.[[key]]).\n      Functions.SetFunctionName(realm, methodDef.$Closure, methodDef.$Key);\n\n      // If the AST name was computed, give the hint to the closure\n      methodDef.$Closure.$HasComputedName = !!MethodDefinition.computed;\n\n      // 4. Let desc be the Property Descriptor{[[Value]]: methodDef.[[closure]], [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true}.\n      let desc: Descriptor = new PropertyDescriptor({\n        value: methodDef.$Closure,\n        writable: true,\n        enumerable: enumerable,\n        configurable: true,\n      });\n\n      // 5. Return DefinePropertyOrThrow(object, methodDef.[[key]], desc).\n      return this.DefinePropertyOrThrow(realm, object, methodDef.$Key, desc);\n    } else if (MethodDefinition.kind === \"generator\") {\n      // MethodDefinition : GeneratorMethod\n      // See 14.4.\n      // ECMA 14.4.13\n      // 1. Let propKey be the result of evaluating PropertyName.\n      let propKey = EvalPropertyName(MethodDefinition, env, realm, strictCode);\n\n      // 2. ReturnIfAbrupt(propKey).\n      // 3. If the function code for this GeneratorMethod is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(MethodDefinition.body);\n\n      // 4. Let scope be the running execution context’s LexicalEnvironment.\n      let scope = env;\n\n      // 5. Let closure be GeneratorFunctionCreate(Method, StrictFormalParameters, GeneratorBody, scope, strict).\n      let closure = Functions.GeneratorFunctionCreate(\n        realm,\n        \"method\",\n        MethodDefinition.params,\n        MethodDefinition.body,\n        scope,\n        strict\n      );\n\n      // 6. Perform MakeMethod(closure, object).\n      Functions.MakeMethod(realm, closure, object);\n\n      // 7. Let prototype be ObjectCreate(%GeneratorPrototype%).\n      let prototype = Create.ObjectCreate(realm, realm.intrinsics.GeneratorPrototype);\n      prototype.originalConstructor = closure;\n\n      // 8. Perform MakeConstructor(closure, true, prototype).\n      MakeConstructor(realm, closure, true, prototype);\n\n      // 9. Perform SetFunctionName(closure, propKey).\n      Functions.SetFunctionName(realm, closure, propKey);\n\n      // 10. Let desc be the Property Descriptor{[[Value]]: closure, [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true}.\n      let desc: Descriptor = new PropertyDescriptor({\n        value: closure,\n        writable: true,\n        enumerable: enumerable,\n        configurable: true,\n      });\n\n      // 11. Return DefinePropertyOrThrow(object, propKey, desc).\n      return this.DefinePropertyOrThrow(realm, object, propKey, desc);\n    } else if (MethodDefinition.kind === \"get\") {\n      // 1. Let propKey be the result of evaluating PropertyName.\n      let propKey = EvalPropertyName(MethodDefinition, env, realm, strictCode);\n\n      // 2. ReturnIfAbrupt(propKey).\n\n      // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(MethodDefinition.body);\n\n      // 4. Let scope be the running execution context's LexicalEnvironment.\n      let scope = env;\n\n      // 5. Let formalParameterList be the production FormalParameters:[empty] .\n      let formalParameterList = [];\n\n      // 6. Let closure be FunctionCreate(Method, formalParameterList, FunctionBody, scope, strict).\n      let closure = Functions.FunctionCreate(\n        realm,\n        \"method\",\n        formalParameterList,\n        MethodDefinition.body,\n        scope,\n        strict\n      );\n\n      // 7. Perform MakeMethod(closure, object).\n      Functions.MakeMethod(realm, closure, object);\n\n      // 8. Perform SetFunctionName(closure, propKey, \"get\").\n      Functions.SetFunctionName(realm, closure, propKey, \"get\");\n\n      // If the AST name was computed, give the hint to the closure\n      closure.$HasComputedName = !!MethodDefinition.computed;\n\n      // 9. Let desc be the PropertyDescriptor{[[Get]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true}.\n      let desc = new PropertyDescriptor({\n        get: closure,\n        enumerable: true,\n        configurable: true,\n      });\n\n      // 10. Return ? DefinePropertyOrThrow(object, propKey, desc).\n      return this.DefinePropertyOrThrow(realm, object, propKey, desc);\n    } else {\n      invariant(MethodDefinition.kind === \"set\");\n      // 1. Let propKey be the result of evaluating PropertyName.\n      let propKey = EvalPropertyName(MethodDefinition, env, realm, strictCode);\n\n      // 2. ReturnIfAbrupt(propKey).\n\n      // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n      let strict = strictCode || IsStrict(MethodDefinition.body);\n\n      // 4. Let scope be the running execution context's LexicalEnvironment.\n      let scope = env;\n\n      // 5. Let closure be FunctionCreate(Method, PropertySetParameterList, FunctionBody, scope, strict).\n      let closure = Functions.FunctionCreate(\n        realm,\n        \"method\",\n        MethodDefinition.params,\n        MethodDefinition.body,\n        scope,\n        strict\n      );\n\n      // 6. Perform MakeMethod(closure, object).\n      Functions.MakeMethod(realm, closure, object);\n\n      // 7. Perform SetFunctionName(closure, propKey, \"set\").\n      Functions.SetFunctionName(realm, closure, propKey, \"set\");\n\n      // If the AST name was computed, give the hint to the closure\n      closure.$HasComputedName = !!MethodDefinition.computed;\n\n      // 8. Let desc be the PropertyDescriptor{[[Set]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true}.\n      let desc = new PropertyDescriptor({\n        set: closure,\n        enumerable: true,\n        configurable: true,\n      });\n\n      // 9. Return ? DefinePropertyOrThrow(object, propKey, desc).\n      return this.DefinePropertyOrThrow(realm, object, propKey, desc);\n    }\n  }\n\n  GetOwnPropertyKeysArray(\n    realm: Realm,\n    O: ObjectValue,\n    allowAbstractKeys: boolean,\n    getOwnPropertyKeysEvenIfPartial: boolean\n  ): Array<string> {\n    if (\n      (O.isPartialObject() && !getOwnPropertyKeysEvenIfPartial) ||\n      O.mightBeLeakedObject() ||\n      O.unknownProperty !== undefined\n    ) {\n      AbstractValue.reportIntrospectionError(O);\n      throw new FatalError();\n    }\n\n    let keyArray = Array.from(O.properties.keys());\n    keyArray = keyArray.filter(x => {\n      let pb = O.properties.get(x);\n      if (!pb || pb.descriptor === undefined) return false;\n      let pv = pb.descriptor.throwIfNotConcrete(realm).value;\n      if (pv === undefined) return true;\n      invariant(pv instanceof Value);\n      if (!pv.mightHaveBeenDeleted()) return true;\n      // The property may or may not be there at runtime.\n      // We can at best return an abstract keys array.\n      // For now, unless the caller has told us that is okay,\n      // just terminate.\n      invariant(pv instanceof AbstractValue);\n      if (allowAbstractKeys) return true;\n      AbstractValue.reportIntrospectionError(pv);\n      throw new FatalError();\n    });\n    realm.callReportObjectGetOwnProperties(O);\n    return keyArray;\n  }\n}\n"],"file":"properties.js"}