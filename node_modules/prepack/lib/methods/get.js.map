{"version":3,"sources":["../../src/methods/get.js"],"names":["GetFunctionRealm","realm","obj","ProxyValue","$ProxyHandler","NullValue","createErrorThrowCompletion","intrinsics","TypeError","$ProxyTarget","ObjectValue","proxyTarget","$Realm","BoundFunctionValue","target","$BoundTargetFunction","OrdinaryGet","O","P","Receiver","dataOnly","prop","unknownProperty","undefined","descriptor","$GetOwnProperty","desc","PropertyDescriptor","val","value","AbstractValue","propValue","StringValue","kind","ArrayValue","isIntrinsicAndHasWidenedNumericProperty","propName","AbstractObjectValue","args","length","aliasSet","object","createdObjectsTrackedForLeaks","has","Leak","GetFromArrayWithWidenedNumericProperty","reportIntrospectionError","FatalError","specializeJoin","AbstractJoinedDescriptor","OrdinaryGetHelper","joinCondition","descriptor1","descriptor2","simplifyAndRefineAbstractCondition","mightNotBeTrue","mightNotBeFalse","result1","generator1","modifiedBindings1","modifiedProperties1","createdObjects1","result","generator","modifiedBindings","modifiedProperties","createdObjects","Path","withCondition","evaluateForEffects","e","InfeasiblePathError","result2","generator2","modifiedBindings2","modifiedProperties2","createdObjects2","withInverseCondition","joinedEffects","Join","joinEffects","Effects","applyEffects","returnOrThrowCompletion","descValue","Value","mightHaveBeenDeleted","parent","$GetPrototypeOf","parentVal","throwIfNotConcreteObject","UndefinedValue","cond","createFromBinaryOp","empty","createFromConditionalOp","EmptyValue","$Get","getter","get","isWidenedValue","v","a","lengthTemplateSrc","absVal","ob","pName","pNumber","NumberValue","createTemporalFromBuildFunction","getType","skipInvariant","isPure","generic_cond","specializeCond","arg1","arg2","expressionLocation","OrdinaryGetPartial","createFromTemplate","convertToTemporalIfArgsAreTemporal","mightNotBeString","mightNotBeNumber","isSimpleObject","isInPureScope","error","CompilerDiagnostic","currentLocation","handleError","mightBeLeakedObject","To","ToStringAbstract","isPartialObject","createFromType","$Prototype","null","key","propertyBinding","properties","throwIfNotConcrete","GetGlobalObject","ctx","getRunningContext","currentRealm","$GlobalObject","GetSubstitution","matched","str","position","captures","replacement","matchLength","stringLength","Array","isArray","tailPos","m","i","ch","charAt","peek","substr","idx","charCodeAt","peek2","newIdx","GetMethod","V","func","GetV","GetPrototypeFromConstructor","constructor","intrinsicDefaultProto","proto","Get","ToObject","GetThisValue","Environment","IsPropertyReference","IsSuperReference","thisValue","GetBase","GetNewTarget","envRec","GetThisEnvironment","SyntaxError","$NewTarget","GetTemplateObject","templateLiteral","rawStrings","quasis","map","quasi","raw","templateRegistry","$TemplateMap","same","$Strings","$Array","cookedStrings","cooked","count","template","Create","ArrayCreate","rawObj","index","ToString","cookedValue","$DefineOwnProperty","writable","enumerable","configurable","rawValue","push","arr","ArrayPrototype","prototypeBinding","NativeFunctionValue"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { InfeasiblePathError } from \"../errors.js\";\nimport { construct_empty_effects, type Realm, Effects } from \"../realm.js\";\nimport type { PropertyKeyValue, CallableObjectValue } from \"../types.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  ArrayValue,\n  BoundFunctionValue,\n  EmptyValue,\n  NativeFunctionValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  ProxyValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { Reference } from \"../environment.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { SetIntegrityLevel } from \"./integrity.js\";\nimport {\n  Call,\n  HasSomeCompatibleType,\n  IsAccessorDescriptor,\n  IsCallable,\n  IsDataDescriptor,\n  IsPropertyKey,\n} from \"./index.js\";\nimport { Create, Environment, Join, Leak, Path, To } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport type { BabelNodeTemplateLiteral } from \"@babel/types\";\nimport { createOperationDescriptor } from \"../utils/generator.js\";\nimport { PropertyDescriptor, AbstractJoinedDescriptor } from \"../descriptors.js\";\nimport { IsArrayIndex } from \"./is.js\";\n\n// ECMA262 7.3.22\nexport function GetFunctionRealm(realm: Realm, obj: ObjectValue): Realm {\n  // 1. Assert: obj is a callable object.\n  invariant(IsCallable(realm, obj), \"expected callable object\");\n\n  // ProxyValue moved to realm before\n  // https://github.com/facebook/prepack/pull/1351\n\n  // 4. If obj is a Proxy exotic object, then\n  if (obj instanceof ProxyValue) {\n    // a. If the value of the [[ProxyHandler]] internal slot of obj is null, throw a TypeError exception.\n    if (obj.$ProxyHandler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"proxy handler is null\");\n    }\n    invariant(obj.$ProxyTarget instanceof ObjectValue);\n\n    // b. Let proxyTarget be the value of obj's [[ProxyTarget]] internal slot.\n    let proxyTarget = obj.$ProxyTarget;\n\n    // c. Return ? GetFunctionRealm(proxyTarget).\n    return GetFunctionRealm(realm, proxyTarget);\n  }\n\n  // 2. If obj has a [[Realm]] internal slot, then\n  if (obj.$Realm) {\n    // a. Return obj's [[Realm]] internal slot.\n    return obj.$Realm;\n  }\n\n  // 3. If obj is a Bound Function exotic object, then\n  if (obj instanceof BoundFunctionValue) {\n    // a. Let target be obj's [[BoundTargetFunction]] internal slot.\n    let target = obj.$BoundTargetFunction;\n\n    // b. Return ? GetFunctionRealm(target).\n    return GetFunctionRealm(realm, target);\n  }\n\n  // 5. Return the current Realm Record.\n  return realm;\n}\n\n// ECMA262 9.1.8.1\nexport function OrdinaryGet(\n  realm: Realm,\n  O: ObjectValue,\n  P: PropertyKeyValue,\n  Receiver: Value,\n  dataOnly?: boolean\n): Value {\n  // First deal with potential unknown properties.\n  let prop = O.unknownProperty;\n  if (prop !== undefined && prop.descriptor !== undefined && O.$GetOwnProperty(P) === undefined) {\n    let desc = prop.descriptor;\n    invariant(\n      desc instanceof PropertyDescriptor,\n      \"unknown properties are only created with Set and have equal descriptors\"\n    );\n    let val = desc.value;\n    invariant(val instanceof AbstractValue);\n    let propValue;\n    if (P instanceof StringValue) {\n      propValue = P;\n    } else if (typeof P === \"string\") {\n      propValue = new StringValue(realm, P);\n    }\n\n    if (val.kind === \"widened numeric property\") {\n      invariant(O instanceof ArrayValue && ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O));\n      let propName;\n      if (P instanceof StringValue) {\n        propName = P.value;\n      } else {\n        propName = P;\n      }\n      invariant(Receiver instanceof ObjectValue || Receiver instanceof AbstractObjectValue);\n\n      if (IsArrayIndex(realm, P)) {\n        // Deal with aliasing effects\n        invariant(val.args.length === 1);\n        let aliasSet = val.args[0];\n\n        invariant(aliasSet instanceof AbstractValue && aliasSet.kind === \"mayAliasSet\");\n        for (let object of aliasSet.args) {\n          // This explicit handling of aliasing should become unnecessary\n          // when we unify arrays with widened numeric properties. We have effectively\n          // pushed this leaking decision as far out as we possibly can, for now.\n          // and objects with widened properties. TODO #2569.\n          invariant(object instanceof ObjectValue);\n          // TODO: Deal with nested Array.map, in which the following\n          // pessimistic leaking call may fail because object is not tracked\n          // for leaking\n          invariant(realm.createdObjectsTrackedForLeaks !== undefined);\n          invariant(realm.createdObjectsTrackedForLeaks.has(object));\n          Leak.value(realm, object);\n        }\n      }\n\n      return GetFromArrayWithWidenedNumericProperty(realm, Receiver, propName);\n    } else if (!propValue) {\n      AbstractValue.reportIntrospectionError(val, \"abstract computed property name\");\n      throw new FatalError();\n    }\n    return specializeJoin(realm, val, propValue);\n  }\n\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n  // 2. Let desc be ? O.[[GetOwnProperty]](P).\n  let desc = O.$GetOwnProperty(P);\n  if (desc === undefined || !(desc instanceof AbstractJoinedDescriptor)) return OrdinaryGetHelper();\n\n  // joined descriptors need special treatment\n  let joinCondition = desc.joinCondition;\n  let descriptor1 = desc.descriptor1;\n  let descriptor2 = desc.descriptor2;\n  joinCondition = realm.simplifyAndRefineAbstractCondition(joinCondition);\n  if (!joinCondition.mightNotBeTrue()) {\n    desc = descriptor1;\n    return OrdinaryGetHelper();\n  }\n  if (!joinCondition.mightNotBeFalse()) {\n    desc = desc.descriptor2;\n    return OrdinaryGetHelper();\n  }\n  invariant(joinCondition instanceof AbstractValue);\n  let result1, generator1, modifiedBindings1, modifiedProperties1, createdObjects1;\n  try {\n    desc = descriptor1;\n    ({\n      result: result1,\n      generator: generator1,\n      modifiedBindings: modifiedBindings1,\n      modifiedProperties: modifiedProperties1,\n      createdObjects: createdObjects1,\n    } = Path.withCondition(joinCondition, () => {\n      return desc !== undefined\n        ? realm.evaluateForEffects(() => OrdinaryGetHelper(), undefined, \"OrdinaryGet/1\")\n        : construct_empty_effects(realm);\n    }));\n  } catch (e) {\n    if (e instanceof InfeasiblePathError) {\n      // The joinCondition cannot be true in the current path, after all\n      desc = descriptor2;\n      return OrdinaryGetHelper();\n    } else {\n      throw e;\n    }\n  }\n  let result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2;\n  try {\n    desc = descriptor2;\n    ({\n      result: result2,\n      generator: generator2,\n      modifiedBindings: modifiedBindings2,\n      modifiedProperties: modifiedProperties2,\n      createdObjects: createdObjects2,\n    } = Path.withInverseCondition(joinCondition, () => {\n      return desc !== undefined\n        ? realm.evaluateForEffects(() => OrdinaryGetHelper(), undefined, \"OrdinaryGet/2\")\n        : construct_empty_effects(realm);\n    }));\n  } catch (e) {\n    if (e instanceof InfeasiblePathError) {\n      // The joinCondition cannot be false in the current path, after all\n      desc = descriptor1;\n      return OrdinaryGetHelper();\n    } else {\n      throw e;\n    }\n  }\n  // Join the effects, creating an abstract view of what happened, regardless\n  // of the actual value of ownDesc.joinCondition.\n  let joinedEffects = Join.joinEffects(\n    joinCondition,\n    new Effects(result1, generator1, modifiedBindings1, modifiedProperties1, createdObjects1),\n    new Effects(result2, generator2, modifiedBindings2, modifiedProperties2, createdObjects2)\n  );\n  realm.applyEffects(joinedEffects);\n  return realm.returnOrThrowCompletion(joinedEffects.result);\n\n  function OrdinaryGetHelper() {\n    let descValue = !desc\n      ? realm.intrinsics.undefined\n      : desc.value === undefined\n        ? realm.intrinsics.undefined\n        : desc.value;\n    invariant(descValue instanceof Value);\n\n    // 3. If desc is undefined, then\n    if (!desc || descValue.mightHaveBeenDeleted()) {\n      // a. Let parent be ? O.[[GetPrototypeOf]]().\n      let parent = O.$GetPrototypeOf();\n\n      // b. If parent is null, return undefined.\n      if (parent instanceof NullValue) {\n        // Return the property value since it is now known to be the right value\n        // even in the case when it is empty.\n        return descValue;\n      }\n\n      // c. Return ? parent.[[Get]](P, Receiver).\n      if (descValue.mightHaveBeenDeleted() && descValue instanceof AbstractValue) {\n        // We don't know for sure that O.P does not exist.\n        let parentVal = OrdinaryGet(realm, parent.throwIfNotConcreteObject(), P, descValue, true);\n        if (parentVal instanceof UndefinedValue)\n          // even O.P returns undefined it is still the right value.\n          return descValue;\n        // Join with parent value with descValue because the actual value will be\n        // descValue unless it is empty.\n        // Only get the parent value if it does not involve a getter call.\n        // Use a property get for the joined value since it does the check for empty.\n        let cond = AbstractValue.createFromBinaryOp(realm, \"!==\", descValue, realm.intrinsics.empty);\n        return AbstractValue.createFromConditionalOp(realm, cond, descValue, parentVal);\n      }\n      invariant(!desc || descValue instanceof EmptyValue);\n      return parent.$Get(P, Receiver);\n    }\n\n    // 4. If IsDataDescriptor(desc) is true, return desc.[[Value]].\n    if (IsDataDescriptor(realm, desc)) return descValue;\n    if (dataOnly) {\n      invariant(descValue instanceof AbstractValue);\n      AbstractValue.reportIntrospectionError(descValue);\n      throw new FatalError();\n    }\n\n    // 5. Assert: IsAccessorDescriptor(desc) is true.\n    invariant(IsAccessorDescriptor(realm, desc), \"expected accessor descriptor\");\n\n    // 6. Let getter be desc.[[Get]].\n    let getter = desc.get;\n\n    // 7. If getter is undefined, return undefined.\n    if (!getter || getter instanceof UndefinedValue) return realm.intrinsics.undefined;\n\n    // 8. Return ? Call(getter, Receiver).\n    return Call(realm, getter, Receiver);\n  }\n}\n\nfunction isWidenedValue(v: void | Value) {\n  if (!(v instanceof AbstractValue)) return false;\n  if (v.kind === \"widened\" || v.kind === \"widened property\") return true;\n  for (let a of v.args) {\n    if (isWidenedValue(a)) return true;\n  }\n  return false;\n}\n\nconst lengthTemplateSrc = \"(A).length\";\n\nfunction specializeJoin(realm: Realm, absVal: AbstractValue, propName: Value): Value {\n  if (absVal.kind === \"widened property\") {\n    let ob = absVal.args[0];\n    if (propName instanceof StringValue) {\n      let pName = propName.value;\n      let pNumber = +pName;\n      if (pName === pNumber + \"\") propName = new NumberValue(realm, pNumber);\n    }\n    return AbstractValue.createTemporalFromBuildFunction(\n      realm,\n      absVal.getType(),\n      [ob, propName],\n      createOperationDescriptor(\"OBJECT_GET_PARTIAL\"),\n      { skipInvariant: true, isPure: true }\n    );\n  }\n  invariant(absVal.args.length === 3 && absVal.kind === \"conditional\");\n  let generic_cond = absVal.args[0];\n  invariant(generic_cond instanceof AbstractValue);\n  let cond = specializeCond(realm, generic_cond, propName);\n  let arg1 = absVal.args[1];\n  if (arg1 instanceof AbstractValue && arg1.args.length === 3) arg1 = specializeJoin(realm, arg1, propName);\n  let arg2 = absVal.args[2];\n  if (arg2 instanceof AbstractValue) {\n    if (arg2.kind === \"template for prototype member expression\") {\n      let ob = arg2.args[0];\n      arg2 = AbstractValue.createTemporalFromBuildFunction(\n        realm,\n        absVal.getType(),\n        [ob, propName],\n        createOperationDescriptor(\"OBJECT_GET_PARTIAL\"),\n        { skipInvariant: true, isPure: true }\n      );\n    } else if (arg2.args.length === 3) {\n      arg2 = specializeJoin(realm, arg2, propName);\n    }\n  }\n  return AbstractValue.createFromConditionalOp(realm, cond, arg1, arg2, absVal.expressionLocation);\n}\n\nfunction specializeCond(realm: Realm, absVal: AbstractValue, propName: Value): Value {\n  if (absVal.kind === \"template for property name condition\")\n    return AbstractValue.createFromBinaryOp(realm, \"===\", absVal.args[0], propName);\n  return absVal;\n}\n\nexport function OrdinaryGetPartial(\n  realm: Realm,\n  O: ObjectValue,\n  P: AbstractValue | PropertyKeyValue,\n  Receiver: Value\n): Value {\n  if (Receiver instanceof AbstractValue && Receiver.getType() === StringValue && P === \"length\") {\n    let absVal = AbstractValue.createFromTemplate(realm, lengthTemplateSrc, NumberValue, [Receiver]);\n    // This operation is a conditional atemporal\n    // See #2327\n    return AbstractValue.convertToTemporalIfArgsAreTemporal(realm, absVal, [Receiver]);\n  }\n\n  if (!(P instanceof AbstractValue)) return O.$Get(P, Receiver);\n\n  // A string coercion might have side-effects.\n  // TODO #1682: We assume that simple objects mean that they don't have a\n  // side-effectful valueOf and toString but that's not enforced.\n  if (P.mightNotBeString() && P.mightNotBeNumber() && !P.isSimpleObject()) {\n    if (realm.isInPureScope()) {\n      // If we're in pure scope, we can leak the key and keep going.\n      // Coercion can only have effects on anything reachable from the key.\n      Leak.value(realm, P);\n    } else {\n      let error = new CompilerDiagnostic(\n        \"property key might not have a well behaved toString or be a symbol\",\n        realm.currentLocation,\n        \"PP0002\",\n        \"RecoverableError\"\n      );\n      if (realm.handleError(error) !== \"Recover\") {\n        throw new FatalError();\n      }\n    }\n  }\n\n  // We assume that simple objects have no getter/setter properties.\n  if (!O.isSimpleObject() || O.mightBeLeakedObject()) {\n    if (realm.isInPureScope()) {\n      // If we're in pure scope, we can leak the object. Coercion\n      // can only have effects on anything reachable from this object.\n      // We assume that if the receiver is different than this object,\n      // then we only got here because there were no other keys with\n      // this name on other parts of the prototype chain.\n      // TODO #1675: A fix to 1675 needs to take this into account.\n      Leak.value(realm, Receiver);\n      return AbstractValue.createTemporalFromBuildFunction(\n        realm,\n        Value,\n        [Receiver, P],\n        createOperationDescriptor(\"OBJECT_GET_PARTIAL\"),\n        { skipInvariant: true, isPure: true }\n      );\n    } else {\n      let error = new CompilerDiagnostic(\n        \"unknown property access might need to invoke a getter\",\n        realm.currentLocation,\n        \"PP0030\",\n        \"RecoverableError\"\n      );\n      if (realm.handleError(error) !== \"Recover\") {\n        throw new FatalError();\n      }\n    }\n  }\n\n  P = To.ToStringAbstract(realm, P);\n\n  // If all else fails, use this expression\n  // TODO #1675: Check the prototype chain for known properties too.\n  let result;\n  if (O.isPartialObject()) {\n    if (isWidenedValue(P)) {\n      // TODO #1678: Use a snapshot or leak this object.\n      return AbstractValue.createTemporalFromBuildFunction(\n        realm,\n        Value,\n        [O, P],\n        createOperationDescriptor(\"OBJECT_GET_PARTIAL\"),\n        { skipInvariant: true, isPure: true }\n      );\n    }\n    result = AbstractValue.createFromType(realm, Value, \"sentinel member expression\", [O, P]);\n  } else {\n    // This is simple and not partial. Any access that isn't covered by checking against\n    // all its properties, is covered by reading from the prototype.\n    if (O.$Prototype === realm.intrinsics.null) {\n      // If the prototype is null, then the fallback value is undefined.\n      result = realm.intrinsics.undefined;\n    } else {\n      // Otherwise, we read the value dynamically from the prototype chain.\n      result = AbstractValue.createTemporalFromBuildFunction(\n        realm,\n        Value,\n        [O.$Prototype, P],\n        createOperationDescriptor(\"OBJECT_GET_PARTIAL\"),\n        { skipInvariant: true, isPure: true }\n      );\n    }\n  }\n\n  // Get a specialization of the join of all values written to the object\n  // with abstract property names.\n  let prop = O.unknownProperty;\n  if (prop !== undefined) {\n    let desc = prop.descriptor;\n    if (desc !== undefined) {\n      invariant(\n        desc instanceof PropertyDescriptor,\n        \"unknown properties are only created with Set and have equal descriptors\"\n      );\n      let val = desc.value;\n      invariant(val instanceof AbstractValue);\n      if (val.kind === \"widened numeric property\") {\n        invariant(O instanceof ArrayValue && ArrayValue.isIntrinsicAndHasWidenedNumericProperty(O));\n        invariant(Receiver instanceof ObjectValue || Receiver instanceof AbstractObjectValue);\n        return GetFromArrayWithWidenedNumericProperty(realm, Receiver, P instanceof StringValue ? P.value : P);\n      }\n      result = specializeJoin(realm, val, P);\n    }\n  }\n  // Join in all of the other values that were written to the object with\n  // concrete property names.\n  for (let [key, propertyBinding] of O.properties) {\n    let desc = propertyBinding.descriptor;\n    if (desc === undefined) continue; // deleted\n    desc = desc.throwIfNotConcrete(realm); // TODO: Join descriptor values based on condition\n    invariant(desc.value !== undefined); // otherwise this is not simple\n    let val = desc.value;\n    invariant(val instanceof Value);\n    let cond = AbstractValue.createFromBinaryOp(\n      realm,\n      \"===\",\n      P,\n      new StringValue(realm, key),\n      undefined,\n      \"check for known property\"\n    );\n    result = AbstractValue.createFromConditionalOp(realm, cond, val, result);\n  }\n  return result;\n}\n\n// ECMA262 8.3.6\nexport function GetGlobalObject(realm: Realm): ObjectValue | AbstractObjectValue {\n  // 1. Let ctx be the running execution context.\n  let ctx = realm.getRunningContext();\n\n  // 2. Let currentRealm be ctx's Realm.\n  let currentRealm = ctx.realm;\n\n  // 3. Return currentRealm.[[GlobalObject]].\n  return currentRealm.$GlobalObject;\n}\n\n// ECMA262 21.1.3.14.1\nexport function GetSubstitution(\n  realm: Realm,\n  matched: string,\n  str: string,\n  position: number,\n  captures: Array<string | void>,\n  replacement: string\n): string {\n  // 1. Assert: Type(matched) is String.\n  invariant(typeof matched === \"string\", \"expected matched to be a stirng\");\n\n  // 2. Let matchLength be the number of code units in matched.\n  let matchLength = matched.length;\n\n  // 3. Assert: Type(str) is String.\n  invariant(typeof str === \"string\", \"expected matched to be a stirng\");\n\n  // 4. Let stringLength be the number of code units in str.\n  let stringLength = str.length;\n\n  // 5. Assert: position is a nonnegative integer.\n  invariant(position >= 0, \"expected position to be a nonegative integer\");\n\n  // 6. Assert: position â‰¤ stringLength.\n  invariant(position <= stringLength, \"expected position to be less than string length\");\n\n  // 7. Assert: captures is a possibly empty List of Strings.\n  invariant(Array.isArray(captures), \"expected captures to be an array\");\n\n  // 8. Assert: Type(replacement) is String.\n  invariant(typeof replacement === \"string\", \"expected replacement to be a stirng\");\n\n  // 9. Let tailPos be position + matchLength.\n  let tailPos = position + matchLength;\n\n  // 10. Let m be the number of elements in captures.\n  let m = captures.length;\n\n  // 11. Let result be a String value derived from replacement by copying code unit elements\n  //     from replacement to result while performing replacements as specified in Table 46.\n  //     These $ replacements are done left-to-right, and, once such a replacement is performed,\n  //     the new replacement text is not subject to further replacements.\n  let result = \"\";\n  for (let i = 0; i < replacement.length; ++i) {\n    let ch = replacement.charAt(i);\n    if (ch !== \"$\" || i + 1 >= replacement.length) {\n      result += ch;\n      continue;\n    }\n    let peek = replacement.charAt(i + 1);\n    if (peek === \"&\") {\n      result += matched;\n    } else if (peek === \"$\") {\n      result += \"$\";\n    } else if (peek === \"`\") {\n      result += str.substr(0, position);\n    } else if (peek === \"'\") {\n      result += str.substr(tailPos);\n    } else if (peek >= \"0\" && peek <= \"9\") {\n      let idx = peek.charCodeAt(0) - \"0\".charCodeAt(0);\n      if (i + 2 < replacement.length) {\n        let peek2 = replacement.charAt(i + 2);\n        if (peek2 >= \"0\" && peek2 <= \"9\") {\n          let newIdx = idx * 10 + (peek2.charCodeAt(0) - \"0\".charCodeAt(0));\n          if (newIdx <= m) {\n            idx = newIdx;\n            i += 1;\n          }\n        }\n      }\n      if (idx > 0 && idx <= m) {\n        result += captures[idx - 1] || \"\";\n      } else {\n        result += \"$\" + idx;\n      }\n    } else {\n      result += \"$\" + peek;\n    }\n    i += 1;\n  }\n\n  // 12. Return result.\n  return result;\n}\n\n// ECMA262 7.3.9\nexport function GetMethod(realm: Realm, V: Value, P: PropertyKeyValue): UndefinedValue | CallableObjectValue {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n  // 2. Let func be ? GetV(V, P).\n  let func = GetV(realm, V, P);\n\n  // 3. If func is either undefined or null, return undefined.\n  if (HasSomeCompatibleType(func, NullValue, UndefinedValue)) {\n    return realm.intrinsics.undefined;\n  }\n\n  // 4. If IsCallable(func) is false, throw a TypeError exception.\n  if (!IsCallable(realm, func)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not callable\");\n  }\n\n  // 5. Return func.\n  return ((func: any): CallableObjectValue);\n}\n\n// ECMA262 9.1.14\nexport function GetPrototypeFromConstructor(\n  realm: Realm,\n  constructor: ObjectValue,\n  intrinsicDefaultProto: string\n): ObjectValue | AbstractObjectValue {\n  // 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic\n  //   object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]]\n  //   value of an object.\n  invariant(realm.intrinsics[intrinsicDefaultProto], \"not a valid proto ref\");\n\n  // 2. Assert: IsCallable(constructor) is true.\n  invariant(IsCallable(realm, constructor) === true, \"expected constructor to be callable\");\n\n  // 3. Let proto be ? Get(constructor, \"prototype\").\n  let proto = Get(realm, constructor, new StringValue(realm, \"prototype\"));\n\n  // 4. If Type(proto) is not Object, then\n  if (!(proto instanceof ObjectValue) && !(proto instanceof AbstractObjectValue)) {\n    // a. Let realm be ? GetFunctionRealm(constructor).\n    realm = GetFunctionRealm(realm, constructor);\n\n    // b. Let proto be realm's intrinsic object named intrinsicDefaultProto.\n    proto = realm.intrinsics[intrinsicDefaultProto];\n  }\n\n  // 5. Return proto.\n  return proto;\n}\n\n// ECMA262 7.3.1\nexport function Get(realm: Realm, O: ObjectValue | AbstractObjectValue, P: PropertyKeyValue): Value {\n  // 1. Assert: Type(O) is Object.\n  invariant(O instanceof ObjectValue || O instanceof AbstractObjectValue, \"Not an object value\");\n\n  // 2. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"Not a valid property key\");\n\n  // 3. Return ? O.[[Get]](P, O).\n  return O.$Get(P, O);\n}\n\n// ECMA262 7.3.2\nexport function GetV(realm: Realm, V: Value, P: PropertyKeyValue): Value {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"Not a valid property key\");\n\n  // 2. Let O be ? ToObject(V).\n  let O = To.ToObject(realm, V);\n\n  // 3. Return ? O.[[Get]](P, V).\n  return O.$Get(P, V);\n}\n\n// ECMA262 6.2.3.3\nexport function GetThisValue(realm: Realm, V: Reference): Value {\n  // 1. Assert: IsPropertyReference(V) is true.\n  invariant(Environment.IsPropertyReference(realm, V), \"expected property reference\");\n\n  // 2. If IsSuperReference(V) is true, then\n  if (Environment.IsSuperReference(realm, V)) {\n    invariant(V.thisValue !== undefined);\n    // a. Return the value of the thisValue component of the reference V.\n    return V.thisValue;\n  }\n\n  // 3. Return GetBase(V).\n  let result = Environment.GetBase(realm, V);\n  invariant(result instanceof Value);\n  return result;\n}\n\n// ECMA262 8.3.5\nexport function GetNewTarget(realm: Realm): UndefinedValue | ObjectValue {\n  // 1. Let envRec be GetThisEnvironment( ).\n  let envRec = Environment.GetThisEnvironment(realm);\n\n  // 2. Assert: envRec has a [[NewTarget]] field.\n  if (!(\"$NewTarget\" in envRec)) {\n    // In the spec we should not get here because earlier static checks are supposed to prevent it.\n    // However, we do not have an appropriate place to do this check earlier.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"new.target not allowed here\");\n  }\n\n  // 3. Return envRec.[[NewTarget]].\n  return envRec.$NewTarget || realm.intrinsics.undefined;\n}\n\nexport function GetTemplateObject(realm: Realm, templateLiteral: BabelNodeTemplateLiteral): ObjectValue {\n  // 1. Let rawStrings be TemplateStrings of templateLiteral with argument true.\n  let rawStrings = templateLiteral.quasis.map(quasi => quasi.value.raw);\n\n  // 2. Let realm be the current Realm Record.\n  realm;\n\n  // 3. Let templateRegistry be realm.[[TemplateMap]].\n  let templateRegistry = realm.$TemplateMap;\n\n  // 4. For each element e of templateRegistry, do\n  for (let e of templateRegistry) {\n    let same;\n    if (e.$Strings.length === rawStrings.length) {\n      same = true;\n      for (let i = 0; i < rawStrings.length; ++i) {\n        if (e.$Strings[i] !== rawStrings[i]) {\n          same = false;\n          break;\n        }\n      }\n    } else {\n      same = false;\n    }\n\n    // a. If e.[[Strings]] and rawStrings contain the same values in the same order, then\n    if (same) {\n      // i. Return e.[[Array]].\n      return e.$Array;\n    }\n  }\n\n  // 5. Let cookedStrings be TemplateStrings of templateLiteral with argument false.\n  let cookedStrings = templateLiteral.quasis.map(quasi => quasi.value.cooked);\n\n  // 6. Let count be the number of elements in the List cookedStrings.\n  let count = cookedStrings.length;\n\n  // 7. Let template be ArrayCreate(count).\n  let template = Create.ArrayCreate(realm, count);\n\n  // 8. Let rawObj be ArrayCreate(count).\n  let rawObj = Create.ArrayCreate(realm, count);\n\n  // 9. Let index be 0.\n  let index = 0;\n\n  // 10. Repeat while index < count\n  while (index < count) {\n    // a. Let prop be ! ToString(index).\n    let prop = To.ToString(realm, new NumberValue(realm, index));\n\n    // b. Let cookedValue be the String value cookedStrings[index].\n    let cookedValue = new StringValue(realm, cookedStrings[index]);\n\n    // c. Call template.[[DefineOwnProperty]](prop, PropertyDescriptor{[[Value]]: cookedValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false}).\n    template.$DefineOwnProperty(\n      prop,\n      new PropertyDescriptor({\n        value: cookedValue,\n        writable: false,\n        enumerable: true,\n        configurable: false,\n      })\n    );\n\n    // d. Let rawValue be the String value rawStrings[index].\n    let rawValue = new StringValue(realm, rawStrings[index]);\n\n    // e. Call rawObj.[[DefineOwnProperty]](prop, PropertyDescriptor{[[Value]]: rawValue, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false}).\n    rawObj.$DefineOwnProperty(\n      prop,\n      new PropertyDescriptor({\n        value: rawValue,\n        writable: false,\n        enumerable: true,\n        configurable: false,\n      })\n    );\n\n    // f. Let index be index+1.\n    index = index + 1;\n  }\n\n  // 11. Perform SetIntegrityLevel(rawObj, \"frozen\").\n  SetIntegrityLevel(realm, rawObj, \"frozen\");\n\n  // 12. Call template.[[DefineOwnProperty]](\"raw\", PropertyDescriptor{[[Value]]: rawObj, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}).\n  template.$DefineOwnProperty(\n    \"raw\",\n    new PropertyDescriptor({\n      value: rawObj,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    })\n  );\n\n  // 13. Perform SetIntegrityLevel(template, \"frozen\").\n  SetIntegrityLevel(realm, template, \"frozen\");\n\n  // 14. Append the Record{[[Strings]]: rawStrings, [[Array]]: template} to templateRegistry.\n  templateRegistry.push({ $Strings: rawStrings, $Array: template });\n\n  // 15. Return template.\n  return template;\n}\n\nexport function GetFromArrayWithWidenedNumericProperty(\n  realm: Realm,\n  arr: AbstractObjectValue | ObjectValue,\n  P: string | Value\n): Value {\n  let proto = arr.$GetPrototypeOf();\n  invariant(proto instanceof ObjectValue && proto === realm.intrinsics.ArrayPrototype);\n  if (typeof P === \"string\") {\n    if (P === \"length\") {\n      return AbstractValue.createTemporalFromBuildFunction(\n        realm,\n        NumberValue,\n        [arr],\n        createOperationDescriptor(\"UNKNOWN_ARRAY_LENGTH\"),\n        { skipInvariant: true, isPure: true }\n      );\n    }\n    let prototypeBinding = proto.properties.get(P);\n    if (prototypeBinding !== undefined) {\n      let descriptor = prototypeBinding.descriptor;\n      // ensure we are accessing a built-in native function\n      if (descriptor instanceof PropertyDescriptor && descriptor.value instanceof NativeFunctionValue) {\n        return descriptor.value;\n      }\n    }\n  }\n  let prop = typeof P === \"string\" ? new StringValue(realm, P) : P;\n  return AbstractValue.createTemporalFromBuildFunction(\n    realm,\n    Value,\n    [arr, prop],\n    createOperationDescriptor(\"UNKNOWN_ARRAY_GET_PARTIAL\"),\n    {\n      skipInvariant: true,\n      isPure: true,\n    }\n  );\n}\n"],"file":"get.js"}