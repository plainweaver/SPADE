{"version":3,"sources":["../../src/methods/hash.js"],"names":["hashBinary","op","x","y","xHash","getHash","yHash","commutative","mightBeObject","mightBeString","hash","hashString","hashCall","calleeName","args","a","hashTernary","z","value","i","length","charCodeAt","hashUnary","HashSet","constructor","expectedEntries","initialSize","_entries","Array","_count","add","e","entries","n","key","entry","undefined","expand","equals","oldEntries","m","oldEntry","j"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelBinaryOperator, BabelUnaryOperator } from \"@babel/types\";\nimport invariant from \"../invariant.js\";\n\ninterface Hashable {\n  getHash(): number;\n  mightBeString(): boolean;\n  mightBeObject(): boolean;\n}\n\nexport function hashBinary<T: Hashable>(op: BabelBinaryOperator, x: T, y: T): [number, Array<T>] {\n  let xHash = x.getHash();\n  let yHash = y.getHash();\n  if (yHash < xHash) {\n    // Check if the operation is commutative so that we can normalize the arguments on hash value order.\n    let commutative;\n    switch (op) {\n      case \"*\":\n      case \"==\":\n      case \"!=\":\n      case \"===\":\n      case \"!==\":\n        // If both operands might be objects, the operation does not commute because of the possibility\n        // that arbitrary code can run on both operands while converting them, in which case the order of the\n        // operands must be maintained to make sure any side-effects happen in the right order.\n        commutative = !(x.mightBeObject() && y.mightBeObject());\n        break;\n      case \"+\":\n        // As above, but in addition, if one of the operands might be a string the operation does not commute\n        commutative = !(x.mightBeObject() && y.mightBeObject()) && !(x.mightBeString() || y.mightBeString());\n        break;\n      default:\n        // The operation itself is not commutative\n        commutative = false;\n        break;\n    }\n    if (commutative) {\n      [x, y] = [y, x];\n      [xHash, yHash] = [yHash, xHash];\n    }\n  }\n  let hash = (((hashString(op) * 13) ^ xHash) * 13) ^ yHash;\n  return [hash, [x, y]];\n}\n\nexport function hashCall<T: Hashable>(calleeName: string, ...args: Array<T>): [number, Array<T>] {\n  let hash = hashString(calleeName);\n  for (let a of args) hash = (hash * 13) ^ a.getHash();\n  return [hash, args];\n}\n\nexport function hashTernary<T: Hashable>(x: T, y: T, z: T): [number, Array<T>] {\n  let hash = (((x.getHash() * 13) ^ y.getHash()) * 13) ^ z.getHash();\n  return [hash, [x, y, z]];\n}\n\nexport function hashString(value: string): number {\n  let hash = 5381;\n  for (let i = value.length - 1; i >= 0; i--) {\n    hash = (hash * 33) ^ value.charCodeAt(i);\n  }\n  return hash;\n}\n\nexport function hashUnary(op: BabelUnaryOperator, x: Hashable): number {\n  return (hashString(op) * 13) ^ x.getHash();\n}\n\ninterface Equatable { equals(x: any): boolean }\n\nexport class HashSet<T: Equatable & Hashable> {\n  constructor(expectedEntries?: number = 32 * 1024) {\n    let initialSize = 16;\n    expectedEntries *= 2;\n    while (initialSize < expectedEntries) initialSize *= 2;\n    this._entries = new Array(initialSize);\n    this._count = 0;\n  }\n\n  _count: number;\n  _entries: Array<void | T>;\n\n  add(e: T): T {\n    let entries = this._entries;\n    let n = entries.length;\n    let key = e.getHash();\n    let i = key & (n - 1);\n    while (true) {\n      let entry = entries[i];\n      if (entry === undefined) {\n        entries[i] = e;\n        if (++this._count > n / 2) this.expand();\n        return e;\n      } else if (e.equals(entry)) {\n        return entry;\n      }\n      if (++i >= n) i = 0;\n    }\n    invariant(false); // otherwise Flow thinks this method can return undefined\n  }\n\n  expand(): void {\n    let oldEntries = this._entries;\n    let n = oldEntries.length;\n    let m = n * 2;\n    if (m <= 0) return;\n    let entries = new Array(m);\n    for (let i = 0; i < n; i++) {\n      let oldEntry = oldEntries[i];\n      if (oldEntry === undefined) continue;\n      let key = oldEntry.getHash();\n      let j = key & (m - 1);\n      while (true) {\n        let entry = entries[j];\n        if (entry === undefined) {\n          entries[j] = oldEntry;\n          break;\n        }\n        if (++j >= m) j = 0;\n      }\n    }\n    this._entries = entries;\n  }\n}\n"],"file":"hash.js"}