{"version":3,"sources":["../../src/methods/regexp.js"],"names":["RegExpCreate","realm","P","F","obj","RegExpAlloc","intrinsics","RegExp","RegExpInitialize","newTarget","Create","OrdinaryCreateFromConstructor","$RegExpMatcher","undefined","$OriginalSource","$OriginalFlags","Properties","DefinePropertyOrThrow","PropertyDescriptor","writable","enumerable","configurable","pattern","flags","isNewObject","UndefinedValue","To","ToStringPartial","i","length","indexOf","charAt","createErrorThrowCompletion","SyntaxError","j","BMP","computedFlags","matcher","S","lastIndex","match","exec","endIndex","index","captures","e","Set","zero","RegExpExec","R","ObjectValue","result","StringValue","NullValue","TypeError","throwIfNotConcrete","RegExpBuiltinExec","ToLength","global","sticky","fullUnicode","matchSucceeded","r","null","AdvanceStringIndex","NumberValue","n","A","ArrayCreate","lengthOfA","value","matchIndex","CreateDataProperty","matchedSubstr","substr","captureI","capturedValue","ToString","unicode","Math","pow","first","charCodeAt","second","EscapeRegExpPattern","replace"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Realm } from \"../realm.js\";\nimport invariant from \"../invariant.js\";\nimport { NullValue, NumberValue, ObjectValue, StringValue, UndefinedValue, Value } from \"../values/index.js\";\nimport { Get } from \"./get.js\";\nimport { IsCallable } from \"./is.js\";\nimport { Call } from \"./call.js\";\nimport { HasCompatibleType, HasSomeCompatibleType } from \"./has.js\";\nimport { Create, Properties, To } from \"../singletons.js\";\nimport { PropertyDescriptor } from \"../descriptors.js\";\n\n// ECMA262 21.2.3.2.3\nexport function RegExpCreate(realm: Realm, P: ?Value, F: ?Value): ObjectValue {\n  // 1. Let obj be ? RegExpAlloc(%RegExp%).\n  let obj = RegExpAlloc(realm, realm.intrinsics.RegExp);\n\n  // 2. Return ? RegExpInitialize(obj, P, F).\n  return RegExpInitialize(realm, obj, P, F);\n}\n\n// ECMA262 21.2.3.2.1\nexport function RegExpAlloc(realm: Realm, newTarget: ObjectValue): ObjectValue {\n  // 1. Let obj be ? OrdinaryCreateFromConstructor(newTarget, \"%RegExpPrototype%\", « [[RegExpMatcher]],\n  //    [[OriginalSource]], [[OriginalFlags]] »).\n  let obj = Create.OrdinaryCreateFromConstructor(realm, newTarget, \"RegExpPrototype\", {\n    $RegExpMatcher: undefined, // always initialized to not undefined before use\n    $OriginalSource: undefined, // ditto\n    $OriginalFlags: undefined, // ditto\n  });\n\n  // 2. Perform ! DefinePropertyOrThrow(obj, \"lastIndex\", PropertyDescriptor {[[Writable]]: true,\n  //    [[Enumerable]]: false, [[Configurable]]: false}).\n  Properties.DefinePropertyOrThrow(\n    realm,\n    obj,\n    \"lastIndex\",\n    new PropertyDescriptor({\n      writable: true,\n      enumerable: false,\n      configurable: false,\n    })\n  );\n\n  // 3. Return obj.\n  return obj;\n}\n\n// ECMA262 21.2.3.2.2\nexport function RegExpInitialize(realm: Realm, obj: ObjectValue, pattern: ?Value, flags: ?Value): ObjectValue {\n  // Note that obj is a new object, and we can thus write to internal slots\n  invariant(realm.isNewObject(obj));\n\n  // 1. If pattern is undefined, let P be the empty String.\n  let P;\n  if (!pattern || HasCompatibleType(pattern, UndefinedValue)) {\n    P = \"\";\n  } else {\n    // 2. Else, let P be ? ToString(pattern).\n    P = To.ToStringPartial(realm, pattern);\n  }\n\n  // 3. If flags is undefined, let F be the empty String.\n  let F;\n  if (!flags || HasCompatibleType(flags, UndefinedValue)) {\n    F = \"\";\n  } else {\n    // 4. Else, let F be ? ToString(flags).\n    F = To.ToStringPartial(realm, flags);\n  }\n\n  // 5. If F contains any code unit other than \"g\", \"i\", \"m\", \"u\", or \"y\" or if it contains the same code unit more than once, throw a SyntaxError exception.\n  for (let i = 0; i < F.length; ++i) {\n    if (\"gimuy\".indexOf(F.charAt(i)) < 0) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"invalid RegExp flag\");\n    }\n    for (let j = i + 1; j < F.length; ++j) {\n      if (F.charAt(i) === F.charAt(j)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"duplicate RegExp flag\");\n      }\n    }\n  }\n\n  // 6. If F contains \"u\", let BMP be false; else let BMP be true.\n  let BMP = F.indexOf(\"u\") >= 0 ? false : true;\n\n  // 7. If BMP is true, then\n  if (BMP) {\n    // a. Parse P using the grammars in 21.2.1 and interpreting each of its 16-bit elements as a Unicode BMP\n    //    code point. UTF-16 decoding is not applied to the elements. The goal symbol for the parse is\n    //    Pattern. Throw a SyntaxError exception if P did not conform to the grammar, if any elements of P\n    //    were not matched by the parse, or if any Early Error conditions exist.\n    // b. Let patternCharacters be a List whose elements are the code unit elements of P.\n  } else {\n    // 8. Else,\n    // a. Parse P using the grammars in 21.2.1 and interpreting P as UTF-16 encoded Unicode code points\n    //    (6.1.4). The goal symbol for the parse is Pattern[U]. Throw a SyntaxError exception if P did not\n    //    conform to the grammar, if any elements of P were not matched by the parse, or if any Early Error\n    //    conditions exist.\n    // b. Let patternCharacters be a List whose elements are the code points resulting from applying UTF-16\n    //    decoding to P's sequence of elements.\n  }\n\n  // 9. Set the value of obj's [[OriginalSource]] internal slot to P.\n  obj.$OriginalSource = P;\n\n  // 10. Set the value of obj's [[OriginalFlags]] internal slot to F.\n  obj.$OriginalFlags = F;\n\n  // 11. Set obj's [[RegExpMatcher]] internal slot to the internal procedure that evaluates the above parse of\n  //     P by applying the semantics provided in 21.2.2 using patternCharacters as the pattern's List of\n  //     SourceCharacter values and F as the flag parameters.\n  try {\n    let computedFlags = \"y\";\n    if (F.indexOf(\"i\") >= 0) computedFlags += \"i\";\n    if (F.indexOf(\"u\") >= 0) computedFlags += \"u\";\n    if (F.indexOf(\"m\") >= 0) computedFlags += \"m\";\n    let matcher = new RegExp(P, (computedFlags: any));\n\n    obj.$RegExpMatcher = (S: string, lastIndex: number) => {\n      matcher.lastIndex = lastIndex;\n      let match = matcher.exec(S);\n      if (!match) {\n        return null;\n      }\n      return {\n        endIndex: match.index + match[0].length,\n        captures: match,\n      };\n    };\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.SyntaxError, \"invalid RegExp\");\n    } else throw e;\n  }\n\n  // 12. Perform ? Set(obj, \"lastIndex\", 0, true).\n  Properties.Set(realm, obj, \"lastIndex\", realm.intrinsics.zero, true);\n\n  // 13. Return obj.\n  return obj;\n}\n\n// ECMA262 21.2.5.2.1\nexport function RegExpExec(realm: Realm, R: ObjectValue, S: string): ObjectValue | NullValue {\n  // 1. Assert: Type(R) is Object.\n  invariant(R instanceof ObjectValue, \"Type(R) is Object\");\n\n  // 2. Assert: Type(S) is String.\n  invariant(typeof S === \"string\", \"Type(S) is String\");\n\n  // 3. Let exec be ? Get(R, \"exec\").\n  let exec = Get(realm, R, \"exec\");\n\n  // 4. If IsCallable(exec) is true, then\n  if (IsCallable(realm, exec)) {\n    // a. Let result be ? Call(exec, R, « S »).\n    let result = Call(realm, exec, R, [new StringValue(realm, S)]);\n\n    // b. If Type(result) is neither Object or Null, throw a TypeError exception.\n    if (!HasSomeCompatibleType(result, ObjectValue, NullValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"Type(result) is neither Object or Null\");\n    }\n\n    // c. Return result.\n    return ((result.throwIfNotConcrete(): any): ObjectValue | NullValue);\n  }\n\n  // 5. If R does not have a [[RegExpMatcher]] internal slot, throw a TypeError exception.\n  if (R.$RegExpMatcher === undefined) {\n    throw realm.createErrorThrowCompletion(\n      realm.intrinsics.TypeError,\n      \"R does not have a [[RegExpMatcher]] internal slot\"\n    );\n  }\n\n  // 6. Return ? RegExpBuiltinExec(R, S).\n  return RegExpBuiltinExec(realm, R, S);\n}\n\n// ECMA262 21.2.5.2.2\nexport function RegExpBuiltinExec(realm: Realm, R: ObjectValue, S: string): ObjectValue | NullValue {\n  // 1. Assert: R is an initialized RegExp instance.\n  invariant(\n    R.$RegExpMatcher !== undefined && R.$OriginalSource !== undefined && R.$OriginalFlags !== undefined,\n    \"R is an initialized RegExp instance\"\n  );\n\n  // 2. Assert: Type(S) is String.\n  invariant(typeof S === \"string\", \"Type(S) is String\");\n\n  // 3. Let length be the number of code units in S.\n  let length = S.length;\n\n  // 4. Let lastIndex be ? ToLength(? Get(R, \"lastIndex\")).\n  let lastIndex = To.ToLength(realm, Get(realm, R, \"lastIndex\"));\n\n  // 5. Let flags be R.[[OriginalFlags]].\n  let flags = R.$OriginalFlags;\n  invariant(typeof flags === \"string\");\n\n  // 6 .If flags contains \"g\", let global be true, else let global be false.\n  let global = flags.indexOf(\"g\") >= 0 ? true : false;\n\n  // 7. If flags contains \"y\", let sticky be true, else let sticky be false.\n  let sticky = flags.indexOf(\"y\") >= 0 ? true : false;\n\n  // 8. If global is false and sticky is false, let lastIndex be 0.\n  if (global === false && sticky === false) lastIndex = 0;\n\n  // 9. Let matcher be the value of R's [[RegExpMatcher]] internal slot.\n  let matcher = R.$RegExpMatcher;\n  invariant(matcher !== undefined);\n\n  // 10. If flags contains \"u\", let fullUnicode be true, else let fullUnicode be false.\n  let fullUnicode = flags.indexOf(\"u\") >= 0 ? true : false;\n\n  // 11. Let matchSucceeded be false.\n  let matchSucceeded = false;\n\n  let r = null;\n  // 12. Repeat, while matchSucceeded is false\n  while (!matchSucceeded) {\n    // a. If lastIndex > length, then\n    if (lastIndex > length) {\n      // i. Perform ? Set(R, \"lastIndex\", 0, true).\n      Properties.Set(realm, R, \"lastIndex\", realm.intrinsics.zero, true);\n      // ii. Return null.\n      return realm.intrinsics.null;\n    }\n\n    // b. Let r be matcher(S, lastIndex).\n    r = matcher(S, lastIndex);\n\n    // c. If r is failure, then\n    if (r == null) {\n      // i. If sticky is true, then\n      if (sticky) {\n        // 1. Perform ? Set(R, \"lastIndex\", 0, true).\n        Properties.Set(realm, R, \"lastIndex\", realm.intrinsics.zero, true);\n\n        // 2. Return null.\n        return realm.intrinsics.null;\n      }\n      // ii. Let lastIndex be AdvanceStringIndex(S, lastIndex, fullUnicode).\n      lastIndex = AdvanceStringIndex(realm, S, lastIndex, fullUnicode);\n    } else {\n      // d. Else,\n      // i. Assert: r is a State.\n      invariant(r, \"r is a State\");\n\n      // ii. Set matchSucceeded to true.\n      matchSucceeded = true;\n\n      // (not in standard) Let lastIndex be the index of the captures\n      lastIndex = (r.captures: any).index;\n    }\n  }\n  invariant(r != null);\n\n  // 13. Let e be r's endIndex value.\n  let e = r.endIndex;\n\n  // 14. If fullUnicode is true, then\n  if (fullUnicode) {\n    // TODO #1018 a. e is an index into the Input character list, derived from S, matched by matcher. Let eUTF be the smallest index into S that corresponds to the character at element e of Input. If e is greater than or equal to the length of Input, then eUTF is the number of code units in S.\n    // b. Let e be eUTF.\n  }\n\n  // 15. If global is true or sticky is true, then\n  if (global === true || sticky === true) {\n    // a. Perform ? Set(R, \"lastIndex\", e, true).\n    Properties.Set(realm, R, \"lastIndex\", new NumberValue(realm, e), true);\n  }\n\n  // 16. Let n be the length of r's captures List. (This is the same value as 21.2.2.1's NcapturingParens.)\n  let n = r.captures.length - 1;\n\n  // 17. Let A be ArrayCreate(n + 1).\n  let A = Create.ArrayCreate(realm, n + 1);\n\n  // 18. Assert: The value of A's \"length\" property is n + 1.\n  let lengthOfA = Get(realm, A, \"length\").throwIfNotConcrete();\n  invariant(lengthOfA instanceof NumberValue);\n  invariant(lengthOfA.value === n + 1, 'The value of A\\'s \"length\" property is n + 1');\n\n  // 19. Let matchIndex be lastIndex.\n  let matchIndex = lastIndex;\n\n  // 20. Perform ! CreateDataProperty(A, \"index\", matchIndex).\n  Create.CreateDataProperty(realm, A, \"index\", new NumberValue(realm, matchIndex));\n\n  // 21. Perform ! CreateDataProperty(A, \"input\", S).\n  Create.CreateDataProperty(realm, A, \"input\", new StringValue(realm, S));\n\n  // 22. Let matchedSubstr be the matched substring (i.e. the portion of S between offset lastIndex inclusive and offset e exclusive).\n  let matchedSubstr = S.substr(lastIndex, e - lastIndex);\n\n  // 23. Perform ! CreateDataProperty(A, \"0\", matchedSubstr).\n  Create.CreateDataProperty(realm, A, \"0\", new StringValue(realm, matchedSubstr));\n\n  // 24. For each integer i such that i > 0 and i ≤ n\n  for (let i = 1; i <= n; ++i) {\n    // a. Let captureI be ith element of r's captures List.\n    let captureI = r.captures[i];\n\n    let capturedValue;\n    // b. If captureI is undefined, let capturedValue be undefined.\n    if (captureI === undefined) {\n      capturedValue = realm.intrinsics.undefined;\n    } else if (fullUnicode) {\n      // c. Else if fullUnicode is true, then\n      // TODO #1018: i. Assert: captureI is a List of code points.\n      // ii. Let capturedValue be a string whose code units are the UTF16Encoding of the code points of captureI.\n      capturedValue = realm.intrinsics.undefined;\n    } else {\n      // d. Else, fullUnicode is false,\n      // i. Assert: captureI is a List of code units.\n      invariant(typeof captureI === \"string\");\n\n      // ii. Let capturedValue be a string consisting of the code units of captureI.\n      capturedValue = new StringValue(realm, captureI);\n    }\n\n    // e. Perform ! CreateDataProperty(A, ! ToString(i), capturedValue).\n    Create.CreateDataProperty(realm, A, To.ToString(realm, new NumberValue(realm, i)), capturedValue);\n  }\n\n  // 25. Return A.\n  return A;\n}\n\nexport function AdvanceStringIndex(realm: Realm, S: string, index: number, unicode: boolean): number {\n  // 1. Assert: Type(S) is String.\n  invariant(typeof S === \"string\", \"Type(S) is String\");\n\n  // 2. Assert: index is an integer such that 0≤index≤253-1.\n  invariant(index >= 0 && index <= Math.pow(2, 53) - 1, \"index is an integer such that 0≤index≤253-1\");\n\n  // 3. Assert: Type(unicode) is Boolean.\n  invariant(typeof unicode === \"boolean\", \"Type(unicode) is Boolean\");\n\n  // 4. If unicode is false, return index+1.\n  if (unicode === false) return index + 1;\n\n  // 5. Let length be the number of code units in S.\n  let length = S.length;\n\n  // 6. If index+1 ≥ length, return index+1.\n  if (index + 1 >= length) return index + 1;\n\n  // 7. Let first be the code unit value at index index in S.\n  let first = S.charCodeAt(index);\n\n  // 8. If first < 0xD800 or first > 0xDBFF, return index+1.\n  if (first < 0xd800 || first > 0xdbff) return index + 1;\n\n  // 9. Let second be the code unit value at index index+1 in S.\n  let second = S.charCodeAt(index + 1);\n\n  // 10. If second < 0xDC00 or second > 0xDFFF, return index+1.\n  if (second < 0xdc00 || second > 0xdfff) return index + 1;\n\n  // 11. Return index+2.\n  return index + 2;\n}\n\nexport function EscapeRegExpPattern(realm: Realm, P: string, F: string): string {\n  return P.replace(\"/\", \"/\");\n}\n"],"file":"regexp.js"}