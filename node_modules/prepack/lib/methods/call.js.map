{"version":3,"sources":["../../src/methods/call.js"],"names":["ArgumentListEvaluation","realm","strictCode","env","argNodes","Array","isArray","args","node_","type","node","list","spreadRef","evaluate","argument","spreadObj","Environment","GetValue","iterator","next","nextArg","push","ref","expr","expressions","length","templateLiteral","siteObj","firstSubRef","firstSub","restSub","slice","map","constructor","Invoke","V","P","argumentsList","func","Call","EvaluateCall","thisValue","Reference","IsPropertyReference","refEnv","GetBase","EnvironmentRecord","WithBaseObject","intrinsics","undefined","EvaluateDirectCall","PrepareForOrdinaryCall","F","newTarget","ObjectValue","callerContext","getRunningContext","calleeContext","createExecutionContext","setFunction","setCaller","calleeRealm","ScriptOrModule","$ScriptOrModule","localEnv","NewFunctionEnvironment","lexicalEnvironment","variableEnvironment","suspend","pushContext","error","onDestroyScope","OrdinaryCallBindThis","thisArgument","thisMode","$ThisMode","$Realm","NullValue","UndefinedValue","globalEnv","$GlobalEnv","globalEnvRec","environmentRecord","GlobalEnvironmentRecord","$GlobalThisValue","To","ToObject","envRec","BindThisValue","callNativeFunctionValue","f","context","GetThisBinding","functionCall","contextVal","inConditional","AbstractObjectValue","completion","callCallback","$NewTarget","value","err","AbruptCompletion","Error","FatalError","wrapInReturnCompletion","ReturnCompletion","currentLocation","kind","condValue","consequentVal","alternateVal","AbstractValue","evaluateWithAbstractConditional","evaluateForEffects","c","OrdinaryCallEvaluateBody","NativeFunctionValue","ECMAScriptSourceFunctionValue","$FunctionKind","Functions","FunctionDeclarationInstantiation","G","Create","OrdinaryCreateFromConstructor","$GeneratorState","$GeneratorContext","code","$ECMAScriptCode","abstractRecursionSummarization","useAbstractInterpretation","pathConditions","isEmpty","normalCall","savedIsSelfRecursive","isSelfRecursive","effects","guardedCall","reportIntrospectionError","applyEffects","result","processResult","JoinedNormalAndAbruptCompletions","activeArguments","has","previousPathLength","previousArguments","get","getLength","widenedArgumentsList","Widen","widenValues","containsArraysOfValue","Map","set","delete","evaluateCompletionDeref","$Strict","getCompletion","priorSavedCompletion","savedCompletion","e","incorporateSavedCompletion","ThrowCompletion","JoinedAbruptCompletions","rc","Completion","makeAllNormalCompletionsResultInUndefined","normalizeSelectedCompletions","r","containsSelectedCompletion","NormalCompletion","rv","Join","joinValuesOfSelectedCompletions","composeWithSavedCompletion","simplifyAndRefineAbstractValue","tailPosition","argList","EvaluateDirectCallWithArgList","Value","isTypeCompatibleWith","getType","FunctionValue","createTemporalFromBuildFunction","functionResultType","concat","throwIfNotConcrete","createErrorThrowCompletion","TypeError","PrepareForTailCall","leafContext","popContext","argsList","Leak","arg","fullArgs","$Call"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { PropertyKeyValue } from \"../types.js\";\nimport type { ECMAScriptFunctionValue } from \"../values/index.js\";\nimport {\n  EnvironmentRecord,\n  GlobalEnvironmentRecord,\n  LexicalEnvironment,\n  mightBecomeAnObject,\n  Reference,\n} from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport { Realm, ExecutionContext } from \"../realm.js\";\nimport Value from \"../values/Value.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  ECMAScriptSourceFunctionValue,\n  FunctionValue,\n  NativeFunctionValue,\n  NullValue,\n  ObjectValue,\n  UndefinedValue,\n} from \"../values/index.js\";\nimport { GetIterator, HasSomeCompatibleType, IsCallable, IsPropertyKey, IteratorStep, IteratorValue } from \"./index.js\";\nimport { GeneratorStart } from \"./generator.js\";\nimport {\n  AbruptCompletion,\n  Completion,\n  JoinedAbruptCompletions,\n  JoinedNormalAndAbruptCompletions,\n  NormalCompletion,\n  ReturnCompletion,\n  ThrowCompletion,\n} from \"../completions.js\";\nimport { GetTemplateObject, GetV, GetThisValue } from \"./get.js\";\nimport { Create, Environment, Functions, Leak, Join, To, Widen } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport { createOperationDescriptor } from \"../utils/generator.js\";\nimport type { BabelNodeExpression, BabelNodeSpreadElement, BabelNodeTemplateLiteral } from \"@babel/types\";\n\n// ECMA262 12.3.6.1\nexport function ArgumentListEvaluation(\n  realm: Realm,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  argNodes: Array<BabelNodeExpression | BabelNodeSpreadElement> | BabelNodeTemplateLiteral\n): Array<Value> {\n  if (Array.isArray(argNodes)) {\n    let args = [];\n    for (let node_ of argNodes) {\n      if (node_.type === \"SpreadElement\") {\n        let node = (node_: BabelNodeSpreadElement);\n        // 1. Let list be a new empty List.\n        let list = args;\n\n        // 2. Let spreadRef be the result of evaluating AssignmentExpression.\n        let spreadRef = env.evaluate(node.argument, strictCode);\n\n        // 3. Let spreadObj be ? GetValue(spreadRef).\n        let spreadObj = Environment.GetValue(realm, spreadRef);\n\n        // 4. Let iterator be ? GetIterator(spreadObj).\n        let iterator = GetIterator(realm, spreadObj);\n\n        // 5. Repeat\n        while (true) {\n          // a. Let next be ? IteratorStep(iterator).\n          let next = IteratorStep(realm, iterator);\n\n          // b. If next is false, return list.\n          if (!next) {\n            break;\n          }\n\n          // c. Let nextArg be ? IteratorValue(next).\n          let nextArg = IteratorValue(realm, next);\n\n          // d. Append nextArg as the last element of list.\n          list.push(nextArg);\n        }\n      } else {\n        let ref = env.evaluate(node_, strictCode);\n        let expr = Environment.GetValue(realm, ref);\n        args.push(expr);\n      }\n    }\n    return args;\n  } else {\n    let node = (argNodes: BabelNodeTemplateLiteral);\n    if (node.expressions.length === 0) {\n      // 1. Let templateLiteral be this TemplateLiteral.\n      let templateLiteral = node;\n\n      // 2. Let siteObj be GetTemplateObject(templateLiteral).\n      let siteObj = GetTemplateObject(realm, templateLiteral);\n\n      // 3. Return a List containing the one element which is siteObj.\n      return [siteObj];\n    } else {\n      // 1. Let templateLiteral be this TemplateLiteral.\n      let templateLiteral = node;\n\n      // 2. Let siteObj be GetTemplateObject(templateLiteral).\n      let siteObj = GetTemplateObject(realm, templateLiteral);\n\n      // 3. Let firstSubRef be the result of evaluating Expression.\n      let firstSubRef = env.evaluate(node.expressions[0], strictCode);\n\n      // 4. Let firstSub be ? GetValue(firstSubRef).\n      let firstSub = Environment.GetValue(realm, firstSubRef);\n\n      // 5. Let restSub be SubstitutionEvaluation of TemplateSpans.\n      let restSub = node.expressions.slice(1, node.expressions.length).map(expr => {\n        return Environment.GetValue(realm, env.evaluate(expr, strictCode));\n      });\n\n      // 6. ReturnIfAbrupt(restSub).\n\n      // 7. Assert: restSub is a List.\n      invariant(restSub.constructor === Array, \"restSub is a List\");\n\n      // 8. Return a List whose first element is siteObj, whose second elements is firstSub, and whose subsequent elements are the elements of restSub, in order. restSub may contain no elements.\n      return [siteObj, firstSub, ...restSub];\n    }\n  }\n}\n\n// ECMA262 7.3.18\nexport function Invoke(realm: Realm, V: Value, P: PropertyKeyValue, argumentsList?: Array<Value>): Value {\n  // 1. Assert: IsPropertyKey(P) is true.\n  invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n  // 2. If argumentsList was not passed, let argumentsList be a new empty List.\n  if (!argumentsList) argumentsList = [];\n\n  // 3. Let func be ? GetV(V, P).\n  let func = GetV(realm, V, P);\n\n  // 4. Return ? Call(func, V, argumentsList).\n  return Call(realm, func, V, argumentsList);\n}\n\n// ECMA262 12.3.4.2\nexport function EvaluateCall(\n  realm: Realm,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  ref: Reference | Value,\n  args: Array<BabelNode> | BabelNodeTemplateLiteral\n): Value {\n  let thisValue;\n\n  // 1. Let func be ? GetValue(ref).\n  let func = Environment.GetValue(realm, ref);\n\n  // 2. If Type(ref) is Reference, then\n  if (ref instanceof Reference) {\n    // a. If IsPropertyReference(ref) is true, then\n    if (Environment.IsPropertyReference(realm, ref)) {\n      // i. Let thisValue be GetThisValue(ref).\n      thisValue = GetThisValue(realm, ref);\n    } else {\n      // b. Else, the base of ref is an Environment Record\n      // i. Let refEnv be GetBase(ref).\n      let refEnv = Environment.GetBase(realm, ref);\n      invariant(refEnv instanceof EnvironmentRecord);\n\n      // ii. Let thisValue be refEnv.WithBaseObject().\n      thisValue = refEnv.WithBaseObject();\n    }\n  } else {\n    // 3. Else Type(ref) is not Reference,\n    // a. Let thisValue be undefined.\n    thisValue = realm.intrinsics.undefined;\n  }\n\n  // 4. Return ? EvaluateDirectCall(func, thisValue, arguments, tailPosition).\n  return EvaluateDirectCall(realm, strictCode, env, ref, func, thisValue, args);\n}\n\n// ECMA262 9.2.1.1\nexport function PrepareForOrdinaryCall(\n  realm: Realm,\n  F: ECMAScriptFunctionValue,\n  newTarget?: ObjectValue\n): ExecutionContext {\n  // 1. Assert: Type(newTarget) is Undefined or Object.\n  invariant(\n    newTarget === undefined || newTarget instanceof ObjectValue,\n    \"expected undefined or object value for new target\"\n  );\n\n  // 2. Let callerContext be the running execution context.\n  let callerContext = realm.getRunningContext();\n\n  // 3. Let calleeContext be a new ECMAScript code execution context.\n  let calleeContext = realm.createExecutionContext();\n\n  // 4. Set the Function of calleeContext to F.\n  calleeContext.setFunction(F);\n  calleeContext.setCaller(realm.getRunningContext());\n\n  // 5. Let calleeRealm be the value of F's [[Realm]] internal slot.\n  let calleeRealm = realm;\n\n  // 6. Set the Realm of calleeContext to calleeRealm.\n  calleeContext.realm = calleeRealm;\n\n  // 7. Set the ScriptOrModule of calleeContext to the value of F's [[ScriptOrModule]] internal slot.\n  calleeContext.ScriptOrModule = F.$ScriptOrModule;\n\n  // 8. Let localEnv be NewFunctionEnvironment(F, newTarget).\n  let localEnv = Environment.NewFunctionEnvironment(realm, F, newTarget);\n\n  // 9. Set the LexicalEnvironment of calleeContext to localEnv.\n  calleeContext.lexicalEnvironment = localEnv;\n\n  // 10. Set the VariableEnvironment of calleeContext to localEnv.\n  calleeContext.variableEnvironment = localEnv;\n\n  // 11. If callerContext is not already suspended, suspend callerContext.\n  callerContext.suspend();\n\n  // 12. Push calleeContext onto the execution context stack; calleeContext is now the running execution context.\n  try {\n    realm.pushContext(calleeContext);\n  } catch (error) {\n    // `realm.pushContext` may throw if we have exceeded the maximum stack size.\n    realm.onDestroyScope(localEnv);\n    throw error;\n  }\n\n  // 13. NOTE Any exception objects produced after this point are associated with calleeRealm.\n\n  // 14. Return calleeContext.\n  return calleeContext;\n}\n\n// ECMA262 9.2.1.2\nexport function OrdinaryCallBindThis(\n  realm: Realm,\n  F: ECMAScriptFunctionValue,\n  calleeContext: ExecutionContext,\n  thisArgument: Value\n): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n  // 1. Let thisMode be the value of F's [[ThisMode]] internal slot.\n  let thisMode = F.$ThisMode;\n\n  // 2. If thisMode is lexical, return NormalCompletion(undefined).\n  if (thisMode === \"lexical\") return realm.intrinsics.undefined;\n\n  // 3. Let calleeRealm be the value of F's [[Realm]] internal slot.\n  let calleeRealm = F.$Realm;\n\n  // 4. Let localEnv be the LexicalEnvironment of calleeContext.\n  let localEnv = calleeContext.lexicalEnvironment;\n\n  let thisValue;\n  // 5. If thisMode is strict, let thisValue be thisArgument.\n  if (thisMode === \"strict\") {\n    thisValue = (thisArgument: any);\n  } else {\n    // 6. Else,\n    // a. If thisArgument is null or undefined, then\n    if (HasSomeCompatibleType(thisArgument, NullValue, UndefinedValue)) {\n      // i. Let globalEnv be calleeRealm.[[GlobalEnv]].\n      let globalEnv = realm.$GlobalEnv;\n\n      // ii. Let globalEnvRec be globalEnv's EnvironmentRecord.\n      let globalEnvRec = globalEnv.environmentRecord;\n      invariant(globalEnvRec instanceof GlobalEnvironmentRecord);\n\n      // iii. Let thisValue be globalEnvRec.[[GlobalThisValue]].\n      thisValue = globalEnvRec.$GlobalThisValue;\n    } else {\n      //  b. Else,\n      // i. Let thisValue be ! ToObject(thisArgument).\n      thisValue = To.ToObject(calleeRealm, thisArgument);\n\n      // ii. NOTE ToObject produces wrapper objects using calleeRealm.\n    }\n  }\n\n  // 7. Let envRec be localEnv's EnvironmentRecord.\n  invariant(localEnv !== undefined);\n  let envRec = localEnv.environmentRecord;\n\n  // 8. Assert: The next step never returns an abrupt completion because envRec.[[ThisBindingStatus]] is not \"initialized\".\n\n  // 9. Return envRec.BindThisValue(thisValue).\n  return envRec.BindThisValue(thisValue);\n}\n\nfunction callNativeFunctionValue(\n  realm: Realm,\n  f: NativeFunctionValue,\n  argumentsList: Array<Value>\n): void | AbruptCompletion {\n  let env = realm.getRunningContext().lexicalEnvironment;\n  let context = env.environmentRecord.GetThisBinding();\n\n  // we have an inConditional flag, as we do not want to return\n  const functionCall = (contextVal, inConditional) => {\n    try {\n      invariant(\n        contextVal instanceof AbstractObjectValue ||\n          contextVal instanceof ObjectValue ||\n          contextVal instanceof NullValue ||\n          contextVal instanceof UndefinedValue ||\n          mightBecomeAnObject(contextVal)\n      );\n      let completion = f.callCallback(\n        // TODO: this is not right. Either fix the type signature of callCallback or wrap contextVal in a coercion\n        ((contextVal: any): AbstractObjectValue | ObjectValue | NullValue | UndefinedValue),\n        argumentsList,\n        env.environmentRecord.$NewTarget\n      );\n      return inConditional ? completion.value : completion;\n    } catch (err) {\n      if (err instanceof AbruptCompletion) {\n        return inConditional ? err.value : err;\n      } else if (err instanceof Error) {\n        throw err;\n      } else {\n        throw new FatalError(err);\n      }\n    }\n  };\n\n  const wrapInReturnCompletion = contextVal => new ReturnCompletion(contextVal, realm.currentLocation);\n\n  if (context instanceof AbstractObjectValue && context.kind === \"conditional\") {\n    let [condValue, consequentVal, alternateVal] = context.args;\n    invariant(condValue instanceof AbstractValue);\n\n    return wrapInReturnCompletion(\n      realm.evaluateWithAbstractConditional(\n        condValue,\n        () => {\n          return realm.evaluateForEffects(\n            () => functionCall(consequentVal, true),\n            null,\n            \"callNativeFunctionValue consequent\"\n          );\n        },\n        () => {\n          return realm.evaluateForEffects(\n            () => functionCall(alternateVal, true),\n            null,\n            \"callNativeFunctionValue alternate\"\n          );\n        }\n      )\n    );\n  }\n  let c = functionCall(context, false);\n  if (c instanceof AbruptCompletion) return c;\n  return undefined;\n}\n\n// ECMA262 9.2.1.3\nexport function OrdinaryCallEvaluateBody(\n  realm: Realm,\n  f: ECMAScriptFunctionValue,\n  argumentsList: Array<Value>\n): void | AbruptCompletion {\n  if (f instanceof NativeFunctionValue) {\n    return callNativeFunctionValue(realm, f, argumentsList);\n  } else {\n    invariant(f instanceof ECMAScriptSourceFunctionValue);\n    let F = f;\n    if (F.$FunctionKind === \"generator\") {\n      // 1. Perform ? FunctionDeclarationInstantiation(functionObject, argumentsList).\n      Functions.FunctionDeclarationInstantiation(realm, F, argumentsList);\n\n      // 2. Let G be ? OrdinaryCreateFromConstructor(functionObject, \"%GeneratorPrototype%\", « [[GeneratorState]], [[GeneratorContext]] »).\n      let G = Create.OrdinaryCreateFromConstructor(realm, F, \"GeneratorPrototype\", {\n        $GeneratorState: undefined,\n        $GeneratorContext: undefined,\n      });\n\n      // 3. Perform GeneratorStart(G, FunctionBody).\n      let code = F.$ECMAScriptCode;\n      invariant(code !== undefined);\n      GeneratorStart(realm, G, code);\n\n      // 4. Return Completion{[[Type]]: return, [[Value]]: G, [[Target]]: empty}.\n      return new ReturnCompletion(G, realm.currentLocation);\n    } else {\n      // TODO #1586: abstractRecursionSummarization is disabled for now, as it is likely too limiting\n      // (as observed in large internal tests).\n      const abstractRecursionSummarization = false;\n      if (!realm.useAbstractInterpretation || realm.pathConditions.isEmpty() || !abstractRecursionSummarization)\n        return normalCall();\n      let savedIsSelfRecursive = F.isSelfRecursive;\n      try {\n        F.isSelfRecursive = false;\n        let effects = realm.evaluateForEffects(guardedCall, undefined, \"OrdinaryCallEvaluateBody\");\n        if (F.isSelfRecursive) {\n          AbstractValue.reportIntrospectionError(F, \"call to function that calls itself\");\n          throw new FatalError();\n          //todo: need to emit a specialized function that temporally captures the heap state at this point\n        } else {\n          realm.applyEffects(effects);\n          let c = effects.result;\n          return processResult(() => {\n            if (c instanceof AbruptCompletion || c instanceof JoinedNormalAndAbruptCompletions) return c;\n            return undefined;\n          });\n        }\n      } finally {\n        F.isSelfRecursive = savedIsSelfRecursive;\n      }\n\n      function guardedCall(): Value | Completion {\n        let currentLocation = realm.currentLocation;\n        if (F.activeArguments !== undefined && F.activeArguments.has(currentLocation)) {\n          let [previousPathLength, previousArguments] = F.activeArguments.get(currentLocation);\n          if (realm.pathConditions.getLength() > previousPathLength) {\n            invariant(previousArguments !== undefined);\n            // F is being called recursively while a call to it is still active\n            F.isSelfRecursive = true;\n            let widenedArgumentsList: Array<Value> = (Widen.widenValues(realm, previousArguments, argumentsList): any);\n            if (Widen.containsArraysOfValue(realm, previousArguments, widenedArgumentsList)) {\n              // Reached a fixed point. Executing this call will not add any knowledge\n              // about the effects of the original call.\n              return realm.intrinsics.undefined;\n            } else {\n              argumentsList = widenedArgumentsList;\n            }\n          }\n        }\n        try {\n          if (F.activeArguments === undefined) F.activeArguments = new Map();\n          F.activeArguments.set(currentLocation, [realm.pathConditions.getLength(), argumentsList]);\n          return normalCall() || realm.intrinsics.undefined;\n        } finally {\n          F.activeArguments.delete(currentLocation);\n        }\n      }\n\n      function normalCall(): void | AbruptCompletion {\n        // 1. Perform ? FunctionDeclarationInstantiation(F, argumentsList).\n        Functions.FunctionDeclarationInstantiation(realm, F, argumentsList);\n\n        // 2. Return the result of EvaluateBody of the parsed code that is the value of F's\n        //    [[ECMAScriptCode]] internal slot passing F as the argument.\n        let code = F.$ECMAScriptCode;\n        invariant(code !== undefined);\n        let context = realm.getRunningContext();\n        return processResult(() => {\n          let c = context.lexicalEnvironment.evaluateCompletionDeref(code, F.$Strict);\n          if (c instanceof AbruptCompletion || c instanceof JoinedNormalAndAbruptCompletions) return c;\n          return undefined;\n        });\n      }\n\n      function processResult(\n        getCompletion: () => void | AbruptCompletion | JoinedNormalAndAbruptCompletions\n      ): void | AbruptCompletion {\n        // We don't want the callee to see abrupt completions from the caller.\n        let priorSavedCompletion = realm.savedCompletion;\n        realm.savedCompletion = undefined;\n\n        let c;\n        try {\n          c = getCompletion();\n        } catch (e) {\n          invariant(!(e instanceof AbruptCompletion));\n          throw e;\n        }\n        c = Functions.incorporateSavedCompletion(realm, c); // in case the callee had conditional abrupt completions\n        realm.savedCompletion = priorSavedCompletion;\n        if (c === undefined) return undefined; // the callee had no returns or throws\n        if (c instanceof ThrowCompletion || c instanceof ReturnCompletion) return c;\n        // Non mixed completions will not be joined completions, but single completions with joined values.\n        // At this point it must be true that\n        // c contains return completions and possibly also normal completions (which are implicitly \"return undefined;\")\n        // and c also contains throw completions. Hence we assert:\n        invariant(c instanceof JoinedAbruptCompletions || c instanceof JoinedNormalAndAbruptCompletions);\n\n        // We want to add only the throw completions to priorSavedCompletion (but must keep their conditions in tact).\n        // The (joined) return completions must be returned to our caller\n        let rc = c;\n        Completion.makeAllNormalCompletionsResultInUndefined(c);\n        c = Completion.normalizeSelectedCompletions(r => r instanceof ReturnCompletion, c);\n        invariant(c.containsSelectedCompletion(r => r instanceof NormalCompletion));\n        let rv = Join.joinValuesOfSelectedCompletions(r => r instanceof NormalCompletion, c);\n        if (c.containsSelectedCompletion(r => r instanceof ThrowCompletion)) {\n          realm.composeWithSavedCompletion(c);\n          if (rv instanceof AbstractValue) {\n            rv = realm.simplifyAndRefineAbstractValue(rv);\n          }\n        }\n        rc = new ReturnCompletion(rv);\n        return rc;\n      }\n    }\n  }\n}\n\n// ECMA262 12.3.4.3\nexport function EvaluateDirectCall(\n  realm: Realm,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  ref: Value | Reference,\n  func: Value,\n  thisValue: Value,\n  args: Array<BabelNodeExpression | BabelNodeSpreadElement> | BabelNodeTemplateLiteral,\n  tailPosition?: boolean\n): Value {\n  // 1. Let argList be ? ArgumentListEvaluation(arguments).\n  let argList = ArgumentListEvaluation(realm, strictCode, env, args);\n\n  return EvaluateDirectCallWithArgList(realm, strictCode, env, ref, func, thisValue, argList, tailPosition);\n}\n\nexport function EvaluateDirectCallWithArgList(\n  realm: Realm,\n  strictCode: boolean,\n  env: LexicalEnvironment,\n  ref: Value | Reference,\n  func: Value,\n  thisValue: Value,\n  argList: Array<Value>,\n  tailPosition?: boolean\n): Value {\n  if (func instanceof AbstractObjectValue && Value.isTypeCompatibleWith(func.getType(), FunctionValue)) {\n    return AbstractValue.createTemporalFromBuildFunction(\n      realm,\n      func.functionResultType || Value,\n      [func].concat(argList),\n      createOperationDescriptor(\"DIRECT_CALL_WITH_ARG_LIST\")\n    );\n  }\n  func = func.throwIfNotConcrete();\n\n  // 2. If Type(func) is not Object, throw a TypeError exception.\n  if (!(func instanceof ObjectValue)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not an object\");\n  }\n\n  // 3. If IsCallable(func) is false, throw a TypeError exception.\n  if (!IsCallable(realm, func)) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not callable\");\n  }\n\n  // 4. If tailPosition is true, perform PrepareForTailCall().\n  if (tailPosition === true) PrepareForTailCall(realm);\n\n  // 5. Let result be Call(func, thisValue, argList).\n  let result = Call(realm, func, thisValue, argList);\n\n  // 6. Assert: If tailPosition is true, the above call will not return here, but instead\n  //    evaluation will continue as if the following return has already occurred.\n\n  // 7. Assert: If result is not an abrupt completion, then Type(result) is an ECMAScript language type.\n  invariant(result instanceof Value, \"expected language value type\");\n\n  // 8. Return result.\n  return result;\n}\n\n// ECMA262 14.6.3\nexport function PrepareForTailCall(realm: Realm): void {\n  // 1. Let leafContext be the running execution context.\n  let leafContext = realm.getRunningContext();\n\n  // 2. Suspend leafContext.\n  leafContext.suspend();\n\n  // 3. Pop leafContext from the execution context stack. The execution context now on the\n  //    top of the stack becomes the running execution context.\n  realm.onDestroyScope(leafContext.lexicalEnvironment);\n  realm.popContext(leafContext);\n\n  // TODO #1008 4. Assert: leafContext has no further use. It will never be activated as the running execution context.\n}\n\n// ECMA262 7.3.12\nexport function Call(realm: Realm, F: Value, V: Value, argsList?: Array<Value>): Value {\n  // 1. If argumentsList was not passed, let argumentsList be a new empty List.\n  argsList = argsList || [];\n\n  // 2. If IsCallable(F) is false, throw a TypeError exception.\n  if (IsCallable(realm, F) === false) {\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not callable\");\n  }\n  if (F instanceof AbstractValue && Value.isTypeCompatibleWith(F.getType(), FunctionValue)) {\n    Leak.value(realm, V);\n    for (let arg of argsList) {\n      Leak.value(realm, arg);\n    }\n    if (V === realm.intrinsics.undefined) {\n      let fullArgs = [F].concat(argsList);\n      return AbstractValue.createTemporalFromBuildFunction(\n        realm,\n        Value,\n        fullArgs,\n        createOperationDescriptor(\"CALL_ABSTRACT_FUNC\")\n      );\n    } else {\n      let fullArgs = [F, V].concat(argsList);\n      return AbstractValue.createTemporalFromBuildFunction(\n        realm,\n        Value,\n        fullArgs,\n        createOperationDescriptor(\"CALL_ABSTRACT_FUNC_THIS\")\n      );\n    }\n  }\n  invariant(F instanceof ObjectValue);\n\n  // 3. Return ? F.[[Call]](V, argumentsList).\n  invariant(F.$Call, \"no call method on this value\");\n  return F.$Call(V, argsList);\n}\n"],"file":"call.js"}