{"version":3,"sources":["../../src/methods/to.js"],"names":["modulo","x","y","ToImplementation","constructor","ElementConv","Int8","ToInt8","bind","Int16","ToInt16","Int32","ToInt32","Uint8","ToUint8","Uint16","ToUint16","Uint32","ToUint32","Uint8Clamped","ToUint8Clamp","realm","argument","number","ToNumber","isNaN","isFinite","int","Math","floor","abs","int32bit","pow","int16bit","int8bit","f","thisBooleanValue","value","BooleanValue","ObjectValue","$BooleanData","booleanData","throwIfNotConcreteBoolean","throwIfNotConcrete","createErrorThrowCompletion","intrinsics","TypeError","thisNumberValue","NumberValue","$NumberData","numberData","throwIfNotConcreteNumber","thisStringValue","StringValue","$StringData","stringData","throwIfNotConcreteString","ToPropertyDescriptor","Obj","desc","PropertyDescriptor","hasEnumerable","enu","ToBooleanPartial","enumerable","hasConfigurable","conf","configurable","hasValue","hasWritable","writable","hasGet","getter","mightBeUndefined","get","hasSet","setter","set","undefined","ToObject","arg","AbstractObjectValue","AbstractValue","_WrapAbstractInObject","UndefinedValue","NullValue","obj","BooleanPrototype","NumberPrototype","Create","StringCreate","StringPrototype","SymbolValue","SymbolPrototype","$SymbolData","getType","IntegralValue","PrimitiveValue","mightBeNull","mightHaveBeenDeleted","isInPureScope","createFromType","throwIfNotConcreteObject","ToLength","len","ToInteger","Infinity","min","ToIndex","index","integerIndex","RangeError","ToIndexPartial","val","num","ToNumberOrAbstract","reportIntrospectionError","FatalError","NaN","prim","ToPrimitiveOrAbstract","Number","IsToNumberPure","Value","IsToPrimitivePure","type","ToPrimitive","input","hint","throwIfNotConcretePrimitive","exoticToPrim","SymbolToPrimitive","result","OrdinaryToPrimitiveOrAbstract","GetToPrimitivePureResultType","mightBeObject","OrdinaryToPrimitive","methodNames","name","method","resultType","error","CompilerDiagnostic","currentLocation","handleError","isTypeCompatibleWith","ToString","primValue","IsToStringPure","ToStringPartial","ToStringValue","ConcreteValue","str","ToStringAbstract","mightNotBeString","coerceToString","isSimpleObject","evaluateWithPossibleThrowCompletion","createTemporalFromBuildFunction","TypesDomain","topVal","ValuesDomain","createFromBuildFunction","ToBoolean","length","mightNotBeObject","ToPropertyKey","key","ToPropertyKeyPartial","mightNotBeNumber","CanonicalNumericIndexString","n"],"mappings":";;;;;;;AAaA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAeA;;AACA;;AACA;;;;AAtCA;;;;;;;;AAmDA,SAASA,MAAT,CAAgBC,CAAhB,EAA2BC,CAA3B,EAA8C;AAC5C,SAAOD,CAAC,GAAG,CAAJ,GAASA,CAAC,GAAGC,CAAL,GAAUA,CAAlB,GAAsBD,CAAC,GAAGC,CAAjC;AACD;;AAEM,MAAMC,gBAAN,CAAuB;AAC5BC,EAAAA,WAAW,GAAG;AACZ,SAAKC,WAAL,GAAmB;AACjBC,MAAAA,IAAI,EAAE,KAAKC,MAAL,CAAYC,IAAZ,CAAiB,IAAjB,CADW;AAEjBC,MAAAA,KAAK,EAAE,KAAKC,OAAL,CAAaF,IAAb,CAAkB,IAAlB,CAFU;AAGjBG,MAAAA,KAAK,EAAE,KAAKC,OAAL,CAAaJ,IAAb,CAAkB,IAAlB,CAHU;AAIjBK,MAAAA,KAAK,EAAE,KAAKC,OAAL,CAAaN,IAAb,CAAkB,IAAlB,CAJU;AAKjBO,MAAAA,MAAM,EAAE,KAAKC,QAAL,CAAcR,IAAd,CAAmB,IAAnB,CALS;AAMjBS,MAAAA,MAAM,EAAE,KAAKC,QAAL,CAAcV,IAAd,CAAmB,IAAnB,CANS;AAOjBW,MAAAA,YAAY,EAAE,KAAKC,YAAL,CAAkBZ,IAAlB,CAAuB,IAAvB;AAPG,KAAnB;AASD;;AAID;AACAI,EAAAA,OAAO,CAACS,KAAD,EAAeC,QAAf,EAAgD;AACrD;AACA,QAAIC,MAAM,GAAG,KAAKC,QAAL,CAAcH,KAAd,EAAqBC,QAArB,CAAb,CAFqD,CAIrD;;AACA,QAAIG,KAAK,CAACF,MAAD,CAAL,IAAiBA,MAAM,KAAK,CAA5B,IAAiC,CAACG,QAAQ,CAACH,MAAD,CAA9C,EAAwD,OAAO,CAAC,CAAR,CALH,CAOrD;;AACA,QAAII,GAAG,GAAGJ,MAAM,GAAG,CAAT,GAAa,CAACK,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,GAAL,CAASP,MAAT,CAAX,CAAd,GAA6CK,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,GAAL,CAASP,MAAT,CAAX,CAAvD,CARqD,CAUrD;;AACA,QAAIQ,QAAQ,GAAG/B,MAAM,CAAC2B,GAAD,EAAMC,IAAI,CAACI,GAAL,CAAS,CAAT,EAAY,EAAZ,CAAN,CAArB,CAXqD,CAarD;;AACA,WAAOD,QAAQ,IAAIH,IAAI,CAACI,GAAL,CAAS,CAAT,EAAY,EAAZ,CAAZ,GAA8BD,QAAQ,GAAGH,IAAI,CAACI,GAAL,CAAS,CAAT,EAAY,EAAZ,CAAzC,GAA2DD,QAAlE;AACD,GA/B2B,CAiC5B;;;AACAb,EAAAA,QAAQ,CAACG,KAAD,EAAeC,QAAf,EAAgD;AACtD;AACA,QAAIC,MAAM,GAAG,KAAKC,QAAL,CAAcH,KAAd,EAAqBC,QAArB,CAAb,CAFsD,CAItD;;AACA,QAAIG,KAAK,CAACF,MAAD,CAAL,IAAiBA,MAAM,KAAK,CAA5B,IAAiC,CAACG,QAAQ,CAACH,MAAD,CAA9C,EAAwD,OAAO,CAAC,CAAR,CALF,CAOtD;;AACA,QAAII,GAAG,GAAGJ,MAAM,GAAG,CAAT,GAAa,CAACK,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,GAAL,CAASP,MAAT,CAAX,CAAd,GAA6CK,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,GAAL,CAASP,MAAT,CAAX,CAAvD,CARsD,CAUtD;;AACA,QAAIQ,QAAQ,GAAG/B,MAAM,CAAC2B,GAAD,EAAMC,IAAI,CAACI,GAAL,CAAS,CAAT,EAAY,EAAZ,CAAN,CAArB,CAXsD,CAatD;;AACA,WAAOD,QAAP;AACD,GAjD2B,CAmD5B;;;AACArB,EAAAA,OAAO,CAACW,KAAD,EAAeC,QAAf,EAAgD;AACrD;AACA,QAAIC,MAAM,GAAG,KAAKC,QAAL,CAAcH,KAAd,EAAqBC,QAArB,CAAb,CAFqD,CAIrD;;AACA,QAAIG,KAAK,CAACF,MAAD,CAAL,IAAiBA,MAAM,KAAK,CAA5B,IAAiC,CAACG,QAAQ,CAACH,MAAD,CAA9C,EAAwD,OAAO,CAAC,CAAR,CALH,CAOrD;;AACA,QAAII,GAAG,GAAGJ,MAAM,GAAG,CAAT,GAAa,CAACK,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,GAAL,CAASP,MAAT,CAAX,CAAd,GAA6CK,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,GAAL,CAASP,MAAT,CAAX,CAAvD,CARqD,CAUrD;;AACA,QAAIU,QAAQ,GAAGjC,MAAM,CAAC2B,GAAD,EAAMC,IAAI,CAACI,GAAL,CAAS,CAAT,EAAY,EAAZ,CAAN,CAArB,CAXqD,CAarD;;AACA,WAAOC,QAAQ,IAAIL,IAAI,CAACI,GAAL,CAAS,CAAT,EAAY,EAAZ,CAAZ,GAA8BC,QAAQ,GAAGL,IAAI,CAACI,GAAL,CAAS,CAAT,EAAY,EAAZ,CAAzC,GAA2DC,QAAlE;AACD,GAnE2B,CAqE5B;;;AACAjB,EAAAA,QAAQ,CAACK,KAAD,EAAeC,QAAf,EAAgD;AACtD;AACA,QAAIC,MAAM,GAAG,KAAKC,QAAL,CAAcH,KAAd,EAAqBC,QAArB,CAAb,CAFsD,CAItD;;AACA,QAAIG,KAAK,CAACF,MAAD,CAAL,IAAiBA,MAAM,KAAK,CAA5B,IAAiC,CAACG,QAAQ,CAACH,MAAD,CAA9C,EAAwD,OAAO,CAAC,CAAR,CALF,CAOtD;;AACA,QAAII,GAAG,GAAGJ,MAAM,GAAG,CAAT,GAAa,CAACK,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,GAAL,CAASP,MAAT,CAAX,CAAd,GAA6CK,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,GAAL,CAASP,MAAT,CAAX,CAAvD,CARsD,CAUtD;;AACA,QAAIU,QAAQ,GAAGjC,MAAM,CAAC2B,GAAD,EAAMC,IAAI,CAACI,GAAL,CAAS,CAAT,EAAY,EAAZ,CAAN,CAArB,CAXsD,CAatD;;AACA,WAAOC,QAAP;AACD,GArF2B,CAuF5B;;;AACA1B,EAAAA,MAAM,CAACc,KAAD,EAAeC,QAAf,EAAgD;AACpD;AACA,QAAIC,MAAM,GAAG,KAAKC,QAAL,CAAcH,KAAd,EAAqBC,QAArB,CAAb,CAFoD,CAIpD;;AACA,QAAIG,KAAK,CAACF,MAAD,CAAL,IAAiBA,MAAM,KAAK,CAA5B,IAAiC,CAACG,QAAQ,CAACH,MAAD,CAA9C,EAAwD,OAAO,CAAC,CAAR,CALJ,CAOpD;;AACA,QAAII,GAAG,GAAGJ,MAAM,GAAG,CAAT,GAAa,CAACK,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,GAAL,CAASP,MAAT,CAAX,CAAd,GAA6CK,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,GAAL,CAASP,MAAT,CAAX,CAAvD,CARoD,CAUpD;;AACA,QAAIW,OAAO,GAAGlC,MAAM,CAAC2B,GAAD,EAAMC,IAAI,CAACI,GAAL,CAAS,CAAT,EAAY,CAAZ,CAAN,CAApB,CAXoD,CAapD;;AACA,WAAOE,OAAO,IAAIN,IAAI,CAACI,GAAL,CAAS,CAAT,EAAY,CAAZ,CAAX,GAA4BE,OAAO,GAAGN,IAAI,CAACI,GAAL,CAAS,CAAT,EAAY,CAAZ,CAAtC,GAAuDE,OAA9D;AACD,GAvG2B,CAyG5B;;;AACApB,EAAAA,OAAO,CAACO,KAAD,EAAeC,QAAf,EAAgD;AACrD;AACA,QAAIC,MAAM,GAAG,KAAKC,QAAL,CAAcH,KAAd,EAAqBC,QAArB,CAAb,CAFqD,CAIrD;;AACA,QAAIG,KAAK,CAACF,MAAD,CAAL,IAAiBA,MAAM,KAAK,CAA5B,IAAiC,CAACG,QAAQ,CAACH,MAAD,CAA9C,EAAwD,OAAO,CAAC,CAAR,CALH,CAOrD;;AACA,QAAII,GAAG,GAAGJ,MAAM,GAAG,CAAT,GAAa,CAACK,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,GAAL,CAASP,MAAT,CAAX,CAAd,GAA6CK,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,GAAL,CAASP,MAAT,CAAX,CAAvD,CARqD,CAUrD;;AACA,QAAIW,OAAO,GAAGlC,MAAM,CAAC2B,GAAD,EAAMC,IAAI,CAACI,GAAL,CAAS,CAAT,EAAY,CAAZ,CAAN,CAApB,CAXqD,CAarD;;AACA,WAAOE,OAAP;AACD,GAzH2B,CA2H5B;;;AACAd,EAAAA,YAAY,CAACC,KAAD,EAAeC,QAAf,EAAgD;AAC1D;AACA,QAAIC,MAAM,GAAG,KAAKC,QAAL,CAAcH,KAAd,EAAqBC,QAArB,CAAb,CAF0D,CAI1D;;AACA,QAAIG,KAAK,CAACF,MAAD,CAAT,EAAmB,OAAO,CAAC,CAAR,CALuC,CAO1D;;AACA,QAAIA,MAAM,IAAI,CAAd,EAAiB,OAAO,CAAC,CAAR,CARyC,CAU1D;;AACA,QAAIA,MAAM,IAAI,GAAd,EAAmB,OAAO,GAAP,CAXuC,CAa1D;;AACA,QAAIY,CAAC,GAAGP,IAAI,CAACC,KAAL,CAAWN,MAAX,CAAR,CAd0D,CAgB1D;;AACA,QAAIY,CAAC,GAAG,GAAJ,GAAUZ,MAAd,EAAsB,OAAOY,CAAC,GAAG,CAAX,CAjBoC,CAmB1D;;AACA,QAAIZ,MAAM,GAAGY,CAAC,GAAG,GAAjB,EAAsB,OAAOA,CAAP,CApBoC,CAsB1D;;AACA,QAAIA,CAAC,GAAG,CAAJ,KAAU,CAAd,EAAiB,OAAOA,CAAC,GAAG,CAAX,CAvByC,CAyB1D;;AACA,WAAOA,CAAP;AACD,GAvJ2B,CAyJ5B;;;AACAC,EAAAA,gBAAgB,CAACf,KAAD,EAAegB,KAAf,EAA2C;AACzD;AACA,QAAIA,KAAK,YAAYC,oBAArB,EAAmC,OAAOD,KAAP,CAFsB,CAIzD;;AACA,QAAIA,KAAK,YAAYE,mBAAjB,IAAgCF,KAAK,CAACG,YAA1C,EAAwD;AACtD,YAAMC,WAAW,GAAGJ,KAAK,CAACG,YAAN,CAAmBE,yBAAnB,EAApB,CADsD,CAEtD;;AACA,8BAAUD,WAAW,YAAYH,oBAAjC,EAA+C,2DAA/C,EAHsD,CAKtD;;AACA,aAAOG,WAAP;AACD;;AAEDJ,IAAAA,KAAK,CAACM,kBAAN,GAdyD,CAgBzD;;AACA,UAAMtB,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBC,SAAlD,CAAN;AACD,GA5K2B,CA8K5B;;;AACAC,EAAAA,eAAe,CAAC1B,KAAD,EAAegB,KAAf,EAA0C;AACvD;AACA,QAAIA,KAAK,YAAYW,mBAArB,EAAkC,OAAOX,KAAP,CAFqB,CAIvD;;AACA,QAAIA,KAAK,YAAYE,mBAAjB,IAAgCF,KAAK,CAACY,WAA1C,EAAuD;AACrD,YAAMC,UAAU,GAAGb,KAAK,CAACY,WAAN,CAAkBE,wBAAlB,EAAnB,CADqD,CAErD;;AACA,8BAAUD,UAAU,YAAYF,mBAAhC,EAA6C,yDAA7C,EAHqD,CAKrD;;AACA,aAAOE,UAAP;AACD;;AAEDb,IAAAA,KAAK,GAAGA,KAAK,CAACM,kBAAN,EAAR,CAduD,CAgBvD;;AACA,UAAMtB,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBC,SAAlD,CAAN;AACD,GAjM2B,CAmM5B;;;AACAM,EAAAA,eAAe,CAAC/B,KAAD,EAAegB,KAAf,EAA0C;AACvD;AACA,QAAIA,KAAK,YAAYgB,mBAArB,EAAkC,OAAOhB,KAAP,CAFqB,CAIvD;;AACA,QAAIA,KAAK,YAAYE,mBAAjB,IAAgCF,KAAK,CAACiB,WAA1C,EAAuD;AACrD,YAAMC,UAAU,GAAGlB,KAAK,CAACiB,WAAN,CAAkBE,wBAAlB,EAAnB,CADqD,CAErD;;AACA,8BAAUD,UAAU,YAAYF,mBAAhC,EAA6C,yDAA7C,EAHqD,CAKrD;;AACA,aAAOE,UAAP;AACD;;AAEDlB,IAAAA,KAAK,GAAGA,KAAK,CAACM,kBAAN,EAAR,CAduD,CAgBvD;;AACA,UAAMtB,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBC,SAAlD,CAAN;AACD,GAtN2B,CAwN5B;;;AACAW,EAAAA,oBAAoB,CAACpC,KAAD,EAAeqC,GAAf,EAAuC;AACzDA,IAAAA,GAAG,GAAGA,GAAG,CAACf,kBAAJ,EAAN,CADyD,CAGzD;;AACA,QAAI,EAAEe,GAAG,YAAYnB,mBAAjB,CAAJ,EAAmC;AACjC,YAAMlB,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBC,SAAlD,CAAN;AACD,KANwD,CAQzD;;;AACA,QAAIa,IAAI,GAAG,IAAIC,+BAAJ,CAAuB,EAAvB,CAAX,CATyD,CAWzD;;AACA,QAAIC,aAAa,GAAG,sBAAYxC,KAAZ,EAAmBqC,GAAnB,EAAwB,YAAxB,CAApB,CAZyD,CAczD;;AACA,QAAIG,aAAa,KAAK,IAAtB,EAA4B;AAC1B;AACA,UAAIC,GAAG,GAAG,KAAKC,gBAAL,CAAsB1C,KAAtB,EAA6B,cAAIA,KAAJ,EAAWqC,GAAX,EAAgB,YAAhB,CAA7B,CAAV,CAF0B,CAI1B;;AACAC,MAAAA,IAAI,CAACK,UAAL,GAAkBF,GAAG,KAAK,IAA1B;AACD,KArBwD,CAuBzD;;;AACA,QAAIG,eAAe,GAAG,sBAAY5C,KAAZ,EAAmBqC,GAAnB,EAAwB,cAAxB,CAAtB,CAxByD,CA0BzD;;AACA,QAAIO,eAAe,KAAK,IAAxB,EAA8B;AAC5B;AACA,UAAIC,IAAI,GAAG,KAAKH,gBAAL,CAAsB1C,KAAtB,EAA6B,cAAIA,KAAJ,EAAWqC,GAAX,EAAgB,cAAhB,CAA7B,CAAX,CAF4B,CAI5B;;AACAC,MAAAA,IAAI,CAACQ,YAAL,GAAoBD,IAAI,KAAK,IAA7B;AACD,KAjCwD,CAmCzD;;;AACA,QAAIE,QAAQ,GAAG,sBAAY/C,KAAZ,EAAmBqC,GAAnB,EAAwB,OAAxB,CAAf,CApCyD,CAsCzD;;AACA,QAAIU,QAAQ,KAAK,IAAjB,EAAuB;AACrB;AACA,UAAI/B,KAAK,GAAG,cAAIhB,KAAJ,EAAWqC,GAAX,EAAgB,OAAhB,CAAZ,CAFqB,CAIrB;;AACAC,MAAAA,IAAI,CAACtB,KAAL,GAAaA,KAAb;AACD,KA7CwD,CA+CzD;;;AACA,QAAIgC,WAAW,GAAG,sBAAYhD,KAAZ,EAAmBqC,GAAnB,EAAwB,UAAxB,CAAlB,CAhDyD,CAkDzD;;AACA,QAAIW,WAAW,KAAK,IAApB,EAA0B;AACxB;AACA,UAAIC,QAAQ,GAAG,KAAKP,gBAAL,CAAsB1C,KAAtB,EAA6B,cAAIA,KAAJ,EAAWqC,GAAX,EAAgB,UAAhB,CAA7B,CAAf,CAFwB,CAIxB;;AACAC,MAAAA,IAAI,CAACW,QAAL,GAAgBA,QAAQ,KAAK,IAA7B;AACD,KAzDwD,CA2DzD;;;AACA,QAAIC,MAAM,GAAG,sBAAYlD,KAAZ,EAAmBqC,GAAnB,EAAwB,KAAxB,CAAb,CA5DyD,CA8DzD;;AACA,QAAIa,MAAM,KAAK,IAAf,EAAqB;AACnB;AACA,UAAIC,MAAM,GAAG,cAAInD,KAAJ,EAAWqC,GAAX,EAAgB,KAAhB,CAAb,CAFmB,CAInB;;AACA,UAAI,oBAAWrC,KAAX,EAAkBmD,MAAlB,MAA8B,KAA9B,IAAuC,CAACA,MAAM,CAACC,gBAAP,EAA5C,EAAuE;AACrE,cAAMpD,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBC,SAAlD,CAAN;AACD;;AACD0B,MAAAA,MAAM,CAAC7B,kBAAP,GARmB,CAUnB;;AACAgB,MAAAA,IAAI,CAACe,GAAL,GAAaF,MAAb;AACD,KA3EwD,CA6EzD;;;AACA,QAAIG,MAAM,GAAG,sBAAYtD,KAAZ,EAAmBqC,GAAnB,EAAwB,KAAxB,CAAb,CA9EyD,CAgFzD;;AACA,QAAIiB,MAAM,KAAK,IAAf,EAAqB;AACnB;AACA,UAAIC,MAAM,GAAG,cAAIvD,KAAJ,EAAWqC,GAAX,EAAgB,KAAhB,CAAb,CAFmB,CAInB;;AACA,UAAI,oBAAWrC,KAAX,EAAkBuD,MAAlB,MAA8B,KAA9B,IAAuC,CAACA,MAAM,CAACH,gBAAP,EAA5C,EAAuE;AACrE,cAAMpD,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBC,SAAlD,CAAN;AACD;;AACD8B,MAAAA,MAAM,CAACjC,kBAAP,GARmB,CAUnB;;AACAgB,MAAAA,IAAI,CAACkB,GAAL,GAAaD,MAAb;AACD,KA7FwD,CA+FzD;;;AACA,QAAIjB,IAAI,CAACe,GAAL,IAAYf,IAAI,CAACkB,GAArB,EAA0B;AACxB;AACA,UAAIlB,IAAI,CAACtB,KAAL,KAAeyC,SAAf,IAA4BnB,IAAI,CAACW,QAAL,KAAkBQ,SAAlD,EAA6D;AAC3D,cAAMzD,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBC,SAAlD,CAAN;AACD;AACF,KArGwD,CAuGzD;;;AACA,WAAOa,IAAP;AACD,GAlU2B,CAoU5B;;;AACAoB,EAAAA,QAAQ,CAAC1D,KAAD,EAAe2D,GAAf,EAA8D;AACpE,QAAIA,GAAG,YAAYC,2BAAnB,EAAwC,OAAOD,GAAP;;AACxC,QAAIA,GAAG,YAAYE,qBAAnB,EAAkC;AAChC,aAAO,KAAKC,qBAAL,CAA2B9D,KAA3B,EAAkC2D,GAAlC,CAAP;AACD;;AACD,QAAIA,GAAG,YAAYI,sBAAnB,EAAmC;AACjC,YAAM/D,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBC,SAAlD,CAAN;AACD,KAFD,MAEO,IAAIkC,GAAG,YAAYK,iBAAnB,EAA8B;AACnC,YAAMhE,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBC,SAAlD,CAAN;AACD,KAFM,MAEA,IAAIkC,GAAG,YAAY1C,oBAAnB,EAAiC;AACtC,UAAIgD,GAAG,GAAG,IAAI/C,mBAAJ,CAAgBlB,KAAhB,EAAuBA,KAAK,CAACwB,UAAN,CAAiB0C,gBAAxC,CAAV;AACAD,MAAAA,GAAG,CAAC9C,YAAJ,GAAmBwC,GAAnB;AACA,aAAOM,GAAP;AACD,KAJM,MAIA,IAAIN,GAAG,YAAYhC,mBAAnB,EAAgC;AACrC,UAAIsC,GAAG,GAAG,IAAI/C,mBAAJ,CAAgBlB,KAAhB,EAAuBA,KAAK,CAACwB,UAAN,CAAiB2C,eAAxC,CAAV;AACAF,MAAAA,GAAG,CAACrC,WAAJ,GAAkB+B,GAAlB;AACA,aAAOM,GAAP;AACD,KAJM,MAIA,IAAIN,GAAG,YAAY3B,mBAAnB,EAAgC;AACrC,UAAIiC,GAAG,GAAGG,mBAAOC,YAAP,CAAoBrE,KAApB,EAA2B2D,GAA3B,EAAgC3D,KAAK,CAACwB,UAAN,CAAiB8C,eAAjD,CAAV;;AACA,aAAOL,GAAP;AACD,KAHM,MAGA,IAAIN,GAAG,YAAYY,mBAAnB,EAAgC;AACrC,UAAIN,GAAG,GAAG,IAAI/C,mBAAJ,CAAgBlB,KAAhB,EAAuBA,KAAK,CAACwB,UAAN,CAAiBgD,eAAxC,CAAV;AACAP,MAAAA,GAAG,CAACQ,WAAJ,GAAkBd,GAAlB;AACA,aAAOM,GAAP;AACD,KAJM,MAIA,IAAIN,GAAG,YAAYzC,mBAAnB,EAAgC;AACrC,aAAOyC,GAAP;AACD;;AACD,4BAAU,KAAV;AACD;;AAEDG,EAAAA,qBAAqB,CAAC9D,KAAD,EAAe2D,GAAf,EAAsE;AACzF,QAAIM,GAAJ;;AACA,YAAQN,GAAG,CAACe,OAAJ,EAAR;AACE,WAAKC,qBAAL;AACA,WAAKhD,mBAAL;AACEsC,QAAAA,GAAG,GAAG,IAAI/C,mBAAJ,CAAgBlB,KAAhB,EAAuBA,KAAK,CAACwB,UAAN,CAAiB2C,eAAxC,CAAN;AACAF,QAAAA,GAAG,CAACrC,WAAJ,GAAkB+B,GAAlB;AACA;;AAEF,WAAK3B,mBAAL;AACEiC,QAAAA,GAAG,GAAG,IAAI/C,mBAAJ,CAAgBlB,KAAhB,EAAuBA,KAAK,CAACwB,UAAN,CAAiB8C,eAAxC,CAAN;AACAL,QAAAA,GAAG,CAAChC,WAAJ,GAAkB0B,GAAlB;AACA;;AAEF,WAAK1C,oBAAL;AACEgD,QAAAA,GAAG,GAAG,IAAI/C,mBAAJ,CAAgBlB,KAAhB,EAAuBA,KAAK,CAACwB,UAAN,CAAiB0C,gBAAxC,CAAN;AACAD,QAAAA,GAAG,CAAC9C,YAAJ,GAAmBwC,GAAnB;AACA;;AAEF,WAAKY,mBAAL;AACEN,QAAAA,GAAG,GAAG,IAAI/C,mBAAJ,CAAgBlB,KAAhB,EAAuBA,KAAK,CAACwB,UAAN,CAAiBgD,eAAxC,CAAN;AACAP,QAAAA,GAAG,CAACQ,WAAJ,GAAkBd,GAAlB;AACA;;AAEF,WAAKI,sBAAL;AACA,WAAKC,iBAAL;AACA,WAAKY,sBAAL;AACE,YAAIjB,GAAG,CAACkB,WAAJ,MAAqBlB,GAAG,CAACmB,oBAAJ,EAArB,IAAmDnB,GAAG,CAACP,gBAAJ,EAAvD,EACE,MAAMpD,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBC,SAAlD,CAAN;;AAEJ;;AACA;AACE;AACA,YAAIzB,KAAK,CAAC+E,aAAN,EAAJ,EAA2B;AACzB;AACAd,UAAAA,GAAG,GAAGJ,sBAAcmB,cAAd,CAA6BhF,KAA7B,EAAoCkB,mBAApC,EAAiD,+BAAjD,EAAkF,CAACyC,GAAD,CAAlF,CAAN;AACA,kCAAUM,GAAG,YAAYL,2BAAzB;AACD,SAJD,MAIO;AACLK,UAAAA,GAAG,GAAGN,GAAG,CAACsB,wBAAJ,EAAN;AACD;;AACD;AAtCJ;;AAwCA,WAAOhB,GAAP;AACD,GA9Y2B,CAgZ5B;;;AACAiB,EAAAA,QAAQ,CAAClF,KAAD,EAAeC,QAAf,EAAgD;AACtD;AACA,QAAIkF,GAAG,GAAG,KAAKC,SAAL,CAAepF,KAAf,EAAsBC,QAAtB,CAAV,CAFsD,CAItD;;AACA,QAAIkF,GAAG,IAAI,CAAX,EAAc,OAAO,CAAC,CAAR,CALwC,CAOtD;;AACA,QAAIA,GAAG,KAAK,CAACE,QAAb,EAAuB,OAAO9E,IAAI,CAACI,GAAL,CAAS,CAAT,EAAY,EAAZ,IAAkB,CAAzB,CAR+B,CAUtD;;AACA,WAAOJ,IAAI,CAAC+E,GAAL,CAASH,GAAT,EAAc5E,IAAI,CAACI,GAAL,CAAS,CAAT,EAAY,EAAZ,IAAkB,CAAhC,CAAP;AACD,GA7Z2B,CA+Z5B;;;AACAyE,EAAAA,SAAS,CAACpF,KAAD,EAAeC,QAAf,EAAgD;AACvD;AACA,QAAIC,MAAM,GAAG,KAAKC,QAAL,CAAcH,KAAd,EAAqBC,QAArB,CAAb,CAFuD,CAIvD;;AACA,QAAIG,KAAK,CAACF,MAAD,CAAT,EAAmB,OAAO,CAAC,CAAR,CALoC,CAOvD;;AACA,QAAI,CAACG,QAAQ,CAACH,MAAD,CAAT,IAAqBA,MAAM,KAAK,CAApC,EAAuC,OAAOA,MAAP,CARgB,CAUvD;;AACA,WAAOA,MAAM,GAAG,CAAT,GAAa,CAACK,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,GAAL,CAASP,MAAT,CAAX,CAAd,GAA6CK,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,GAAL,CAASP,MAAT,CAAX,CAApD;AACD,GA5a2B,CA8a5B;;;AACAqF,EAAAA,OAAO,CAACvF,KAAD,EAAegB,KAAf,EAAsD;AAC3D,QAAIwE,KAAJ,CAD2D,CAE3D;;AACA,QAAIxE,KAAK,YAAY+C,sBAArB,EAAqC;AACnC;AACAyB,MAAAA,KAAK,GAAG,CAAR;AACD,KAHD,MAGO;AACL;AACA;AACA,UAAIC,YAAY,GAAG,KAAKL,SAAL,CAAepF,KAAf,EAAsBgB,KAAtB,CAAnB,CAHK,CAKL;;AACA,UAAIyE,YAAY,GAAG,CAAnB,EAAsB;AACpB,cAAMzF,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBkE,UAAlD,EAA8D,kBAA9D,CAAN;AACD,OARI,CAUL;;;AACAF,MAAAA,KAAK,GAAG,KAAKN,QAAL,CAAclF,KAAd,EAAqByF,YAArB,CAAR,CAXK,CAaL;;AACA,UAAI,6BAAczF,KAAd,EAAqB,IAAI2B,mBAAJ,CAAgB3B,KAAhB,EAAuByF,YAAvB,CAArB,EAA2D,IAAI9D,mBAAJ,CAAgB3B,KAAhB,EAAuBwF,KAAvB,CAA3D,MAA8F,KAAlG,EAAyG;AACvG,cAAMxF,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBkE,UAAlD,EAA8D,kBAA9D,CAAN;AACD;AACF,KAvB0D,CAwB3D;;;AACA,WAAOF,KAAP;AACD;;AAEDG,EAAAA,cAAc,CAAC3F,KAAD,EAAegB,KAAf,EAA6C;AACzD,WAAO,KAAKuE,OAAL,CAAavF,KAAb,EAAoB,OAAOgB,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCA,KAAK,CAACM,kBAAN,EAAxD,CAAP;AACD;;AAEDnB,EAAAA,QAAQ,CAACH,KAAD,EAAe4F,GAAf,EAA2C;AACjD,UAAMC,GAAG,GAAG,KAAKC,kBAAL,CAAwB9F,KAAxB,EAA+B4F,GAA/B,CAAZ;;AACA,QAAI,OAAOC,GAAP,KAAe,QAAnB,EAA6B;AAC3BhC,4BAAckC,wBAAd,CAAuCF,GAAvC;;AACA,YAAM,IAAIG,kBAAJ,EAAN;AACD;;AACD,WAAOH,GAAP;AACD,GAtd2B,CAwd5B;;;AACAC,EAAAA,kBAAkB,CAAC9F,KAAD,EAAe4F,GAAf,EAA2E;AAC3F,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,aAAOA,GAAP;AACD,KAFD,MAEO,IAAIA,GAAG,YAAY/B,qBAAnB,EAAkC;AACvC,aAAO+B,GAAP;AACD,KAFM,MAEA,IAAIA,GAAG,YAAY7B,sBAAnB,EAAmC;AACxC,aAAOkC,GAAP;AACD,KAFM,MAEA,IAAIL,GAAG,YAAY5B,iBAAnB,EAA8B;AACnC,aAAO,CAAC,CAAR;AACD,KAFM,MAEA,IAAI4B,GAAG,YAAY1E,mBAAnB,EAAgC;AACrC,UAAIgF,IAAI,GAAG,KAAKC,qBAAL,CAA2BnG,KAA3B,EAAkC4F,GAAlC,EAAuC,QAAvC,CAAX;AACA,aAAO,KAAKE,kBAAL,CAAwB9F,KAAxB,EAA+BkG,IAA/B,CAAP;AACD,KAHM,MAGA,IAAIN,GAAG,YAAY3E,oBAAnB,EAAiC;AACtC,UAAI2E,GAAG,CAAC5E,KAAJ,KAAc,IAAlB,EAAwB;AACtB,eAAO,CAAP;AACD,OAFD,MAEO;AACL;AACA,eAAO,CAAP;AACD;AACF,KAPM,MAOA,IAAI4E,GAAG,YAAYjE,mBAAnB,EAAgC;AACrC,aAAOiE,GAAG,CAAC5E,KAAX;AACD,KAFM,MAEA,IAAI4E,GAAG,YAAY5D,mBAAnB,EAAgC;AACrC,aAAOoE,MAAM,CAACR,GAAG,CAAC5E,KAAL,CAAb;AACD,KAFM,MAEA,IAAI4E,GAAG,YAAYrB,mBAAnB,EAAgC;AACrC,YAAMvE,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBC,SAAlD,CAAN;AACD,KAFM,MAEA;AACL,8BAAU,KAAV,EAAiB,0BAAjB;AACD;AACF;;AAED4E,EAAAA,cAAc,CAACrG,KAAD,EAAe4F,GAAf,EAA4C;AACxD,QAAIA,GAAG,YAAYU,aAAnB,EAA0B;AACxB,UAAI,KAAKC,iBAAL,CAAuBvG,KAAvB,EAA8B4F,GAA9B,CAAJ,EAAwC;AACtC,YAAIY,IAAI,GAAGZ,GAAG,CAAClB,OAAJ,EAAX;AACA,eAAO8B,IAAI,KAAKjC,mBAAT,IAAwBiC,IAAI,KAAK5B,sBAAjC,IAAmD4B,IAAI,KAAKF,aAAnE;AACD;;AACD,aAAO,KAAP;AACD;;AACD,WAAO,IAAP;AACD,GAhgB2B,CAkgB5B;;;AACAG,EAAAA,WAAW,CAACzG,KAAD,EAAe0G,KAAf,EAAqCC,IAArC,EAA6F;AACtG,WAAO,KAAKR,qBAAL,CAA2BnG,KAA3B,EAAkC0G,KAAlC,EAAyCC,IAAzC,EAA+CC,2BAA/C,EAAP;AACD;;AAEDT,EAAAA,qBAAqB,CACnBnG,KADmB,EAEnB0G,KAFmB,EAGnBC,IAHmB,EAIa;AAChC,QAAID,KAAK,YAAY9B,sBAArB,EAAqC;AACnC,aAAO8B,KAAP;AACD,KAH+B,CAKhC;;;AACA,4BAAUA,KAAK,YAAYxF,mBAA3B,EAAwC,oBAAxC,EANgC,CAQhC;;AACAyF,IAAAA,IAAI,GAAGA,IAAI,IAAI,SAAf,CATgC,CAWhC;AACA;AACA;AAEA;;AACA,QAAIE,YAAY,GAAG,oBAAU7G,KAAV,EAAiB0G,KAAjB,EAAwB1G,KAAK,CAACwB,UAAN,CAAiBsF,iBAAzC,CAAnB,CAhBgC,CAkBhC;;AACA,QAAI,EAAED,YAAY,YAAY9C,sBAA1B,CAAJ,EAA+C;AAC7C;AACA,UAAIgD,MAAM,GAAG,gBAAK/G,KAAL,EAAY6G,YAAZ,EAA0BH,KAA1B,EAAiC,CAAC,IAAI1E,mBAAJ,CAAgBhC,KAAhB,EAAuB2G,IAAvB,CAAD,CAAjC,CAAb,CAF6C,CAI7C;;AACA,UAAI,EAAEI,MAAM,YAAY7F,mBAApB,CAAJ,EAAsC;AACpC,gCAAU6F,MAAM,YAAYnC,sBAA5B;AACA,eAAOmC,MAAP;AACD,OAR4C,CAU7C;;;AACA,YAAM/G,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBC,SAAlD,CAAN;AACD,KA/B+B,CAiChC;;;AACA,QAAIkF,IAAI,KAAK,SAAb,EAAwBA,IAAI,GAAG,QAAP,CAlCQ,CAoChC;;AACA,WAAO,KAAKK,6BAAL,CAAmChH,KAAnC,EAA0C0G,KAA1C,EAAiDC,IAAjD,CAAP;AACD,GAjjB2B,CAmjB5B;;;AACAM,EAAAA,4BAA4B,CAACjH,KAAD,EAAe0G,KAAf,EAAkD;AAC5E,QAAIF,IAAI,GAAGE,KAAK,CAAChC,OAAN,EAAX;AACA,QAAIgC,KAAK,YAAY9B,sBAArB,EAAqC,OAAO4B,IAAP;AACrC,QAAIE,KAAK,YAAY7C,qBAAjB,IAAkC,CAAC6C,KAAK,CAACQ,aAAN,EAAvC,EAA8D,OAAOtC,sBAAP;AAC9D,WAAOnB,SAAP;AACD;;AAED8C,EAAAA,iBAAiB,CAACvG,KAAD,EAAe0G,KAAf,EAA6B;AAC5C,WAAO,KAAKO,4BAAL,CAAkCjH,KAAlC,EAAyC0G,KAAzC,MAAoDjD,SAA3D;AACD,GA7jB2B,CA+jB5B;;;AACA0D,EAAAA,mBAAmB,CAACnH,KAAD,EAAe0G,KAAf,EAAmCC,IAAnC,EAA8E;AAC/F,WAAO,KAAKK,6BAAL,CAAmChH,KAAnC,EAA0C0G,KAA1C,EAAiDC,IAAjD,EAAuDC,2BAAvD,EAAP;AACD;;AAEDI,EAAAA,6BAA6B,CAC3BhH,KAD2B,EAE3B0G,KAF2B,EAG3BC,IAH2B,EAIK;AAChC,QAAIS,WAAJ,CADgC,CAGhC;;AACA,4BAAUV,KAAK,YAAYxF,mBAA3B,EAAwC,iBAAxC,EAJgC,CAMhC;;AACA,4BAAUyF,IAAI,KAAK,QAAT,IAAqBA,IAAI,KAAK,QAAxC,EAAkD,gCAAlD,EAPgC,CAShC;;AACA,QAAIA,IAAI,KAAK,QAAb,EAAuB;AACrB;AACAS,MAAAA,WAAW,GAAG,CAAC,UAAD,EAAa,SAAb,CAAd;AACD,KAHD,MAGO;AACL;AACA;AACAA,MAAAA,WAAW,GAAG,CAAC,SAAD,EAAY,UAAZ,CAAd;AACD,KAjB+B,CAmBhC;;;AACA,SAAK,IAAIC,IAAT,IAAiBD,WAAjB,EAA8B;AAC5B;AACA,UAAIE,MAAM,GAAG,cAAItH,KAAJ,EAAW0G,KAAX,EAAkB,IAAI1E,mBAAJ,CAAgBhC,KAAhB,EAAuBqH,IAAvB,CAAlB,CAAb,CAF4B,CAI5B;;AACA,UAAI,oBAAWrH,KAAX,EAAkBsH,MAAlB,CAAJ,EAA+B;AAC7B;AACA,YAAIP,MAAM,GAAG,gBAAK/G,KAAL,EAAYsH,MAAZ,EAAoBZ,KAApB,CAAb;AACA,YAAIa,UAAU,GAAGR,MAAM,CAACrC,OAAP,EAAjB,CAH6B,CAK7B;;AACA,YAAI6C,UAAU,KAAKjB,aAAnB,EAA0B;AACxB,kCAAUS,MAAM,YAAYlD,qBAA5B;AACA,cAAI2D,KAAK,GAAG,IAAIC,0BAAJ,CACT,GAAEJ,IAAK,6CADE,EAEVrH,KAAK,CAAC0H,eAFI,EAGV,QAHU,EAIV,kBAJU,CAAZ;AAMA1H,UAAAA,KAAK,CAAC2H,WAAN,CAAkBH,KAAlB;AACA,gBAAM,IAAIxB,kBAAJ,EAAN;AACD;;AACD,YAAIM,cAAMsB,oBAAN,CAA2BL,UAA3B,EAAuC3C,sBAAvC,CAAJ,EAA4D;AAC1D,kCAAUmC,MAAM,YAAYlD,qBAAlB,IAAmCkD,MAAM,YAAYnC,sBAA/D;AACA,iBAAOmC,MAAP;AACD;AACF;AACF,KA/C+B,CAiDhC;;;AACA,UAAM/G,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBC,SAAlD,EAA6D,yBAA7D,CAAN;AACD,GA3nB2B,CA6nB5B;;;AACAoG,EAAAA,QAAQ,CAAC7H,KAAD,EAAe4F,GAAf,EAAoD;AAC1D,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,aAAOA,GAAP;AACD,KAFD,MAEO,IAAIA,GAAG,YAAY5D,mBAAnB,EAAgC;AACrC,aAAO4D,GAAG,CAAC5E,KAAX;AACD,KAFM,MAEA,IAAI4E,GAAG,YAAYjE,mBAAnB,EAAgC;AACrC,aAAOiE,GAAG,CAAC5E,KAAJ,GAAY,EAAnB;AACD,KAFM,MAEA,IAAI4E,GAAG,YAAY7B,sBAAnB,EAAmC;AACxC,aAAO,WAAP;AACD,KAFM,MAEA,IAAI6B,GAAG,YAAY5B,iBAAnB,EAA8B;AACnC,aAAO,MAAP;AACD,KAFM,MAEA,IAAI4B,GAAG,YAAYrB,mBAAnB,EAAgC;AACrC,YAAMvE,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBC,SAAlD,CAAN;AACD,KAFM,MAEA,IAAImE,GAAG,YAAY3E,oBAAnB,EAAiC;AACtC,aAAO2E,GAAG,CAAC5E,KAAJ,GAAY,MAAZ,GAAqB,OAA5B;AACD,KAFM,MAEA,IAAI4E,GAAG,YAAY1E,mBAAnB,EAAgC;AACrC,UAAI4G,SAAS,GAAG,KAAKrB,WAAL,CAAiBzG,KAAjB,EAAwB4F,GAAxB,EAA6B,QAA7B,CAAhB;AACA,aAAO,KAAKiC,QAAL,CAAc7H,KAAd,EAAqB8H,SAArB,CAAP;AACD,KAHM,MAGA;AACL,YAAM9H,KAAK,CAACuB,0BAAN,CAAiCvB,KAAK,CAACwB,UAAN,CAAiBC,SAAlD,EAA6D,4CAA7D,CAAN;AACD;AACF;;AAEDsG,EAAAA,cAAc,CAAC/H,KAAD,EAAe0G,KAAf,EAA+C;AAC3D,QAAIA,KAAK,YAAYJ,aAArB,EAA4B;AAC1B,UAAI,KAAKC,iBAAL,CAAuBvG,KAAvB,EAA8B0G,KAA9B,CAAJ,EAA0C;AACxC,YAAIF,IAAI,GAAGE,KAAK,CAAChC,OAAN,EAAX;AACA,eAAO8B,IAAI,KAAKjC,mBAAT,IAAwBiC,IAAI,KAAK5B,sBAAjC,IAAmD4B,IAAI,KAAKF,aAAnE;AACD;AACF;;AACD,WAAO,IAAP;AACD;;AAED0B,EAAAA,eAAe,CAAChI,KAAD,EAAe4F,GAAf,EAA4C;AACzD,WAAO,KAAKiC,QAAL,CAAc7H,KAAd,EAAqB,OAAO4F,GAAP,KAAe,QAAf,GAA0BA,GAA1B,GAAgCA,GAAG,CAACtE,kBAAJ,EAArD,CAAP;AACD;;AAED2G,EAAAA,aAAa,CAACjI,KAAD,EAAe4F,GAAf,EAAkC;AAC7C,QAAIA,GAAG,CAAClB,OAAJ,OAAkB1C,mBAAtB,EAAmC,OAAO4D,GAAP;;AACnC,QAAIA,GAAG,YAAY1E,mBAAnB,EAAgC;AAC9B,UAAI4G,SAAS,GAAG,KAAK3B,qBAAL,CAA2BnG,KAA3B,EAAkC4F,GAAlC,EAAuC,QAAvC,CAAhB;AACA,UAAIkC,SAAS,CAACpD,OAAV,OAAwB1C,mBAA5B,EAAyC,OAAO8F,SAAP;AACzC,aAAO,KAAKG,aAAL,CAAmBjI,KAAnB,EAA0B8H,SAA1B,CAAP;AACD,KAJD,MAIO,IAAIlC,GAAG,YAAYsC,qBAAnB,EAAkC;AACvC,UAAIC,GAAG,GAAG,KAAKN,QAAL,CAAc7H,KAAd,EAAqB4F,GAArB,CAAV;AACA,aAAO,IAAI5D,mBAAJ,CAAgBhC,KAAhB,EAAuBmI,GAAvB,CAAP;AACD,KAHM,MAGA,IAAIvC,GAAG,YAAY/B,qBAAnB,EAAkC;AACvC,aAAO,KAAKuE,gBAAL,CAAsBpI,KAAtB,EAA6B4F,GAA7B,CAAP;AACD,KAFM,MAEA;AACL,8BAAU,KAAV,EAAiB,4CAAjB;AACD;AACF;;AAEDwC,EAAAA,gBAAgB,CAACpI,KAAD,EAAegB,KAAf,EAAoD;AAClE,QAAIA,KAAK,CAACqH,gBAAN,EAAJ,EAA8B;AAC5B,UAAItB,MAAJ,CAD4B,CAE5B;;AACA,UAAIuB,cAAc,GAAG,0CAA0B,kBAA1B,CAArB;;AACA,UAAItH,KAAK,CAACkG,aAAN,MAAyB,CAAClG,KAAK,CAACuH,cAAN,EAA9B,EAAsD;AACpD;AACA;AACA;AACA;AACA;AACA;AACAxB,QAAAA,MAAM,GAAG/G,KAAK,CAACwI,mCAAN,CACP,MAAM3E,sBAAc4E,+BAAd,CAA8CzI,KAA9C,EAAqDgC,mBAArD,EAAkE,CAAChB,KAAD,CAAlE,EAA2EsH,cAA3E,CADC,EAEPI,mBAAYC,MAFL,EAGPC,oBAAaD,MAHN,CAAT;AAKD,OAZD,MAYO;AACL5B,QAAAA,MAAM,GAAGlD,sBAAcgF,uBAAd,CAAsC7I,KAAtC,EAA6CgC,mBAA7C,EAA0D,CAAChB,KAAD,CAA1D,EAAmEsH,cAAnE,CAAT;AACD;;AACD,8BAAUvB,MAAM,YAAYlD,qBAA5B;AACA,aAAOkD,MAAP;AACD;;AACD,WAAO/F,KAAP;AACD,GA3sB2B,CA6sB5B;;;AACA8H,EAAAA,SAAS,CAAC9I,KAAD,EAAe4F,GAAf,EAA4C;AACnD,QAAIA,GAAG,YAAY3E,oBAAnB,EAAiC;AAC/B,aAAO2E,GAAG,CAAC5E,KAAX;AACD,KAFD,MAEO,IAAI4E,GAAG,YAAY7B,sBAAnB,EAAmC;AACxC,aAAO,KAAP;AACD,KAFM,MAEA,IAAI6B,GAAG,YAAY5B,iBAAnB,EAA8B;AACnC,aAAO,KAAP;AACD,KAFM,MAEA,IAAI4B,GAAG,YAAYjE,mBAAnB,EAAgC;AACrC,aAAOiE,GAAG,CAAC5E,KAAJ,KAAc,CAAd,IAAmB,CAACZ,KAAK,CAACwF,GAAG,CAAC5E,KAAL,CAAhC;AACD,KAFM,MAEA,IAAI4E,GAAG,YAAY5D,mBAAnB,EAAgC;AACrC,aAAO4D,GAAG,CAAC5E,KAAJ,CAAU+H,MAAV,GAAmB,CAA1B;AACD,KAFM,MAEA,IAAInD,GAAG,YAAY1E,mBAAnB,EAAgC;AACrC,aAAO,IAAP;AACD,KAFM,MAEA,IAAI0E,GAAG,YAAYrB,mBAAnB,EAAgC;AACrC,aAAO,IAAP;AACD,KAFM,MAEA;AACL,8BAAU,EAAEqB,GAAG,YAAY/B,qBAAjB,CAAV;AACA,YAAM7D,KAAK,CAACuB,0BAAN,CACJvB,KAAK,CAACwB,UAAN,CAAiBC,SADb,EAEJ,+CAFI,CAAN;AAID;AACF;;AAEDiB,EAAAA,gBAAgB,CAAC1C,KAAD,EAAe4F,GAAf,EAAoC;AAClD,QAAI,CAACA,GAAG,CAACoD,gBAAJ,EAAL,EAA6B,OAAO,IAAP;AAC7B,WAAO,KAAKF,SAAL,CAAe9I,KAAf,EAAsB4F,GAAG,CAACtE,kBAAJ,EAAtB,CAAP;AACD,GAzuB2B,CA2uB5B;;;AACA2H,EAAAA,aAAa,CAACjJ,KAAD,EAAe2D,GAAf;AAAyD;AAA0B;AAC9F;AACA,QAAIuF,GAAG,GAAG,KAAKzC,WAAL,CAAiBzG,KAAjB,EAAwB2D,GAAxB,EAA6B,QAA7B,CAAV,CAF8F,CAI9F;;AACA,QAAIuF,GAAG,YAAY3E,mBAAnB,EAAgC;AAC9B;AACA,aAAO2E,GAAP;AACD,KAR6F,CAU9F;;;AACA,WAAO,KAAKrB,QAAL,CAAc7H,KAAd,EAAqBkJ,GAArB,CAAP;AACD;;AAEDC,EAAAA,oBAAoB,CAACnJ,KAAD,EAAe2D,GAAf;AAAiE;AAA0B;AAC7G,QAAIA,GAAG,YAAYuE,qBAAnB,EAAkC,OAAO,KAAKe,aAAL,CAAmBjJ,KAAnB,EAA0B2D,GAA1B,CAAP,CAD2E,CAE7G;AACA;;AACA,QAAIA,GAAG,CAAC0E,gBAAJ,MAA0B1E,GAAG,CAACyF,gBAAJ,EAA1B,IAAoD,CAACzF,GAAG,CAAC4E,cAAJ,EAArD,IAA6E,CAACvI,KAAK,CAAC+E,aAAN,EAAlF,EAAyG;AACvGpB,MAAAA,GAAG,CAACrC,kBAAJ;AACD;;AACD,4BAAUqC,GAAG,YAAYE,qBAAzB;AACA,WAAOF,GAAP;AACD,GAnwB2B,CAqwB5B;;;AACA0F,EAAAA,2BAA2B,CAACrJ,KAAD,EAAeC,QAAf,EAAqD;AAC9E;AACA,4BAAUA,QAAQ,YAAY+B,mBAA9B,EAF8E,CAI9E;;AACA,QAAI/B,QAAQ,CAACe,KAAT,KAAmB,IAAvB,EAA6B,OAAO,CAAC,CAAR,CALiD,CAO9E;;AACA,QAAIsI,CAAC,GAAG,KAAKnJ,QAAL,CAAcH,KAAd,EAAqBC,QAArB,CAAR,CAR8E,CAU9E;;AACA,QAAI,yBAAUD,KAAV,EAAiB,IAAIgC,mBAAJ,CAAgBhC,KAAhB,EAAuB,KAAK6H,QAAL,CAAc7H,KAAd,EAAqB,IAAI2B,mBAAJ,CAAgB3B,KAAhB,EAAuBsJ,CAAvB,CAArB,CAAvB,CAAjB,EAA0FrJ,QAA1F,MAAwG,KAA5G,EACE,OAAOwD,SAAP,CAZ4E,CAc9E;;AACA,WAAO6F,CAAP;AACD;;AAtxB2B","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Descriptor, CallableObjectValue } from \"../types.js\";\nimport type { Realm } from \"../realm.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { GetMethod, Get } from \"./get.js\";\nimport { Create } from \"../singletons.js\";\nimport { HasProperty } from \"./has.js\";\nimport { Call } from \"./call.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport { IsCallable } from \"./is.js\";\nimport { SameValue, SameValueZero } from \"./abstract.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  NullValue,\n  NumberValue,\n  IntegralValue,\n  ObjectValue,\n  PrimitiveValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport invariant from \"../invariant.js\";\nimport { createOperationDescriptor } from \"../utils/generator.js\";\nimport { PropertyDescriptor } from \"../descriptors.js\";\n\ntype ElementConvType = {\n  Int8: (Realm, numberOrValue) => number,\n  Int16: (Realm, numberOrValue) => number,\n  Int32: (Realm, numberOrValue) => number,\n  Uint8: (Realm, numberOrValue) => number,\n  Uint16: (Realm, numberOrValue) => number,\n  Uint32: (Realm, numberOrValue) => number,\n  Uint8Clamped: (Realm, numberOrValue) => number,\n};\ntype numberOrValue = number | Value;\n\nfunction modulo(x: number, y: number): number {\n  return x < 0 ? (x % y) + y : x % y;\n}\n\nexport class ToImplementation {\n  constructor() {\n    this.ElementConv = {\n      Int8: this.ToInt8.bind(this),\n      Int16: this.ToInt16.bind(this),\n      Int32: this.ToInt32.bind(this),\n      Uint8: this.ToUint8.bind(this),\n      Uint16: this.ToUint16.bind(this),\n      Uint32: this.ToUint32.bind(this),\n      Uint8Clamped: this.ToUint8Clamp.bind(this),\n    };\n  }\n\n  ElementConv: ElementConvType;\n\n  // ECMA262 7.1.5\n  ToInt32(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int16bit be int modulo 2^32.\n    let int32bit = modulo(int, Math.pow(2, 32));\n\n    // 5. If int32bit ≥ 2^31, return int32bit - 2^32; otherwise return int32bit.\n    return int32bit >= Math.pow(2, 31) ? int32bit - Math.pow(2, 32) : int32bit;\n  }\n\n  // ECMA262 7.1.6\n  ToUint32(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int16bit be int modulo 2^32.\n    let int32bit = modulo(int, Math.pow(2, 32));\n\n    // 5. Return int32bit.\n    return int32bit;\n  }\n\n  // ECMA262 7.1.7\n  ToInt16(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int16bit be int modulo 2^16.\n    let int16bit = modulo(int, Math.pow(2, 16));\n\n    // 5. If int16bit ≥ 2^15, return int16bit - 2^16; otherwise return int16bit.\n    return int16bit >= Math.pow(2, 15) ? int16bit - Math.pow(2, 16) : int16bit;\n  }\n\n  // ECMA262 7.1.8\n  ToUint16(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int16bit be int modulo 2^16.\n    let int16bit = modulo(int, Math.pow(2, 16));\n\n    // 5. Return int16bit.\n    return int16bit;\n  }\n\n  // ECMA262 7.1.9\n  ToInt8(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int8bit be int modulo 2^8.\n    let int8bit = modulo(int, Math.pow(2, 8));\n\n    // 5. If int8bit ≥ 2^7, return int8bit - 2^8; otherwise return int8bit.\n    return int8bit >= Math.pow(2, 7) ? int8bit - Math.pow(2, 8) : int8bit;\n  }\n\n  // ECMA262 7.1.10\n  ToUint8(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, +0, -0, +∞, or -∞, return +0.\n    if (isNaN(number) || number === 0 || !isFinite(number)) return +0;\n\n    // 3. Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(number)).\n    let int = number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n\n    // 4. Let int8bit be int modulo 2^8.\n    let int8bit = modulo(int, Math.pow(2, 8));\n\n    // 5. Return int8bit.\n    return int8bit;\n  }\n\n  // ECMA262 7.1.11\n  ToUint8Clamp(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, return +0.\n    if (isNaN(number)) return +0;\n\n    // 3. If number ≤ 0, return +0.\n    if (number <= 0) return +0;\n\n    // 4. If number ≥ 255, return 255.\n    if (number >= 255) return 255;\n\n    // 5. Let f be floor(number).\n    let f = Math.floor(number);\n\n    // 6. If f + 0.5 < number, return f + 1.\n    if (f + 0.5 < number) return f + 1;\n\n    // 7. If number < f + 0.5, return f.\n    if (number < f + 0.5) return f;\n\n    // 8. If f is odd, return f + 1.\n    if (f % 2 === 1) return f + 1;\n\n    // 9. Return f.\n    return f;\n  }\n\n  // ECMA262 19.3.3.1\n  thisBooleanValue(realm: Realm, value: Value): BooleanValue {\n    // 1. If Type(value) is Boolean, return value.\n    if (value instanceof BooleanValue) return value;\n\n    // 2. If Type(value) is Object and value has a [[BooleanData]] internal slot, then\n    if (value instanceof ObjectValue && value.$BooleanData) {\n      const booleanData = value.$BooleanData.throwIfNotConcreteBoolean();\n      // a. Assert: value's [[BooleanData]] internal slot is a Boolean value.\n      invariant(booleanData instanceof BooleanValue, \"expected boolean data internal slot to be a boolean value\");\n\n      // b. Return the value of value's [[BooleanData]] internal slot.\n      return booleanData;\n    }\n\n    value.throwIfNotConcrete();\n\n    // 3. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n\n  // ECMA262 20.1.3\n  thisNumberValue(realm: Realm, value: Value): NumberValue {\n    // 1. If Type(value) is Number, return value.\n    if (value instanceof NumberValue) return value;\n\n    // 2. If Type(value) is Object and value has a [[NumberData]] internal slot, then\n    if (value instanceof ObjectValue && value.$NumberData) {\n      const numberData = value.$NumberData.throwIfNotConcreteNumber();\n      // a. Assert: value's [[NumberData]] internal slot is a Number value.\n      invariant(numberData instanceof NumberValue, \"expected number data internal slot to be a number value\");\n\n      // b. Return the value of value's [[NumberData]] internal slot.\n      return numberData;\n    }\n\n    value = value.throwIfNotConcrete();\n\n    // 3. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n\n  // ECMA262 21.1.3\n  thisStringValue(realm: Realm, value: Value): StringValue {\n    // 1. If Type(value) is String, return value.\n    if (value instanceof StringValue) return value;\n\n    // 2. If Type(value) is Object and value has a [[StringData]] internal slot, then\n    if (value instanceof ObjectValue && value.$StringData) {\n      const stringData = value.$StringData.throwIfNotConcreteString();\n      // a. Assert: value's [[StringData]] internal slot is a String value.\n      invariant(stringData instanceof StringValue, \"expected string data internal slot to be a string value\");\n\n      // b. Return the value of value's [[StringData]] internal slot.\n      return stringData;\n    }\n\n    value = value.throwIfNotConcrete();\n\n    // 3. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n  }\n\n  // ECMA262 6.2.4.5\n  ToPropertyDescriptor(realm: Realm, Obj: Value): Descriptor {\n    Obj = Obj.throwIfNotConcrete();\n\n    // 1. If Type(Obj) is not Object, throw a TypeError exception.\n    if (!(Obj instanceof ObjectValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 2. Let desc be a new Property Descriptor that initially has no fields.\n    let desc = new PropertyDescriptor({});\n\n    // 3. Let hasEnumerable be ? HasProperty(Obj, \"enumerable\").\n    let hasEnumerable = HasProperty(realm, Obj, \"enumerable\");\n\n    // 4. If hasEnumerable is true, then\n    if (hasEnumerable === true) {\n      // a. Let enum be ToBoolean(? Get(Obj, \"enumerable\")).\n      let enu = this.ToBooleanPartial(realm, Get(realm, Obj, \"enumerable\"));\n\n      // b. Set the [[Enumerable]] field of desc to enum.\n      desc.enumerable = enu === true;\n    }\n\n    // 5. Let hasConfigurable be ? HasProperty(Obj, \"configurable\").\n    let hasConfigurable = HasProperty(realm, Obj, \"configurable\");\n\n    // 6. If hasConfigurable is true, then\n    if (hasConfigurable === true) {\n      // a. Let conf be ToBoolean(? Get(Obj, \"configurable\")).\n      let conf = this.ToBooleanPartial(realm, Get(realm, Obj, \"configurable\"));\n\n      // b. Set the [[Configurable]] field of desc to conf.\n      desc.configurable = conf === true;\n    }\n\n    // 7. Let hasValue be ? HasProperty(Obj, \"value\").\n    let hasValue = HasProperty(realm, Obj, \"value\");\n\n    // 8. If hasValue is true, then\n    if (hasValue === true) {\n      // a. Let value be ? Get(Obj, \"value\").\n      let value = Get(realm, Obj, \"value\");\n\n      // b. Set the [[Value]] field of desc to value.\n      desc.value = value;\n    }\n\n    // 9. Let hasWritable be ? HasProperty(Obj, \"writable\").\n    let hasWritable = HasProperty(realm, Obj, \"writable\");\n\n    // 10. If hasWritable is true, then\n    if (hasWritable === true) {\n      // a. Let writable be ToBoolean(? Get(Obj, \"writable\")).\n      let writable = this.ToBooleanPartial(realm, Get(realm, Obj, \"writable\"));\n\n      // b. Set the [[Writable]] field of desc to writable.\n      desc.writable = writable === true;\n    }\n\n    // 11. Let hasGet be ? HasProperty(Obj, \"get\").\n    let hasGet = HasProperty(realm, Obj, \"get\");\n\n    // 12. If hasGet is true, then\n    if (hasGet === true) {\n      // a. Let getter be ? Get(Obj, \"get\").\n      let getter = Get(realm, Obj, \"get\");\n\n      // b. If IsCallable(getter) is false and getter is not undefined, throw a TypeError exception.\n      if (IsCallable(realm, getter) === false && !getter.mightBeUndefined()) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n      getter.throwIfNotConcrete();\n\n      // c. Set the [[Get]] field of desc to getter.\n      desc.get = ((getter: any): CallableObjectValue | UndefinedValue);\n    }\n\n    // 13. Let hasSet be ? HasProperty(Obj, \"set\").\n    let hasSet = HasProperty(realm, Obj, \"set\");\n\n    // 14. If hasSet is true, then\n    if (hasSet === true) {\n      // a. Let setter be ? Get(Obj, \"set\").\n      let setter = Get(realm, Obj, \"set\");\n\n      // b. If IsCallable(setter) is false and setter is not undefined, throw a TypeError exception.\n      if (IsCallable(realm, setter) === false && !setter.mightBeUndefined()) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n      setter.throwIfNotConcrete();\n\n      // c. Set the [[Set]] field of desc to setter.\n      desc.set = ((setter: any): CallableObjectValue | UndefinedValue);\n    }\n\n    // 15. If either desc.[[Get]] or desc.[[Set]] is present, then\n    if (desc.get || desc.set) {\n      // a. If either desc.[[Value]] or desc.[[Writable]] is present, throw a TypeError exception.\n      if (desc.value !== undefined || desc.writable !== undefined) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    }\n\n    // 16. Return desc.\n    return desc;\n  }\n\n  // ECMA262 7.1.13\n  ToObject(realm: Realm, arg: Value): ObjectValue | AbstractObjectValue {\n    if (arg instanceof AbstractObjectValue) return arg;\n    if (arg instanceof AbstractValue) {\n      return this._WrapAbstractInObject(realm, arg);\n    }\n    if (arg instanceof UndefinedValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else if (arg instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else if (arg instanceof BooleanValue) {\n      let obj = new ObjectValue(realm, realm.intrinsics.BooleanPrototype);\n      obj.$BooleanData = arg;\n      return obj;\n    } else if (arg instanceof NumberValue) {\n      let obj = new ObjectValue(realm, realm.intrinsics.NumberPrototype);\n      obj.$NumberData = arg;\n      return obj;\n    } else if (arg instanceof StringValue) {\n      let obj = Create.StringCreate(realm, arg, realm.intrinsics.StringPrototype);\n      return obj;\n    } else if (arg instanceof SymbolValue) {\n      let obj = new ObjectValue(realm, realm.intrinsics.SymbolPrototype);\n      obj.$SymbolData = arg;\n      return obj;\n    } else if (arg instanceof ObjectValue) {\n      return arg;\n    }\n    invariant(false);\n  }\n\n  _WrapAbstractInObject(realm: Realm, arg: AbstractValue): ObjectValue | AbstractObjectValue {\n    let obj;\n    switch (arg.getType()) {\n      case IntegralValue:\n      case NumberValue:\n        obj = new ObjectValue(realm, realm.intrinsics.NumberPrototype);\n        obj.$NumberData = arg;\n        break;\n\n      case StringValue:\n        obj = new ObjectValue(realm, realm.intrinsics.StringPrototype);\n        obj.$StringData = arg;\n        break;\n\n      case BooleanValue:\n        obj = new ObjectValue(realm, realm.intrinsics.BooleanPrototype);\n        obj.$BooleanData = arg;\n        break;\n\n      case SymbolValue:\n        obj = new ObjectValue(realm, realm.intrinsics.SymbolPrototype);\n        obj.$SymbolData = arg;\n        break;\n\n      case UndefinedValue:\n      case NullValue:\n      case PrimitiveValue:\n        if (arg.mightBeNull() || arg.mightHaveBeenDeleted() || arg.mightBeUndefined())\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n\n      /*eslint-disable */\n      default:\n        /*eslint-enable */\n        if (realm.isInPureScope()) {\n          // will be serialized as Object.assign(serialized_arg)\n          obj = AbstractValue.createFromType(realm, ObjectValue, \"explicit conversion to object\", [arg]);\n          invariant(obj instanceof AbstractObjectValue);\n        } else {\n          obj = arg.throwIfNotConcreteObject();\n        }\n        break;\n    }\n    return obj;\n  }\n\n  // ECMA262 7.1.15\n  ToLength(realm: Realm, argument: numberOrValue): number {\n    // Let len be ? ToInteger(argument).\n    let len = this.ToInteger(realm, argument);\n\n    // If len ≤ +0, return +0.\n    if (len <= 0) return +0;\n\n    // If len is +∞, return 2^53-1.\n    if (len === +Infinity) return Math.pow(2, 53) - 1;\n\n    // Return min(len, 2^53-1).\n    return Math.min(len, Math.pow(2, 53) - 1);\n  }\n\n  // ECMA262 7.1.4\n  ToInteger(realm: Realm, argument: numberOrValue): number {\n    // 1. Let number be ? ToNumber(argument).\n    let number = this.ToNumber(realm, argument);\n\n    // 2. If number is NaN, return +0.\n    if (isNaN(number)) return +0;\n\n    // 3. If number is +0, -0, +∞, or -∞, return number.\n    if (!isFinite(number) || number === 0) return number;\n\n    // 4. Return the number value that is the same sign as number and whose magnitude is floor(abs(number)).\n    return number < 0 ? -Math.floor(Math.abs(number)) : Math.floor(Math.abs(number));\n  }\n\n  // ECMA262 7.1.17\n  ToIndex(realm: Realm, value: number | ConcreteValue): number {\n    let index;\n    // 1. If value is undefined, then\n    if (value instanceof UndefinedValue) {\n      // a. Let index be 0.\n      index = 0;\n    } else {\n      // 2. Else,\n      // a. Let integerIndex be ? ToInteger(value).\n      let integerIndex = this.ToInteger(realm, value);\n\n      // b. If integerIndex < 0, throw a RangeError exception.\n      if (integerIndex < 0) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"integerIndex < 0\");\n      }\n\n      // c. Let index be ! ToLength(integerIndex).\n      index = this.ToLength(realm, integerIndex);\n\n      // d. If SameValueZero(integerIndex, index) is false, throw a RangeError exception.\n      if (SameValueZero(realm, new NumberValue(realm, integerIndex), new NumberValue(realm, index)) === false) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.RangeError, \"integerIndex < 0\");\n      }\n    }\n    // 3. Return index.\n    return index;\n  }\n\n  ToIndexPartial(realm: Realm, value: numberOrValue): number {\n    return this.ToIndex(realm, typeof value === \"number\" ? value : value.throwIfNotConcrete());\n  }\n\n  ToNumber(realm: Realm, val: numberOrValue): number {\n    const num = this.ToNumberOrAbstract(realm, val);\n    if (typeof num !== \"number\") {\n      AbstractValue.reportIntrospectionError(num);\n      throw new FatalError();\n    }\n    return num;\n  }\n\n  // ECMA262 7.1.3\n  ToNumberOrAbstract(realm: Realm, val: numberOrValue | AbstractValue): AbstractValue | number {\n    if (typeof val === \"number\") {\n      return val;\n    } else if (val instanceof AbstractValue) {\n      return val;\n    } else if (val instanceof UndefinedValue) {\n      return NaN;\n    } else if (val instanceof NullValue) {\n      return +0;\n    } else if (val instanceof ObjectValue) {\n      let prim = this.ToPrimitiveOrAbstract(realm, val, \"number\");\n      return this.ToNumberOrAbstract(realm, prim);\n    } else if (val instanceof BooleanValue) {\n      if (val.value === true) {\n        return 1;\n      } else {\n        // `val.value === false`\n        return 0;\n      }\n    } else if (val instanceof NumberValue) {\n      return val.value;\n    } else if (val instanceof StringValue) {\n      return Number(val.value);\n    } else if (val instanceof SymbolValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else {\n      invariant(false, \"unexpected type of value\");\n    }\n  }\n\n  IsToNumberPure(realm: Realm, val: numberOrValue): boolean {\n    if (val instanceof Value) {\n      if (this.IsToPrimitivePure(realm, val)) {\n        let type = val.getType();\n        return type !== SymbolValue && type !== PrimitiveValue && type !== Value;\n      }\n      return false;\n    }\n    return true;\n  }\n\n  // ECMA262 7.1.1\n  ToPrimitive(realm: Realm, input: ConcreteValue, hint?: \"default\" | \"string\" | \"number\"): PrimitiveValue {\n    return this.ToPrimitiveOrAbstract(realm, input, hint).throwIfNotConcretePrimitive();\n  }\n\n  ToPrimitiveOrAbstract(\n    realm: Realm,\n    input: ConcreteValue,\n    hint?: \"default\" | \"string\" | \"number\"\n  ): AbstractValue | PrimitiveValue {\n    if (input instanceof PrimitiveValue) {\n      return input;\n    }\n\n    // When Type(input) is Object, the following steps are taken\n    invariant(input instanceof ObjectValue, \"expected an object\");\n\n    // 1. If PreferredType was not passed, let hint be \"default\".\n    hint = hint || \"default\";\n\n    // Following two steps are redundant since we just pass string hints.\n    // 2. Else if PreferredType is hint String, let hint be \"string\".\n    // 3. Else PreferredType is hint Number, let hint be \"number\".\n\n    // 4. Let exoticToPrim be ? GetMethod(input, @@toPrimitive).\n    let exoticToPrim = GetMethod(realm, input, realm.intrinsics.SymbolToPrimitive);\n\n    // 5. If exoticToPrim is not undefined, then\n    if (!(exoticToPrim instanceof UndefinedValue)) {\n      // a. Let result be ? Call(exoticToPrim, input, « hint »).\n      let result = Call(realm, exoticToPrim, input, [new StringValue(realm, hint)]);\n\n      // b. If Type(result) is not Object, return result.\n      if (!(result instanceof ObjectValue)) {\n        invariant(result instanceof PrimitiveValue);\n        return result;\n      }\n\n      // c. Throw a TypeError exception.\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 6. If hint is \"default\", let hint be \"number\".\n    if (hint === \"default\") hint = \"number\";\n\n    // 7. Return ? OrdinaryToPrimitive(input, hint).\n    return this.OrdinaryToPrimitiveOrAbstract(realm, input, hint);\n  }\n\n  // Returns result type of ToPrimitive if it is pure (terminates, does not throw exception, does not read or write heap), otherwise undefined.\n  GetToPrimitivePureResultType(realm: Realm, input: Value): void | typeof Value {\n    let type = input.getType();\n    if (input instanceof PrimitiveValue) return type;\n    if (input instanceof AbstractValue && !input.mightBeObject()) return PrimitiveValue;\n    return undefined;\n  }\n\n  IsToPrimitivePure(realm: Realm, input: Value) {\n    return this.GetToPrimitivePureResultType(realm, input) !== undefined;\n  }\n\n  // ECMA262 7.1.1\n  OrdinaryToPrimitive(realm: Realm, input: ObjectValue, hint: \"string\" | \"number\"): PrimitiveValue {\n    return this.OrdinaryToPrimitiveOrAbstract(realm, input, hint).throwIfNotConcretePrimitive();\n  }\n\n  OrdinaryToPrimitiveOrAbstract(\n    realm: Realm,\n    input: ObjectValue,\n    hint: \"string\" | \"number\"\n  ): AbstractValue | PrimitiveValue {\n    let methodNames;\n\n    // 1. Assert: Type(O) is Object.\n    invariant(input instanceof ObjectValue, \"Expected object\");\n\n    // 2. Assert: Type(hint) is String and its value is either \"string\" or \"number\".\n    invariant(hint === \"string\" || hint === \"number\", \"Expected string or number hint\");\n\n    // 3. If hint is \"string\", then\n    if (hint === \"string\") {\n      // a. Let methodNames be « \"toString\", \"valueOf\" ».\n      methodNames = [\"toString\", \"valueOf\"];\n    } else {\n      // 4. Else,\n      // a. Let methodNames be « \"valueOf\", \"toString\" ».\n      methodNames = [\"valueOf\", \"toString\"];\n    }\n\n    // 5. For each name in methodNames in List order, do\n    for (let name of methodNames) {\n      // a. Let method be ? Get(O, name).\n      let method = Get(realm, input, new StringValue(realm, name));\n\n      // b. If IsCallable(method) is true, then\n      if (IsCallable(realm, method)) {\n        // i. Let result be ? Call(method, O).\n        let result = Call(realm, method, input);\n        let resultType = result.getType();\n\n        // ii. If Type(result) is not Object, return result.\n        if (resultType === Value) {\n          invariant(result instanceof AbstractValue);\n          let error = new CompilerDiagnostic(\n            `${name} might return either an object or primitive`,\n            realm.currentLocation,\n            \"PP0028\",\n            \"RecoverableError\"\n          );\n          realm.handleError(error);\n          throw new FatalError();\n        }\n        if (Value.isTypeCompatibleWith(resultType, PrimitiveValue)) {\n          invariant(result instanceof AbstractValue || result instanceof PrimitiveValue);\n          return result;\n        }\n      }\n    }\n\n    // 6. Throw a TypeError exception.\n    throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"can't turn to primitive\");\n  }\n\n  // ECMA262 7.1.12\n  ToString(realm: Realm, val: string | ConcreteValue): string {\n    if (typeof val === \"string\") {\n      return val;\n    } else if (val instanceof StringValue) {\n      return val.value;\n    } else if (val instanceof NumberValue) {\n      return val.value + \"\";\n    } else if (val instanceof UndefinedValue) {\n      return \"undefined\";\n    } else if (val instanceof NullValue) {\n      return \"null\";\n    } else if (val instanceof SymbolValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    } else if (val instanceof BooleanValue) {\n      return val.value ? \"true\" : \"false\";\n    } else if (val instanceof ObjectValue) {\n      let primValue = this.ToPrimitive(realm, val, \"string\");\n      return this.ToString(realm, primValue);\n    } else {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"unknown value type, can't coerce to string\");\n    }\n  }\n\n  IsToStringPure(realm: Realm, input: string | Value): boolean {\n    if (input instanceof Value) {\n      if (this.IsToPrimitivePure(realm, input)) {\n        let type = input.getType();\n        return type !== SymbolValue && type !== PrimitiveValue && type !== Value;\n      }\n    }\n    return true;\n  }\n\n  ToStringPartial(realm: Realm, val: string | Value): string {\n    return this.ToString(realm, typeof val === \"string\" ? val : val.throwIfNotConcrete());\n  }\n\n  ToStringValue(realm: Realm, val: Value): Value {\n    if (val.getType() === StringValue) return val;\n    if (val instanceof ObjectValue) {\n      let primValue = this.ToPrimitiveOrAbstract(realm, val, \"string\");\n      if (primValue.getType() === StringValue) return primValue;\n      return this.ToStringValue(realm, primValue);\n    } else if (val instanceof ConcreteValue) {\n      let str = this.ToString(realm, val);\n      return new StringValue(realm, str);\n    } else if (val instanceof AbstractValue) {\n      return this.ToStringAbstract(realm, val);\n    } else {\n      invariant(false, \"unknown value type, can't coerce to string\");\n    }\n  }\n\n  ToStringAbstract(realm: Realm, value: AbstractValue): AbstractValue {\n    if (value.mightNotBeString()) {\n      let result;\n      // If the property is not a string we need to coerce it.\n      let coerceToString = createOperationDescriptor(\"COERCE_TO_STRING\");\n      if (value.mightBeObject() && !value.isSimpleObject()) {\n        // If this might be a non-simple object, we need to coerce this at a\n        // temporal point since it can have side-effects.\n        // We can't rely on comparison to do it later, even if\n        // it is non-strict comparison since we'll do multiple\n        // comparisons. So we have to be explicit about when this\n        // happens.\n        result = realm.evaluateWithPossibleThrowCompletion(\n          () => AbstractValue.createTemporalFromBuildFunction(realm, StringValue, [value], coerceToString),\n          TypesDomain.topVal,\n          ValuesDomain.topVal\n        );\n      } else {\n        result = AbstractValue.createFromBuildFunction(realm, StringValue, [value], coerceToString);\n      }\n      invariant(result instanceof AbstractValue);\n      return result;\n    }\n    return value;\n  }\n\n  // ECMA262 7.1.2\n  ToBoolean(realm: Realm, val: ConcreteValue): boolean {\n    if (val instanceof BooleanValue) {\n      return val.value;\n    } else if (val instanceof UndefinedValue) {\n      return false;\n    } else if (val instanceof NullValue) {\n      return false;\n    } else if (val instanceof NumberValue) {\n      return val.value !== 0 && !isNaN(val.value);\n    } else if (val instanceof StringValue) {\n      return val.value.length > 0;\n    } else if (val instanceof ObjectValue) {\n      return true;\n    } else if (val instanceof SymbolValue) {\n      return true;\n    } else {\n      invariant(!(val instanceof AbstractValue));\n      throw realm.createErrorThrowCompletion(\n        realm.intrinsics.TypeError,\n        \"unknown value type, can't coerce to a boolean\"\n      );\n    }\n  }\n\n  ToBooleanPartial(realm: Realm, val: Value): boolean {\n    if (!val.mightNotBeObject()) return true;\n    return this.ToBoolean(realm, val.throwIfNotConcrete());\n  }\n\n  // ECMA262 7.1.14\n  ToPropertyKey(realm: Realm, arg: ConcreteValue): SymbolValue | string /* but not StringValue */ {\n    // 1. Let key be ? ToPrimitive(argument, hint String).\n    let key = this.ToPrimitive(realm, arg, \"string\");\n\n    // 2. If Type(key) is Symbol, then\n    if (key instanceof SymbolValue) {\n      // a. Return key.\n      return key;\n    }\n\n    // 3. Return ! ToString(key).\n    return this.ToString(realm, key);\n  }\n\n  ToPropertyKeyPartial(realm: Realm, arg: Value): AbstractValue | SymbolValue | string /* but not StringValue */ {\n    if (arg instanceof ConcreteValue) return this.ToPropertyKey(realm, arg);\n    // if we are in pure scope, we can assume that ToPropertyKey\n    // won't cause side-effects even if it's not simple\n    if (arg.mightNotBeString() && arg.mightNotBeNumber() && !arg.isSimpleObject() && !realm.isInPureScope()) {\n      arg.throwIfNotConcrete();\n    }\n    invariant(arg instanceof AbstractValue);\n    return arg;\n  }\n\n  // ECMA262 7.1.16\n  CanonicalNumericIndexString(realm: Realm, argument: StringValue): number | void {\n    // 1. Assert: Type(argument) is String.\n    invariant(argument instanceof StringValue);\n\n    // 2. If argument is \"-0\", return −0.\n    if (argument.value === \"-0\") return -0;\n\n    // 3. Let n be ToNumber(argument).\n    let n = this.ToNumber(realm, argument);\n\n    // 4. If SameValue(ToString(n), argument) is false, return undefined.\n    if (SameValue(realm, new StringValue(realm, this.ToString(realm, new NumberValue(realm, n))), argument) === false)\n      return undefined;\n\n    // 5. Return n.\n    return n;\n  }\n}\n"],"file":"to.js"}