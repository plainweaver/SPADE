{"version":3,"sources":["../../src/methods/function.js"],"names":["InternalCall","realm","F","thisArgument","argsList","tracerIndex","startCall","FunctionValue","tracers","length","tracer","nextIndex","detourResult","detourCall","undefined","Value","$FunctionKind","createErrorThrowCompletion","intrinsics","TypeError","callerContext","getRunningContext","calleeContext","calleeEnv","lexicalEnvironment","result","t1","beforeCall","popContext","onDestroyScope","t2","afterCall","ReturnCompletion","value","AbruptCompletion","endCall","$BoundCall","argumentsList","target","$BoundTargetFunction","boundThis","$BoundThis","boundArgs","$BoundArguments","args","concat","$BoundConstruct","newTarget","$Construct","InternalConstruct","ObjectValue","hasRunningContext","useAbstractInterpretation","FatalError","kind","$ConstructorKind","Create","OrdinaryCreateFromConstructor","envRec","constructorEnv","environmentRecord","v","map","AbstractObjectValue","__bottomValue","AbstractValue","condition","consequent","alternate","evaluateWithAbstractConditional","evaluateForEffects","createFromTemplate","throwIfNotConcreteObject","mightBeUndefined","throwIfNotConcrete","envRecThisBinding","GetThisBinding","FunctionImplementation","FindVarScopedDeclarations","ast_node","FindVarScopedDeclarationsFor","ast","level","statements","type","body","astIfStatement","astForStatement","init","astForInStatement","left","astForOfStatement","switchCase","cases","push","astTryStatement","block","finalizer","handler","decls","statement","FunctionDeclarationInstantiation","func","env","code","$ECMAScriptCode","strict","$Strict","formals","$FormalParameters","parameterNames","Object","create","param","paramBindings","t","getBindingIdentifiers","name","hasDuplicates","identifiers","keys","simpleParameterList","hasParameterExpressions","Environment","ContainsExpression","varNames","node","varDeclarations","lexicalNames","functionNames","functionsToInitialize","d","reverse","fn","BoundNames","indexOf","unshift","argumentsObjectNeeded","$ThisMode","paramName","alreadyDeclared","HasBinding","CreateMutableBinding","InitializeBinding","ao","CreateUnmappedArgumentsObject","CreateMappedArgumentsObject","CreateImmutableBinding","iteratorRecord","$Iterator","$Done","IteratorBindingInitialization","varEnv","varEnvRec","instantiatedVarNames","slice","n","NewDeclarativeEnvironment","activeLexicalEnvironments","delete","variableEnvironment","initialValue","GetBindingValue","lexEnv","add","lexEnvRec","lexDeclarations","dn","f","fo","evaluate","SetMutableBinding","empty","SetFunctionName","_name","prefix","getExtensible","StringValue","SymbolValue","description","$Description","emptyString","throwIfNotConcreteString","prefixVal","createFromBinaryOp","expressionLocation","Properties","DefinePropertyOrThrow","PropertyDescriptor","enumerable","writable","configurable","FunctionInitialize","ParameterList","Body","Scope","markVisibleLocalBindingsAsPotentiallyCaptured","isNewObject","len","FormalParameter","NumberValue","Strict","UndefinedValue","$Environment","initialize","$ScriptOrModule","GetActiveScriptOrModule","GeneratorFunctionCreate","functionPrototype","Generator","FunctionAllocate","AddRestrictedFunctionProperties","thrower","ThrowTypeError","desc","get","set","$Call","functionKind","needsConstruct","ECMAScriptSourceFunctionValue","$Prototype","setExtensible","$Realm","BoundFunctionCreate","targetFunction","proto","$GetPrototypeOf","obj","BoundFunctionValue","PerformEval","x","evalRealm","strictCaller","direct","script","program","blockStatement","directives","strictEval","ctx","$GlobalEnv","suspend","evalCxt","createExecutionContext","isStrict","setFunction","setRealm","ScriptOrModule","pushContext","EvalDeclarationInstantiation","e","directive","EvaluateStatements","EmptyValue","resume","incorporateSavedCompletion","c","savedCompletion","pathConditions","pathConditionsAtCreation","SimpleNormalCompletion","JoinedNormalAndAbruptCompletions","subsequentEffects","getCapturedEffects","stopEffectCaptureAndUndoEffects","joinedEffects","Join","composeWithEffects","applyEffects","composedWith","composeCompletions","initialBlockValue","strictCode","blockEnv","blockValue","res","evaluateCompletionDeref","FunctionCreate","prototype","FunctionPrototype","allocKind","pathConditionDuringDeclaration","isEmpty","isReadOnly","GlobalEnvironmentRecord","HasLexicalDeclaration","SyntaxError","thisLex","thisEnvRec","ObjectEnvironmentRecord","parent","declaredFunctionNames","fnDefinable","CanDeclareGlobalFunction","declaredVarNames","vn","vnDefinable","CanDeclareGlobalVar","s","CreateGlobalFunctionBinding","bindingExists","CreateGlobalVarBinding","MakeMethod","homeObject","$HomeObject","DefineMethod","prop","propKey","scope","closure","params","$Key","$Closure"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { LexicalEnvironment } from \"../environment.js\";\nimport type { PropertyKeyValue } from \"../types.js\";\nimport { FatalError } from \"../errors.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { ECMAScriptFunctionValue } from \"../values/index.js\";\nimport {\n  AbruptCompletion,\n  Completion,\n  JoinedNormalAndAbruptCompletions,\n  ReturnCompletion,\n  SimpleNormalCompletion,\n} from \"../completions.js\";\nimport { GlobalEnvironmentRecord, ObjectEnvironmentRecord } from \"../environment.js\";\nimport {\n  AbstractValue,\n  AbstractObjectValue,\n  BoundFunctionValue,\n  ECMAScriptSourceFunctionValue,\n  EmptyValue,\n  FunctionValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { OrdinaryCallEvaluateBody, OrdinaryCallBindThis, PrepareForOrdinaryCall, Call } from \"./call.js\";\nimport { SameValue } from \"../methods/abstract.js\";\nimport { Construct } from \"../methods/construct.js\";\nimport { UpdateEmpty } from \"../methods/index.js\";\nimport { CreateListIterator } from \"../methods/iterator.js\";\nimport { EvalPropertyName } from \"../evaluators/ObjectExpression.js\";\nimport { Create, Environment, Join, Properties } from \"../singletons.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport invariant from \"../invariant.js\";\nimport parse from \"../utils/parse.js\";\nimport IsStrict from \"../utils/strict.js\";\nimport type {\n  BabelNode,\n  BabelNodeBlockStatement,\n  BabelNodeClassMethod,\n  BabelNodeDoWhileStatement,\n  BabelNodeForInStatement,\n  BabelNodeForOfStatement,\n  BabelNodeForStatement,\n  BabelNodeIfStatement,\n  BabelNodeLabeledStatement,\n  BabelNodeLVal,\n  BabelNodeObjectMethod,\n  BabelNodeProgram,\n  BabelNodeStatement,\n  BabelNodeSwitchStatement,\n  BabelNodeTryStatement,\n  BabelNodeVariableDeclaration,\n  BabelNodeWhileStatement,\n  BabelNodeWithStatement,\n} from \"@babel/types\";\nimport * as t from \"@babel/types\";\nimport { PropertyDescriptor } from \"../descriptors.js\";\n\nfunction InternalCall(\n  realm: Realm,\n  F: ECMAScriptFunctionValue,\n  thisArgument: Value,\n  argsList: Array<Value>,\n  tracerIndex: number\n): Value {\n  realm.startCall();\n  try {\n    // 1. Assert: F is an ECMAScript function object.\n    invariant(F instanceof FunctionValue, \"expected function value\");\n\n    // Tracing: Give all registered tracers a chance to detour, wrapping around each other if needed.\n    while (tracerIndex < realm.tracers.length) {\n      let tracer = realm.tracers[tracerIndex];\n      let nextIndex = ++tracerIndex;\n      let detourResult = tracer.detourCall(F, thisArgument, argsList, undefined, () =>\n        InternalCall(realm, F, thisArgument, argsList, nextIndex)\n      );\n      if (detourResult instanceof Value) return detourResult;\n    }\n\n    // 2. If F's [[FunctionKind]] internal slot is \"classConstructor\", throw a TypeError exception.\n    if (F.$FunctionKind === \"classConstructor\")\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"not callable\");\n\n    // 3. Let callerContext be the running execution context.\n    let callerContext = realm.getRunningContext();\n\n    // 4. Let calleeContext be PrepareForOrdinaryCall(F, undefined).\n    let calleeContext = PrepareForOrdinaryCall(realm, F, undefined);\n    let calleeEnv = calleeContext.lexicalEnvironment;\n\n    let result;\n    try {\n      for (let t1 of realm.tracers) t1.beforeCall(F, thisArgument, argsList, undefined);\n\n      // 5. Assert: calleeContext is now the running execution context.\n      invariant(realm.getRunningContext() === calleeContext, \"calleeContext should be current execution context\");\n\n      // 6. Perform OrdinaryCallBindThis(F, calleeContext, thisArgument).\n      OrdinaryCallBindThis(realm, F, calleeContext, thisArgument);\n\n      // 7. Let result be OrdinaryCallEvaluateBody(F, argumentsList).\n      result = OrdinaryCallEvaluateBody(realm, F, argsList);\n    } finally {\n      // 8. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.\n      realm.popContext(calleeContext);\n      realm.onDestroyScope(calleeContext.lexicalEnvironment);\n      if (calleeContext.lexicalEnvironment !== calleeEnv) realm.onDestroyScope(calleeEnv);\n      invariant(realm.getRunningContext() === callerContext);\n\n      for (let t2 of realm.tracers) t2.afterCall(F, thisArgument, argsList, undefined, (result: any));\n    }\n\n    // 9. If result.[[Type]] is return, return NormalCompletion(result.[[Value]]).\n    if (result instanceof ReturnCompletion) {\n      return result.value;\n    }\n\n    // 10. ReturnIfAbrupt(result).\n    if (result instanceof AbruptCompletion) {\n      throw result;\n    }\n\n    // 11. Return NormalCompletion(undefined).\n    return realm.intrinsics.undefined;\n  } finally {\n    realm.endCall();\n  }\n}\n\n// ECMA262 9.4.1.1\nfunction $BoundCall(realm: Realm, F: BoundFunctionValue, thisArgument: Value, argumentsList: Array<Value>): Value {\n  // 1. Let target be the value of F's [[BoundTargetFunction]] internal slot.\n  let target = F.$BoundTargetFunction;\n\n  // 2. Let boundThis be the value of F's [[BoundThis]] internal slot.\n  let boundThis = F.$BoundThis;\n\n  // 3. Let boundArgs be the value of F's [[BoundArguments]] internal slot.\n  let boundArgs = F.$BoundArguments;\n\n  // 4. Let args be a new list containing the same values as the list boundArgs in the same order followed\n  //    by the same values as the list argumentsList in the same order.\n  let args = boundArgs.concat(argumentsList);\n\n  // 5. Return ? Call(target, boundThis, args).\n  return Call(realm, target, boundThis, args);\n}\n\n// ECMA262 9.4.1.2\nfunction $BoundConstruct(\n  realm: Realm,\n  F: BoundFunctionValue,\n  argumentsList: Array<Value>,\n  newTarget: ObjectValue\n): ObjectValue | AbstractObjectValue {\n  // 1. Let target be the value of F's [[BoundTargetFunction]] internal slot.\n  let target = F.$BoundTargetFunction;\n\n  // 2. Assert: target has a [[Construct]] internal method.\n  invariant(target.$Construct !== undefined, \"doesn't have a construct internal method\");\n\n  // 3. Let boundArgs be the value of F's [[BoundArguments]] internal slot.\n  let boundArgs = F.$BoundArguments;\n\n  // 4. Let args be a new list containing the same values as the list boundArgs in the same order followed\n  //    by the same values as the list argumentsList in the same order.\n  let args = boundArgs.concat(argumentsList);\n\n  // 5. If SameValue(F, newTarget) is true, let newTarget be target.\n  if (SameValue(realm, F, newTarget)) newTarget = target;\n\n  // 6. Return ? Construct(target, args, newTarget).\n  return Construct(realm, target, args, newTarget);\n}\n\nfunction InternalConstruct(\n  realm: Realm,\n  F: ECMAScriptFunctionValue,\n  argumentsList: Array<Value>,\n  newTarget: ObjectValue,\n  thisArgument: void | ObjectValue,\n  tracerIndex: number\n): ObjectValue | AbstractObjectValue {\n  realm.startCall();\n  try {\n    // 1. Assert: F is an ECMAScript function object.\n    invariant(F instanceof FunctionValue, \"expected function\");\n\n    // 2. Assert: Type(newTarget) is Object.\n    invariant(newTarget instanceof ObjectValue, \"expected object\");\n\n    if (!realm.hasRunningContext()) {\n      invariant(realm.useAbstractInterpretation);\n      throw new FatalError(\"no running context\");\n    }\n\n    // 3. Let callerContext be the running execution context.\n    let callerContext = realm.getRunningContext();\n\n    // 4. Let kind be F's [[ConstructorKind]] internal slot.\n    let kind = F.$ConstructorKind;\n\n    // 5. If kind is \"base\", then\n    if (thisArgument === undefined && kind === \"base\") {\n      // a. Let thisArgument be ? OrdinaryCreateFromConstructor(newTarget, \"%ObjectPrototype%\").\n      thisArgument = Create.OrdinaryCreateFromConstructor(realm, newTarget, \"ObjectPrototype\");\n    }\n\n    // Tracing: Give all registered tracers a chance to detour, wrapping around each other if needed.\n    while (tracerIndex < realm.tracers.length) {\n      let tracer = realm.tracers[tracerIndex];\n      let nextIndex = ++tracerIndex;\n      let detourResult = tracer.detourCall(F, thisArgument, argumentsList, newTarget, () =>\n        InternalConstruct(realm, F, argumentsList, newTarget, thisArgument, nextIndex)\n      );\n      if (detourResult instanceof ObjectValue) return detourResult;\n      invariant(detourResult === undefined);\n    }\n\n    // 6. Let calleeContext be PrepareForOrdinaryCall(F, newTarget).\n    let calleeContext = PrepareForOrdinaryCall(realm, F, newTarget);\n    let calleeEnv = calleeContext.lexicalEnvironment;\n\n    // 7. Assert: calleeContext is now the running execution context.\n    invariant(realm.getRunningContext() === calleeContext, \"expected calleeContext to be running context\");\n\n    let result, envRec;\n    try {\n      for (let t1 of realm.tracers) t1.beforeCall(F, thisArgument, argumentsList, newTarget);\n\n      // 8. If kind is \"base\", perform OrdinaryCallBindThis(F, calleeContext, thisArgument).\n      if (kind === \"base\") {\n        invariant(thisArgument, \"this wasn't initialized for some reason\");\n        OrdinaryCallBindThis(realm, F, calleeContext, thisArgument);\n      }\n\n      // 9. Let constructorEnv be the LexicalEnvironment of calleeContext.\n      let constructorEnv = calleeContext.lexicalEnvironment;\n\n      // 10. Let envRec be constructorEnv's EnvironmentRecord.\n      envRec = constructorEnv.environmentRecord;\n\n      // 11. Let result be OrdinaryCallEvaluateBody(F, argumentsList).\n      result = OrdinaryCallEvaluateBody(realm, F, argumentsList);\n    } finally {\n      // 12. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.\n      realm.popContext(calleeContext);\n      realm.onDestroyScope(calleeContext.lexicalEnvironment);\n      if (calleeContext.lexicalEnvironment !== calleeEnv) realm.onDestroyScope(calleeEnv);\n      invariant(realm.getRunningContext() === callerContext);\n\n      for (let t2 of realm.tracers) t2.afterCall(F, thisArgument, argumentsList, newTarget, result);\n    }\n\n    // 13. If result.[[Type]] is return, then\n    if (result instanceof ReturnCompletion) {\n      const v = map(result.value);\n      invariant(v instanceof ObjectValue || v instanceof AbstractObjectValue);\n      return v;\n\n      function map(value: Value) {\n        if (value === realm.intrinsics.__bottomValue) return value;\n\n        if (value instanceof AbstractValue) {\n          if (value.kind === \"conditional\") {\n            const [condition, consequent, alternate] = value.args;\n            return realm.evaluateWithAbstractConditional(\n              condition,\n              () => realm.evaluateForEffects(() => map(consequent), undefined, \"AbstractValue/conditional/true\"),\n              () => realm.evaluateForEffects(() => map(alternate), undefined, \"AbstractValue/conditional/false\")\n            );\n          }\n          if (!(value instanceof AbstractObjectValue)) {\n            if (kind === \"base\") {\n              invariant(thisArgument, \"this wasn't initialized for some reason\");\n              return AbstractValue.createFromTemplate(\n                realm,\n                \"typeof A === 'object' || typeof A === 'function' ? A : B\",\n                ObjectValue,\n                [value, thisArgument]\n              );\n            } else {\n              value.throwIfNotConcreteObject(); // Not yet supported.\n            }\n          }\n        }\n\n        // a. If Type(result.[[Value]]) is Object, return NormalCompletion(result.[[Value]]).\n        if (value instanceof ObjectValue || value instanceof AbstractObjectValue) return value;\n\n        // b. If kind is \"base\", return NormalCompletion(thisArgument).\n        if (kind === \"base\") {\n          invariant(thisArgument, \"this wasn't initialized for some reason\");\n          return thisArgument;\n        }\n\n        // c. If result.[[Value]] is not undefined, throw a TypeError exception.\n        if (!value.mightBeUndefined()) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"constructor must return Object\");\n        }\n\n        value.throwIfNotConcrete();\n\n        // 15. Return ? envRec.GetThisBinding().\n        let envRecThisBinding = envRec.GetThisBinding();\n        invariant(envRecThisBinding instanceof ObjectValue);\n        return envRecThisBinding;\n      }\n    } else if (result instanceof AbruptCompletion) {\n      // 14. Else, ReturnIfAbrupt(result).\n      throw result;\n    }\n\n    // 15. Return ? envRec.GetThisBinding().\n    let envRecThisBinding = envRec.GetThisBinding();\n    invariant(envRecThisBinding instanceof ObjectValue);\n    return envRecThisBinding;\n  } finally {\n    realm.endCall();\n  }\n}\n\nexport class FunctionImplementation {\n  FindVarScopedDeclarations(ast_node: BabelNode): Array<BabelNode> {\n    function FindVarScopedDeclarationsFor(ast: BabelNode, level: number) {\n      let statements = [];\n      switch (ast.type) {\n        case \"Program\":\n          statements = ((ast: any): BabelNodeProgram).body;\n          break;\n        case \"BlockStatement\":\n          statements = ((ast: any): BabelNodeBlockStatement).body;\n          break;\n        case \"DoWhileStatement\":\n          statements = [((ast: any): BabelNodeDoWhileStatement).body];\n          break;\n        case \"WhileStatement\":\n          statements = [((ast: any): BabelNodeWhileStatement).body];\n          break;\n        case \"IfStatement\":\n          let astIfStatement: BabelNodeIfStatement = (ast: any);\n          statements = [astIfStatement.consequent, astIfStatement.alternate];\n          break;\n        case \"ForStatement\":\n          let astForStatement: BabelNodeForStatement = (ast: any);\n          statements = [astForStatement.init, astForStatement.body];\n          break;\n        case \"ForInStatement\":\n          let astForInStatement: BabelNodeForInStatement = (ast: any);\n          statements = [astForInStatement.left, astForInStatement.body];\n          break;\n        case \"ForOfStatement\":\n          let astForOfStatement: BabelNodeForOfStatement = (ast: any);\n          statements = [astForOfStatement.left, astForOfStatement.body];\n          break;\n        case \"LabeledStatement\":\n          statements = [((ast: any): BabelNodeLabeledStatement).body];\n          break;\n        case \"WithStatement\":\n          statements = [((ast: any): BabelNodeWithStatement).body];\n          break;\n        case \"SwitchStatement\":\n          for (let switchCase of ((ast: any): BabelNodeSwitchStatement).cases) {\n            statements.push(...switchCase.consequent);\n          }\n          break;\n        case \"TryStatement\":\n          let astTryStatement: BabelNodeTryStatement = (ast: any);\n          statements = [astTryStatement.block];\n          if (astTryStatement.finalizer) statements.push(astTryStatement.finalizer);\n          if (astTryStatement.handler) statements.push(astTryStatement.handler.body);\n          break;\n        case \"VariableDeclaration\":\n          return ((ast: any): BabelNodeVariableDeclaration).kind === \"var\" ? [ast] : [];\n        case \"FunctionDeclaration\":\n          return level < 2 ? [ast] : [];\n        default:\n          return [];\n      }\n\n      let decls = [];\n      for (let statement of statements) {\n        if (statement) {\n          decls = decls.concat(FindVarScopedDeclarationsFor(statement, level + 1));\n        }\n      }\n\n      return decls;\n    }\n    return FindVarScopedDeclarationsFor(ast_node, 0);\n  }\n\n  // ECMA262 9.2.12\n  FunctionDeclarationInstantiation(\n    realm: Realm,\n    func: ECMAScriptSourceFunctionValue,\n    argumentsList: Array<Value>\n  ): EmptyValue {\n    // 1. Let calleeContext be the running execution context.\n    let calleeContext = realm.getRunningContext();\n\n    // 2. Let env be the LexicalEnvironment of calleeContext.\n    let env = calleeContext.lexicalEnvironment;\n\n    // 3. Let envRec be env's EnvironmentRecord.\n    let envRec = env.environmentRecord;\n\n    // 4. Let code be the value of the [[ECMAScriptCode]] internal slot of func.\n    let code = func.$ECMAScriptCode;\n    invariant(code !== undefined);\n\n    // 5. Let strict be the value of the [[Strict]] internal slot of func.\n    let strict = func.$Strict;\n\n    // 6. Let formals be the value of the [[FormalParameters]] internal slot of func.\n    let formals = func.$FormalParameters;\n    invariant(formals !== undefined);\n\n    // 7. Let parameterNames be the BoundNames of formals.\n    let parameterNames = Object.create(null);\n    for (let param of formals) {\n      let paramBindings = t.getBindingIdentifiers(param, true);\n\n      for (let name in paramBindings) {\n        parameterNames[name] = (parameterNames[name] || []).concat(paramBindings[name]);\n      }\n    }\n\n    // 8. If parameterNames has any duplicate entries, let hasDuplicates be true. Otherwise, let hasDuplicates be false.\n    let hasDuplicates = false;\n    for (let name in parameterNames) {\n      let identifiers = parameterNames[name];\n      if (identifiers.length > 1) hasDuplicates = true;\n    }\n    parameterNames = Object.keys(parameterNames);\n\n    // 9. Let simpleParameterList be IsSimpleParameterList of formals.\n    let simpleParameterList = true;\n    for (let param of formals) {\n      if (param.type !== \"Identifier\") {\n        simpleParameterList = false;\n        break;\n      }\n    }\n\n    // 10. Let hasParameterExpressions be ContainsExpression of formals.\n    let hasParameterExpressions = false;\n    invariant(formals !== undefined);\n    for (let param of formals) {\n      if (Environment.ContainsExpression(realm, param)) {\n        hasParameterExpressions = true;\n        break;\n      }\n    }\n\n    // 11. Let varNames be the VarDeclaredNames of code.\n    let varNames = [];\n    traverseFast(code, node => {\n      if (node.type === \"VariableDeclaration\" && ((node: any): BabelNodeVariableDeclaration).kind === \"var\") {\n        varNames = varNames.concat(Object.keys(t.getBindingIdentifiers(node)));\n      }\n\n      if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n        return true;\n      }\n\n      return false;\n    });\n\n    // 12. Let varDeclarations be the VarScopedDeclarations of code.\n    let varDeclarations = this.FindVarScopedDeclarations(code);\n\n    // 13. Let lexicalNames be the LexicallyDeclaredNames of code.\n    let lexicalNames = [];\n\n    // 14. Let functionNames be an empty List.\n    let functionNames = [];\n\n    // 15. Let functionsToInitialize be an empty List.\n    let functionsToInitialize = [];\n\n    // 16. For each d in varDeclarations, in reverse list order do\n    for (let d of varDeclarations.reverse()) {\n      // a. If d is neither a VariableDeclaration or a ForBinding, then\n      if (d.type !== \"VariableDeclaration\") {\n        // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.\n        invariant(d.type === \"FunctionDeclaration\" || d.type === \"GeneratorDeclaration\");\n        // ii. Let fn be the sole element of the BoundNames of d.\n        let fn = Environment.BoundNames(realm, d)[0];\n        // iii. If fn is not an element of functionNames, then\n        if (functionNames.indexOf(fn) < 0) {\n          // 1. Insert fn as the first element of functionNames.\n          functionNames.unshift(fn);\n          // 2. NOTE If there are multiple FunctionDeclarations or GeneratorDeclarations for the same name, the last declaration is used.\n          // 3. Insert d as the first element of functionsToInitialize.\n          functionsToInitialize.unshift(d);\n        }\n      }\n    }\n\n    // 17. Let argumentsObjectNeeded be true.\n    let argumentsObjectNeeded = true;\n\n    // 18. If the value of the [[realmMode]] internal slot of func is lexical, then\n    if (func.$ThisMode === \"lexical\") {\n      // a. NOTE Arrow functions never have an arguments objects.\n      // b. Let argumentsObjectNeeded be false.\n      argumentsObjectNeeded = false;\n    } else if (parameterNames.indexOf(\"arguments\") >= 0) {\n      // 19. Else if \"arguments\" is an element of parameterNames, then\n      // a. Let argumentsObjectNeeded be false.\n      argumentsObjectNeeded = false;\n    } else if (hasParameterExpressions === false) {\n      // 20. Else if hasParameterExpressions is false, then\n      // a. If \"arguments\" is an element of functionNames or if \"arguments\" is an element of lexicalNames, then\n      if (functionNames.indexOf(\"arguments\") >= 0 || lexicalNames.indexOf(\"arguments\") >= 0) {\n        // i. Let argumentsObjectNeeded be false.\n        argumentsObjectNeeded = true;\n      }\n    }\n\n    // 21. For each String paramName in parameterNames, do\n    for (let paramName of parameterNames) {\n      // a. Let alreadyDeclared be envRec.HasBinding(paramName).\n      let alreadyDeclared = envRec.HasBinding(paramName);\n\n      // b. NOTE Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.\n\n      // c. If alreadyDeclared is false, then\n      if (alreadyDeclared === false) {\n        // i. Perform ! envRec.CreateMutableBinding(paramName, false).\n        envRec.CreateMutableBinding(paramName, false);\n\n        // ii. If hasDuplicates is true, then\n        if (hasDuplicates === true) {\n          // 1. Perform ! envRec.InitializeBinding(paramName, undefined).\n          envRec.InitializeBinding(paramName, realm.intrinsics.undefined);\n        }\n      }\n    }\n\n    // 22. If argumentsObjectNeeded is true, then\n    if (argumentsObjectNeeded === true) {\n      let ao;\n\n      // a. If strict is true or if simpleParameterList is false, then\n      if (strict === true || simpleParameterList === false) {\n        // i. Let ao be CreateUnmappedArgumentsObject(argumentsList).\n        ao = Create.CreateUnmappedArgumentsObject(realm, argumentsList);\n      } else {\n        // b. Else,\n        // i. NOTE mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.\n        // ii. Let ao be CreateMappedArgumentsObject(func, formals, argumentsList, envRec).\n        invariant(formals !== undefined);\n        ao = Create.CreateMappedArgumentsObject(realm, func, formals, argumentsList, envRec);\n      }\n\n      // c. If strict is true, then\n      if (strict === true) {\n        // i. Perform ! envRec.CreateImmutableBinding(\"arguments\", false).\n        envRec.CreateImmutableBinding(\"arguments\", false);\n      } else {\n        // d. Else,\n        // i. Perform ! envRec.CreateMutableBinding(\"arguments\", false).\n        envRec.CreateMutableBinding(\"arguments\", false);\n      }\n\n      // e. Call envRec.InitializeBinding(\"arguments\", ao).\n      envRec.InitializeBinding(\"arguments\", ao);\n\n      // f. Append \"arguments\" to parameterNames.\n      parameterNames.push(\"arguments\");\n    }\n\n    // 23. Let iteratorRecord be Record {[[Iterator]]: CreateListIterator(argumentsList), [[Done]]: false}.\n    let iteratorRecord = {\n      $Iterator: CreateListIterator(realm, argumentsList),\n      $Done: false,\n    };\n\n    // 24. If hasDuplicates is true, then\n    if (hasDuplicates === true) {\n      // a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and undefined as arguments.\n      invariant(formals !== undefined);\n      Environment.IteratorBindingInitialization(realm, formals, iteratorRecord, strict);\n    } else {\n      // 25. Else,\n      // a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and env as arguments.\n      invariant(formals !== undefined);\n      Environment.IteratorBindingInitialization(realm, formals, iteratorRecord, strict, env);\n    }\n\n    // 26. If hasParameterExpressions is false, then\n    let varEnv, varEnvRec;\n    if (hasParameterExpressions === false) {\n      // a. NOTE Only a single lexical environment is needed for the parameters and top-level vars.\n      // b. Let instantiatedVarNames be a copy of the List parameterNames.\n      let instantiatedVarNames = parameterNames.slice();\n\n      // c. For each n in varNames, do\n      for (let n of varNames) {\n        // i. If n is not an element of instantiatedVarNames, then\n        if (instantiatedVarNames.indexOf(n) < 0) {\n          // 1. Append n to instantiatedVarNames.\n          instantiatedVarNames.push(n);\n\n          // 2. Perform ! envRec.CreateMutableBinding(n, false).\n          envRec.CreateMutableBinding(n, false);\n\n          // 3. Call envRec.InitializeBinding(n, undefined).\n          envRec.InitializeBinding(n, realm.intrinsics.undefined);\n        }\n      }\n\n      // e. Let varEnv be env.\n      varEnv = env;\n\n      // f. Let varEnvRec be envRec.\n      varEnvRec = envRec;\n    } else {\n      // 27. Else,\n      // a. NOTE A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.\n\n      // b. Let varEnv be NewDeclarativeEnvironment(env).\n      varEnv = Environment.NewDeclarativeEnvironment(realm, env);\n      // At this point we haven't set any context's lexical environment to varEnv (and we might never do so),\n      // so it shouldn't be active\n      realm.activeLexicalEnvironments.delete(varEnv);\n\n      // c. Let varEnvRec be varEnv's EnvironmentRecord.\n      varEnvRec = varEnv.environmentRecord;\n\n      // d. Set the VariableEnvironment of calleeContext to varEnv.\n      calleeContext.variableEnvironment = varEnv;\n\n      // e. Let instantiatedVarNames be a new empty List.\n      let instantiatedVarNames = [];\n\n      // f. For each n in varNames, do\n      for (let n of varNames) {\n        // i. If n is not an element of instantiatedVarNames, then\n        if (instantiatedVarNames.indexOf(n) < 0) {\n          // 1. Append n to instantiatedVarNames.\n          instantiatedVarNames.push(n);\n\n          // 2. Perform ! varEnvRec.CreateMutableBinding(n, false).\n          varEnvRec.CreateMutableBinding(n, false);\n\n          // 3. If n is not an element of parameterNames or if n is an element of functionNames, let initialValue be undefined.\n          let initialValue;\n          if (parameterNames.indexOf(n) < 0 || functionNames.indexOf(n) < 0) {\n            initialValue = realm.intrinsics.undefined;\n          } else {\n            // 4. Else,\n            // a. Let initialValue be ! envRec.GetBindingValue(n, false).\n            initialValue = envRec.GetBindingValue(n, false);\n          }\n\n          // 5. Call varEnvRec.InitializeBinding(n, initialValue).\n          varEnvRec.InitializeBinding(n, initialValue);\n\n          // 6. NOTE vars whose names are the same as a formal parameter, initially have the same value as the corresponding initialized parameter.\n        }\n      }\n    }\n\n    // 28. NOTE: Annex B.3.3.1 adds additional steps at realm point.\n\n    let lexEnv;\n\n    // 29. If strict is false, then\n    if (strict === false) {\n      // a. Let lexEnv be NewDeclarativeEnvironment(varEnv).\n      lexEnv = Environment.NewDeclarativeEnvironment(realm, varEnv);\n\n      // b. NOTE: Non-strict functions use a separate lexical Environment Record for top-level lexical declarations so that a direct eval (see 12.3.4.1) can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. realm is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.\n    } else {\n      // 30. Else, let lexEnv be varEnv.\n      lexEnv = varEnv;\n      // Since we previously removed varEnv, make sure to re-add it when it's used.\n      realm.activeLexicalEnvironments.add(varEnv);\n    }\n\n    // 31. Let lexEnvRec be lexEnv's EnvironmentRecord.\n    let lexEnvRec = lexEnv.environmentRecord;\n\n    // 32. Set the LexicalEnvironment of calleeContext to lexEnv.\n    calleeContext.lexicalEnvironment = lexEnv;\n\n    // 33. Let lexDeclarations be the LexicallyScopedDeclarations of code.\n    let lexDeclarations = [];\n\n    // 34. For each element d in lexDeclarations do\n    for (let d of lexDeclarations) {\n      // a. NOTE A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.\n      // b. For each element dn of the BoundNames of d do\n      for (let dn of Environment.BoundNames(realm, d)) {\n        // i. If IsConstantDeclaration of d is true, then\n        if (d.kind === \"const\") {\n          // 1. Perform ! lexEnvRec.CreateImmutableBinding(dn, true).\n          lexEnvRec.CreateImmutableBinding(dn, true);\n        } else {\n          // ii. Else,\n          // 1. Perform ! lexEnvRec.CreateMutableBinding(dn, false).\n          lexEnvRec.CreateMutableBinding(dn, false);\n        }\n      }\n    }\n\n    // 35. For each parsed grammar phrase f in functionsToInitialize, do\n    for (let f of functionsToInitialize) {\n      // a. Let fn be the sole element of the BoundNames of f.\n      let fn = Environment.BoundNames(realm, f)[0];\n      // b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.\n      let fo = lexEnv.evaluate(f, strict);\n      invariant(fo instanceof Value);\n      // c. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).\n      varEnvRec.SetMutableBinding(fn, fo, false);\n    }\n\n    // 36. Return NormalCompletion(empty).\n    return realm.intrinsics.empty;\n  }\n\n  // ECMA262 9.2.11\n  SetFunctionName(realm: Realm, F: ObjectValue, _name: PropertyKeyValue | AbstractValue, prefix?: string): boolean {\n    // 1. Assert: F is an extensible object that does not have a name own property.\n    invariant(F.getExtensible(), \"expected object to be extensible and not have a name property\");\n\n    // 2. Assert: Type(name) is either Symbol or String.\n    invariant(\n      typeof _name === \"string\" ||\n        _name instanceof StringValue ||\n        _name instanceof SymbolValue ||\n        _name instanceof AbstractValue,\n      \"expected name to be a string or symbol\"\n    );\n    let name = typeof _name === \"string\" ? new StringValue(realm, _name) : _name;\n\n    // 3. Assert: If prefix was passed, then Type(prefix) is String.\n    invariant(prefix === undefined || typeof prefix === \"string\", \"expected prefix to be a string if passed\");\n\n    // 4. If Type(name) is Symbol, then\n    if (name instanceof SymbolValue) {\n      // a. Let description be name's [[Description]] value.\n      let description = name.$Description;\n\n      // b. If description is undefined, let name be the empty String.\n      if (description === undefined) {\n        name = realm.intrinsics.emptyString;\n      } else {\n        // c. Else, let name be the concatenation of \"[\", description, and \"]\".\n        invariant(description instanceof Value);\n        name = new StringValue(realm, `[${description.throwIfNotConcreteString().value}]`);\n      }\n    }\n\n    // 5. If prefix was passed, then\n    if (prefix) {\n      // a. Let name be the concatenation of prefix, code unit 0x0020 (SPACE), and name.\n      if (name instanceof AbstractValue) {\n        let prefixVal = new StringValue(realm, prefix + \" \");\n        name = AbstractValue.createFromBinaryOp(realm, \"+\", prefixVal, name, name.expressionLocation);\n      } else {\n        name = new StringValue(realm, `${prefix} ${name.value}`);\n      }\n    }\n\n    // 6. Return ! DefinePropertyOrThrow(F, \"name\", PropertyDescriptor{[[Value]]: name, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).\n    return Properties.DefinePropertyOrThrow(\n      realm,\n      F,\n      \"name\",\n      new PropertyDescriptor({\n        value: name,\n        enumerable: false,\n        writable: false,\n        configurable: true,\n      })\n    );\n  }\n\n  // ECMA262 9.2.3\n  FunctionInitialize(\n    realm: Realm,\n    F: ECMAScriptSourceFunctionValue,\n    kind: \"normal\" | \"method\" | \"arrow\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment\n  ): ECMAScriptSourceFunctionValue {\n    // Tell the realm to mark any local bindings that are visible to this function as being potentially captured by it.\n    realm.markVisibleLocalBindingsAsPotentiallyCaptured();\n\n    // Note that F is a new object, and we can thus write to internal slots\n    invariant(realm.isNewObject(F));\n\n    // 1. Assert: F is an extensible object that does not have a length own property.\n    invariant(F.getExtensible(), \"expected to be extensible and no length property\");\n\n    // 2. Let len be the ExpectedArgumentCount of ParameterList.\n    let len = 0;\n    for (let FormalParameter of ParameterList) {\n      if (FormalParameter.type === \"AssignmentPattern\") {\n        break;\n      }\n      len += 1;\n    }\n\n    // 3. Perform ! DefinePropertyOrThrow(F, \"length\", PropertyDescriptor{[[Value]]: len, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(\n      realm,\n      F,\n      \"length\",\n      new PropertyDescriptor({\n        value: new NumberValue(realm, len),\n        writable: false,\n        enumerable: false,\n        configurable: true,\n      })\n    );\n\n    // 4. Let Strict be the value of the [[Strict]] internal slot of F.\n    let Strict = F.$Strict;\n    if (!Strict) {\n      Properties.DefinePropertyOrThrow(\n        realm,\n        F,\n        \"caller\",\n        new PropertyDescriptor({\n          value: new UndefinedValue(realm),\n          writable: true,\n          enumerable: false,\n          configurable: true,\n        })\n      );\n    }\n\n    // 5. Set the [[Environment]] internal slot of F to the value of Scope.\n    F.$Environment = Scope;\n\n    // 6. Set the [[FormalParameters]] internal slot of F to ParameterList. + 7. Set the [[ECMAScriptCode]] internal slot of F to Body.\n    F.initialize(ParameterList, Body);\n\n    // 8. Set the [[ScriptOrModule]] internal slot of F to GetActiveScriptOrModule().\n    F.$ScriptOrModule = Environment.GetActiveScriptOrModule(realm);\n\n    // 9. If kind is Arrow, set the [[realmMode]] internal slot of F to lexical.\n    if (kind === \"arrow\") {\n      F.$ThisMode = \"lexical\";\n    } else if (Strict === true) {\n      // 10. Else if Strict is true, set the [[realmMode]] internal slot of F to strict.\n      F.$ThisMode = \"strict\";\n    } else {\n      // 11. Else set the [[realmMode]] internal slot of F to global.\n      F.$ThisMode = \"global\";\n    }\n\n    // Return F.\n    return F;\n  }\n\n  // ECMA262 9.2.6\n  GeneratorFunctionCreate(\n    realm: Realm,\n    kind: \"normal\" | \"method\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment,\n    Strict: boolean\n  ): ECMAScriptSourceFunctionValue {\n    // 1. Let functionPrototype be the intrinsic object %Generator%.\n    let functionPrototype = realm.intrinsics.Generator;\n\n    // 2. Let F be FunctionAllocate(functionPrototype, Strict, \"generator\").\n    let F = this.FunctionAllocate(realm, functionPrototype, Strict, \"generator\");\n\n    // 3. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).\n    return this.FunctionInitialize(realm, F, kind, ParameterList, Body, Scope);\n  }\n\n  // ECMA262 9.2.7\n  AddRestrictedFunctionProperties(F: FunctionValue, realm: Realm): boolean {\n    // 1. Assert: realm.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized.\n    // 2. Let thrower be realm.[[Intrinsics]].[[%ThrowTypeError%]].\n    let thrower = realm.intrinsics.ThrowTypeError;\n    invariant(thrower);\n\n    let desc = new PropertyDescriptor({\n      get: thrower,\n      set: thrower,\n      enumerable: false,\n      configurable: true,\n    });\n    // 3. Perform ! DefinePropertyOrThrow(F, \"caller\", PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: true}).\n    Properties.DefinePropertyOrThrow(realm, F, \"caller\", desc);\n    // 4. Return ! DefinePropertyOrThrow(F, \"arguments\", PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: true}).\n    return Properties.DefinePropertyOrThrow(realm, F, \"arguments\", desc);\n  }\n\n  // ECMA262 9.2.1\n  $Call(realm: Realm, F: ECMAScriptFunctionValue, thisArgument: Value, argsList: Array<Value>): Value {\n    return InternalCall(realm, F, thisArgument, argsList, 0);\n  }\n\n  // ECMA262 9.2.2\n  $Construct(\n    realm: Realm,\n    F: ECMAScriptFunctionValue,\n    argumentsList: Array<Value>,\n    newTarget: ObjectValue\n  ): ObjectValue | AbstractObjectValue {\n    return InternalConstruct(realm, F, argumentsList, newTarget, undefined, 0);\n  }\n\n  // ECMA262 9.2.3\n  FunctionAllocate(\n    realm: Realm,\n    functionPrototype: ObjectValue | AbstractObjectValue,\n    strict: boolean,\n    functionKind: \"normal\" | \"non-constructor\" | \"generator\"\n  ): ECMAScriptSourceFunctionValue {\n    // 1. Assert: Type(functionPrototype) is Object.\n    invariant(functionPrototype instanceof ObjectValue, \"expected functionPrototype to be an object\");\n\n    // 2. Assert: functionKind is either \"normal\", \"non-constructor\" or \"generator\".\n    invariant(\n      functionKind === \"normal\" || functionKind === \"non-constructor\" || functionKind === \"generator\",\n      \"invalid functionKind\"\n    );\n\n    // 3. If functionKind is \"normal\", let needsConstruct be true.\n    let needsConstruct;\n    if (functionKind === \"normal\") {\n      needsConstruct = true;\n    } else {\n      // 4. Else, let needsConstruct be false.\n      needsConstruct = false;\n    }\n\n    // 5. If functionKind is \"non-constructor\", let functionKind be \"normal\".\n    if (functionKind === \"non-constructor\") {\n      functionKind = \"normal\";\n    }\n\n    // 6. Let F be a newly created ECMAScript function object with the internal slots listed in Table 27. All of those internal slots are initialized to undefined.\n    let F = new ECMAScriptSourceFunctionValue(realm);\n\n    // 7. Set F's essential internal methods to the default ordinary object definitions specified in 9.1.\n\n    // 8. Set F's [[Call]] internal method to the definition specified in 9.2.1.\n    F.$Call = (thisArgument, argsList) => {\n      return this.$Call(realm, F, thisArgument, argsList);\n    };\n\n    // 9. If needsConstruct is true, then\n    if (needsConstruct === true) {\n      // a. Set F's [[Construct]] internal method to the definition specified in 9.2.2.\n      F.$Construct = (argumentsList, newTarget) => {\n        return this.$Construct(realm, F, argumentsList, newTarget);\n      };\n\n      // b. Set the [[ConstructorKind]] internal slot of F to \"base\".\n      F.$ConstructorKind = \"base\";\n    }\n\n    // 10. Set the [[Strict]] internal slot of F to strict.\n    F.$Strict = strict;\n\n    // 11. Set the [[FunctionKind]] internal slot of F to functionKind.\n    F.$FunctionKind = functionKind;\n\n    // 12. Set the [[Prototype]] internal slot of F to functionPrototype.\n    F.$Prototype = functionPrototype;\n\n    // 13. Set the [[Extensible]] internal slot of F to true.\n    F.setExtensible(true);\n\n    // 14. Set the [[Realm]] internal slot of F to the current Realm Record.\n    F.$Realm = realm;\n\n    // 15. Return F.\n    return F;\n  }\n\n  // ECMA262 9.4.1.3\n  BoundFunctionCreate(\n    realm: Realm,\n    targetFunction: ObjectValue,\n    boundThis: Value,\n    boundArgs: Array<Value>\n  ): ObjectValue {\n    // 1. Assert: Type(targetFunction) is Object.\n    invariant(targetFunction instanceof ObjectValue, \"expected an object\");\n\n    // 2. Let proto be ? targetFunction.[[GetPrototypeOf]]().\n    let proto = targetFunction.$GetPrototypeOf();\n\n    // 3. Let obj be a newly created object.\n    let obj = new BoundFunctionValue(realm);\n\n    // 4. Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.\n\n    // 5. Set the [[Call]] internal method of obj as described in 9.4.1.1.\n    obj.$Call = (thisArgument, argsList) => {\n      return $BoundCall(realm, obj, thisArgument, argsList);\n    };\n\n    // 6. If targetFunction has a [[Construct]] internal method, then\n    if (targetFunction.$Construct) {\n      // a. Set the [[Construct]] internal method of obj as described in 9.4.1.2.\n      obj.$Construct = (thisArgument, argsList) => {\n        return $BoundConstruct(realm, obj, thisArgument, argsList);\n      };\n    }\n\n    // 7. Set the [[Prototype]] internal slot of obj to proto.\n    obj.$Prototype = proto;\n\n    // 8. Set the [[Extensible]] internal slot of obj to true.\n    obj.setExtensible(true);\n\n    // 9. Set the [[BoundTargetFunction]] internal slot of obj to targetFunction.\n    obj.$BoundTargetFunction = targetFunction;\n\n    // 10. Set the [[BoundThis]] internal slot of obj to the value of boundThis.\n    obj.$BoundThis = boundThis;\n\n    // 11. Set the [[BoundArguments]] internal slot of obj to boundArgs.\n    obj.$BoundArguments = boundArgs;\n\n    // 12. Return obj.\n    return obj;\n  }\n\n  // ECMA262 18.2.1.1\n  PerformEval(realm: Realm, x: Value, evalRealm: Realm, strictCaller: boolean, direct: boolean): Value {\n    // 1. Assert: If direct is false, then strictCaller is also false.\n    if (direct === false) invariant(strictCaller === false, \"strictCaller is only allowed on direct eval\");\n\n    // 2. If Type(x) is not String, return x.\n    if (!(x instanceof StringValue)) return x;\n\n    // 3. Let script be the ECMAScript code that is the result of parsing x, interpreted as UTF-16 encoded Unicode text\n    //    as described in 6.1.4, for the goal symbol Script. If the parse fails, throw a SyntaxError exception. If any\n    //    early errors are detected, throw a SyntaxError or a ReferenceError exception, depending on the type of the\n    //    error (but see also clause 16). Parsing and early error detection may be interweaved in an implementation\n    //    dependent manner.\n    let ast = parse(realm, x.value, \"eval\", \"script\");\n    let script = ast.program;\n\n    // 4. If script Contains ScriptBody is false, return undefined.\n    if (!script.body) return realm.intrinsics.undefined;\n\n    // 5. Let body be the ScriptBody of script.\n    let body = t.blockStatement(script.body, script.directives);\n\n    // 6. If strictCaller is true, let strictEval be true.\n    let strictEval;\n    if (strictCaller) {\n      strictEval = true;\n    } else {\n      // 7. Else, let strictEval be IsStrict of script.\n      strictEval = IsStrict(script);\n    }\n\n    // 8. Let ctx be the running execution context. If direct is true, ctx will be the execution context that\n    //    performed the direct eval. If direct is false, ctx will be the execution context for the invocation of\n    //    the eval function.\n    let ctx = realm.getRunningContext();\n\n    // 9. If direct is true, then\n    let lexEnv, varEnv;\n    if (direct) {\n      // a. Let lexEnv be NewDeclarativeEnvironment(ctx's LexicalEnvironment).\n      lexEnv = Environment.NewDeclarativeEnvironment(realm, ctx.lexicalEnvironment);\n\n      // b. Let varEnv be ctx's VariableEnvironment.\n      varEnv = ctx.variableEnvironment;\n    } else {\n      // 10. Else,\n      // a. Let lexEnv be NewDeclarativeEnvironment(evalRealm.[[GlobalEnv]]).\n      lexEnv = Environment.NewDeclarativeEnvironment(realm, evalRealm.$GlobalEnv);\n\n      // b. Let varEnv be evalRealm.[[GlobalEnv]].\n      varEnv = evalRealm.$GlobalEnv;\n    }\n\n    // 11. If strictEval is true, let varEnv be lexEnv.\n    if (strictEval) varEnv = lexEnv;\n\n    // 12. If ctx is not already suspended, suspend ctx.\n    ctx.suspend();\n\n    // 13. Let evalCxt be a new ECMAScript code execution context.\n    let evalCxt = realm.createExecutionContext();\n    evalCxt.isStrict = strictEval;\n\n    // 14. Set the evalCxt's Function to null.\n    evalCxt.setFunction(null);\n\n    // 15. Set the evalCxt's Realm to evalRealm.\n    evalCxt.setRealm(evalRealm);\n\n    // 16. Set the evalCxt's ScriptOrModule to ctx's ScriptOrModule.\n    evalCxt.ScriptOrModule = ctx.ScriptOrModule;\n\n    // 17. Set the evalCxt's VariableEnvironment to varEnv.\n    evalCxt.variableEnvironment = varEnv;\n\n    // 18. Set the evalCxt's LexicalEnvironment to lexEnv.\n    evalCxt.lexicalEnvironment = lexEnv;\n\n    // 19. Push evalCxt on to the execution context stack; evalCxt is now the running execution context.\n    realm.pushContext(evalCxt);\n\n    let result;\n    try {\n      // 20. Let result be EvalDeclarationInstantiation(body, varEnv, lexEnv, strictEval).\n      invariant(varEnv);\n      try {\n        result = this.EvalDeclarationInstantiation(realm, body, varEnv, lexEnv, strictEval);\n      } catch (e) {\n        if (e instanceof AbruptCompletion) {\n          result = e;\n        } else {\n          throw e;\n        }\n      }\n      invariant(result instanceof Value || result instanceof AbruptCompletion);\n\n      // 21. If result.[[Type]] is normal, then\n      if (result instanceof Value) {\n        // Evaluate expressions that passed for directives.\n        if (script.directives) {\n          for (let directive of script.directives) {\n            result = new StringValue(realm, directive.value.value);\n          }\n        }\n\n        // a. Let result be the result of evaluating body.\n        result = this.EvaluateStatements(script.body, result, strictEval, lexEnv, realm);\n      }\n\n      // 22. If result.[[Type]] is normal and result.[[Value]] is empty, then\n      if (result instanceof EmptyValue) {\n        // a. Let result be NormalCompletion(undefined).\n        result = realm.intrinsics.undefined;\n      }\n    } finally {\n      // 23. Suspend evalCxt and remove it from the execution context stack.\n      evalCxt.suspend();\n      realm.popContext(evalCxt);\n      realm.onDestroyScope(evalCxt.lexicalEnvironment);\n    }\n\n    // 24. Resume the context that is now on the top of the execution context stack as the running execution context.\n    invariant(realm.getRunningContext() === ctx);\n    ctx.resume();\n\n    // 25. Return Completion(result).\n    if (result instanceof Value) {\n      return result;\n    } else {\n      invariant(result instanceof AbruptCompletion);\n      throw result;\n    }\n  }\n\n  // Composes realm.savedCompletion with c, clears realm.savedCompletion and return the composition.\n  // Call this only when a join point has been reached.\n  incorporateSavedCompletion(realm: Realm, c: void | Completion | Value): void | Completion | Value {\n    let savedCompletion = realm.savedCompletion;\n    if (savedCompletion !== undefined) {\n      realm.savedCompletion = undefined;\n      realm.pathConditions = savedCompletion.pathConditionsAtCreation;\n      if (c === undefined) c = realm.intrinsics.empty;\n      if (c instanceof Value) c = new SimpleNormalCompletion(c);\n      if (savedCompletion instanceof JoinedNormalAndAbruptCompletions) {\n        let subsequentEffects = realm.getCapturedEffects(c);\n        realm.stopEffectCaptureAndUndoEffects(savedCompletion);\n        let joinedEffects = Join.composeWithEffects(savedCompletion, subsequentEffects);\n        realm.applyEffects(joinedEffects);\n        realm.savedCompletion = savedCompletion.composedWith;\n        if (realm.savedCompletion !== undefined) return this.incorporateSavedCompletion(realm, joinedEffects.result);\n        return joinedEffects.result;\n      }\n      return Join.composeCompletions(savedCompletion, c);\n    }\n    return c;\n  }\n\n  EvaluateStatements(\n    body: Array<BabelNodeStatement>,\n    initialBlockValue: void | Value,\n    strictCode: boolean,\n    blockEnv: LexicalEnvironment,\n    realm: Realm\n  ): Value {\n    let blockValue = initialBlockValue;\n    for (let node of body) {\n      if (node.type !== \"FunctionDeclaration\") {\n        let res = blockEnv.evaluateCompletionDeref(node, strictCode);\n        if (!(res instanceof EmptyValue)) {\n          if (res instanceof AbruptCompletion) throw UpdateEmpty(realm, res, blockValue || realm.intrinsics.empty);\n          invariant(res instanceof Value);\n          blockValue = res;\n        }\n      }\n    }\n\n    // 7. Return blockValue.\n    return blockValue || realm.intrinsics.empty;\n  }\n\n  // ECMA262 9.2.5\n  FunctionCreate(\n    realm: Realm,\n    kind: \"normal\" | \"arrow\" | \"method\",\n    ParameterList: Array<BabelNodeLVal>,\n    Body: BabelNodeBlockStatement,\n    Scope: LexicalEnvironment,\n    Strict: boolean,\n    prototype?: ObjectValue\n  ): ECMAScriptSourceFunctionValue {\n    // 1. If the prototype argument was not passed, then\n    if (!prototype) {\n      // a. Let prototype be the intrinsic object %FunctionPrototype%.\n      prototype = realm.intrinsics.FunctionPrototype;\n    }\n\n    // 2. If kind is not Normal, let allocKind be \"non-constructor\".\n    let allocKind;\n    if (kind !== \"normal\") {\n      allocKind = \"non-constructor\";\n    } else {\n      // 3. Else, let allocKind be \"normal\".\n      allocKind = \"normal\";\n    }\n\n    // 4. Let F be FunctionAllocate(prototype, Strict, allocKind).\n    let F = this.FunctionAllocate(realm, prototype, Strict, allocKind);\n\n    // ECMAScript 2016, section 17:\n    //   \"Every other data property described in clauses 18 through 26 and in Annex B.2 has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } unless otherwise specified.\"\n    // Because we call `AddRestrictedFunctionProperties` on `FunctionPrototype`, accessing property \"arguments\" will raise a `TypeError` by default.\n    // However, in non-strict mode this behavior is not desired, so we will add them as own properties of each `FunctionValue`, in accordance with ECMA 17.\n    // Note: \"arguments\" ***MUST NOT*** be set if the function is in strict mode or is an arrow, method, constructor, or generator function.\n    //   See 16.2 \"Forbidden Extensions\"\n    if (!Strict && kind === \"normal\") {\n      Properties.DefinePropertyOrThrow(\n        realm,\n        F,\n        \"arguments\",\n        new PropertyDescriptor({\n          value: realm.intrinsics.undefined,\n          enumerable: false,\n          writable: true,\n          configurable: true,\n        })\n      );\n    }\n\n    // 5. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).\n    let result = this.FunctionInitialize(realm, F, kind, ParameterList, Body, Scope);\n    invariant(F.pathConditionDuringDeclaration === undefined, \"Function should only have one declaration site\");\n    // Create a new path condition to make the saved condition readonly\n    F.pathConditionDuringDeclaration = realm.pathConditions.isEmpty() ? undefined : realm.pathConditions;\n    if (F.pathConditionDuringDeclaration) invariant(F.pathConditionDuringDeclaration.isReadOnly());\n    return result;\n  }\n\n  // ECMA262 18.2.1.2\n  EvalDeclarationInstantiation(\n    realm: Realm,\n    body: BabelNodeBlockStatement,\n    varEnv: LexicalEnvironment,\n    lexEnv: LexicalEnvironment,\n    strict: boolean\n  ): Value {\n    // 1. Let varNames be the VarDeclaredNames of body.\n    let varNames = [];\n    traverseFast(body, node => {\n      if (node.type === \"VariableDeclaration\" && ((node: any): BabelNodeVariableDeclaration).kind === \"var\") {\n        varNames = varNames.concat(Object.keys(t.getBindingIdentifiers(node)));\n      }\n\n      if (node.type === \"FunctionExpression\" || node.type === \"FunctionDeclaration\") {\n        return true;\n      }\n\n      return false;\n    });\n\n    // 2. Let varDeclarations be the VarScopedDeclarations of body.\n    let varDeclarations = this.FindVarScopedDeclarations(body);\n\n    // 3. Let lexEnvRec be lexEnv's EnvironmentRecord.\n    let lexEnvRec = lexEnv.environmentRecord;\n\n    // 4. Let varEnvRec be varEnv's EnvironmentRecord.\n    let varEnvRec = varEnv.environmentRecord;\n\n    // 5. If strict is false, then\n    if (!strict) {\n      // a. If varEnvRec is a global Environment Record, then\n      if (varEnvRec instanceof GlobalEnvironmentRecord) {\n        // i. For each name in varNames, do\n        for (let name of varNames) {\n          // 1. If varEnvRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n          if (varEnvRec.HasLexicalDeclaration(name)) {\n            throw realm.createErrorThrowCompletion(\n              realm.intrinsics.SyntaxError,\n              new StringValue(realm, name + \" global object is restricted\")\n            );\n          }\n          // 2. NOTE: eval will not create a global var declaration that would be shadowed by a global lexical declaration.\n        }\n      }\n      // b. Let thisLex be lexEnv.\n      let thisLex = lexEnv;\n      // c. Assert: The following loop will terminate.\n      // d. Repeat while thisLex is not the same as varEnv,\n      while (thisLex !== varEnv) {\n        // i. Let thisEnvRec be thisLex's EnvironmentRecord.\n        let thisEnvRec = thisLex.environmentRecord;\n        // ii. If thisEnvRec is not an object Environment Record, then\n        if (!(thisEnvRec instanceof ObjectEnvironmentRecord)) {\n          // 1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.\n          // 2. For each name in varNames, do\n          for (let name of varNames) {\n            // a. If thisEnvRec.HasBinding(name) is true, then\n            if (thisEnvRec.HasBinding(name)) {\n              // i. Throw a SyntaxError exception.\n              throw realm.createErrorThrowCompletion(\n                realm.intrinsics.SyntaxError,\n                name + \" global object is restricted\"\n              );\n              // ii. NOTE: Annex B.3.5 defines alternate semantics for the above step.\n            }\n            // b. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.\n          }\n        }\n        // iii. Let thisLex be thisLex's outer environment reference.\n        thisLex = thisLex.parent;\n        invariant(thisLex !== null);\n      }\n    }\n\n    // 6. Let functionsToInitialize be a new empty List.\n    let functionsToInitialize = [];\n\n    // 7. Let declaredFunctionNames be a new empty List.\n    let declaredFunctionNames = [];\n\n    // 8. For each d in varDeclarations, in reverse list order do\n    for (let d of varDeclarations.reverse()) {\n      // a. If d is neither a VariableDeclaration or a ForBinding, then\n      if (d.type !== \"VariableDeclaration\") {\n        // i. Assert: d is either a FunctionDeclaration or a GeneratorDeclaration.\n        invariant(d.type === \"FunctionDeclaration\" || d.type === \"GeneratorDeclaration\");\n        // ii. NOTE If there are multiple FunctionDeclarations for the same name, the last declaration is used.\n        // iii. Let fn be the sole element of the BoundNames of d.\n        let fn = Environment.BoundNames(realm, d)[0];\n        // iv. If fn is not an element of declaredFunctionNames, then\n        if (declaredFunctionNames.indexOf(fn) < 0) {\n          // 1. If varEnvRec is a global Environment Record, then\n          if (varEnvRec instanceof GlobalEnvironmentRecord) {\n            // a. Let fnDefinable be ? varEnvRec.CanDeclareGlobalFunction(fn).\n            let fnDefinable = varEnvRec.CanDeclareGlobalFunction(fn);\n            // b. If fnDefinable is false, throw a TypeError exception.\n            if (!fnDefinable) {\n              throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, fn + \" is not definable\");\n            }\n          }\n          // 2. Append fn to declaredFunctionNames.\n          declaredFunctionNames.push(fn);\n          // 3. Insert d as the first element of functionsToInitialize.\n          functionsToInitialize.unshift(d);\n        }\n      }\n    }\n\n    // 9. NOTE: Annex B.3.3.3 adds additional steps at this point.\n\n    // 10. Let declaredVarNames be a new empty List.\n    let declaredVarNames = [];\n\n    // 11. For each d in varDeclarations, do\n    for (let d of varDeclarations) {\n      // a. If d is a VariableDeclaration or a ForBinding, then\n      if (d.type === \"VariableDeclaration\") {\n        // i. For each String vn in the BoundNames of d, do\n        for (let vn of Environment.BoundNames(realm, d)) {\n          // 1. If vn is not an element of declaredFunctionNames, then\n          if (declaredFunctionNames.indexOf(vn) < 0) {\n            // a. If varEnvRec is a global Environment Record, then\n            if (varEnvRec instanceof GlobalEnvironmentRecord) {\n              // i. Let vnDefinable be ? varEnvRec.CanDeclareGlobalVar(vn).\n              let vnDefinable = varEnvRec.CanDeclareGlobalVar(vn);\n              // ii. If vnDefinable is false, throw a TypeError exception.\n              if (!vnDefinable) {\n                throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, vn + \" is not definable\");\n              }\n            }\n            // b. If vn is not an element of declaredVarNames, then\n            if (declaredVarNames.indexOf(vn) < 0) {\n              // i. Append vn to declaredVarNames.\n              declaredVarNames.push(vn);\n            }\n          }\n        }\n      }\n    }\n\n    // 12. NOTE: No abnormal terminations occur after this algorithm step unless varEnvRec is a global Environment Record and the global object is a Proxy exotic object.\n\n    // 13. Let lexDeclarations be the LexicallyScopedDeclarations of body.\n    let lexDeclarations = [];\n    for (let s of body.body) {\n      if (s.type === \"VariableDeclaration\" && s.kind !== \"var\") {\n        lexDeclarations.push(s);\n      }\n    }\n\n    // 14. For each element d in lexDeclarations do\n    for (let d of lexDeclarations) {\n      // a. NOTE Lexically declared names are only instantiated here but not initialized.\n      // b. For each element dn of the BoundNames of d do\n      for (let dn of Environment.BoundNames(realm, d)) {\n        // c. If IsConstantDeclaration of d is true, then\n        if (d.kind === \"const\") {\n          // i. Perform ? lexEnvRec.CreateImmutableBinding(dn, true).\n          lexEnvRec.CreateImmutableBinding(dn, true);\n        } else {\n          // d. Else,\n          // i. Perform ? lexEnvRec.CreateMutableBinding(dn, false).\n          lexEnvRec.CreateMutableBinding(dn, false);\n        }\n      }\n    }\n\n    // 15. For each production f in functionsToInitialize, do\n    for (let f of functionsToInitialize) {\n      // a. Let fn be the sole element of the BoundNames of f.\n      let fn = Environment.BoundNames(realm, f)[0];\n      // b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.\n      let fo = lexEnv.evaluate(f, strict);\n      invariant(fo instanceof Value);\n      // c. If varEnvRec is a global Environment Record, then\n      if (varEnvRec instanceof GlobalEnvironmentRecord) {\n        // i. Perform ? varEnvRec.CreateGlobalFunctionBinding(fn, fo, true).\n        varEnvRec.CreateGlobalFunctionBinding(fn, fo, true);\n      } else {\n        // d. Else,\n        // i. Let bindingExists be varEnvRec.HasBinding(fn).\n        let bindingExists = varEnvRec.HasBinding(fn);\n        // ii. If bindingExists is false, then\n        if (!bindingExists) {\n          // 1. Let status be ! varEnvRec.CreateMutableBinding(fn, true).\n          varEnvRec.CreateMutableBinding(fn, true);\n          // 2. Assert: status is not an abrupt completion because of validation preceding step 12.\n          // 3. Perform ! varEnvRec.InitializeBinding(fn, fo).\n          varEnvRec.InitializeBinding(fn, fo);\n        } else {\n          // iii. Else,\n          // 1. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).\n          varEnvRec.SetMutableBinding(fn, fo, false);\n        }\n      }\n    }\n\n    // 16. For each String vn in declaredVarNames, in list order do\n    for (let vn of declaredVarNames) {\n      // a. If varEnvRec is a global Environment Record, then\n      if (varEnvRec instanceof GlobalEnvironmentRecord) {\n        // i. Perform ? varEnvRec.CreateGlobalVarBinding(vn, true).\n        varEnvRec.CreateGlobalVarBinding(vn, true);\n      } else {\n        // b. Else,\n        // i. Let bindingExists be varEnvRec.HasBinding(vn).\n        let bindingExists = varEnvRec.HasBinding(vn);\n        // ii. If bindingExists is false, then\n        if (!bindingExists) {\n          // 1. Let status be ! varEnvRec.CreateMutableBinding(vn, true).\n          varEnvRec.CreateMutableBinding(vn, true);\n          // 2. Assert: status is not an abrupt completion because of validation preceding step 12.\n          // 3. Perform ! varEnvRec.InitializeBinding(vn, undefined).\n          varEnvRec.InitializeBinding(vn, realm.intrinsics.undefined);\n        }\n      }\n    }\n\n    // 17. Return NormalCompletion(empty).\n    return realm.intrinsics.empty;\n  }\n\n  // ECMA 9.2.10\n  MakeMethod(realm: Realm, F: ECMAScriptSourceFunctionValue, homeObject: ObjectValue): Value {\n    // Note that F is a new object, and we can thus write to internal slots\n    invariant(realm.isNewObject(F));\n\n    // 1. Assert: F is an ECMAScript function object.\n    invariant(F instanceof ECMAScriptSourceFunctionValue, \"F is an ECMAScript function object.\");\n\n    // 2. Assert: Type(homeObject) is Object.\n    invariant(homeObject instanceof ObjectValue, \"Type(homeObject) is Object.\");\n\n    // 3. Set the [[HomeObject]] internal slot of F to homeObject.\n    F.$HomeObject = homeObject;\n\n    // 4. Return NormalCompletion(undefined).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA 14.3.8\n  DefineMethod(\n    realm: Realm,\n    prop: BabelNodeObjectMethod | BabelNodeClassMethod,\n    obj: ObjectValue,\n    env: LexicalEnvironment,\n    strictCode: boolean,\n    functionPrototype?: ObjectValue\n  ): { $Key: PropertyKeyValue, $Closure: ECMAScriptSourceFunctionValue } {\n    // 1. Let propKey be the result of evaluating PropertyName.\n    let propKey = EvalPropertyName(prop, env, realm, strictCode);\n\n    // 2. ReturnIfAbrupt(propKey).\n\n    // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n    let strict = strictCode || IsStrict(prop.body);\n\n    // 4. Let scope be the running execution context's LexicalEnvironment.\n    let scope = env;\n\n    // 5. If functionPrototype was passed as a parameter, let kind be Normal; otherwise let kind be Method.\n    let kind;\n    if (functionPrototype) {\n      // let kind be Normal;\n      kind = \"normal\";\n    } else {\n      // otherwise let kind be Method.\n      kind = \"method\";\n    }\n\n    // 6. Let closure be FunctionCreate(kind, StrictFormalParameters, FunctionBody, scope, strict). If functionPrototype was passed as a parameter, then pass its value as the prototype optional argument of FunctionCreate.\n    let closure = this.FunctionCreate(realm, kind, prop.params, prop.body, scope, strict, functionPrototype);\n\n    // 7. Perform MakeMethod(closure, object).\n    this.MakeMethod(realm, closure, obj);\n\n    // 8. Return the Record{[[Key]]: propKey, [[Closure]]: closure}.\n    return { $Key: propKey, $Closure: closure };\n  }\n}\n"],"file":"function.js"}