{"version":3,"sources":["../../src/utils/ShapeInformation.js"],"names":["ShapeInformation","constructor","descriptor","parentDescriptor","parentKey","universe","_descriptor","_parentDescriptor","_parentKey","_universe","getGetter","undefined","graphQLType","kind","_getAssociatedGetter","getAbstractType","_isOptional","jsType","Value","Utils","getTypeFromName","getPropertyShape","key","property","_getInformationForProperty","_resolveLinksAndWrap","shape","createForArgument","model","argname","arguments","createForReactComponentProps","component","props","properties","optional","elementShape","_arrayLengthProperty","innerShape","parentDescription","shapeName","createAndValidateArgModel","realm","argModelString","argModelError","StringValue","argModel","JSON","parse","value","CompilerDiagnostic","currentLocation","e","handleError","FatalError"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Utils } from \"../singletons.js\";\nimport { Value, StringValue } from \"../values/index.js\";\nimport type {\n  SupportedGraphQLGetters,\n  ShapeInformationInterface,\n  ShapeUniverse,\n  ShapeDescriptorNonLink,\n  ArgModel,\n  ShapeDescriptor,\n  ShapePropertyDescriptor,\n} from \"../types.js\";\nimport { FatalError, CompilerDiagnostic } from \"../errors.js\";\nimport { Realm } from \"../realm.js\";\n\nexport type ComponentModel = {\n  universe: ShapeUniverse,\n  component: { props: string },\n};\n\nexport class ShapeInformation implements ShapeInformationInterface {\n  constructor(\n    descriptor: ShapeDescriptorNonLink,\n    parentDescriptor: void | ShapeDescriptorNonLink,\n    parentKey: void | string,\n    universe: ShapeUniverse\n  ) {\n    this._descriptor = descriptor;\n    this._parentDescriptor = parentDescriptor;\n    this._parentKey = parentKey;\n    this._universe = universe;\n  }\n\n  _descriptor: ShapeDescriptorNonLink;\n  _parentDescriptor: void | ShapeDescriptorNonLink;\n  _parentKey: void | string;\n  _universe: ShapeUniverse;\n\n  getGetter(): void | SupportedGraphQLGetters {\n    // we want getter only for existing GraphQL objects\n    return this._parentDescriptor !== undefined &&\n      this._parentDescriptor.graphQLType !== undefined &&\n      this._parentDescriptor.kind === \"object\"\n      ? this._getAssociatedGetter()\n      : undefined;\n  }\n\n  getAbstractType(): typeof Value {\n    // we assume that value is not optional if it root\n    if (this._isOptional() || this._descriptor.jsType === \"void\" || this._descriptor.jsType === \"null\") {\n      return Value;\n    }\n    return Utils.getTypeFromName(this._descriptor.jsType) || Value;\n  }\n\n  getPropertyShape(key: string): void | ShapeInformation {\n    let property = this._getInformationForProperty(key);\n    return property !== undefined\n      ? ShapeInformation._resolveLinksAndWrap(property.shape, this._descriptor, key, this._universe)\n      : undefined;\n  }\n\n  static createForArgument(model: void | ArgModel, argname: string): void | ShapeInformation {\n    return model !== undefined\n      ? ShapeInformation._resolveLinksAndWrap(\n          model.universe[model.arguments[argname]],\n          undefined,\n          undefined,\n          model.universe\n        )\n      : undefined;\n  }\n\n  static createForReactComponentProps(model: void | ComponentModel): void | ShapeInformation {\n    return model !== undefined\n      ? ShapeInformation._resolveLinksAndWrap(\n          model.universe[model.component.props],\n          undefined,\n          undefined,\n          model.universe\n        )\n      : undefined;\n  }\n\n  _isOptional(): void | boolean {\n    if (this._parentDescriptor === undefined) {\n      return undefined;\n    }\n    switch (this._parentDescriptor.kind) {\n      case \"object\":\n        return this._parentKey !== undefined && this._parentDescriptor.properties[this._parentKey] !== undefined\n          ? this._parentDescriptor.properties[this._parentKey].optional\n          : undefined;\n      case \"array\":\n        return this._parentDescriptor.elementShape !== undefined\n          ? this._parentDescriptor.elementShape.optional\n          : undefined;\n      default:\n        return undefined;\n    }\n  }\n\n  _getInformationForProperty(key: string): void | ShapePropertyDescriptor {\n    switch (this._descriptor.kind) {\n      case \"object\":\n        return this._descriptor.properties[key];\n      case \"array\":\n        switch (key) {\n          case \"length\":\n            return ShapeInformation._arrayLengthProperty;\n          case \"prototype\":\n            return undefined;\n          default:\n            return this._descriptor.elementShape;\n        }\n      default:\n        // it is still legal to do member access on primitive value\n        // such as string\n        return undefined;\n    }\n  }\n\n  _getAssociatedGetter(): void | SupportedGraphQLGetters {\n    switch (this._descriptor.kind) {\n      case \"object\":\n        return \"tree\";\n      case \"array\":\n        let elementShape =\n          this._descriptor.elementShape !== undefined ? this._descriptor.elementShape.shape : undefined;\n        let innerShape = ShapeInformation._resolveLinksAndWrap(\n          elementShape,\n          this._descriptor,\n          undefined,\n          this._universe\n        );\n        if (innerShape === undefined) {\n          return undefined;\n        }\n        switch (innerShape._getAssociatedGetter()) {\n          case \"bool\":\n            return \"bool_list\";\n          case \"double\":\n            return \"double_list\";\n          case \"int\":\n            return \"int_list\";\n          case \"time\":\n            return \"time_list\";\n          case \"string\":\n            return \"string_list\";\n          case \"tree\":\n            return \"tree_list\";\n          // no support for nested arrays yet\n          default:\n            return undefined;\n        }\n      case \"scalar\":\n        switch (this._descriptor.graphQLType) {\n          case \"Color\":\n          case \"File\":\n          case \"ID\":\n          case \"String\":\n          case \"Url\":\n            return \"string\";\n          case \"Int\":\n          case \"Time\":\n            return \"int\";\n          case \"Float\":\n            return \"double\";\n          case \"Boolean\":\n            return \"bool\";\n          default:\n            return undefined;\n        }\n      case \"enum\":\n        return \"string\";\n      default:\n        return undefined;\n    }\n  }\n\n  static _resolveLinksAndWrap(\n    descriptor: void | ShapeDescriptor,\n    parentDescription: void | ShapeDescriptorNonLink,\n    parentKey: void | string,\n    universe: ShapeUniverse\n  ): void | ShapeInformation {\n    while (descriptor && descriptor.kind === \"link\") {\n      descriptor = universe[descriptor.shapeName];\n    }\n    return descriptor !== undefined\n      ? new ShapeInformation(descriptor, parentDescription, parentKey, universe)\n      : undefined;\n  }\n\n  static _arrayLengthProperty = {\n    shape: {\n      kind: \"scalar\",\n      jsType: \"integral\",\n    },\n    optional: false,\n  };\n}\n\n// TODO: do more full validation walking the whole shape\nexport function createAndValidateArgModel(realm: Realm, argModelString: Value): ArgModel | void {\n  let argModelError;\n  if (argModelString instanceof StringValue) {\n    try {\n      let argModel = JSON.parse(argModelString.value);\n      if (!argModel.universe)\n        argModelError = new CompilerDiagnostic(\n          \"ArgModel must contain a universe property containing a ShapeUniverse\",\n          realm.currentLocation,\n          \"PP1008\",\n          \"FatalError\"\n        );\n      if (!argModel.arguments)\n        argModelError = new CompilerDiagnostic(\n          \"ArgModel must contain an arguments property.\",\n          realm.currentLocation,\n          \"PP1008\",\n          \"FatalError\"\n        );\n      return (argModel: ArgModel);\n    } catch (e) {\n      argModelError = new CompilerDiagnostic(\n        \"Failed to parse model for arguments\",\n        realm.currentLocation,\n        \"PP1008\",\n        \"FatalError\"\n      );\n    }\n  } else {\n    argModelError = new CompilerDiagnostic(\"String expected as a model\", realm.currentLocation, \"PP1008\", \"FatalError\");\n  }\n  if (argModelError !== undefined && realm.handleError(argModelError) !== \"Recover\") {\n    throw new FatalError();\n  }\n  return undefined;\n}\n"],"file":"ShapeInformation.js"}