"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DebugReproPackager = void 0;

var _nodeZip = _interopRequireDefault(require("node-zip"));

var _zipDir = _interopRequireDefault(require("zip-dir"));

var _path = _interopRequireDefault(require("path"));

var _child_process = _interopRequireDefault(require("child_process"));

var _fs = _interopRequireDefault(require("fs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/* -strict */

/* eslint-disable no-shadow */
class DebugReproPackager {
  constructor() {
    this._reproZip = (0, _nodeZip.default)();
    return;
  }

  _generateZip(reproArguments, reproFileNames, reproFilePath, runtimeDir) {
    // Programatically assemble parameters to debugger.
    let reproScriptArguments = `prepackArguments=${reproArguments.map(a => `${a}`).join("&prepackArguments=")}`;
    let reproScriptSourceFiles = `sourceFiles=$(pwd)/${reproFileNames.map(f => `${_path.default.basename(f)}`).join("&sourceFiles=$(pwd)/")}`; // Generating script that `yarn install`s prepack dependencies.
    // Then assembles a Nuclide deeplink that reflects the copy of Prepack in the package,
    // the prepack arguments that this run was started with, and the input files being prepacked.
    // The link is then called to open the Nuclide debugger.

    this._reproZip.file("repro.sh", `#!/bin/bash
      unzip prepack-runtime-bundle.zip
      yarn install
      PREPACK_RUNTIME="prepackRuntime=$(pwd)/${runtimeDir}/prepack-cli.js"
      PREPACK_ARGUMENTS="${reproScriptArguments}"
      PREPACK_SOURCEFILES="${reproScriptSourceFiles}"
      atom \"atom://nuclide/prepack-debugger?$PREPACK_SOURCEFILES&$PREPACK_RUNTIME&$PREPACK_ARGUMENTS\"
      `);

    const data = this._reproZip.generate({
      base64: false,
      compression: "DEFLATE"
    });

    if (reproFilePath) {
      _fs.default.writeFileSync(reproFilePath, data, "binary");

      console.log(`ReproBundle written to ${reproFilePath}`);
    }
  } // Returns true on success, false on failure


  generateDebugRepro(shouldExitWithError, sourceFiles, sourceMaps, reproFilePath, reproFileNames, reproArguments, externalPrepackPath) {
    if (reproFilePath === undefined) process.exit(1); // Copy all input files.

    for (let file of reproFileNames) {
      try {
        let content = _fs.default.readFileSync(file, "utf8");

        this._reproZip.file(_path.default.basename(file), content);
      } catch (err) {
        console.error(`Could not zip input file ${err}`);
        process.exit(1);
      }
    } // Copy all sourcemaps (discovered while prepacking).


    for (let map of sourceMaps) {
      try {
        let content = _fs.default.readFileSync(map, "utf8");

        this._reproZip.file(_path.default.basename(map), content);
      } catch (err) {
        console.error(`Could not zip sourcemap: ${err}`);
        process.exit(1);
      }
    } // Copy all original sourcefiles used while Prepacking.


    for (let file of sourceFiles) {
      try {
        // To avoid copying the "/User/name/..." version of the bundle/map/model included in originalSourceFiles
        if (!reproFileNames.includes(file.relative)) {
          let content = _fs.default.readFileSync(file.absolute, "utf8");

          this._reproZip.file(file.relative, content);
        }
      } catch (err) {
        console.error(`Could not zip source file: ${err}. Proceeding...`);
      }
    } // If not told where to copy prepack from, try to yarn pack it up.


    if (externalPrepackPath === undefined) {
      // Copy Prepack lib and package.json to install dependencies.
      // The `yarn pack` command finds all necessary files automatically.
      // The following steps need to be sequential, hence the series of `.on("exit")` callbacks.
      let yarnRuntime = "yarn";
      let yarnCommand = ["pack", "--filename", _path.default.resolve(process.cwd(), "prepack-bundled.tgz")];

      _child_process.default.spawnSync(yarnRuntime, yarnCommand, {
        cwd: __dirname
      }); // Because zipping the .tgz causes corruption issues when unzipping, we will
      // unpack the .tgz, then zip those contents.


      let unzipRuntime = "tar";
      let unzipCommand = ["-xzf", _path.default.resolve(`.`, "prepack-bundled.tgz")];

      _child_process.default.spawnSync(unzipRuntime, unzipCommand); // Note that this process is asynchronous. A process.exit() elsewhere in this cli code
      // might cause the whole process (including an ongoing zip) to prematurely terminate.


      (0, _zipDir.default)(_path.default.resolve(".", "package"), (err, buffer) => {
        if (err) {
          console.error(`Could not zip Prepack ${err}`);
          process.exit(1);
        }

        this._reproZip.file("prepack-runtime-bundle.zip", buffer);

        this._generateZip(reproArguments, reproFileNames, reproFilePath, "lib");

        if (shouldExitWithError) process.exit(1);
      });
    } else {
      try {
        let prepackContent = _fs.default.readFileSync(externalPrepackPath);

        this._reproZip.file("prepack-runtime-bundle.zip", prepackContent);

        this._generateZip(reproArguments, reproFileNames, reproFilePath, "src");
      } catch (err) {
        console.error(`Could not zip prepack from given path: ${err}`);
        process.exit(1);
      }

      if (shouldExitWithError) process.exit(1);
    }
  }

}

exports.DebugReproPackager = DebugReproPackager;
//# sourceMappingURL=DebugReproPackager.js.map