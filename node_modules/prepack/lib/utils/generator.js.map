{"version":3,"sources":["../../src/utils/generator.js"],"names":["createOperationDescriptor","type","data","GeneratorEntry","constructor","realm","index","temporalEntryCounter","print","printer","visit","callbacks","containingGenerator","serialize","context","getDependencies","notEqualToAndDoesNotHappenBefore","entry","notEqualToAndDoesNotHappenAfter","TemporalOperationEntry","args","Object","assign","mutatesOnly","undefined","isPure","arg","includes","operationDescriptor","printGeneratorEntry","declared","toDisplayJson","depth","obj","Utils","verboseToDisplayJson","omit","canOmit","recordDelayedEntry","recordDeclaration","i","n","length","originalArg","visitedArg","visitEquivalentValue","thisArg","value","ObjectValue","object","dependencies","dependency","visitGenerator","nodes","map","boundArg","serializeValue","valuesToProcess","Set","declaredId","intrinsicName","node","serializeOperationDescriptor","block","statements","body","options","debugScopes","emit","serializeDebugScopeComment","processValues","declare","generator","generators","TemporalObjectAssignEntry","AbstractObjectValue","$Realm","result","attemptToMergeEquivalentObjectAssigns","nextResult","ModifiedPropertyEntry","descriptor","newDescriptor","propertyBinding","toDisplayString","propertyKey","key","propertyKeyString","Value","desc","emitPropertyModification","visitModifiedProperty","ModifiedBindingEntry","binding","modifiedBinding","name","emitBindingModification","visitModifiedBinding","ReturnValueEntry","returnValue","promoteEmptyToUndefined","serializeReturnValue","BindingAssignmentEntry","serializeBindingAssignment","visitBindingAssignment","Generator","pathConditions","effects","useAbstractInterpretation","realmPreludeGenerator","preludeGenerator","_entries","id","nextGeneratorId","_name","effectsToApply","jsonToDisplayString","_generatorOfEffects","additionalFunctionEffects","optimizedFunction","preEvaluationComponentToWriteEffectFunction","modifiedBindings","modifiedProperties","createdObjects","output","appendGenerator","keys","isValid","has","refuseSerializationOnPropertyBinding","isIntrinsic","previousValue","entries","cannonicalize","functionValue","get","optimizedFunctionValue","valueOrParentEqualsFunction","canonicalOptimizedFunction","additionalEffects","parent","parentAdditionalFunction","environment","FunctionEnvironmentRecord","$FunctionObject","creatingOptimizedFunction","UndefinedValue","SimpleNormalCompletion","emitReturnValue","ThrowCompletion","emitThrow","JoinedNormalAndAbruptCompletions","selector","c","intrinsics","__bottomValue","EmptyValue","emitConditionalThrow","Join","joinValuesOfSelectedCompletions","fromEffects","withEffectsAppliedInGlobalEnv","bind","PropertyDescriptor","AbstractValue","kind","x","y","ydesc","yprop","xdesc","xprop","push","getName","empty","emitGlobalDeclaration","declaredGlobals","add","emitGlobalAssignment","_addEntry","StringValue","emitConcreteModel","emitGlobalDelete","emitBindingAssignment","emitPropertyAssignment","refuseSerialization","emitDefineProperty","isDescChanged","enumerable","configurable","writable","descValue","set","emitPropertyDelete","emitCall","callFunctionRef","emitConsoleLog","method","v","emitDoWhileStatement","test","_issueThrowCompilerDiagnostic","message","objectMessage","evaluateWithUndo","_SafeGetDataPropertyValue","objectStack","diagnostic","CompilerDiagnostic","expressionLocation","handleError","emitStatement","emitFullInvariant","isTop","concreteComparisons","typeComparisons","populateComparisonsLists","absValue","nestedValue","ConcreteValue","getType","_emitInvariant","FunctionValue","emitPropertyInvariant","state","violationConditionOperationDescriptor","appendLastToInvariantOperationDescriptor","invariantLevel","invariantOperationDescriptor","emitCallAndCaptureResult","types","values","deriveAbstract","emitVoidExpression","emitForInStatement","o","lh","sourceObject","targetObject","boundName","deriveConcreteObject","buildValue","optionalArgs","nameGenerator","generate","intrinsicNameGenerated","isScopedTemplate","_addDerivedEntry","shape","Constructor","isTypeCompatibleWith","res","derivedIds","size","skipInvariant","typeofString","NullValue","BooleanValue","NumberValue","IntegralValue","SymbolValue","visitFn","serializeFn","initGenerator","finalizeGenerator","entryArgs","saveTemporalGeneratorEntryArgs","other","leadingComment","joinGenerators","joinCondition","generator1","generator2","temporalOperationEntry","to","loopThroughArgs","possibleOtherObjectAssignTo","otherTemporalOperationEntry","getTemporalOperationEntryFromDerivedValue","otherArgs","otherArgsToUse","mightBeLeakedObject","temporalGeneratorEntries","getTemporalGeneratorEntriesReferencingArg","temporalGeneratorEntry","prefixArgs","slice","suffixArgs","newArgs","newTemporalObjectAssignEntryArgs"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { Effects, Realm } from \"../realm.js\";\nimport type {\n  ConsoleMethodTypes,\n  Descriptor,\n  DisplayResult,\n  PropertyBinding,\n  SupportedGraphQLGetters,\n} from \"../types.js\";\nimport type { BaseValue, Binding, ReferenceName } from \"../environment.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  type AbstractValueKind,\n  BooleanValue,\n  ConcreteValue,\n  EmptyValue,\n  FunctionValue,\n  NullValue,\n  NumberValue,\n  IntegralValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  Value,\n} from \"../values/index.js\";\nimport { CompilerDiagnostic } from \"../errors.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport invariant from \"../invariant.js\";\nimport { JoinedNormalAndAbruptCompletions, SimpleNormalCompletion, ThrowCompletion } from \"../completions.js\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeIdentifier,\n  BabelNodeMemberExpression,\n  BabelNodeStatement,\n  BabelNodeVariableDeclaration,\n  BabelNodeBlockStatement,\n  BabelNodeLVal,\n  BabelUnaryOperator,\n  BabelBinaryOperator,\n  BabelLogicalOperator,\n  BabelNodeTemplateElement,\n} from \"@babel/types\";\nimport { concretize, Join, Utils } from \"../singletons.js\";\nimport type { SerializerOptions } from \"../options.js\";\nimport type { PathConditions, ShapeInformationInterface } from \"../types.js\";\nimport { PreludeGenerator } from \"./PreludeGenerator.js\";\nimport { PropertyDescriptor } from \"../descriptors.js\";\nimport type { AdditionalFunctionEffects } from \"../serializer/types.js\";\nimport { FunctionEnvironmentRecord } from \"../environment\";\n\nexport type OperationDescriptorType =\n  | \"ABSTRACT_FROM_TEMPLATE\"\n  | \"ABSTRACT_OBJECT_GET\"\n  | \"ABSTRACT_OBJECT_GET_PARTIAL\"\n  | \"ABSTRACT_OBJECT_GET_PROTO_OF\"\n  | \"ABSTRACT_PROPERTY\"\n  | \"ASSUME_CALL\"\n  | \"BABEL_HELPERS_OBJECT_WITHOUT_PROPERTIES\"\n  | \"BINARY_EXPRESSION\"\n  | \"CALL_ABSTRACT_FUNC\"\n  | \"CALL_ABSTRACT_FUNC_THIS\"\n  | \"CALL_BAILOUT\"\n  | \"CANNOT_BECOME_OBJECT\"\n  | \"COERCE_TO_STRING\"\n  | \"CONCRETE_MODEL\"\n  | \"CONDITIONAL_EXPRESSION\"\n  | \"CONDITIONAL_PROPERTY_ASSIGNMENT\"\n  | \"CONDITIONAL_THROW\"\n  | \"CONSOLE_LOG\"\n  | \"DEFINE_PROPERTY\"\n  | \"DERIVED_ABSTRACT_INVARIANT\"\n  | \"DIRECT_CALL_WITH_ARG_LIST\"\n  | \"DO_WHILE\"\n  | \"EMIT_CALL\"\n  | \"EMIT_CALL_AND_CAPTURE_RESULT\"\n  | \"EMIT_PROPERTY_ASSIGNMENT\"\n  | \"FB_MOCKS_BOOTLOADER_LOAD_MODULES\"\n  | \"FB_MOCKS_MAGIC_GLOBAL_FUNCTION\"\n  | \"FOR_IN\"\n  | \"FOR_STATEMENT_FUNC\"\n  | \"FULL_INVARIANT\"\n  | \"FULL_INVARIANT_ABSTRACT\"\n  | \"FULL_INVARIANT_FUNCTION\"\n  | \"GET_BINDING\"\n  | \"GLOBAL_ASSIGNMENT\"\n  | \"GLOBAL_DELETE\"\n  | \"IDENTIFIER\"\n  | \"INVARIANT\"\n  | \"INVARIANT_APPEND\"\n  | \"JOIN_GENERATORS\"\n  | \"LOCAL_ASSIGNMENT\"\n  | \"LOGICAL_EXPRESSION\"\n  | \"LOGICAL_PROPERTY_ASSIGNMENT\"\n  | \"MODULES_REQUIRE\"\n  | \"NEW_EXPRESSION\"\n  | \"NOOP\"\n  | \"OBJECT_ASSIGN\"\n  | \"OBJECT_GET_PARTIAL\"\n  | \"OBJECT_PROTO_GET_OWN_PROPERTY_DESCRIPTOR\"\n  | \"OBJECT_PROTO_HAS_OWN_PROPERTY\"\n  | \"OBJECT_SET_PARTIAL\"\n  | \"PROPERTY_ASSIGNMENT\"\n  | \"PROPERTY_DELETE\"\n  | \"PROPERTY_INVARIANT\"\n  | \"REACT_CREATE_CONTEXT_PROVIDER\"\n  | \"REACT_DEFAULT_PROPS_HELPER\"\n  | \"REACT_NATIVE_STRING_LITERAL\"\n  | \"REACT_RELAY_MOCK_CONTAINER\"\n  | \"REACT_SSR_PREV_TEXT_NODE\"\n  | \"REACT_SSR_REGEX_CONSTANT\"\n  | \"REACT_SSR_RENDER_VALUE_HELPER\"\n  | \"REACT_SSR_TEMPLATE_LITERAL\"\n  | \"REACT_TEMPORAL_FUNC\"\n  | \"REBUILT_OBJECT\"\n  | \"RESIDUAL_CALL\"\n  | \"SINGLE_ARG\"\n  | \"THROW\"\n  | \"UNARY_EXPRESSION\"\n  | \"UNKNOWN_ARRAY_GET_PARTIAL\"\n  | \"UNKNOWN_ARRAY_LENGTH\"\n  | \"UNKNOWN_ARRAY_METHOD_CALL\"\n  | \"UNKNOWN_ARRAY_METHOD_PROPERTY_CALL\"\n  | \"UPDATE_INCREMENTOR\"\n  | \"WIDEN_PROPERTY\"\n  | \"WIDEN_PROPERTY_ASSIGNMENT\"\n  | \"WIDENED_IDENTIFIER\";\n\nexport type OperationDescriptor = {\n  data: OperationDescriptorData,\n  type: OperationDescriptorType,\n};\n\n// TODO: gradually remove all these, currently it's a random bag of values\n// that should be in args or in other places rather than here.\nexport type OperationDescriptorData = {\n  appendLastToInvariantOperationDescriptor?: OperationDescriptor, // used by INVARIANT\n  binding?: Binding, // used by GET_BINDING\n  propertyBinding?: PropertyBinding, // used by LOGICAL_PROPERTY_ASSIGNMENT\n  boundName?: BabelNodeIdentifier, // used by FOR_IN\n  callFunctionRef?: string, // used by EMIT_CALL and EMIT_CALL_AND_CAPTURE_RESULT\n  concreteComparisons?: Array<Value>, // used by FULL_INVARIANT_ABSTRACT\n  descriptor?: Descriptor, // used by DEFINE_PROPERTY\n  generator?: Generator, // used by DO_WHILE\n  generators?: Array<Generator>, // used by JOIN_GENERATORS\n  id?: string, // used by IDENTIFIER\n  lh?: BabelNodeVariableDeclaration, // used by FOR_IN\n  unaryOperator?: BabelUnaryOperator, // used by UNARY_EXPRESSION\n  binaryOperator?: BabelBinaryOperator, // used by BINARY_EXPRESSION\n  logicalOperator?: BabelLogicalOperator, // used by LOGICAL_EXPRESSION\n  incrementor?: \"+\" | \"-\", // used by UPDATE_INCREMENTOR\n  prefix?: boolean, // used by UNARY_EXPRESSION\n  path?: Value, // used by PROPERTY_ASSIGNMENT, CONDITIONAL_PROPERTY_ASSIGNMENT\n  propertyGetter?: SupportedGraphQLGetters, // used by ABSTRACT_OBJECT_GET\n  propRef?: ReferenceName | AbstractValue, // used by CALL_BAILOUT, and then only if string\n  object?: ObjectValue, // used by DEFINE_PROPERTY\n  quasis?: Array<BabelNodeTemplateElement>, // used by REACT_SSR_TEMPLATE_LITERAL\n  state?: \"MISSING\" | \"PRESENT\" | \"DEFINED\", // used by PROPERTY_INVARIANT\n  thisArg?: BaseValue | Value, // used by CALL_BAILOUT\n  templateSource?: string, // used by ABSTRACT_FROM_TEMPLATE\n  typeComparisons?: Set<typeof Value>, // used by FULL_INVARIANT_ABSTRACT\n  usesThis?: boolean, // used by FOR_STATEMENT_FUNC\n  value?: Value, // used by DO_WHILE, CONDITIONAL_PROPERTY_ASSIGNMENT, LOGICAL_PROPERTY_ASSIGNMENT, LOCAL_ASSIGNMENT, CONDITIONAL_THROW, EMIT_PROPERTY_ASSIGNMENT\n  violationConditionOperationDescriptor?: OperationDescriptor, // used by INVARIANT\n};\n\nexport function createOperationDescriptor(\n  type: OperationDescriptorType,\n  data?: OperationDescriptorData = {}\n): OperationDescriptor {\n  return {\n    data,\n    type,\n  };\n}\n\nexport type SerializationContext = {|\n  serializeOperationDescriptor: (\n    OperationDescriptor,\n    Array<BabelNodeExpression>,\n    SerializationContext,\n    Set<AbstractValue | ObjectValue>,\n    void | string\n  ) => BabelNodeStatement,\n  serializeBinding: Binding => BabelNodeIdentifier | BabelNodeMemberExpression,\n  serializeBindingAssignment: (Binding, Value) => BabelNodeStatement,\n  serializeCondition: (Value, Generator, Generator, Set<AbstractValue | ObjectValue>) => BabelNodeStatement,\n  serializeDebugScopeComment: (AbstractValue | ObjectValue) => BabelNodeStatement,\n  serializeReturnValue: Value => BabelNodeStatement,\n  serializeGenerator: (Generator, Set<AbstractValue | ObjectValue>) => Array<BabelNodeStatement>,\n  serializeValue: Value => BabelNodeExpression,\n  getPropertyAssignmentStatement: (\n    location: BabelNodeLVal,\n    value: Value,\n    mightHaveBeenDeleted: boolean,\n    deleteIfMightHaveBeenDeleted: boolean\n  ) => BabelNodeStatement,\n  initGenerator: Generator => void,\n  finalizeGenerator: Generator => void,\n  emitDefinePropertyBody: (ObjectValue, string | SymbolValue, Descriptor) => BabelNodeStatement,\n  emit: BabelNodeStatement => void,\n  processValues: (Set<AbstractValue | ObjectValue>) => void,\n  canOmit: Value => boolean,\n  declare: (AbstractValue | ObjectValue) => void,\n  emitPropertyModification: PropertyBinding => void,\n  emitBindingModification: Binding => void,\n  options: SerializerOptions,\n|};\n\nexport type VisitEntryCallbacks = {|\n  visitEquivalentValue: Value => Value,\n  visitGenerator: (Generator, Generator) => void,\n  canOmit: Value => boolean,\n  recordDeclaration: (AbstractValue | ObjectValue) => void,\n  recordDelayedEntry: (Generator, GeneratorEntry) => void,\n  visitModifiedProperty: PropertyBinding => void,\n  visitModifiedBinding: Binding => void,\n  visitBindingAssignment: (Binding, Value) => Value,\n|};\n\nexport type CustomGeneratorEntryType = \"MODIFIED_PROPERTY\" | \"MODIFIED_BINDING\" | \"RETURN\" | \"BINDING_ASSIGNMENT\";\n\nexport interface Printer {\n  printGeneratorEntry(\n    declared: void | AbstractValue | ObjectValue,\n    type: OperationDescriptorType | CustomGeneratorEntryType,\n    args: Array<Value>,\n    data: OperationDescriptorData,\n    metadata: { isPure: boolean, mutatesOnly: void | Array<Value> }\n  ): void;\n  printGenerator(generator: Generator, label?: string): void;\n}\n\nexport class GeneratorEntry {\n  constructor(realm: Realm) {\n    // We increment the index of every TemporalOperationEntry created.\n    // This should match up as a form of timeline value due to the tree-like\n    // structure we use to create entries during evaluation. For example,\n    // if all AST nodes in a BlockStatement resulted in a temporal operation\n    // for each AST node, then each would have a sequential index as to its\n    // position of how it was evaluated in the BlockSstatement.\n    this.index = realm.temporalEntryCounter++;\n  }\n\n  print(printer: Printer): void {\n    invariant(false, \"GeneratorEntry is an abstract base class\");\n  }\n\n  visit(callbacks: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    invariant(false, \"GeneratorEntry is an abstract base class\");\n  }\n\n  serialize(context: SerializationContext) {\n    invariant(false, \"GeneratorEntry is an abstract base class\");\n  }\n\n  getDependencies(): void | Array<Generator> {\n    invariant(false, \"GeneratorEntry is an abstract base class\");\n  }\n\n  notEqualToAndDoesNotHappenBefore(entry: GeneratorEntry): boolean {\n    return this.index > entry.index;\n  }\n\n  notEqualToAndDoesNotHappenAfter(entry: GeneratorEntry): boolean {\n    return this.index < entry.index;\n  }\n\n  index: number;\n}\n\nexport type TemporalOperationEntryArgs = {\n  declared?: AbstractValue | ObjectValue,\n  args: Array<Value>,\n  operationDescriptor: OperationDescriptor,\n  isPure?: boolean,\n  mutatesOnly?: Array<Value>,\n};\n\nexport class TemporalOperationEntry extends GeneratorEntry {\n  constructor(realm: Realm, args: TemporalOperationEntryArgs) {\n    super(realm);\n    Object.assign(this, args);\n    if (this.mutatesOnly !== undefined) {\n      invariant(!this.isPure);\n      for (let arg of this.mutatesOnly) {\n        invariant(this.args.includes(arg));\n      }\n    }\n    invariant(this.operationDescriptor !== undefined);\n  }\n\n  declared: void | AbstractValue | ObjectValue;\n  args: Array<Value>;\n  operationDescriptor: OperationDescriptor;\n  isPure: void | boolean;\n  mutatesOnly: void | Array<Value>;\n\n  print(printer: Printer): void {\n    const operationDescriptor = this.operationDescriptor;\n    printer.printGeneratorEntry(this.declared, operationDescriptor.type, this.args, this.operationDescriptor.data, {\n      isPure: !!this.isPure,\n      mutatesOnly: this.mutatesOnly,\n    });\n  }\n\n  toDisplayJson(depth: number): DisplayResult {\n    if (depth <= 0) return `TemporalOperation${this.index}`;\n    let obj = { type: \"TemporalOperation\", ...this };\n    delete obj.operationDescriptor;\n    return Utils.verboseToDisplayJson(obj, depth);\n  }\n\n  visit(callbacks: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    let omit = this.isPure && this.declared && callbacks.canOmit(this.declared);\n\n    if (!omit && this.declared && this.mutatesOnly !== undefined) {\n      omit = true;\n      for (let arg of this.mutatesOnly) {\n        if (!callbacks.canOmit(arg)) {\n          omit = false;\n        }\n      }\n    }\n    if (omit) {\n      callbacks.recordDelayedEntry(containingGenerator, this);\n      return false;\n    } else {\n      if (this.declared) callbacks.recordDeclaration(this.declared);\n      for (let i = 0, n = this.args.length; i < n; i++) {\n        let originalArg = this.args[i];\n        let visitedArg = callbacks.visitEquivalentValue(originalArg);\n        this.args[i] = visitedArg;\n        if (i === 0) {\n          switch (this.operationDescriptor.type) {\n            case \"CALL_BAILOUT\":\n              if (originalArg === this.operationDescriptor.data.thisArg)\n                this.operationDescriptor.data.thisArg = visitedArg;\n              break;\n            case \"CONDITIONAL_THROW\":\n              this.operationDescriptor.data.value = visitedArg;\n              break;\n            default:\n              break;\n          }\n        } else if (i === 1) {\n          switch (this.operationDescriptor.type) {\n            case \"EMIT_PROPERTY_ASSIGNMENT\":\n            case \"LOGICAL_PROPERTY_ASSIGNMENT\":\n              this.operationDescriptor.data.value = visitedArg;\n              break;\n            case \"CONDITIONAL_PROPERTY_ASSIGNMENT\":\n              if (originalArg === this.operationDescriptor.data.value) this.operationDescriptor.data.value = visitedArg;\n              break;\n            case \"DEFINE_PROPERTY\":\n              invariant(visitedArg instanceof ObjectValue);\n              this.operationDescriptor.data.object = visitedArg;\n              break;\n            default:\n              break;\n          }\n        }\n      }\n      let dependencies = this.getDependencies();\n      if (dependencies !== undefined)\n        for (let dependency of dependencies) callbacks.visitGenerator(dependency, containingGenerator);\n      return true;\n    }\n  }\n\n  serialize(context: SerializationContext): void {\n    let omit = this.isPure && this.declared && context.canOmit(this.declared);\n\n    if (!omit && this.declared && this.mutatesOnly !== undefined) {\n      omit = true;\n      for (let arg of this.mutatesOnly) {\n        if (!context.canOmit(arg)) {\n          omit = false;\n        }\n      }\n    }\n    if (!omit) {\n      let nodes = this.args.map((boundArg, i) => context.serializeValue(boundArg));\n      let valuesToProcess = new Set();\n      let declaredId = this.declared !== undefined ? this.declared.intrinsicName : undefined;\n      let node = context.serializeOperationDescriptor(\n        this.operationDescriptor,\n        nodes,\n        context,\n        valuesToProcess,\n        declaredId\n      );\n      if (node.type === \"BlockStatement\") {\n        let block: BabelNodeBlockStatement = (node: any);\n        let statements = block.body;\n        if (statements.length === 0) return;\n        if (statements.length === 1) {\n          node = statements[0];\n        }\n      }\n      let declared = this.declared;\n      if (declared !== undefined && context.options.debugScopes) {\n        context.emit(context.serializeDebugScopeComment(declared));\n      }\n      context.emit(node);\n      context.processValues(valuesToProcess);\n\n      if (this.declared !== undefined) context.declare(this.declared);\n    }\n  }\n\n  getDependencies(): void | Array<Generator> {\n    const operationDescriptor = this.operationDescriptor;\n    switch (operationDescriptor.type) {\n      case \"DO_WHILE\":\n        let generator = operationDescriptor.data.generator;\n        invariant(generator !== undefined);\n        return [generator];\n      case \"JOIN_GENERATORS\":\n        let generators = operationDescriptor.data.generators;\n        invariant(generators !== undefined);\n        return generators;\n      default:\n        return undefined;\n    }\n  }\n}\n\nexport class TemporalObjectAssignEntry extends TemporalOperationEntry {\n  visit(callbacks: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    let declared = this.declared;\n    if (!(declared instanceof AbstractObjectValue || declared instanceof ObjectValue)) {\n      return false;\n    }\n    let realm = declared.$Realm;\n    // The only optimization we attempt to do to Object.assign for now is merging of multiple entries\n    // into a new generator entry.\n    let result = attemptToMergeEquivalentObjectAssigns(realm, callbacks, this);\n\n    if (result instanceof TemporalObjectAssignEntry) {\n      let nextResult = result;\n      while (nextResult instanceof TemporalObjectAssignEntry) {\n        nextResult = attemptToMergeEquivalentObjectAssigns(realm, callbacks, result);\n        // If we get back a TemporalObjectAssignEntry, then we have successfully merged a single\n        // Object.assign, but we may be able to merge more. So repeat the process.\n        if (nextResult instanceof TemporalObjectAssignEntry) {\n          result = nextResult;\n        }\n      }\n      // We have an optimized temporal entry, so replace the current temporal\n      // entry and visit that entry instead.\n      this.args = result.args;\n    } else if (result === \"POSSIBLE_OPTIMIZATION\") {\n      callbacks.recordDelayedEntry(containingGenerator, this);\n      return false;\n    }\n    return super.visit(callbacks, containingGenerator);\n  }\n}\n\ntype ModifiedPropertyEntryArgs = {|\n  propertyBinding: PropertyBinding,\n  newDescriptor: void | Descriptor,\n  containingGenerator: Generator,\n|};\n\nclass ModifiedPropertyEntry extends GeneratorEntry {\n  constructor(realm: Realm, args: ModifiedPropertyEntryArgs) {\n    super(realm);\n    Object.assign(this, args);\n  }\n\n  containingGenerator: Generator;\n  propertyBinding: PropertyBinding;\n  newDescriptor: void | Descriptor;\n\n  print(printer: Printer): void {\n    printer.printGeneratorEntry(\n      undefined,\n      \"MODIFIED_PROPERTY\",\n      [],\n      { descriptor: this.newDescriptor, propertyBinding: this.propertyBinding },\n      { isPure: false, mutatesOnly: undefined }\n    );\n  }\n\n  toDisplayString(): string {\n    let propertyKey = this.propertyBinding.key;\n    let propertyKeyString = propertyKey instanceof Value ? propertyKey.toDisplayString() : propertyKey;\n    invariant(propertyKeyString !== undefined);\n    return `[ModifiedProperty ${propertyKeyString}]`;\n  }\n\n  serialize(context: SerializationContext): void {\n    let desc = this.propertyBinding.descriptor;\n    invariant(desc === this.newDescriptor);\n    context.emitPropertyModification(this.propertyBinding);\n  }\n\n  visit(context: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    invariant(\n      containingGenerator === this.containingGenerator,\n      \"This entry requires effects to be applied and may not be moved\"\n    );\n    let desc = this.propertyBinding.descriptor;\n    invariant(desc === this.newDescriptor);\n    context.visitModifiedProperty(this.propertyBinding);\n    return true;\n  }\n\n  getDependencies(): void | Array<Generator> {\n    return undefined;\n  }\n}\n\ntype ModifiedBindingEntryArgs = {|\n  modifiedBinding: Binding,\n  containingGenerator: Generator,\n|};\n\nclass ModifiedBindingEntry extends GeneratorEntry {\n  constructor(realm: Realm, args: ModifiedBindingEntryArgs) {\n    super(realm);\n    Object.assign(this, args);\n  }\n\n  containingGenerator: Generator;\n  modifiedBinding: Binding;\n\n  print(printer: Printer): void {\n    printer.printGeneratorEntry(\n      undefined,\n      \"MODIFIED_BINDING\",\n      [],\n      { binding: this.modifiedBinding, value: this.modifiedBinding.value },\n      { isPure: false, mutatesOnly: undefined }\n    );\n  }\n\n  toDisplayString(): string {\n    return `[ModifiedBinding ${this.modifiedBinding.name}]`;\n  }\n\n  serialize(context: SerializationContext): void {\n    context.emitBindingModification(this.modifiedBinding);\n  }\n\n  visit(context: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    invariant(\n      containingGenerator === this.containingGenerator,\n      \"This entry requires effects to be applied and may not be moved\"\n    );\n    context.visitModifiedBinding(this.modifiedBinding);\n    return true;\n  }\n\n  getDependencies(): void | Array<Generator> {\n    return undefined;\n  }\n}\n\nclass ReturnValueEntry extends GeneratorEntry {\n  constructor(realm: Realm, generator: Generator, returnValue: Value) {\n    super(realm);\n    this.returnValue = returnValue.promoteEmptyToUndefined();\n    this.containingGenerator = generator;\n  }\n\n  returnValue: Value;\n  containingGenerator: Generator;\n\n  print(printer: Printer): void {\n    printer.printGeneratorEntry(undefined, \"RETURN\", [this.returnValue], {}, { isPure: false, mutatesOnly: undefined });\n  }\n\n  toDisplayString(): string {\n    return `[Return ${this.returnValue.toDisplayString()}]`;\n  }\n\n  visit(context: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    invariant(\n      containingGenerator === this.containingGenerator,\n      \"This entry requires effects to be applied and may not be moved\"\n    );\n    this.returnValue = context.visitEquivalentValue(this.returnValue);\n    return true;\n  }\n\n  serialize(context: SerializationContext): void {\n    context.emit(context.serializeReturnValue(this.returnValue));\n  }\n\n  getDependencies(): void | Array<Generator> {\n    return undefined;\n  }\n}\n\nclass BindingAssignmentEntry extends GeneratorEntry {\n  constructor(realm: Realm, binding: Binding, value: Value) {\n    super(realm);\n    this.binding = binding;\n    this.value = value;\n  }\n\n  binding: Binding;\n  value: Value;\n\n  print(printer: Printer): void {\n    printer.printGeneratorEntry(\n      undefined,\n      \"BINDING_ASSIGNMENT\",\n      [this.value],\n      { binding: this.binding },\n      { isPure: false, mutatesOnly: undefined }\n    );\n  }\n\n  toDisplayString(): string {\n    return `[BindingAssignment ${this.binding.name} = ${this.value.toDisplayString()}]`;\n  }\n\n  serialize(context: SerializationContext): void {\n    context.emit(context.serializeBindingAssignment(this.binding, this.value));\n  }\n\n  visit(context: VisitEntryCallbacks, containingGenerator: Generator): boolean {\n    this.value = context.visitBindingAssignment(this.binding, this.value);\n    return true;\n  }\n\n  getDependencies(): void | Array<Generator> {\n    return undefined;\n  }\n}\n\nexport class Generator {\n  constructor(realm: Realm, name: string, pathConditions: PathConditions, effects?: Effects) {\n    invariant(realm.useAbstractInterpretation);\n    let realmPreludeGenerator = realm.preludeGenerator;\n    invariant(realmPreludeGenerator);\n    this.preludeGenerator = realmPreludeGenerator;\n    this.realm = realm;\n    this._entries = [];\n    this.id = realm.nextGeneratorId++;\n    this._name = name;\n    this.effectsToApply = effects;\n    this.pathConditions = pathConditions;\n  }\n\n  realm: Realm;\n  _entries: Array<GeneratorEntry>;\n  preludeGenerator: PreludeGenerator;\n  effectsToApply: void | Effects;\n  id: number;\n  _name: string;\n  pathConditions: PathConditions;\n\n  print(printer: Printer): void {\n    for (let entry of this._entries) entry.print(printer);\n  }\n\n  toDisplayString(): string {\n    return Utils.jsonToDisplayString(this, 2);\n  }\n\n  toDisplayJson(depth: number): DisplayResult {\n    if (depth <= 0) return `Generator${this.id}-${this._name}`;\n    return Utils.verboseToDisplayJson(this, depth);\n  }\n\n  static _generatorOfEffects(\n    realm: Realm,\n    name: string,\n    additionalFunctionEffects: Map<FunctionValue, AdditionalFunctionEffects>,\n    optimizedFunction: FunctionValue,\n    preEvaluationComponentToWriteEffectFunction: Map<FunctionValue, FunctionValue>,\n    effects: Effects\n  ): Generator {\n    let { result, generator, modifiedBindings, modifiedProperties, createdObjects } = effects;\n\n    let output = new Generator(realm, name, generator.pathConditions, effects);\n    output.appendGenerator(generator, generator._name);\n\n    for (let propertyBinding of modifiedProperties.keys()) {\n      let object = propertyBinding.object;\n      invariant(object.isValid());\n      if (createdObjects.has(object)) continue; // Created Object's binding\n      if (ObjectValue.refuseSerializationOnPropertyBinding(propertyBinding)) continue; // modification to internal state\n      // modifications to intrinsic objects are tracked in the generator\n      if (object.isIntrinsic()) continue;\n      output.emitPropertyModification(propertyBinding);\n    }\n\n    for (let [modifiedBinding, previousValue] of modifiedBindings.entries()) {\n      let cannonicalize = functionValue =>\n        preEvaluationComponentToWriteEffectFunction.get(functionValue) || functionValue;\n      let optimizedFunctionValue = optimizedFunction;\n      invariant(optimizedFunctionValue);\n      invariant(\n        cannonicalize(optimizedFunctionValue) === optimizedFunctionValue,\n        \"These values should be canonical already\"\n      );\n      // Walks up the parent chain for the given optimized function checking if the value or any of its parents are\n      // equal to the optimized function we're currently building a generator for.\n      let valueOrParentEqualsFunction = functionValue => {\n        let canonicalOptimizedFunction = cannonicalize(functionValue);\n        if (canonicalOptimizedFunction === optimizedFunctionValue) return true;\n        let additionalEffects = additionalFunctionEffects.get(canonicalOptimizedFunction);\n        invariant(additionalEffects !== undefined);\n        let parent = additionalEffects.parentAdditionalFunction;\n        if (parent !== undefined) return valueOrParentEqualsFunction(parent);\n        return false;\n      };\n\n      let environment = modifiedBinding.environment;\n      if (environment instanceof FunctionEnvironmentRecord && environment.$FunctionObject === optimizedFunctionValue)\n        continue;\n      let creatingOptimizedFunction = environment.creatingOptimizedFunction;\n      if (creatingOptimizedFunction && valueOrParentEqualsFunction(creatingOptimizedFunction)) continue;\n      // TODO #2586: modifiedBinding.value should always exist\n      if (modifiedBinding.value || previousValue.value) {\n        output.emitBindingModification(modifiedBinding);\n      }\n    }\n\n    if (result instanceof UndefinedValue) return output;\n    if (result instanceof SimpleNormalCompletion) {\n      output.emitReturnValue(result.value);\n    } else if (result instanceof ThrowCompletion) {\n      output.emitThrow(result.value);\n    } else if (result instanceof JoinedNormalAndAbruptCompletions) {\n      let selector = c =>\n        c instanceof ThrowCompletion && c.value !== realm.intrinsics.__bottomValue && !(c.value instanceof EmptyValue);\n      output.emitConditionalThrow(Join.joinValuesOfSelectedCompletions(selector, result, true));\n      output.emitReturnValue(result.value);\n    } else {\n      invariant(false);\n    }\n    return output;\n  }\n\n  // Make sure to to fixup\n  // how to apply things around sets of things\n  static fromEffects(\n    effects: Effects,\n    realm: Realm,\n    name: string,\n    additionalFunctionEffects: Map<FunctionValue, AdditionalFunctionEffects>,\n    preEvaluationComponentToWriteEffectFunction: Map<FunctionValue, FunctionValue>,\n    optimizedFunction: FunctionValue\n  ): Generator {\n    return realm.withEffectsAppliedInGlobalEnv(\n      this._generatorOfEffects.bind(\n        this,\n        realm,\n        name,\n        additionalFunctionEffects,\n        optimizedFunction,\n        preEvaluationComponentToWriteEffectFunction\n      ),\n      effects\n    );\n  }\n\n  emitPropertyModification(propertyBinding: PropertyBinding): void {\n    invariant(this.effectsToApply !== undefined);\n    let desc = propertyBinding.descriptor;\n    if (desc !== undefined && desc instanceof PropertyDescriptor) {\n      let value = desc.value;\n      if (value instanceof AbstractValue) {\n        if (value.kind === \"conditional\") {\n          let [c, x, y] = value.args;\n          if (c instanceof AbstractValue && c.kind === \"template for property name condition\") {\n            let ydesc = new PropertyDescriptor(Object.assign({}, (desc: any), { value: y }));\n            let yprop = Object.assign({}, propertyBinding, { descriptor: ydesc });\n            this.emitPropertyModification(yprop);\n            let xdesc = new PropertyDescriptor(Object.assign({}, (desc: any), { value: x }));\n            let key = c.args[0];\n            invariant(key instanceof AbstractValue);\n            let xprop = Object.assign({}, propertyBinding, { key, descriptor: xdesc });\n            this.emitPropertyModification(xprop);\n            return;\n          }\n        } else if (value.kind === \"template for prototype member expression\") {\n          return;\n        }\n      }\n    }\n    this._entries.push(\n      new ModifiedPropertyEntry(this.realm, {\n        propertyBinding,\n        newDescriptor: desc,\n        containingGenerator: this,\n      })\n    );\n  }\n\n  emitBindingModification(modifiedBinding: Binding): void {\n    invariant(this.effectsToApply !== undefined);\n    this._entries.push(\n      new ModifiedBindingEntry(this.realm, {\n        modifiedBinding,\n        containingGenerator: this,\n      })\n    );\n  }\n\n  emitReturnValue(result: Value): void {\n    this._entries.push(new ReturnValueEntry(this.realm, this, result));\n  }\n\n  getName(): string {\n    return `${this._name}(#${this.id})`;\n  }\n\n  empty(): boolean {\n    return this._entries.length === 0;\n  }\n\n  emitGlobalDeclaration(key: string, value: Value): void {\n    this.preludeGenerator.declaredGlobals.add(key);\n    if (!(value instanceof UndefinedValue)) this.emitGlobalAssignment(key, value);\n  }\n\n  emitGlobalAssignment(key: string, value: Value): void {\n    this._addEntry({\n      args: [value, new StringValue(this.realm, key)],\n      operationDescriptor: createOperationDescriptor(\"GLOBAL_ASSIGNMENT\"),\n    });\n  }\n\n  emitConcreteModel(key: string, value: Value): void {\n    this._addEntry({\n      args: [concretize(this.realm, value), new StringValue(this.realm, key)],\n      operationDescriptor: createOperationDescriptor(\"CONCRETE_MODEL\"),\n    });\n  }\n\n  emitGlobalDelete(key: string): void {\n    this._addEntry({\n      args: [new StringValue(this.realm, key)],\n      operationDescriptor: createOperationDescriptor(\"GLOBAL_DELETE\"),\n    });\n  }\n\n  emitBindingAssignment(binding: Binding, value: Value): void {\n    this._entries.push(new BindingAssignmentEntry(this.realm, binding, value));\n  }\n\n  emitPropertyAssignment(object: Value, key: string | Value, value: Value): void {\n    if (object instanceof ObjectValue && object.refuseSerialization) {\n      return;\n    }\n    if (typeof key === \"string\") {\n      key = new StringValue(this.realm, key);\n    }\n    this._addEntry({\n      args: [object, value, key],\n      operationDescriptor: createOperationDescriptor(\"EMIT_PROPERTY_ASSIGNMENT\", { value }),\n    });\n  }\n\n  emitDefineProperty(object: ObjectValue, key: string, desc: PropertyDescriptor, isDescChanged: boolean = true): void {\n    if (object.refuseSerialization) return;\n    if (desc.enumerable && desc.configurable && desc.writable && desc.value && !isDescChanged) {\n      let descValue = desc.value;\n      invariant(descValue instanceof Value);\n      this.emitPropertyAssignment(object, key, descValue);\n    } else {\n      desc = new PropertyDescriptor(desc);\n      let descValue = desc.value || object.$Realm.intrinsics.undefined;\n      invariant(descValue instanceof Value);\n      this._addEntry({\n        args: [\n          new StringValue(this.realm, key),\n          object,\n          descValue,\n          desc.get || object.$Realm.intrinsics.undefined,\n          desc.set || object.$Realm.intrinsics.undefined,\n        ],\n        operationDescriptor: createOperationDescriptor(\"DEFINE_PROPERTY\", { object, descriptor: desc }),\n      });\n    }\n  }\n\n  emitPropertyDelete(object: ObjectValue, key: string): void {\n    if (object.refuseSerialization) return;\n    this._addEntry({\n      args: [object, new StringValue(this.realm, key)],\n      operationDescriptor: createOperationDescriptor(\"PROPERTY_DELETE\"),\n    });\n  }\n\n  emitCall(callFunctionRef: string, args: Array<Value>): void {\n    this._addEntry({\n      args,\n      operationDescriptor: createOperationDescriptor(\"EMIT_CALL\", { callFunctionRef }),\n    });\n  }\n\n  emitConsoleLog(method: ConsoleMethodTypes, args: Array<string | ConcreteValue>): void {\n    this._addEntry({\n      args: [\n        new StringValue(this.realm, method),\n        ...args.map(v => (typeof v === \"string\" ? new StringValue(this.realm, v) : v)),\n      ],\n      operationDescriptor: createOperationDescriptor(\"CONSOLE_LOG\"),\n    });\n  }\n\n  // test must be a temporal value, which means that it must have a defined intrinsicName\n  emitDoWhileStatement(test: AbstractValue, body: Generator): void {\n    this._addEntry({\n      args: [],\n      operationDescriptor: createOperationDescriptor(\"DO_WHILE\", { generator: body, value: test }),\n    });\n  }\n\n  emitConditionalThrow(value: Value): void {\n    if (value instanceof EmptyValue) return;\n    this._issueThrowCompilerDiagnostic(value);\n    this._addEntry({\n      args: [value],\n      operationDescriptor: createOperationDescriptor(\"CONDITIONAL_THROW\", { value }),\n    });\n  }\n\n  _issueThrowCompilerDiagnostic(value: Value): void {\n    let message = \"Program may terminate with exception\";\n    if (value instanceof ObjectValue) {\n      let object = ((value: any): ObjectValue);\n      let objectMessage = this.realm.evaluateWithUndo(() => object._SafeGetDataPropertyValue(\"message\"));\n      if (objectMessage instanceof StringValue) message += `: ${objectMessage.value}`;\n      const objectStack = this.realm.evaluateWithUndo(() => object._SafeGetDataPropertyValue(\"stack\"));\n      if (objectStack instanceof StringValue)\n        message += `\n  ${objectStack.value}`;\n    }\n    const diagnostic = new CompilerDiagnostic(message, value.expressionLocation, \"PP0023\", \"Warning\");\n    this.realm.handleError(diagnostic);\n  }\n\n  emitThrow(value: Value): void {\n    this._issueThrowCompilerDiagnostic(value);\n    this.emitStatement([value], createOperationDescriptor(\"THROW\"));\n  }\n\n  // Checks the full set of possible concrete values as well as typeof\n  // for any AbstractValues\n  // e.g: (obj.property !== undefined && typeof obj.property !== \"object\")\n  // NB: if the type of the AbstractValue is top, skips the invariant\n  emitFullInvariant(object: ObjectValue | AbstractObjectValue, key: string, value: Value): void {\n    if (object.refuseSerialization) return;\n    if (value instanceof AbstractValue) {\n      let isTop = false;\n      let concreteComparisons = [];\n      let typeComparisons = new Set();\n\n      function populateComparisonsLists(absValue: AbstractValue) {\n        if (absValue.kind === \"abstractConcreteUnion\") {\n          // recurse\n          for (let nestedValue of absValue.args)\n            if (nestedValue instanceof ConcreteValue) {\n              concreteComparisons.push(nestedValue);\n            } else {\n              invariant(nestedValue instanceof AbstractValue);\n              populateComparisonsLists(nestedValue);\n            }\n        } else if (absValue.getType() === Value) {\n          isTop = true;\n        } else {\n          typeComparisons.add(absValue.getType());\n        }\n      }\n      populateComparisonsLists(value);\n\n      // No point in doing the invariant if we don't know the type\n      // of one of the nested abstract values\n      if (isTop) {\n        return;\n      } else {\n        this._emitInvariant(\n          [new StringValue(this.realm, key), value, value],\n          createOperationDescriptor(\"FULL_INVARIANT_ABSTRACT\", { concreteComparisons, typeComparisons }),\n          createOperationDescriptor(\"INVARIANT_APPEND\")\n        );\n      }\n    } else if (value instanceof FunctionValue) {\n      // We do a special case for functions,\n      // as we like to use concrete functions in the model to model abstract behaviors.\n      // These concrete functions do not have the right identity.\n      this._emitInvariant(\n        [new StringValue(this.realm, key), object, value, object],\n        createOperationDescriptor(\"FULL_INVARIANT_FUNCTION\"),\n        createOperationDescriptor(\"INVARIANT_APPEND\")\n      );\n    } else {\n      this._emitInvariant(\n        [new StringValue(this.realm, key), object, value, object],\n        createOperationDescriptor(\"FULL_INVARIANT\"),\n        createOperationDescriptor(\"INVARIANT_APPEND\")\n      );\n    }\n  }\n\n  emitPropertyInvariant(\n    object: ObjectValue | AbstractObjectValue,\n    key: string,\n    state: \"MISSING\" | \"PRESENT\" | \"DEFINED\"\n  ): void {\n    if (object.refuseSerialization) return;\n    this._emitInvariant(\n      [new StringValue(this.realm, key), object, object],\n      createOperationDescriptor(\"PROPERTY_INVARIANT\", { state }),\n      createOperationDescriptor(\"INVARIANT_APPEND\")\n    );\n  }\n\n  _emitInvariant(\n    args: Array<Value>,\n    violationConditionOperationDescriptor: OperationDescriptor,\n    appendLastToInvariantOperationDescriptor: OperationDescriptor\n  ): void {\n    invariant(this.realm.invariantLevel > 0);\n    let invariantOperationDescriptor = createOperationDescriptor(\"INVARIANT\", {\n      appendLastToInvariantOperationDescriptor,\n      violationConditionOperationDescriptor,\n    });\n    this._addEntry({\n      args,\n      operationDescriptor: invariantOperationDescriptor,\n    });\n  }\n\n  emitCallAndCaptureResult(\n    types: TypesDomain,\n    values: ValuesDomain,\n    callFunctionRef: string,\n    args: Array<Value>,\n    kind?: AbstractValueKind\n  ): AbstractValue {\n    return this.deriveAbstract(\n      types,\n      values,\n      args,\n      createOperationDescriptor(\"EMIT_CALL_AND_CAPTURE_RESULT\", { callFunctionRef }),\n      { kind }\n    );\n  }\n\n  emitStatement(args: Array<Value>, operationDescriptor: OperationDescriptor): void {\n    invariant(typeof operationDescriptor !== \"function\");\n    this._addEntry({\n      args,\n      operationDescriptor,\n    });\n  }\n\n  emitVoidExpression(\n    types: TypesDomain,\n    values: ValuesDomain,\n    args: Array<Value>,\n    operationDescriptor: OperationDescriptor\n  ): UndefinedValue {\n    this._addEntry({\n      args,\n      operationDescriptor,\n    });\n    return this.realm.intrinsics.undefined;\n  }\n\n  emitForInStatement(\n    o: ObjectValue | AbstractObjectValue,\n    lh: BabelNodeVariableDeclaration,\n    sourceObject: ObjectValue,\n    targetObject: ObjectValue,\n    boundName: BabelNodeIdentifier\n  ): void {\n    this._addEntry({\n      // duplicate args to ensure refcount > 1\n      args: [o, targetObject, sourceObject, targetObject, sourceObject],\n      operationDescriptor: createOperationDescriptor(\"FOR_IN\", { boundName, lh }),\n    });\n  }\n\n  deriveConcreteObject(\n    buildValue: (intrinsicName: string) => ObjectValue,\n    args: Array<Value>,\n    operationDescriptor: OperationDescriptor,\n    optionalArgs?: {| isPure?: boolean |}\n  ): ConcreteValue {\n    let id = this.preludeGenerator.nameGenerator.generate(\"derived\");\n    let value = buildValue(id);\n    value.intrinsicNameGenerated = true;\n    value.isScopedTemplate = true; // because this object doesn't exist ahead of time, and the visitor would otherwise declare it in the common scope\n    invariant(value.intrinsicName === id);\n    this._addDerivedEntry({\n      isPure: optionalArgs ? optionalArgs.isPure : undefined,\n      declared: value,\n      args,\n      operationDescriptor,\n    });\n    return value;\n  }\n\n  deriveAbstract(\n    types: TypesDomain,\n    values: ValuesDomain,\n    args: Array<Value>,\n    operationDescriptor: OperationDescriptor,\n    optionalArgs?: {|\n      kind?: AbstractValueKind,\n      isPure?: boolean,\n      skipInvariant?: boolean,\n      mutatesOnly?: Array<Value>,\n      shape?: void | ShapeInformationInterface,\n    |}\n  ): AbstractValue {\n    let id = this.preludeGenerator.nameGenerator.generate(\"derived\");\n    let options = {};\n    if (optionalArgs && optionalArgs.kind !== undefined) options.kind = optionalArgs.kind;\n    if (optionalArgs && optionalArgs.shape !== undefined) options.shape = optionalArgs.shape;\n    let Constructor = Value.isTypeCompatibleWith(types.getType(), ObjectValue) ? AbstractObjectValue : AbstractValue;\n    let res = new Constructor(\n      this.realm,\n      types,\n      values,\n      1735003607742176 + this.realm.derivedIds.size,\n      [],\n      createOperationDescriptor(\"IDENTIFIER\", { id }),\n      options\n    );\n    res.intrinsicName = id;\n    this._addDerivedEntry({\n      isPure: optionalArgs ? optionalArgs.isPure : undefined,\n      declared: res,\n      args,\n      operationDescriptor,\n      mutatesOnly: optionalArgs ? optionalArgs.mutatesOnly : undefined,\n    });\n    let type = types.getType();\n    if (optionalArgs && optionalArgs.skipInvariant) return res;\n    let typeofString;\n    if (type instanceof FunctionValue) typeofString = \"function\";\n    else if (type === UndefinedValue) invariant(false);\n    else if (type === NullValue) invariant(false);\n    else if (type === StringValue) typeofString = \"string\";\n    else if (type === BooleanValue) typeofString = \"boolean\";\n    else if (type === NumberValue) typeofString = \"number\";\n    else if (type === IntegralValue) typeofString = \"number\";\n    else if (type === SymbolValue) typeofString = \"symbol\";\n    else if (type === ObjectValue) typeofString = \"object\";\n    if (typeofString !== undefined && this.realm.invariantLevel >= 1) {\n      // Verify that the types are as expected, a failure of this invariant\n      // should mean the model is wrong.\n      this._emitInvariant(\n        [new StringValue(this.realm, typeofString), res, res],\n        createOperationDescriptor(\"DERIVED_ABSTRACT_INVARIANT\"),\n        createOperationDescriptor(\"SINGLE_ARG\")\n      );\n    }\n\n    return res;\n  }\n\n  visit(callbacks: VisitEntryCallbacks): void {\n    let visitFn = () => {\n      for (let entry of this._entries) entry.visit(callbacks, this);\n      return null;\n    };\n    if (this.effectsToApply) {\n      this.realm.withEffectsAppliedInGlobalEnv(visitFn, this.effectsToApply);\n    } else {\n      visitFn();\n    }\n  }\n\n  serialize(context: SerializationContext): void {\n    let serializeFn = () => {\n      context.initGenerator(this);\n      for (let entry of this._entries) entry.serialize(context);\n      context.finalizeGenerator(this);\n      return null;\n    };\n    if (this.effectsToApply) {\n      this.realm.withEffectsAppliedInGlobalEnv(serializeFn, this.effectsToApply);\n    } else {\n      serializeFn();\n    }\n  }\n\n  getDependencies(): Array<Generator> {\n    let res = [];\n    for (let entry of this._entries) {\n      let dependencies = entry.getDependencies();\n      if (dependencies !== undefined) res.push(...dependencies);\n    }\n    return res;\n  }\n\n  _addEntry(entryArgs: TemporalOperationEntryArgs): TemporalOperationEntry {\n    let entry;\n    let operationDescriptor = entryArgs.operationDescriptor;\n    if (operationDescriptor && operationDescriptor.type === \"OBJECT_ASSIGN\") {\n      entry = new TemporalObjectAssignEntry(this.realm, entryArgs);\n    } else {\n      entry = new TemporalOperationEntry(this.realm, entryArgs);\n    }\n    this.realm.saveTemporalGeneratorEntryArgs(entry);\n    this._entries.push(entry);\n    return entry;\n  }\n\n  _addDerivedEntry(entryArgs: TemporalOperationEntryArgs): void {\n    let declared = entryArgs.declared;\n    invariant(declared !== undefined);\n    let id = declared.intrinsicName;\n    invariant(id !== undefined);\n    let entry = this._addEntry(entryArgs);\n    this.realm.derivedIds.set(id, entry);\n  }\n\n  appendGenerator(other: Generator, leadingComment: string): void {\n    invariant(other !== this);\n    invariant(other.realm === this.realm);\n    invariant(other.preludeGenerator === this.preludeGenerator);\n    invariant(other.effectsToApply === undefined);\n\n    if (other.empty()) return;\n    this._entries.push(...other._entries);\n  }\n\n  joinGenerators(joinCondition: AbstractValue, generator1: Generator, generator2: Generator): void {\n    invariant(generator1 !== this && generator2 !== this && generator1 !== generator2);\n    if (generator1.empty() && generator2.empty()) return;\n    let generators = [generator1, generator2];\n    this._addEntry({\n      args: [joinCondition],\n      operationDescriptor: createOperationDescriptor(\"JOIN_GENERATORS\", { generators }),\n    });\n  }\n}\n\ntype TemporalOperationEntryOptimizationStatus = \"NO_OPTIMIZATION\" | \"POSSIBLE_OPTIMIZATION\";\n\n// This function attempts to optimize Object.assign calls, by merging mulitple\n// calls into one another where possible. For example:\n//\n// var a = Object.assign({}, someAbstact);\n// var b = Object.assign({}, a);\n//\n// Becomes:\n// var b = Object.assign({}, someAbstract, a);\n//\nexport function attemptToMergeEquivalentObjectAssigns(\n  realm: Realm,\n  callbacks: VisitEntryCallbacks,\n  temporalOperationEntry: TemporalOperationEntry\n): TemporalOperationEntryOptimizationStatus | TemporalObjectAssignEntry {\n  let args = temporalOperationEntry.args;\n  // If we are Object.assigning 2 or more args\n  if (args.length < 2) {\n    return \"NO_OPTIMIZATION\";\n  }\n  let to = args[0];\n  // Then scan through the args after the \"to\" of this Object.assign, to see if any\n  // other sources are the \"to\" of a previous Object.assign call\n  loopThroughArgs: for (let i = 1; i < args.length; i++) {\n    let possibleOtherObjectAssignTo = args[i];\n    // Ensure that the \"to\" value can be omitted\n    // Note: this check is still somewhat fragile and depends on the visiting order\n    // but it's not a functional problem right now and can be better addressed at a\n    // later point.\n    if (!callbacks.canOmit(possibleOtherObjectAssignTo)) {\n      continue;\n    }\n    // Check if the \"to\" was definitely an Object.assign, it should\n    // be a snapshot AbstractObjectValue\n    if (possibleOtherObjectAssignTo instanceof AbstractObjectValue) {\n      let otherTemporalOperationEntry = realm.getTemporalOperationEntryFromDerivedValue(possibleOtherObjectAssignTo);\n      if (!(otherTemporalOperationEntry instanceof TemporalObjectAssignEntry)) {\n        continue;\n      }\n      let otherArgs = otherTemporalOperationEntry.args;\n      // Object.assign has at least 1 arg\n      if (otherArgs.length < 1) {\n        continue;\n      }\n      let otherArgsToUse = [];\n      for (let x = 1; x < otherArgs.length; x++) {\n        let arg = otherArgs[x];\n        // The arg might have been leaked, so ensure we do not continue in this case\n        if (arg instanceof ObjectValue && arg.mightBeLeakedObject()) {\n          continue loopThroughArgs;\n        }\n        if (arg instanceof ObjectValue || arg instanceof AbstractValue) {\n          let temporalGeneratorEntries = realm.getTemporalGeneratorEntriesReferencingArg(arg);\n          // We need to now check if there are any other temporal entries that exist\n          // between the Object.assign TemporalObjectAssignEntry that we're trying to\n          // merge and the current TemporalObjectAssignEntry we're going to merge into.\n          if (temporalGeneratorEntries !== undefined) {\n            for (let temporalGeneratorEntry of temporalGeneratorEntries) {\n              // If the entry is that of another Object.assign, then\n              // we know that this entry isn't going to cause issues\n              // with merging the TemporalObjectAssignEntry.\n              if (temporalGeneratorEntry instanceof TemporalObjectAssignEntry) {\n                continue;\n              }\n              // TODO: what if the temporalGeneratorEntry can be omitted and not needed?\n\n              // If the index of this entry exists between start and end indexes,\n              // then we cannot optimize and merge the TemporalObjectAssignEntry\n              // because another generator entry may have a dependency on the Object.assign\n              // TemporalObjectAssignEntry we're trying to merge.\n              if (\n                temporalGeneratorEntry.notEqualToAndDoesNotHappenBefore(otherTemporalOperationEntry) &&\n                temporalGeneratorEntry.notEqualToAndDoesNotHappenAfter(temporalOperationEntry)\n              ) {\n                continue loopThroughArgs;\n              }\n            }\n          }\n        }\n        otherArgsToUse.push(arg);\n      }\n      // If we cannot omit the \"to\" value that means it's being used, so we shall not try to\n      // optimize this Object.assign.\n      if (!callbacks.canOmit(to)) {\n        // our merged Object.assign, shoud look like:\n        // Object.assign(to, ...prefixArgs, ...otherArgsToUse, ...suffixArgs)\n        let prefixArgs = args.slice(1, i - 1); // We start at 1, as 0 is the index of \"to\" a\n        let suffixArgs = args.slice(i + 1);\n        let newArgs = [to, ...prefixArgs, ...otherArgsToUse, ...suffixArgs];\n\n        // We now create a new TemporalObjectAssignEntry, without mutating the existing\n        // entry at this point. This new entry is essentially a TemporalObjectAssignEntry\n        // that contains two Object.assign call TemporalObjectAssignEntry entries that have\n        // been merged into a single entry. The previous Object.assign TemporalObjectAssignEntry\n        // should dead-code eliminate away once we replace the original TemporalObjectAssignEntry\n        // we started with with the new merged on as they will no longer be referenced.\n        let newTemporalObjectAssignEntryArgs = Object.assign({}, temporalOperationEntry, {\n          args: newArgs,\n        });\n        return new TemporalObjectAssignEntry(realm, newTemporalObjectAssignEntryArgs);\n      }\n      // We might be able to optimize, but we are not sure because \"to\" can still omit.\n      // So we return possible optimization status and wait until \"to\" does get visited.\n      // It may never get visited, but that's okay as we'll skip the optimization all\n      // together.\n      return \"POSSIBLE_OPTIMIZATION\";\n    }\n  }\n  return \"NO_OPTIMIZATION\";\n}\n"],"file":"generator.js"}