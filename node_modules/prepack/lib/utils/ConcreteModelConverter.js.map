{"version":3,"sources":["../../src/utils/ConcreteModelConverter.js"],"names":["reportCompileError","realm","message","loc","error","CompilerDiagnostic","handleError","createEmptyFunction","concreteFunction","ECMAScriptSourceFunctionValue","initialize","t","blockStatement","concretize","val","ConcreteValue","AbstractValue","kind","args","length","type","types","getType","isTop","UndefinedValue","prototype","PrimitiveValue","values","StringValue","NumberValue","SymbolValue","BooleanValue","NullValue","getElements","size","value","FunctionValue","ArrayValue","expressionLocation","AbstractObjectValue","ObjectValue","template","getTemplate","concreteObj","Create","ObjectCreate","$GetPrototypeOf","keys","P","newElement","CreateDataProperty"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\n/**\n * This file contains code that converts abstract models into concrete values.\n */\n\nimport type { Realm } from \"../realm.js\";\nimport type { BabelNodeSourceLocation } from \"@babel/types\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  BooleanValue,\n  ConcreteValue,\n  FunctionValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  SymbolValue,\n  UndefinedValue,\n  PrimitiveValue,\n  ArrayValue,\n  ECMAScriptSourceFunctionValue,\n  Value,\n} from \"../values/index.js\";\nimport * as t from \"@babel/types\";\nimport invariant from \"../invariant.js\";\nimport { CompilerDiagnostic } from \"../errors.js\";\nimport { EnumerableOwnProperties, Get } from \"../methods/index.js\";\nimport { Create } from \"../singletons.js\";\n\nfunction reportCompileError(realm: Realm, message: string, loc: ?BabelNodeSourceLocation) {\n  let error = new CompilerDiagnostic(message, loc, \"PP9000\", \"RecoverableError\");\n  realm.handleError(error);\n}\n\nfunction createEmptyFunction(realm: Realm) {\n  const concreteFunction = new ECMAScriptSourceFunctionValue(realm);\n  concreteFunction.initialize([], t.blockStatement([]));\n  return concreteFunction;\n}\n\n/**\n * Convert abstract model value into concrete value.\n */\nexport function concretize(realm: Realm, val: Value): ConcreteValue {\n  if (val instanceof ConcreteValue) {\n    return val;\n  }\n  invariant(val instanceof AbstractValue);\n  if (val.kind === \"abstractConcreteUnion\") {\n    invariant(val.args.length >= 2);\n    return concretize(realm, val.args[0]);\n  }\n  const type = val.types.getType();\n  if (val.types.isTop()) {\n    return new UndefinedValue(realm);\n  } else if ((type: any).prototype instanceof PrimitiveValue) {\n    if (val.values.isTop()) {\n      switch (type) {\n        case StringValue:\n          return new StringValue(realm, \"__concreteModel\");\n        case NumberValue:\n          return new NumberValue(realm, 42);\n        case SymbolValue:\n          return new SymbolValue(realm, new StringValue(realm, \"__concreteModel\"));\n        case BooleanValue:\n          return new BooleanValue(realm, true);\n        case NullValue:\n          return new NullValue(realm);\n        case UndefinedValue:\n          return new UndefinedValue(realm);\n        default:\n          invariant(false, \"Not yet implemented\");\n      }\n    } else {\n      // TODO: This was broken. Is this actually used?\n      const values = val.values.getElements();\n      invariant(values.size === 1, \"Concrete model should only have one value\");\n      for (let value in values) {\n        invariant(value instanceof ConcreteValue, \"Concrete model should only contain one concrete value\");\n        return value;\n      }\n      invariant(false);\n    }\n  } else if (type === FunctionValue) {\n    return createEmptyFunction(realm);\n  } else if (type === ArrayValue) {\n    reportCompileError(\n      realm,\n      \"Emitting a concrete model for abstract array value is not supported yet.\",\n      val.expressionLocation\n    );\n  } else if (val instanceof AbstractObjectValue) {\n    if (val.values.isTop()) {\n      return new ObjectValue(realm);\n    } else {\n      let template = val.getTemplate();\n      let concreteObj = Create.ObjectCreate(realm, template.$GetPrototypeOf());\n      let keys = EnumerableOwnProperties(realm, template, \"key\", true);\n      for (let P of keys) {\n        invariant(P instanceof StringValue);\n        let newElement = Get(realm, template, P);\n        Create.CreateDataProperty(realm, concreteObj, P, concretize(realm, newElement));\n      }\n      return concreteObj;\n    }\n  }\n  reportCompileError(\n    realm,\n    \"Emitting a concrete model for this abstract value is not supported yet.\",\n    val.expressionLocation\n  );\n  // Return undefined to make flow happy.\n  return new UndefinedValue(realm);\n}\n"],"file":"ConcreteModelConverter.js"}