"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAndValidateArgModel = createAndValidateArgModel;
exports.ShapeInformation = void 0;

var _singletons = require("../singletons.js");

var _index = require("../values/index.js");

var _errors = require("../errors.js");

var _realm = require("../realm.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class ShapeInformation {
  constructor(descriptor, parentDescriptor, parentKey, universe) {
    this._descriptor = descriptor;
    this._parentDescriptor = parentDescriptor;
    this._parentKey = parentKey;
    this._universe = universe;
  }

  getGetter() {
    // we want getter only for existing GraphQL objects
    return this._parentDescriptor !== undefined && this._parentDescriptor.graphQLType !== undefined && this._parentDescriptor.kind === "object" ? this._getAssociatedGetter() : undefined;
  }

  getAbstractType() {
    // we assume that value is not optional if it root
    if (this._isOptional() || this._descriptor.jsType === "void" || this._descriptor.jsType === "null") {
      return _index.Value;
    }

    return _singletons.Utils.getTypeFromName(this._descriptor.jsType) || _index.Value;
  }

  getPropertyShape(key) {
    let property = this._getInformationForProperty(key);

    return property !== undefined ? ShapeInformation._resolveLinksAndWrap(property.shape, this._descriptor, key, this._universe) : undefined;
  }

  static createForArgument(model, argname) {
    return model !== undefined ? ShapeInformation._resolveLinksAndWrap(model.universe[model.arguments[argname]], undefined, undefined, model.universe) : undefined;
  }

  static createForReactComponentProps(model) {
    return model !== undefined ? ShapeInformation._resolveLinksAndWrap(model.universe[model.component.props], undefined, undefined, model.universe) : undefined;
  }

  _isOptional() {
    if (this._parentDescriptor === undefined) {
      return undefined;
    }

    switch (this._parentDescriptor.kind) {
      case "object":
        return this._parentKey !== undefined && this._parentDescriptor.properties[this._parentKey] !== undefined ? this._parentDescriptor.properties[this._parentKey].optional : undefined;

      case "array":
        return this._parentDescriptor.elementShape !== undefined ? this._parentDescriptor.elementShape.optional : undefined;

      default:
        return undefined;
    }
  }

  _getInformationForProperty(key) {
    switch (this._descriptor.kind) {
      case "object":
        return this._descriptor.properties[key];

      case "array":
        switch (key) {
          case "length":
            return ShapeInformation._arrayLengthProperty;

          case "prototype":
            return undefined;

          default:
            return this._descriptor.elementShape;
        }

      default:
        // it is still legal to do member access on primitive value
        // such as string
        return undefined;
    }
  }

  _getAssociatedGetter() {
    switch (this._descriptor.kind) {
      case "object":
        return "tree";

      case "array":
        let elementShape = this._descriptor.elementShape !== undefined ? this._descriptor.elementShape.shape : undefined;

        let innerShape = ShapeInformation._resolveLinksAndWrap(elementShape, this._descriptor, undefined, this._universe);

        if (innerShape === undefined) {
          return undefined;
        }

        switch (innerShape._getAssociatedGetter()) {
          case "bool":
            return "bool_list";

          case "double":
            return "double_list";

          case "int":
            return "int_list";

          case "time":
            return "time_list";

          case "string":
            return "string_list";

          case "tree":
            return "tree_list";
          // no support for nested arrays yet

          default:
            return undefined;
        }

      case "scalar":
        switch (this._descriptor.graphQLType) {
          case "Color":
          case "File":
          case "ID":
          case "String":
          case "Url":
            return "string";

          case "Int":
          case "Time":
            return "int";

          case "Float":
            return "double";

          case "Boolean":
            return "bool";

          default:
            return undefined;
        }

      case "enum":
        return "string";

      default:
        return undefined;
    }
  }

  static _resolveLinksAndWrap(descriptor, parentDescription, parentKey, universe) {
    while (descriptor && descriptor.kind === "link") {
      descriptor = universe[descriptor.shapeName];
    }

    return descriptor !== undefined ? new ShapeInformation(descriptor, parentDescription, parentKey, universe) : undefined;
  }

} // TODO: do more full validation walking the whole shape


exports.ShapeInformation = ShapeInformation;

_defineProperty(ShapeInformation, "_arrayLengthProperty", {
  shape: {
    kind: "scalar",
    jsType: "integral"
  },
  optional: false
});

function createAndValidateArgModel(realm, argModelString) {
  let argModelError;

  if (argModelString instanceof _index.StringValue) {
    try {
      let argModel = JSON.parse(argModelString.value);
      if (!argModel.universe) argModelError = new _errors.CompilerDiagnostic("ArgModel must contain a universe property containing a ShapeUniverse", realm.currentLocation, "PP1008", "FatalError");
      if (!argModel.arguments) argModelError = new _errors.CompilerDiagnostic("ArgModel must contain an arguments property.", realm.currentLocation, "PP1008", "FatalError");
      return argModel;
    } catch (e) {
      argModelError = new _errors.CompilerDiagnostic("Failed to parse model for arguments", realm.currentLocation, "PP1008", "FatalError");
    }
  } else {
    argModelError = new _errors.CompilerDiagnostic("String expected as a model", realm.currentLocation, "PP1008", "FatalError");
  }

  if (argModelError !== undefined && realm.handleError(argModelError) !== "Recover") {
    throw new _errors.FatalError();
  }

  return undefined;
}
//# sourceMappingURL=ShapeInformation.js.map