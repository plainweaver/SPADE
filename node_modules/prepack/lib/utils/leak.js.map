{"version":3,"sources":["../../src/utils/leak.js"],"names":["visitName","path","state","name","read","write","scope","hasBinding","unboundReads","add","unboundWrites","ignorePath","parent","t","isLabeledStatement","isBreakStatement","isContinueStatement","LeakedClosureRefVisitor","ReferencedIdentifier","innerName","node","doesRead","operator","getBindingIdentifiers","getLeakedFunctionInfo","value","ECMAScriptSourceFunctionValue","constructor","functionInfo","Set","formalParameters","$FormalParameters","code","$ECMAScriptCode","file","program","expressionStatement","functionExpression","traverse","cache","clear","materializeObject","realm","object","getCachingHeapInspector","generator","symbols","size","FatalError","unknownProperty","undefined","getHeapInspector","HeapInspector","Logger","propertyBinding","properties","canIgnoreProperty","descriptor","emitPropertyDelete","PropertyDescriptor","Value","EmptyValue","targetDescriptor","getTargetIntegrityDescriptor","writable","configurable","emitDefineProperty","emitPropertyAssignment","ObjectValueLeakingVisitor","objectsTrackedForLeaks","visitedValues","mustVisit","val","ObjectValue","has","visitObjectProperty","binding","desc","visitDescriptor","visitObjectProperties","obj","kind","propertyBindingValue","visitObjectPropertiesWithComputedNamesDescriptor","visitObjectPrototype","mightNotBeLeakedObject","leak","makeAndCacheHeapInspector","heapInspector","_heapInspector","proto","$Prototype","visitValue","AbstractValue","visitObjectPropertiesWithComputedNames","AbstractJoinedDescriptor","joinCondition","descriptor1","descriptor2","absVal","cond","args","P","V","earlier_props","consequent","alternate","get","set","visitDeclarativeEnvironmentRecordBinding","record","remainingLeakedBindings","bindings","bindingName","Object","keys","isRead","delete","isWritten","visitValueMap","getKind","entries","$MapData","$WeakMapData","len","length","i","entry","key","$Key","$Value","visitValueSet","$SetData","$WeakSetData","visitValueFunction","BoundFunctionValue","$BoundTargetFunction","$BoundThis","boundArg","$BoundArguments","NativeFunctionValue","environment","$Environment","environmentRecord","ObjectEnvironmentRecord","GlobalEnvironmentRecord","DeclarativeEnvironmentRecord","FunctionEnvironmentRecord","fn","$FunctionObject","visitValueObject","dateValue","$DateValue","buf","$ViewedArrayBuffer","$ParameterMap","visitValueProxy","$ProxyTarget","$ProxyHandler","visitAbstractValue","mightBeObject","values","isTop","whitelistedKind","startsWith","intrinsicName","n","element","getElements","isIntrinsic","ArrayValue","isIntrinsicAndHasWidenedNumericProperty","PrimitiveValue","ProxyValue","FunctionValue","ensureFrozenValue","loc","diag","CompilerDiagnostic","currentLocation","handleError","LeakImplementation","instantRender","enabled","createdObjectsTrackedForLeaks","visitor","MaterializeImplementation","makeFinal","computeReachableObjects","rootValue","isInPureScope","reachableObjects","computeFromValue","computeFromBindings","func","nonLocalReadBindings","computeFromDeclarativeEnvironmentRecord","environmentBindings","found","computeFromAbstractValue","arg","computeFromProxyValue","visit","ifNotVisited","computeFromFunctionValue","computeFromObjectValue","computeFromObjectProperties","computeFromMap","computeFromSet","computeFromDescriptor","computeFromObjectPropertyBinding","computeFromObjectPropertiesWithComputedNamesDescriptor","computeFromObjectPrototype","nonLocalReadBindingsOfFunction","notSupportedForTransitiveMaterialization","computeFrom","error","expressionLocation"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { Descriptor, PropertyBinding, ObjectKind } from \"../types.js\";\nimport {\n  leakBinding,\n  DeclarativeEnvironmentRecord,\n  FunctionEnvironmentRecord,\n  ObjectEnvironmentRecord,\n  GlobalEnvironmentRecord,\n} from \"../environment.js\";\nimport {\n  AbstractValue,\n  ArrayValue,\n  BoundFunctionValue,\n  ECMAScriptSourceFunctionValue,\n  EmptyValue,\n  FunctionValue,\n  NativeFunctionValue,\n  ObjectValue,\n  PrimitiveValue,\n  ProxyValue,\n  Value,\n} from \"../values/index.js\";\nimport { TestIntegrityLevel } from \"../methods/index.js\";\nimport * as t from \"@babel/types\";\nimport traverse from \"@babel/traverse\";\nimport type { BabelTraversePath } from \"@babel/traverse\";\nimport type { BabelNodeSourceLocation } from \"@babel/types\";\nimport invariant from \"../invariant.js\";\nimport { HeapInspector } from \"../utils/HeapInspector.js\";\nimport { Logger } from \"../utils/logger.js\";\nimport { isReactElement } from \"../react/utils.js\";\nimport { PropertyDescriptor, AbstractJoinedDescriptor } from \"../descriptors.js\";\n\ntype LeakedFunctionInfo = {\n  unboundReads: Set<string>,\n  unboundWrites: Set<string>,\n};\n\nfunction visitName(\n  path: BabelTraversePath,\n  state: LeakedFunctionInfo,\n  name: string,\n  read: boolean,\n  write: boolean\n): void {\n  // Is the name bound to some local identifier? If so, we don't need to do anything\n  if (path.scope.hasBinding(name, /*noGlobals*/ true)) return;\n\n  // Otherwise, let's record that there's an unbound identifier\n  if (read) state.unboundReads.add(name);\n  if (write) state.unboundWrites.add(name);\n}\n\nfunction ignorePath(path: BabelTraversePath): boolean {\n  let parent = path.parent;\n  return t.isLabeledStatement(parent) || t.isBreakStatement(parent) || t.isContinueStatement(parent);\n}\n\nlet LeakedClosureRefVisitor = {\n  ReferencedIdentifier(path: BabelTraversePath, state: LeakedFunctionInfo): void {\n    if (ignorePath(path)) return;\n\n    let innerName = path.node.name;\n    if (innerName === \"arguments\") {\n      return;\n    }\n    visitName(path, state, innerName, true, false);\n  },\n\n  \"AssignmentExpression|UpdateExpression\"(path: BabelTraversePath, state: LeakedFunctionInfo): void {\n    let doesRead = path.node.operator !== \"=\";\n    for (let name in path.getBindingIdentifiers()) {\n      visitName(path, state, name, doesRead, true);\n    }\n  },\n};\n\nfunction getLeakedFunctionInfo(value: FunctionValue) {\n  // TODO: This should really be cached on a per AST basis in case we have\n  // many uses of the same closure. It should ideally share this cache\n  // and data with ResidualHeapVisitor.\n  invariant(value instanceof ECMAScriptSourceFunctionValue);\n  invariant(value.constructor === ECMAScriptSourceFunctionValue);\n  let functionInfo = {\n    unboundReads: new Set(),\n    unboundWrites: new Set(),\n  };\n  let formalParameters = value.$FormalParameters;\n  invariant(formalParameters != null);\n  let code = value.$ECMAScriptCode;\n  invariant(code != null);\n\n  traverse(\n    t.file(t.program([t.expressionStatement(t.functionExpression(null, formalParameters, code))])),\n    LeakedClosureRefVisitor,\n    null,\n    functionInfo\n  );\n  traverse.cache.clear();\n  return functionInfo;\n}\n\nfunction materializeObject(realm: Realm, object: ObjectValue, getCachingHeapInspector?: () => HeapInspector): void {\n  let generator = realm.generator;\n\n  if (object.symbols.size > 0) {\n    throw new FatalError(\"TODO: Support havocing objects with symbols\");\n  }\n\n  if (object.unknownProperty !== undefined) {\n    // TODO: Support unknown properties, or throw FatalError.\n    // We have repros, e.g. test/serializer/additional-functions/ArrayConcat.js.\n  }\n\n  let getHeapInspector =\n    getCachingHeapInspector || (() => new HeapInspector(realm, new Logger(realm, /*internalDebug*/ false)));\n\n  // TODO: We should emit current value and then reset value for all *internal slots*; this will require deep serializer support; or throw FatalError when we detect any non-initial values in internal slots.\n  for (let [name, propertyBinding] of object.properties) {\n    // ignore properties with their correct default values\n    if (getHeapInspector().canIgnoreProperty(object, name)) continue;\n\n    let descriptor = propertyBinding.descriptor;\n    if (descriptor === undefined) {\n      // TODO: This happens, e.g. test/serializer/pure-functions/ObjectAssign2.js\n      // If it indeed means deleted binding, should we initialize descriptor with a deleted value?\n      if (generator !== undefined) generator.emitPropertyDelete(object, name);\n    } else {\n      invariant(descriptor instanceof PropertyDescriptor); // TODO: Deal with joined descriptors.\n      let value = descriptor.value;\n      invariant(\n        value === undefined || value instanceof Value,\n        \"cannot be an array because we are not dealing with intrinsics here\"\n      );\n      if (value === undefined) {\n        // TODO: Deal with accessor properties\n        // We have repros, e.g. test/serializer/pure-functions/AbstractPropertyObjectKeyAssignment.js\n      } else {\n        invariant(value instanceof Value);\n        if (value instanceof EmptyValue) {\n          if (generator !== undefined) generator.emitPropertyDelete(object, name);\n        } else {\n          if (generator !== undefined) {\n            let targetDescriptor = getHeapInspector().getTargetIntegrityDescriptor(object);\n            if (!isReactElement(object)) {\n              if (\n                descriptor.writable !== targetDescriptor.writable ||\n                descriptor.configurable !== targetDescriptor.configurable\n              ) {\n                generator.emitDefineProperty(object, name, descriptor);\n              } else {\n                generator.emitPropertyAssignment(object, name, value);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\nclass ObjectValueLeakingVisitor {\n  realm: Realm;\n  // ObjectValues to visit if they're reachable.\n  objectsTrackedForLeaks: Set<ObjectValue>;\n  // Values that has been visited.\n  visitedValues: Set<Value>;\n  _heapInspector: HeapInspector;\n\n  constructor(realm: Realm, objectsTrackedForLeaks: Set<ObjectValue>) {\n    this.realm = realm;\n    this.objectsTrackedForLeaks = objectsTrackedForLeaks;\n    this.visitedValues = new Set();\n  }\n\n  mustVisit(val: Value): boolean {\n    if (val instanceof ObjectValue) {\n      // For Objects we only need to visit it if it is tracked\n      // as a newly created object that might still be mutated.\n      // Abstract values gets their arguments visited.\n      if (!this.objectsTrackedForLeaks.has(val)) return false;\n    }\n    if (this.visitedValues.has(val)) return false;\n    this.visitedValues.add(val);\n    return true;\n  }\n\n  visitObjectProperty(binding: PropertyBinding): void {\n    let desc = binding.descriptor;\n    if (desc === undefined) return; //deleted\n    this.visitDescriptor(desc);\n  }\n\n  visitObjectProperties(obj: ObjectValue, kind?: ObjectKind): void {\n    // visit symbol properties\n    for (let [, propertyBindingValue] of obj.symbols) {\n      invariant(propertyBindingValue);\n      this.visitObjectProperty(propertyBindingValue);\n    }\n\n    // visit string properties\n    for (let [, propertyBindingValue] of obj.properties) {\n      invariant(propertyBindingValue);\n      this.visitObjectProperty(propertyBindingValue);\n    }\n\n    // inject properties with computed names\n    if (obj.unknownProperty !== undefined) {\n      let desc = obj.unknownProperty.descriptor;\n      this.visitObjectPropertiesWithComputedNamesDescriptor(desc);\n    }\n\n    // prototype\n    this.visitObjectPrototype(obj);\n\n    if (TestIntegrityLevel(this.realm, obj, \"frozen\")) return;\n\n    // if this object wasn't already leaked, we need mark it as leaked\n    // so that any mutation and property access get tracked after this.\n    if (obj.mightNotBeLeakedObject()) {\n      obj.leak();\n\n      // materialization is a common operation and needs to be invoked\n      // whenever non-final values need to be made available at intermediate\n      // points in a program's control flow. An object can be materialized by\n      // calling materializeObject(). Sometimes, objects\n      // are materialized in cohorts (such as during leaking).\n      // In these cases, we provide a caching mechanism for HeapInspector().\n      let makeAndCacheHeapInspector = () => {\n        let heapInspector = this._heapInspector;\n        if (heapInspector !== undefined) return heapInspector;\n        else {\n          heapInspector = new HeapInspector(this.realm, new Logger(this.realm, /*internalDebug*/ false));\n          this._heapInspector = heapInspector;\n          return heapInspector;\n        }\n      };\n      invariant(this.realm.generator !== undefined);\n      materializeObject(this.realm, obj, makeAndCacheHeapInspector);\n    }\n  }\n\n  visitObjectPrototype(obj: ObjectValue): void {\n    let proto = obj.$Prototype;\n    this.visitValue(proto);\n  }\n\n  visitObjectPropertiesWithComputedNamesDescriptor(desc: void | Descriptor): void {\n    if (desc !== undefined) {\n      if (desc instanceof PropertyDescriptor) {\n        let val = desc.value;\n        invariant(val instanceof AbstractValue);\n        this.visitObjectPropertiesWithComputedNames(val);\n      } else if (desc instanceof AbstractJoinedDescriptor) {\n        this.visitValue(desc.joinCondition);\n        this.visitObjectPropertiesWithComputedNamesDescriptor(desc.descriptor1);\n        this.visitObjectPropertiesWithComputedNamesDescriptor(desc.descriptor2);\n      } else {\n        invariant(false, \"unknown descriptor\");\n      }\n    }\n  }\n\n  visitObjectPropertiesWithComputedNames(absVal: AbstractValue): void {\n    if (absVal.kind === \"widened property\") return;\n    if (absVal.kind === \"template for prototype member expression\") return;\n    if (absVal.kind === \"conditional\") {\n      let cond = absVal.args[0];\n      invariant(cond instanceof AbstractValue);\n      if (cond.kind === \"template for property name condition\") {\n        let P = cond.args[0];\n        invariant(P instanceof AbstractValue);\n        let V = absVal.args[1];\n        let earlier_props = absVal.args[2];\n        if (earlier_props instanceof AbstractValue) this.visitObjectPropertiesWithComputedNames(earlier_props);\n        this.visitValue(P);\n        this.visitValue(V);\n      } else {\n        // conditional assignment\n        this.visitValue(cond);\n        let consequent = absVal.args[1];\n        if (consequent instanceof AbstractValue) {\n          this.visitObjectPropertiesWithComputedNames(consequent);\n        }\n        let alternate = absVal.args[2];\n        if (alternate instanceof AbstractValue) {\n          this.visitObjectPropertiesWithComputedNames(alternate);\n        }\n      }\n    } else {\n      this.visitValue(absVal);\n    }\n  }\n\n  visitDescriptor(desc: void | Descriptor): void {\n    if (desc === undefined) {\n    } else if (desc instanceof PropertyDescriptor) {\n      if (desc.value !== undefined) this.visitValue(desc.value);\n      if (desc.get !== undefined) this.visitValue(desc.get);\n      if (desc.set !== undefined) this.visitValue(desc.set);\n    } else if (desc instanceof AbstractJoinedDescriptor) {\n      this.visitValue(desc.joinCondition);\n      if (desc.descriptor1 !== undefined) this.visitDescriptor(desc.descriptor1);\n      if (desc.descriptor2 !== undefined) this.visitDescriptor(desc.descriptor2);\n    } else {\n      invariant(false, \"unknown descriptor\");\n    }\n  }\n\n  visitDeclarativeEnvironmentRecordBinding(\n    record: DeclarativeEnvironmentRecord,\n    remainingLeakedBindings: LeakedFunctionInfo\n  ): void {\n    let bindings = record.bindings;\n    for (let bindingName of Object.keys(bindings)) {\n      let binding = bindings[bindingName];\n      // Check if this binding is referenced, and if so delete it from the set.\n      let isRead = remainingLeakedBindings.unboundReads.delete(bindingName);\n      let isWritten = remainingLeakedBindings.unboundWrites.delete(bindingName);\n      if (isRead) {\n        // If this binding can be read from the closure, its value has now leaked.\n        let value = binding.value;\n        if (value) {\n          this.visitValue(value);\n        }\n      }\n      if (isWritten || isRead) {\n        // If this binding could have been mutated from the closure, then the\n        // binding itself has now leaked, but not necessarily the value in it.\n        // TODO: We could tag a leaked binding as read and/or write. That way\n        // we don't have to leak values written to this binding if only the binding\n        // has been written to. We also don't have to leak reads from this binding\n        // if it is only read from.\n        leakBinding(binding);\n      }\n    }\n  }\n\n  visitValueMap(val: ObjectValue): void {\n    let kind = val.getKind();\n\n    let entries;\n    if (kind === \"Map\") {\n      entries = val.$MapData;\n    } else {\n      invariant(kind === \"WeakMap\");\n      entries = val.$WeakMapData;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      let key = entry.$Key;\n      let value = entry.$Value;\n      if (key === undefined || value === undefined) continue;\n      this.visitValue(key);\n      this.visitValue(value);\n    }\n  }\n\n  visitValueSet(val: ObjectValue): void {\n    let kind = val.getKind();\n\n    let entries;\n    if (kind === \"Set\") {\n      entries = val.$SetData;\n    } else {\n      invariant(kind === \"WeakSet\");\n      entries = val.$WeakSetData;\n    }\n    invariant(entries !== undefined);\n    let len = entries.length;\n\n    for (let i = 0; i < len; i++) {\n      let entry = entries[i];\n      if (entry === undefined) continue;\n      this.visitValue(entry);\n    }\n  }\n\n  visitValueFunction(val: FunctionValue): void {\n    if (!val.mightNotBeLeakedObject()) {\n      return;\n    }\n    this.visitObjectProperties(val);\n\n    if (val instanceof BoundFunctionValue) {\n      this.visitValue(val.$BoundTargetFunction);\n      this.visitValue(val.$BoundThis);\n      for (let boundArg of val.$BoundArguments) this.visitValue(boundArg);\n      return;\n    }\n\n    invariant(\n      !(val instanceof NativeFunctionValue),\n      \"all native function values should have already been created outside this pure function\"\n    );\n\n    let remainingLeakedBindings = getLeakedFunctionInfo(val);\n\n    let environment = val.$Environment;\n    while (environment) {\n      let record = environment.environmentRecord;\n      if (record instanceof ObjectEnvironmentRecord) {\n        this.visitValue(record.object);\n        continue;\n      }\n      if (record instanceof GlobalEnvironmentRecord) {\n        break;\n      }\n\n      invariant(record instanceof DeclarativeEnvironmentRecord);\n      this.visitDeclarativeEnvironmentRecordBinding(record, remainingLeakedBindings);\n\n      if (record instanceof FunctionEnvironmentRecord) {\n        // If this is a function environment, which is not tracked for leaks,\n        // we can bail out because its bindings should not be mutated in a\n        // pure function.\n        let fn = record.$FunctionObject;\n        if (!this.objectsTrackedForLeaks.has(fn)) {\n          break;\n        }\n      }\n      environment = environment.parent;\n    }\n  }\n\n  visitValueObject(val: ObjectValue): void {\n    if (!val.mightNotBeLeakedObject()) {\n      return;\n    }\n\n    let kind = val.getKind();\n    this.visitObjectProperties(val, kind);\n\n    switch (kind) {\n      case \"RegExp\":\n      case \"Number\":\n      case \"String\":\n      case \"Boolean\":\n      case \"ReactElement\":\n      case \"ArrayBuffer\":\n      case \"Array\":\n        return;\n      case \"Date\":\n        let dateValue = val.$DateValue;\n        invariant(dateValue !== undefined);\n        this.visitValue(dateValue);\n        return;\n      case \"Float32Array\":\n      case \"Float64Array\":\n      case \"Int8Array\":\n      case \"Int16Array\":\n      case \"Int32Array\":\n      case \"Uint8Array\":\n      case \"Uint16Array\":\n      case \"Uint32Array\":\n      case \"Uint8ClampedArray\":\n      case \"DataView\":\n        let buf = val.$ViewedArrayBuffer;\n        invariant(buf !== undefined);\n        this.visitValue(buf);\n        return;\n      case \"Map\":\n      case \"WeakMap\":\n        this.visitValueMap(val);\n        return;\n      case \"Set\":\n      case \"WeakSet\":\n        this.visitValueSet(val);\n        return;\n      default:\n        invariant(kind === \"Object\", `Object of kind ${kind} is not supported in calls to abstract functions.`);\n        invariant(val.$ParameterMap === undefined, `Arguments object is not supported in calls to abstract functions.`);\n        return;\n    }\n  }\n\n  visitValueProxy(val: ProxyValue): void {\n    this.visitValue(val.$ProxyTarget);\n    this.visitValue(val.$ProxyHandler);\n  }\n\n  visitAbstractValue(val: AbstractValue): void {\n    if (!val.mightBeObject()) {\n      // Only objects need to be leaked.\n      return;\n    }\n    if (val.values.isTop()) {\n      // If we don't know which object instances it might be,\n      // then it might be one of the arguments that created\n      // this value. See #2179.\n\n      if (val.kind === \"conditional\") {\n        // For a conditional, we only have to visit each case. Not the condition itself.\n        this.visitValue(val.args[1]);\n        this.visitValue(val.args[2]);\n        return;\n      }\n\n      // To ensure that we don't forget to provide arguments\n      // that can be havoced, we require at least one argument.\n      let whitelistedKind =\n        val.kind &&\n        (val.kind === \"widened numeric property\" || // TODO: Widened properties needs to be havocable.\n          val.kind.startsWith(\"abstractCounted\"));\n      invariant(\n        whitelistedKind !== undefined || val.intrinsicName !== undefined || val.args.length > 0,\n        \"Havoced unknown object requires havocable arguments\"\n      );\n\n      // TODO: This is overly conservative. We recursively leak all the inputs\n      // to this operation whether or not they can possible be part of the\n      // result value or not.\n      for (let i = 0, n = val.args.length; i < n; i++) {\n        this.visitValue(val.args[i]);\n      }\n      return;\n    }\n    // If we know which object this might be, then leak each of them.\n    for (let element of val.values.getElements()) {\n      this.visitValue(element);\n    }\n  }\n\n  visitValue(val: Value): void {\n    if (val instanceof AbstractValue) {\n      if (this.mustVisit(val)) this.visitAbstractValue(val);\n    } else if (val.isIntrinsic()) {\n      // All intrinsic values exist from the beginning of time (except arrays with widened properties)...\n      // ...except for a few that come into existance as templates for abstract objects.\n      if (val instanceof ArrayValue && ArrayValue.isIntrinsicAndHasWidenedNumericProperty(val)) {\n        if (this.mustVisit(val)) this.visitValueObject(val);\n      } else {\n        this.mustVisit(val);\n      }\n    } else if (val instanceof EmptyValue) {\n      this.mustVisit(val);\n    } else if (val instanceof PrimitiveValue) {\n      this.mustVisit(val);\n    } else if (val instanceof ProxyValue) {\n      if (this.mustVisit(val)) this.visitValueProxy(val);\n    } else if (val instanceof FunctionValue) {\n      invariant(val instanceof FunctionValue);\n      if (this.mustVisit(val)) this.visitValueFunction(val);\n    } else {\n      invariant(val instanceof ObjectValue);\n      if (this.mustVisit(val)) this.visitValueObject(val);\n    }\n  }\n}\n\nfunction ensureFrozenValue(realm, value, loc): void {\n  // TODO: This should really check if it is recursively immutability.\n  if (value instanceof ObjectValue && !TestIntegrityLevel(realm, value, \"frozen\")) {\n    let diag = new CompilerDiagnostic(\n      \"Unfrozen object leaked before end of global code\",\n      loc || realm.currentLocation,\n      \"PP0017\",\n      \"RecoverableError\"\n    );\n    if (realm.handleError(diag) !== \"Recover\") throw new FatalError();\n  }\n}\n\n// Ensure that a value is immutable. If it is not, set all its properties to abstract values\n// and all reachable bindings to abstract values.\nexport class LeakImplementation {\n  value(realm: Realm, value: Value, loc: ?BabelNodeSourceLocation): void {\n    if (realm.instantRender.enabled) {\n      // TODO: For InstantRender...\n      // - For declarative bindings, we do want proper materialization/leaking/havocing\n      // - For object properties, we conceptually want materialization\n      //   (however, not via statements that mutate the objects,\n      //   but only as part of the initial object literals),\n      //   but actual no leaking or leaking as there should be a way to annotate/enforce\n      //   that external/abstract functions are pure with regards to heap objects\n      return;\n    }\n    let objectsTrackedForLeaks = realm.createdObjectsTrackedForLeaks;\n    if (objectsTrackedForLeaks === undefined) {\n      // We're not tracking a pure function. That means that we would track\n      // everything as leaked. We'll assume that any object argument\n      // is invalid unless it's frozen.\n      ensureFrozenValue(realm, value, loc);\n    } else {\n      // If we're tracking a pure function, we can assume that only newly\n      // created objects and bindings, within it, are mutable. Any other\n      // object can safely be assumed to be deeply immutable as far as this\n      // pure function is concerned. However, any mutable object needs to\n      // be tainted as possibly having changed to anything.\n      let visitor = new ObjectValueLeakingVisitor(realm, objectsTrackedForLeaks);\n      visitor.visitValue(value);\n    }\n  }\n}\n\nexport class MaterializeImplementation {\n  // TODO: Understand relation to snapshots: #2441\n  materializeObject(realm: Realm, val: ObjectValue): void {\n    if (realm.instantRender.enabled)\n      // Materialization leads to runtime code that mutates objects\n      // this is at best undesirable in InstantRender\n      val.makeFinal();\n    else materializeObject(realm, val);\n  }\n\n  // This routine materializes objects reachable from non-local bindings read\n  // by a function. It does this for the purpose of outlining calls to that function.\n  //\n  // Notes:\n  // - Locations that are only read need not materialize because their values are up-to-date\n  // at optimization time,\n  // - Locations that are written to are ignored, because we make the assumption, for now,\n  // that the function being outlined is pure.\n  // - Previously havoced locations (#2446) should be reloaded, but are currently rejected.\n  // - Specialization depends on the assumption that the Array op will only be used once.\n  // First, we will enforce it: #2448. Later we will relax it: #2454\n  computeReachableObjects(realm: Realm, rootValue: Value): Set<ObjectValue> {\n    invariant(realm.isInPureScope());\n\n    let reachableObjects: Set<ObjectValue> = new Set();\n    let visitedValues: Set<Value> = new Set();\n    computeFromValue(rootValue);\n\n    return reachableObjects;\n\n    function computeFromBindings(func: FunctionValue, nonLocalReadBindings: Set<string>): void {\n      invariant(func instanceof ECMAScriptSourceFunctionValue);\n      let environment = func.$Environment;\n      while (environment) {\n        let record = environment.environmentRecord;\n        if (record instanceof ObjectEnvironmentRecord) computeFromValue(record.object);\n        else if (record instanceof DeclarativeEnvironmentRecord || record instanceof FunctionEnvironmentRecord)\n          computeFromDeclarativeEnvironmentRecord(record, nonLocalReadBindings);\n        else if (record instanceof GlobalEnvironmentRecord) {\n          // TODO: #2484\n          break;\n        }\n        environment = environment.parent;\n      }\n    }\n    function computeFromDeclarativeEnvironmentRecord(\n      record: DeclarativeEnvironmentRecord,\n      nonLocalReadBindings: Set<string>\n    ): void {\n      let environmentBindings = record.bindings;\n      for (let bindingName of Object.keys(environmentBindings)) {\n        let binding = environmentBindings[bindingName];\n        invariant(binding !== undefined);\n        let found = nonLocalReadBindings.delete(bindingName);\n        // Check what undefined could mean here, besides absent binding\n        // #2446\n        if (found && binding.value !== undefined) {\n          computeFromValue(binding.value);\n        }\n      }\n    }\n    function computeFromAbstractValue(value: AbstractValue): void {\n      if (value.values.isTop()) {\n        for (let arg of value.args) {\n          computeFromValue(arg);\n        }\n      } else {\n        // If we know which object this might be, then leak each of them.\n        for (let element of value.values.getElements()) {\n          computeFromValue(element);\n        }\n      }\n    }\n    function computeFromProxyValue(value: ProxyValue): void {\n      computeFromValue(value.$ProxyTarget);\n      computeFromValue(value.$ProxyHandler);\n    }\n    function computeFromValue(value: Value): void {\n      invariant(value !== undefined);\n      if (value.isIntrinsic() || value instanceof EmptyValue || value instanceof PrimitiveValue) {\n        visit(value);\n      } else if (value instanceof AbstractValue) {\n        ifNotVisited(value, computeFromAbstractValue);\n      } else if (value instanceof FunctionValue) {\n        ifNotVisited(value, computeFromFunctionValue);\n      } else if (value instanceof ObjectValue) {\n        ifNotVisited(value, computeFromObjectValue);\n      } else if (value instanceof ProxyValue) {\n        ifNotVisited(value, computeFromProxyValue);\n      }\n    }\n    function computeFromObjectValue(value: Value): void {\n      invariant(value instanceof ObjectValue);\n      let kind = value.getKind();\n      computeFromObjectProperties(value, kind);\n\n      switch (kind) {\n        case \"RegExp\":\n        case \"Number\":\n        case \"String\":\n        case \"Boolean\":\n        case \"ReactElement\":\n        case \"ArrayBuffer\":\n        case \"Array\":\n          break;\n        case \"Date\":\n          let dateValue = value.$DateValue;\n          invariant(dateValue !== undefined);\n          computeFromValue(dateValue);\n          break;\n        case \"Float32Array\":\n        case \"Float64Array\":\n        case \"Int8Array\":\n        case \"Int16Array\":\n        case \"Int32Array\":\n        case \"Uint8Array\":\n        case \"Uint16Array\":\n        case \"Uint32Array\":\n        case \"Uint8ClampedArray\":\n        case \"DataView\":\n          let buf = value.$ViewedArrayBuffer;\n          invariant(buf !== undefined);\n          computeFromValue(buf);\n          break;\n        case \"Map\":\n        case \"WeakMap\":\n          ifNotVisited(value, computeFromMap);\n          break;\n        case \"Set\":\n        case \"WeakSet\":\n          ifNotVisited(value, computeFromSet);\n          break;\n        default:\n          invariant(kind === \"Object\", `Object of kind ${kind} is not supported in calls to abstract functions.`);\n          invariant(\n            value.$ParameterMap === undefined,\n            `Arguments object is not supported in calls to abstract functions.`\n          );\n          break;\n      }\n      if (!reachableObjects.has(value)) reachableObjects.add(value);\n    }\n    function computeFromDescriptor(descriptor: Descriptor): void {\n      if (descriptor === undefined) {\n      } else if (descriptor instanceof PropertyDescriptor) {\n        if (descriptor.value !== undefined) computeFromValue(descriptor.value);\n        if (descriptor.get !== undefined) computeFromValue(descriptor.get);\n        if (descriptor.set !== undefined) computeFromValue(descriptor.set);\n      } else if (descriptor instanceof AbstractJoinedDescriptor) {\n        computeFromValue(descriptor.joinCondition);\n        if (descriptor.descriptor1 !== undefined) computeFromDescriptor(descriptor.descriptor1);\n        if (descriptor.descriptor2 !== undefined) computeFromDescriptor(descriptor.descriptor2);\n      } else {\n        invariant(false, \"unknown descriptor\");\n      }\n    }\n    function computeFromObjectPropertyBinding(binding: PropertyBinding): void {\n      let descriptor = binding.descriptor;\n      if (descriptor === undefined) return; //deleted\n      computeFromDescriptor(descriptor);\n    }\n\n    function computeFromObjectProperties(obj: ObjectValue, kind?: ObjectKind): void {\n      // symbol properties\n      for (let [, propertyBindingValue] of obj.symbols) {\n        invariant(propertyBindingValue);\n        computeFromObjectPropertyBinding(propertyBindingValue);\n      }\n\n      // string properties\n      for (let [, propertyBindingValue] of obj.properties) {\n        invariant(propertyBindingValue);\n        computeFromObjectPropertyBinding(propertyBindingValue);\n      }\n\n      // inject properties with computed names\n      if (obj.unknownProperty !== undefined) {\n        let descriptor = obj.unknownProperty.descriptor;\n        computeFromObjectPropertiesWithComputedNamesDescriptor(descriptor);\n      }\n\n      // prototype\n      computeFromObjectPrototype(obj);\n    }\n    function computeFromObjectPrototype(obj: ObjectValue) {\n      if (obj.$Prototype !== undefined) computeFromValue(obj.$Prototype);\n    }\n    function computeFromFunctionValue(fn: FunctionValue) {\n      computeFromObjectProperties(fn);\n\n      if (fn instanceof BoundFunctionValue) {\n        computeFromValue(fn.$BoundTargetFunction);\n        computeFromValue(fn.$BoundThis);\n        for (let boundArg of fn.$BoundArguments) computeFromValue(boundArg);\n        return;\n      }\n\n      invariant(\n        !(fn instanceof NativeFunctionValue),\n        \"all native function values should have already been created outside this pure function\"\n      );\n\n      let nonLocalReadBindings = nonLocalReadBindingsOfFunction(fn);\n      computeFromBindings(fn, nonLocalReadBindings);\n    }\n\n    function computeFromObjectPropertiesWithComputedNamesDescriptor(descriptor: void | Descriptor): void {\n      // TODO: #2484\n      notSupportedForTransitiveMaterialization();\n    }\n\n    function computeFromMap(val: ObjectValue): void {\n      let kind = val.getKind();\n\n      let entries;\n      if (kind === \"Map\") {\n        entries = val.$MapData;\n      } else {\n        invariant(kind === \"WeakMap\");\n        entries = val.$WeakMapData;\n      }\n      invariant(entries !== undefined);\n      let len = entries.length;\n\n      for (let i = 0; i < len; i++) {\n        let entry = entries[i];\n        let key = entry.$Key;\n        let value = entry.$Value;\n        if (key === undefined || value === undefined) continue;\n        computeFromValue(key);\n        computeFromValue(value);\n      }\n    }\n\n    function computeFromSet(val: ObjectValue): void {\n      let kind = val.getKind();\n\n      let entries;\n      if (kind === \"Set\") {\n        entries = val.$SetData;\n      } else {\n        invariant(kind === \"WeakSet\");\n        entries = val.$WeakSetData;\n      }\n      invariant(entries !== undefined);\n      let len = entries.length;\n\n      for (let i = 0; i < len; i++) {\n        let entry = entries[i];\n        if (entry === undefined) continue;\n\n        computeFromValue(entry);\n      }\n    }\n\n    function nonLocalReadBindingsOfFunction(func: FunctionValue) {\n      // unboundWrites is currently not used, but we leave it in place\n      // to reuse the function closure visitor implemented for leaking\n      let functionInfo = {\n        unboundReads: new Set(),\n        unboundWrites: new Set(),\n      };\n\n      invariant(func instanceof ECMAScriptSourceFunctionValue);\n\n      let formalParameters = func.$FormalParameters;\n      invariant(formalParameters != null);\n\n      let code = func.$ECMAScriptCode;\n      invariant(code != null);\n\n      traverse(\n        t.file(t.program([t.expressionStatement(t.functionExpression(null, formalParameters, code))])),\n        LeakedClosureRefVisitor,\n        null,\n        functionInfo\n      );\n      traverse.cache.clear();\n\n      // TODO #2478: add invariant that there are no write bindings\n      return functionInfo.unboundReads;\n    }\n    function ifNotVisited<T>(value: T, computeFrom: T => void): void {\n      if (!visitedValues.has(value)) {\n        visitedValues.add(value);\n        computeFrom(value);\n      }\n    }\n    function visit(value: Value): void {\n      visitedValues.add(value);\n    }\n    function notSupportedForTransitiveMaterialization() {\n      let error = new CompilerDiagnostic(\n        \"Not supported for transitive materialization\",\n        rootValue.expressionLocation,\n        \"PP0041\",\n        \"FatalError\"\n      );\n      realm.handleError(error);\n      throw new FatalError();\n    }\n  }\n}\n"],"file":"leak.js"}