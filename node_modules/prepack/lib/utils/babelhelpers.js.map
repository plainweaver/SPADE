{"version":3,"sources":["../../src/utils/babelhelpers.js"],"names":["voidExpression","t","unaryExpression","numericLiteral","nullExpression","nullLiteral","emptyExpression","identifier","constructorExpression","protoExpression","getAsPropertyNameExpression","key","canBeIdentifier","index","Number","parseInt","toString","keyIsAscii","test","isValidIdentifier","stringLiteral","memberExpressionHelper","object","property","propertyExpression","computed","isIdentifier","isStringLiteral","value","memberExpression","optionalStringOfLocation","location","stringOfLocation","source","start","line","column"],"mappings":";;;;;;;;;;;AAkBA;;;;AAlBA;;;;;;;;AAoBO,MAAMA,cAAmC,GAAGC,CAAC,CAACC,eAAF,CAAkB,MAAlB,EAA0BD,CAAC,CAACE,cAAF,CAAiB,CAAjB,CAA1B,EAA+C,IAA/C,CAA5C;;AACA,MAAMC,cAAmC,GAAGH,CAAC,CAACI,WAAF,EAA5C;;AACA,MAAMC,eAAoC,GAAGL,CAAC,CAACM,UAAF,CAAa,SAAb,CAA7C;;AACA,MAAMC,qBAA0C,GAAGP,CAAC,CAACM,UAAF,CAAa,eAAb,CAAnD;;AACA,MAAME,eAAoC,GAAGR,CAAC,CAACM,UAAF,CAAa,WAAb,CAA7C;;;AAEA,SAASG,2BAAT,CAAqCC,GAArC,EAAkDC,eAAwB,GAAG,IAA7E,EAAwG;AAC7G;AACA,MAAIC,KAAK,GAAGC,MAAM,CAACC,QAAP,CAAgBJ,GAAhB,EAAqB,EAArB,CAAZ;;AACA,MAAIE,KAAK,IAAI,CAAT,IAAcA,KAAK,CAACG,QAAN,OAAqBL,GAAvC,EAA4C;AAC1C,WAAOV,CAAC,CAACE,cAAF,CAAiBU,KAAjB,CAAP;AACD;;AAED,MAAID,eAAJ,EAAqB;AACnB;AACA,QAAIK,UAAU,GAAG,qBAAqBC,IAArB,CAA0BP,GAA1B,CAAjB;AACA,QAAIV,CAAC,CAACkB,iBAAF,CAAoBR,GAApB,KAA4BM,UAAhC,EAA4C,OAAOhB,CAAC,CAACM,UAAF,CAAaI,GAAb,CAAP;AAC7C;;AAED,SAAOV,CAAC,CAACmB,aAAF,CAAgBT,GAAhB,CAAP;AACD;;AAEM,SAASU,sBAAT,CACLC,MADK,EAELC,QAFK,EAGsB;AAC3B,MAAIC,kBAAJ;AACA,MAAIC,QAAJ;;AACA,MAAI,OAAOF,QAAP,KAAoB,QAAxB,EAAkC;AAChCC,IAAAA,kBAAkB,GAAGd,2BAA2B,CAACa,QAAD,CAAhD;AACAE,IAAAA,QAAQ,GAAG,CAACxB,CAAC,CAACyB,YAAF,CAAeF,kBAAf,CAAZ;AACD,GAHD,MAGO,IAAIvB,CAAC,CAAC0B,eAAF,CAAkBJ,QAAlB,CAAJ,EAAiC;AACtCC,IAAAA,kBAAkB,GAAGd,2BAA2B,CAAGa,QAAF,CAA0CK,KAA3C,CAAhD;AACAH,IAAAA,QAAQ,GAAG,CAACxB,CAAC,CAACyB,YAAF,CAAeF,kBAAf,CAAZ;AACD,GAHM,MAGA;AACLA,IAAAA,kBAAkB,GAAGD,QAArB;AACAE,IAAAA,QAAQ,GAAG,IAAX;AACD;;AACD,SAAOxB,CAAC,CAAC4B,gBAAF,CAAmBP,MAAnB,EAA2BE,kBAA3B,EAA+CC,QAA/C,CAAP;AACD;;AAEM,SAASK,wBAAT,CAAkCC,QAAlC,EAA8E;AACnF;AACA,SAAOA,QAAQ,GAAI,gBAAeC,gBAAgB,CAACD,QAAD,CAAW,EAA9C,GAAkD,EAAjE;AACD;;AAEM,SAASC,gBAAT,CAA0BD,QAA1B,EAAqE;AAC1E,SAAQ,GAAEA,QAAQ,CAACE,MAAT,IAAmB,uBAAwB,IAAGF,QAAQ,CAACG,KAAT,CAAeC,IAAK,IAAGJ,QAAQ,CAACG,KAAT,CAAeE,MAAO,GAArG;AACD","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  BabelNodeExpression,\n  BabelNodeMemberExpression,\n  BabelNodeStringLiteral,\n  BabelNodeIdentifier,\n  BabelNodeSourceLocation,\n} from \"@babel/types\";\nimport * as t from \"@babel/types\";\n\nexport const voidExpression: BabelNodeExpression = t.unaryExpression(\"void\", t.numericLiteral(0), true);\nexport const nullExpression: BabelNodeExpression = t.nullLiteral();\nexport const emptyExpression: BabelNodeIdentifier = t.identifier(\"__empty\");\nexport const constructorExpression: BabelNodeIdentifier = t.identifier(\"__constructor\");\nexport const protoExpression: BabelNodeIdentifier = t.identifier(\"__proto__\");\n\nexport function getAsPropertyNameExpression(key: string, canBeIdentifier: boolean = true): BabelNodeExpression {\n  // If key is a non-negative numeric string literal, parse it and set it as a numeric index instead.\n  let index = Number.parseInt(key, 10);\n  if (index >= 0 && index.toString() === key) {\n    return t.numericLiteral(index);\n  }\n\n  if (canBeIdentifier) {\n    // TODO #1020: revert this when Unicode identifiers are supported by all targetted JavaScript engines\n    let keyIsAscii = /^[\\u0000-\\u007f]*$/.test(key);\n    if (t.isValidIdentifier(key) && keyIsAscii) return t.identifier(key);\n  }\n\n  return t.stringLiteral(key);\n}\n\nexport function memberExpressionHelper(\n  object: BabelNodeExpression,\n  property: string | BabelNodeExpression\n): BabelNodeMemberExpression {\n  let propertyExpression: BabelNodeExpression;\n  let computed;\n  if (typeof property === \"string\") {\n    propertyExpression = getAsPropertyNameExpression(property);\n    computed = !t.isIdentifier(propertyExpression);\n  } else if (t.isStringLiteral(property)) {\n    propertyExpression = getAsPropertyNameExpression(((property: any): BabelNodeStringLiteral).value);\n    computed = !t.isIdentifier(propertyExpression);\n  } else {\n    propertyExpression = property;\n    computed = true;\n  }\n  return t.memberExpression(object, propertyExpression, computed);\n}\n\nexport function optionalStringOfLocation(location: ?BabelNodeSourceLocation): string {\n  // if we can't get a value, then it's likely that the source file was not given\n  return location ? ` at location ${stringOfLocation(location)}` : \"\";\n}\n\nexport function stringOfLocation(location: BabelNodeSourceLocation): string {\n  return `${location.source || \"(unknown source file)\"}[${location.start.line}:${location.start.column}]`;\n}\n"],"file":"babelhelpers.js"}