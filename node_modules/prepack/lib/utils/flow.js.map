{"version":3,"sources":["../../src/utils/flow.js"],"names":["stripFlowTypeAnnotations","ast","ImportDeclaration","path","node","specifiers","length","typeCount","forEach","importKind","remove","Flow","ClassProperty","variance","typeAnnotation","value","Class","implements","get","child","isClassProperty","AssignmentPattern","left","optional","Function","i","params","param","type","predicate","TypeCastExpression","expression","t","isTypeCastExpression","replaceWith","undefined","traverse","cache","clear"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict */\n\nimport traverse from \"@babel/traverse\";\nimport { BabelNode } from \"@babel/types\";\nimport * as t from \"@babel/types\";\n\n// Taken directly from Babel:\n// https://github.com/babel/babel/blob/cde005422701a69ff21044c138c29a5ad23b6d0a/packages/babel-plugin-transform-flow-strip-types/src/index.js#L32-L107\n// Copyright 2015-present Sebastian McKenzie / Babel project (https://github.com/babel)\n// only the lines reflected in the above were used\nexport function stripFlowTypeAnnotations(ast: BabelNode): void {\n  traverse(\n    ast,\n    {\n      ImportDeclaration(path) {\n        if (!path.node.specifiers.length) return;\n        let typeCount = 0;\n        path.node.specifiers.forEach(({ importKind }) => {\n          if (importKind === \"type\" || importKind === \"typeof\") {\n            typeCount++;\n          }\n        });\n        if (typeCount === path.node.specifiers.length) {\n          path.remove();\n        }\n      },\n      Flow(path) {\n        path.remove();\n      },\n      ClassProperty(path) {\n        path.node.variance = null;\n        path.node.typeAnnotation = null;\n        if (!path.node.value) path.remove();\n      },\n      Class(path) {\n        path.node.implements = null;\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassProperty()) {\n            child.node.typeAnnotation = null;\n            if (!child.node.value) child.remove();\n          }\n        });\n      },\n      AssignmentPattern({ node }) {\n        node.left.optional = false;\n      },\n      Function({ node }) {\n        for (let i = 0; i < node.params.length; i++) {\n          const param = node.params[i];\n          param.optional = false;\n          if (param.type === \"AssignmentPattern\") {\n            param.left.optional = false;\n          }\n        }\n        node.predicate = null;\n      },\n      TypeCastExpression(path) {\n        let { node } = path;\n        do {\n          node = node.expression;\n        } while (t.isTypeCastExpression(node));\n        path.replaceWith(node);\n      },\n    },\n    undefined,\n    {},\n    undefined\n  );\n  traverse.cache.clear();\n}\n"],"file":"flow.js"}