{"version":3,"sources":["../../src/utils/JSONTokenizer.js"],"names":["data","isLegal","x","undefined","pushData","stack","push","JSON","stringify","visited","Set","length","pop","has","TypeError","add","Array","isArray","i","value","reversedStack","key","reverse"],"mappings":";;;;;;;AAWA;;;;AAXA;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;eACgBA,IAAD,IAAsC;AACnD;AACA,MAAIC,OAAO,GAAGC,CAAC,IAAIA,CAAC,KAAKC,SAAN,IAAmB,OAAOD,CAAP,KAAa,UAAhC,IAA8C,OAAOA,CAAP,KAAa,QAA9E;;AACA,0BAAUD,OAAO,CAACD,IAAD,CAAjB;;AACA,MAAII,QAAQ,GAAG,CAACC,KAAD,EAAQH,CAAR,KAAcG,KAAK,CAACC,IAAN,CAAW,OAAOJ,CAAP,KAAa,QAAb,IAAyBA,CAAC,KAAK,IAA/B,GAAsCA,CAAtC,GAA0CK,IAAI,CAACC,SAAL,CAAeN,CAAf,CAArD,CAA7B;;AACA,MAAIG,KAAK,GAAG,EAAZ;AACAD,EAAAA,QAAQ,CAACC,KAAD,EAAQL,IAAR,CAAR;AACA,MAAIS,OAAO,GAAG,IAAIC,GAAJ,EAAd;AACA,SAAO,MAAM;AACX,WAAOL,KAAK,CAACM,MAAN,GAAe,CAAtB,EAAyB;AACvBX,MAAAA,IAAI,GAAGK,KAAK,CAACO,GAAN,EAAP;AACA,UAAI,OAAOZ,IAAP,KAAgB,QAApB,EAA8B,OAAOA,IAAP;AAC9B,8BAAU,OAAOA,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,IAA/C;AACA,UAAIS,OAAO,CAACI,GAAR,CAAYb,IAAZ,CAAJ,EAAuB,MAAM,IAAIc,SAAJ,CAAc,uCAAd,CAAN;AACvBL,MAAAA,OAAO,CAACM,GAAR,CAAYf,IAAZ;;AACA,UAAIgB,KAAK,CAACC,OAAN,CAAcjB,IAAd,CAAJ,EAAyB;AACvBK,QAAAA,KAAK,CAACC,IAAN,CAAW,GAAX;;AACA,aAAK,IAAIY,CAAC,GAAGlB,IAAI,CAACW,MAAL,GAAc,CAA3B,EAA8BO,CAAC,IAAI,CAAnC,EAAsCA,CAAC,EAAvC,EAA2C;AACzC,cAAIC,KAAK,GAAGnB,IAAI,CAACkB,CAAD,CAAhB;AACAd,UAAAA,QAAQ,CAACC,KAAD,EAAQJ,OAAO,CAACkB,KAAD,CAAP,GAAiBA,KAAjB,GAAyB,IAAjC,CAAR;AACA,cAAID,CAAC,GAAG,CAAR,EAAWb,KAAK,CAACC,IAAN,CAAW,GAAX;AACZ;;AACDD,QAAAA,KAAK,CAACC,IAAN,CAAW,GAAX;AACD,OARD,MAQO;AACLD,QAAAA,KAAK,CAACC,IAAN,CAAW,GAAX;AACA,YAAIc,aAAa,GAAG,EAApB;;AACA,aAAK,IAAIC,GAAT,IAAgBrB,IAAhB,EAAsB;AACpB;AACA,cAAI,OAAOqB,GAAP,KAAe,QAAnB,EAA6B;AAC7B,cAAIF,KAAK,GAAGnB,IAAI,CAACqB,GAAD,CAAhB;AACA,cAAI,CAACpB,OAAO,CAACkB,KAAD,CAAZ,EAAqB;AACrB,cAAIC,aAAa,CAACT,MAAd,GAAuB,CAA3B,EAA8BS,aAAa,CAACd,IAAd,CAAmB,GAAnB;AAC9Bc,UAAAA,aAAa,CAACd,IAAd,CAAmBC,IAAI,CAACC,SAAL,CAAea,GAAf,CAAnB;AACAD,UAAAA,aAAa,CAACd,IAAd,CAAmB,GAAnB;AACAF,UAAAA,QAAQ,CAACgB,aAAD,EAAgBD,KAAhB,CAAR;AACD;;AACDd,QAAAA,KAAK,CAACC,IAAN,CAAW,GAAGc,aAAa,CAACE,OAAd,EAAd;AACAjB,QAAAA,KAAK,CAACC,IAAN,CAAW,GAAX;AACD;AACF;AACF,GAhCD;AAiCD,C","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport invariant from \"../invariant.js\";\n\n// JSON.stringify is not the right choice when writing out giant objects\n// to disk. This is an alternative that produces a stream of tokens incrementally\n// instead of building a giant in-memory representation first.\n// The exported function returns a function that, when called repeatedly,\n// provides all the strings that when concatenated together produce the\n// result JSON.stringified would have produced on the data.\n// After all strings have been provided, the final answer will be undefined.\nexport default (data: any): (() => void | string) => {\n  // $FlowFixMe: \"symbol\" not yet supported by Flow\n  let isLegal = x => x !== undefined && typeof x !== \"function\" && typeof x !== \"symbol\";\n  invariant(isLegal(data));\n  let pushData = (stack, x) => stack.push(typeof x === \"object\" && x !== null ? x : JSON.stringify(x));\n  let stack = [];\n  pushData(stack, data);\n  let visited = new Set();\n  return () => {\n    while (stack.length > 0) {\n      data = stack.pop();\n      if (typeof data === \"string\") return data;\n      invariant(typeof data === \"object\" && data !== null);\n      if (visited.has(data)) throw new TypeError(\"Converting circular structure to JSON\");\n      visited.add(data);\n      if (Array.isArray(data)) {\n        stack.push(\"]\");\n        for (let i = data.length - 1; i >= 0; i--) {\n          let value = data[i];\n          pushData(stack, isLegal(value) ? value : null);\n          if (i > 0) stack.push(\",\");\n        }\n        stack.push(\"[\");\n      } else {\n        stack.push(\"}\");\n        let reversedStack = [];\n        for (let key in data) {\n          // $FlowFixMe: \"symbol\" not yet supported by Flow\n          if (typeof key === \"symbol\") continue;\n          let value = data[key];\n          if (!isLegal(value)) continue;\n          if (reversedStack.length > 0) reversedStack.push(\",\");\n          reversedStack.push(JSON.stringify(key));\n          reversedStack.push(\":\");\n          pushData(reversedStack, value);\n        }\n        stack.push(...reversedStack.reverse());\n        stack.push(\"{\");\n      }\n    }\n  };\n};\n"],"file":"JSONTokenizer.js"}