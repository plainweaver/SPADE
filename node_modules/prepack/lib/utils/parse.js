"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _invariant = _interopRequireDefault(require("../invariant.js"));

var _completions = require("../completions.js");

var _index = require("../values/index.js");

var _construct = require("../methods/construct.js");

var _traverseFast = _interopRequireDefault(require("./traverse-fast.js"));

var _parser = require("@babel/parser");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
function _default(realm, code, filename, sourceType = "script", startLine = 1) {
  try {
    let plugins = ["objectRestSpread"];

    if (realm.react.enabled) {
      plugins.push("jsx");
    }

    if (realm.stripFlow) {
      plugins.push("flow");
    }

    let ast = (0, _parser.parse)(code, {
      filename,
      sourceType,
      startLine,
      plugins
    });
    (0, _traverseFast.default)(ast, node => {
      (0, _invariant.default)(node.loc);
      node.loc.source = filename;
      return false;
    });
    return ast;
  } catch (e) {
    if (e instanceof SyntaxError) {
      // Babel reports all errors as syntax errors, even if a ReferenceError should be thrown.
      // What we do here is a totally robust way to address that issue.
      let referenceErrors = ["Invalid left-hand side in postfix operation", "Invalid left-hand side in prefix operation", "Invalid left-hand side in assignment expression"];
      let error;

      if (referenceErrors.some(msg => e.message.indexOf(msg) >= 0)) {
        error = (0, _construct.Construct)(realm, realm.intrinsics.ReferenceError, [new _index.StringValue(realm, e.message)]);
      } else {
        error = (0, _construct.Construct)(realm, realm.intrinsics.SyntaxError, [new _index.StringValue(realm, e.message)]);
      }

      error = error.throwIfNotConcreteObject(); // These constructors are currently guaranteed to produce an object with
      // built-in error data. Append location information about the syntax error
      // and the source code to it so that we can use it to print nicer errors.

      (0, _invariant.default)(error.$ErrorData);
      error.$ErrorData.locationData = {
        filename: filename,
        sourceCode: code,
        loc: e.loc,
        stackDecorated: false
      };
      throw new _completions.ThrowCompletion(error, e.loc);
    } else {
      throw e;
    }
  }
}
//# sourceMappingURL=parse.js.map