{"version":3,"sources":["../../src/utils/paths.js"],"names":["PathConditionsImplementation","PathConditions","constructor","baseConditions","_assumedConditions","Set","_readonly","undefined","_baseConditions","add","c","_failedImplications","_failedNegativeImplications","isReadOnly","implies","e","depth","mightNotBeTrue","mightNotBeFalse","AbstractValue","has","_impliedConditions","_impliedNegatives","assumedCondition","cacheImplicationSuccess","kind","x","y","args","NullValue","UndefinedValue","impliesNot","cacheNegativeImplicationSuccess","isEmpty","size","getLength","getAssumedConditions","refineBaseConditons","realm","totalRefinements","refinementTarget","abstractValueImpliesMax","total","refine","condition","refinedCondition","simplifyAndRefineAbstractCondition","InfeasiblePathError","savedBaseConditions","PathImplementation","$Realm","pathConditions","withCondition","evaluate","impliesCounterOverflowed","savedPath","pushPathCondition","pushInversePathCondition","withInverseCondition","pushAndRefine","pushInverseAndRefine","ConcreteValue","left","right","cond","equals","leftNeNull","createFromBinaryOp","intrinsics","null","leftNeUndefined","leftEqNull","leftEqUndefined","createFromLogicalOp","op","inverseCondition","createFromUnaryOp","simplifiedInverseCondition"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { InfeasiblePathError } from \"../errors.js\";\nimport invariant from \"../invariant.js\";\nimport { Realm } from \"../realm.js\";\nimport { PathConditions } from \"../types.js\";\nimport { AbstractValue, ConcreteValue, NullValue, UndefinedValue, Value } from \"../values/index.js\";\n\nexport class PathConditionsImplementation extends PathConditions {\n  constructor(baseConditions?: void | PathConditions) {\n    super();\n    this._assumedConditions = new Set();\n    this._readonly = false;\n    if (baseConditions !== undefined) {\n      invariant(baseConditions instanceof PathConditionsImplementation);\n      this._baseConditions = baseConditions;\n    }\n  }\n\n  _assumedConditions: Set<AbstractValue>;\n  _readonly: boolean;\n  _baseConditions: void | PathConditionsImplementation;\n  _impliedConditions: void | Set<AbstractValue>;\n  _impliedNegatives: void | Set<AbstractValue>;\n  _failedImplications: void | Set<AbstractValue>;\n  _failedNegativeImplications: void | Set<AbstractValue>;\n\n  add(c: AbstractValue): void {\n    invariant(!this._readonly);\n    this._assumedConditions.add(c);\n    this._failedImplications = undefined;\n    this._failedNegativeImplications = undefined;\n  }\n\n  isReadOnly(): boolean {\n    return this._readonly;\n  }\n\n  // this => val. A false value does not imply that !(this => val).\n  implies(e: Value, depth: number = 0): boolean {\n    if (!e.mightNotBeTrue()) return true;\n    if (!e.mightNotBeFalse()) return false;\n    invariant(e instanceof AbstractValue);\n    if (this._assumedConditions.has(e)) return true;\n    if (this._impliedConditions !== undefined && this._impliedConditions.has(e)) return true;\n    if (this._impliedNegatives !== undefined && this._impliedNegatives.has(e)) return false;\n    if (this._failedImplications !== undefined && this._failedImplications.has(e)) return false;\n    if (depth > 10) return false;\n    if (this._baseConditions !== undefined && this._baseConditions.implies(e, depth + 1)) return true;\n    for (let assumedCondition of this._assumedConditions) {\n      if (assumedCondition.implies(e, depth + 1)) return this.cacheImplicationSuccess(e);\n    }\n    if (e.kind === \"||\") {\n      let [x, y] = e.args;\n      // this => x || true, regardless of the value of x\n      // this => true || y, regardless of the value of y\n      if (!x.mightNotBeTrue() || !y.mightNotBeTrue()) return this.cacheImplicationSuccess(e);\n      // this => false || y, if this => y\n      if (!x.mightNotBeFalse() && this.implies(y, depth + 1)) return this.cacheImplicationSuccess(e);\n      // this => x || false if this => x\n      if (!y.mightNotBeFalse() && this.implies(x, depth + 1)) return this.cacheImplicationSuccess(e);\n      // this => x || y if this => x\n      if (this.implies(x, depth + 1)) return this.cacheImplicationSuccess(e);\n      // this => x || y if this => y\n      if (this.implies(y, depth + 1)) return this.cacheImplicationSuccess(e);\n    }\n    if (e.kind === \"!==\" || e.kind === \"!=\") {\n      let [x, y] = e.args;\n      if (x instanceof AbstractValue) {\n        // this => x !== null && x !== undefined, if this => x\n        // this => x != null && x != undefined, if this => x\n        if ((y instanceof NullValue || y instanceof UndefinedValue) && this.implies(x, depth + 1))\n          return this.cacheImplicationSuccess(e);\n      } else {\n        invariant(y instanceof AbstractValue); // otherwise e would have been simplied\n        // this => null !== y && undefined !== y, if this => y\n        // this => null != y && undefined != y, if this => y\n        if ((x instanceof NullValue || x instanceof UndefinedValue) && this.implies(y, depth + 1))\n          return this.cacheImplicationSuccess(e);\n      }\n    }\n    if (e.kind === \"!\") {\n      let [x] = e.args;\n      if (this.impliesNot(x, depth + 1)) return this.cacheImplicationSuccess(e);\n    }\n    if (this._failedImplications === undefined) this._failedImplications = new Set();\n    this._failedImplications.add(e);\n    return false;\n  }\n\n  cacheImplicationSuccess(e: AbstractValue): true {\n    if (this._impliedConditions === undefined) this._impliedConditions = new Set();\n    this._impliedConditions.add(e);\n    return true;\n  }\n\n  // this => !val. A false value does not imply that !(this => !val).\n  impliesNot(e: Value, depth: number = 0): boolean {\n    if (!e.mightNotBeTrue()) return false;\n    if (!e.mightNotBeFalse()) return true;\n    invariant(e instanceof AbstractValue);\n    if (this._assumedConditions.has(e)) return false;\n    if (this._impliedConditions !== undefined && this._impliedConditions.has(e)) return false;\n    if (this._impliedNegatives !== undefined && this._impliedNegatives.has(e)) return true;\n    if (this._failedNegativeImplications !== undefined && this._failedNegativeImplications.has(e)) return false;\n    if (depth > 10) return false;\n    if (this._baseConditions !== undefined && this._baseConditions.impliesNot(e, depth + 1)) return true;\n    for (let assumedCondition of this._assumedConditions) {\n      if (assumedCondition.impliesNot(e, depth + 1)) return this.cacheNegativeImplicationSuccess(e);\n    }\n    if (e.kind === \"&&\") {\n      let [x, y] = e.args;\n      // this => !(false && y) regardless of the value of y\n      // this => !(x && false) regardless of the value of x\n      if (!x.mightNotBeFalse() || !y.mightNotBeFalse()) return this.cacheNegativeImplicationSuccess(e);\n      // this => !(true && y), if this => !y\n      if (!x.mightNotBeTrue() && this.impliesNot(y, depth + 1)) return this.cacheNegativeImplicationSuccess(e);\n      // this => !(x && true) if this => !x\n      if (!y.mightNotBeTrue() && this.impliesNot(x, depth + 1)) return this.cacheNegativeImplicationSuccess(e);\n      // this => !(x && y) if this => !x\n      if (this.impliesNot(x, depth + 1)) return this.cacheNegativeImplicationSuccess(e);\n      // this => !(x && y) if this => !y\n      if (this.impliesNot(y, depth + 1)) return this.cacheNegativeImplicationSuccess(e);\n    }\n    if (e.kind === \"===\" || e.kind === \"==\") {\n      let [x, y] = e.args;\n      if (x instanceof AbstractValue) {\n        // this => !(x === null) && !(x === undefined), if this => x\n        // this => !(x == null) && !(x == undefined), if this => x\n        if ((y instanceof NullValue || y instanceof UndefinedValue) && this.implies(x, depth + 1))\n          return this.cacheNegativeImplicationSuccess(e);\n      } else {\n        invariant(y instanceof AbstractValue); // otherwise e would have been simplied\n        // this => !(null === y) && !(undefined === y), if this => y\n        // this => !(null == y) && !(undefined == y), if this => y\n        if ((x instanceof NullValue || x instanceof UndefinedValue) && this.implies(y, depth + 1))\n          return this.cacheNegativeImplicationSuccess(e);\n      }\n    }\n    if (e.kind === \"!\") {\n      let [x] = e.args;\n      if (this.implies(x, depth + 1)) return this.cacheNegativeImplicationSuccess(e);\n    }\n    if (this._failedNegativeImplications === undefined) this._failedNegativeImplications = new Set();\n    this._failedNegativeImplications.add(e);\n    return false;\n  }\n\n  cacheNegativeImplicationSuccess(e: AbstractValue): true {\n    if (this._impliedNegatives === undefined) this._impliedNegatives = new Set();\n    this._impliedNegatives.add(e);\n    return true;\n  }\n\n  isEmpty(): boolean {\n    return this._assumedConditions.size === 0;\n  }\n\n  getLength(): number {\n    return this._assumedConditions.size;\n  }\n\n  getAssumedConditions(): Set<AbstractValue> {\n    return this._assumedConditions;\n  }\n\n  // Refinement may temporarily make a target non-read-only, but marks the target as read-only at the end.\n  refineBaseConditons(\n    realm: Realm,\n    totalRefinements: number = 0,\n    refinementTarget: PathConditionsImplementation = this\n  ): void {\n    try {\n      if (realm.abstractValueImpliesMax > 0) return;\n      let total = totalRefinements;\n      let refine = (condition: AbstractValue) => {\n        let refinedCondition = realm.simplifyAndRefineAbstractCondition(condition);\n        if (refinedCondition !== condition) {\n          if (!refinedCondition.mightNotBeFalse()) throw new InfeasiblePathError();\n          if (refinedCondition instanceof AbstractValue) {\n            refinementTarget._readonly = false;\n            refinementTarget.add(refinedCondition);\n          }\n        }\n      };\n      if (this._baseConditions !== undefined) {\n        let savedBaseConditions = this._baseConditions;\n        try {\n          this._baseConditions = undefined;\n          for (let assumedCondition of savedBaseConditions._assumedConditions) {\n            if (assumedCondition.kind === \"||\") {\n              if (++total > 4) break;\n              refine(assumedCondition);\n            }\n          }\n        } finally {\n          this._baseConditions = savedBaseConditions;\n        }\n        savedBaseConditions.refineBaseConditons(realm, total, refinementTarget);\n      }\n    } finally {\n      refinementTarget._readonly = true;\n    }\n  }\n}\n\nexport class PathImplementation {\n  // this => val. A false value does not imply that !(this => val).\n  implies(condition: Value, depth: number = 0): boolean {\n    if (!condition.mightNotBeTrue()) return true; // any path implies true\n    if (!condition.mightNotBeFalse()) return false; // no path condition is false\n    invariant(condition instanceof AbstractValue);\n    return condition.$Realm.pathConditions.implies(condition, depth);\n  }\n\n  // this => !val. A false value does not imply that !(this => !val).\n  impliesNot(condition: Value, depth: number = 0): boolean {\n    if (!condition.mightNotBeFalse()) return true; // any path implies !false\n    if (!condition.mightNotBeTrue()) return false; // no path condition is false, so none can imply !true\n    invariant(condition instanceof AbstractValue);\n    return condition.$Realm.pathConditions.impliesNot(condition, depth);\n  }\n\n  withCondition<T>(condition: Value, evaluate: () => T): T {\n    let realm = condition.$Realm;\n    if (!condition.mightNotBeFalse()) {\n      if (realm.impliesCounterOverflowed) throw new InfeasiblePathError();\n      invariant(false, \"assuming that false equals true is asking for trouble\");\n    }\n    let savedPath = realm.pathConditions;\n    realm.pathConditions = new PathConditionsImplementation(savedPath);\n    try {\n      pushPathCondition(condition);\n      realm.pathConditions.refineBaseConditons(realm);\n      return evaluate();\n    } catch (e) {\n      if (e instanceof InfeasiblePathError) {\n        // if condition is true, one of the saved path conditions must be false\n        // since we have to assume that those conditions are true we now know that on this path, condition is false\n        realm.pathConditions = savedPath;\n        pushInversePathCondition(condition);\n      }\n      throw e;\n    } finally {\n      realm.pathConditions = savedPath;\n    }\n  }\n\n  withInverseCondition<T>(condition: Value, evaluate: () => T): T {\n    let realm = condition.$Realm;\n    if (!condition.mightNotBeTrue()) {\n      if (realm.impliesCounterOverflowed) throw new InfeasiblePathError();\n      invariant(false, \"assuming that false equals true is asking for trouble\");\n    }\n    let savedPath = realm.pathConditions;\n    realm.pathConditions = new PathConditionsImplementation(savedPath);\n    try {\n      pushInversePathCondition(condition);\n      realm.pathConditions.refineBaseConditons(realm);\n      return evaluate();\n    } catch (e) {\n      if (e instanceof InfeasiblePathError) {\n        // if condition is false, one of the saved path conditions must be false\n        // since we have to assume that those conditions are true we now know that on this path, condition is true\n        realm.pathConditions = savedPath;\n        pushPathCondition(condition);\n      }\n      throw e;\n    } finally {\n      realm.pathConditions = savedPath;\n    }\n  }\n\n  pushAndRefine(condition: Value): void {\n    let realm = condition.$Realm;\n    let savedPath = realm.pathConditions;\n    realm.pathConditions = new PathConditionsImplementation(savedPath);\n\n    pushPathCondition(condition);\n    realm.pathConditions.refineBaseConditons(realm);\n  }\n\n  pushInverseAndRefine(condition: Value): void {\n    let realm = condition.$Realm;\n    let savedPath = realm.pathConditions;\n    realm.pathConditions = new PathConditionsImplementation(savedPath);\n\n    pushInversePathCondition(condition);\n    realm.pathConditions.refineBaseConditons(realm);\n  }\n}\n\n// A path condition is an abstract value that must be true in this particular code path, so we want to assume as much\nfunction pushPathCondition(condition: Value): void {\n  let realm = condition.$Realm;\n  if (realm.pathConditions.isReadOnly()) realm.pathConditions = new PathConditionsImplementation(realm.pathConditions);\n  if (!condition.mightNotBeFalse()) {\n    if (realm.impliesCounterOverflowed) throw new InfeasiblePathError();\n    invariant(false, \"assuming that false equals true is asking for trouble\");\n  }\n  if (condition instanceof ConcreteValue) return;\n  if (!condition.mightNotBeTrue()) return;\n  invariant(condition instanceof AbstractValue);\n  if (condition.kind === \"&&\") {\n    let left = condition.args[0];\n    let right = condition.args[1];\n    invariant(left instanceof AbstractValue); // it is a mistake to create an abstract value when concrete value will do\n    pushPathCondition(left);\n    pushPathCondition(right);\n  } else if (condition.kind === \"===\") {\n    let [left, right] = condition.args;\n    if (right instanceof AbstractValue && right.kind === \"conditional\") [left, right] === [right, left];\n    if (left instanceof AbstractValue && left.kind === \"conditional\") {\n      let [cond, x, y] = left.args;\n      if (right instanceof ConcreteValue && x instanceof ConcreteValue && y instanceof ConcreteValue) {\n        if (right.equals(x) && !right.equals(y)) {\n          pushPathCondition(cond);\n        } else if (!right.equals(x) && right.equals(y)) {\n          pushInversePathCondition(cond);\n        }\n      }\n    }\n    realm.pathConditions.add(condition);\n  } else {\n    if (condition.kind === \"!=\" || condition.kind === \"==\") {\n      let left = condition.args[0];\n      let right = condition.args[1];\n      if (left instanceof ConcreteValue && right instanceof AbstractValue) [left, right] = [right, left];\n      if (left instanceof AbstractValue && (right instanceof UndefinedValue || right instanceof NullValue)) {\n        if (condition.kind === \"!=\") {\n          // x != null => x!==null && x!==undefined\n          pushPathCondition(left);\n          let leftNeNull = AbstractValue.createFromBinaryOp(realm, \"!==\", left, realm.intrinsics.null);\n          let leftNeUndefined = AbstractValue.createFromBinaryOp(realm, \"!==\", left, realm.intrinsics.undefined);\n          pushPathCondition(leftNeNull);\n          pushPathCondition(leftNeUndefined);\n        } else if (condition.kind === \"==\") {\n          // x == null => x===null || x===undefined\n          pushInversePathCondition(left);\n          let leftEqNull = AbstractValue.createFromBinaryOp(realm, \"===\", left, realm.intrinsics.null);\n          let leftEqUndefined = AbstractValue.createFromBinaryOp(realm, \"===\", left, realm.intrinsics.undefined);\n          let c;\n          if (!leftEqNull.mightNotBeFalse()) c = leftEqUndefined;\n          else if (!leftEqUndefined.mightNotBeFalse()) c = leftEqNull;\n          else c = AbstractValue.createFromLogicalOp(realm, \"||\", leftEqNull, leftEqUndefined);\n          pushPathCondition(c);\n        }\n        return;\n      }\n    }\n    realm.pathConditions.add(condition);\n  }\n}\n\n// An inverse path condition is an abstract value that must be false in this particular code path, so we want to assume as much\nfunction pushInversePathCondition(condition: Value): void {\n  let realm = condition.$Realm;\n  if (realm.pathConditions.isReadOnly()) realm.pathConditions = new PathConditionsImplementation(realm.pathConditions);\n  if (!condition.mightNotBeTrue()) {\n    if (realm.impliesCounterOverflowed) throw new InfeasiblePathError();\n    invariant(false, \"assuming that false equals true is asking for trouble\");\n  }\n  if (condition instanceof ConcreteValue) return;\n  invariant(condition instanceof AbstractValue);\n  if (condition.kind === \"||\") {\n    let left = condition.args[0];\n    let right = condition.args[1];\n    invariant(left instanceof AbstractValue); // it is a mistake to create an abstract value when concrete value will do\n    pushInversePathCondition(left);\n    if (right instanceof AbstractValue) right = realm.simplifyAndRefineAbstractCondition(right);\n    if (right.mightNotBeTrue()) pushInversePathCondition(right);\n  } else {\n    if (condition.kind === \"!=\" || condition.kind === \"==\") {\n      let left = condition.args[0];\n      let right = condition.args[1];\n      if (left instanceof ConcreteValue && right instanceof AbstractValue) [left, right] = [right, left];\n      if (left instanceof AbstractValue && (right instanceof UndefinedValue || right instanceof NullValue)) {\n        let op = condition.kind === \"!=\" ? \"===\" : \"!==\";\n        if (op === \"!==\") pushPathCondition(left);\n        else pushInversePathCondition(left);\n        let leftEqNull = AbstractValue.createFromBinaryOp(realm, op, left, realm.intrinsics.null);\n        if (leftEqNull.mightNotBeFalse()) pushPathCondition(leftEqNull);\n        let leftEqUndefined = AbstractValue.createFromBinaryOp(realm, op, left, realm.intrinsics.undefined);\n        if (leftEqUndefined.mightNotBeFalse()) pushPathCondition(leftEqUndefined);\n        return;\n      }\n    }\n    let inverseCondition = AbstractValue.createFromUnaryOp(realm, \"!\", condition, false, undefined, true, true);\n    pushPathCondition(inverseCondition);\n    if (inverseCondition instanceof AbstractValue) {\n      let simplifiedInverseCondition = realm.simplifyAndRefineAbstractCondition(inverseCondition);\n      if (!simplifiedInverseCondition.equals(inverseCondition)) pushPathCondition(simplifiedInverseCondition);\n    }\n  }\n}\n"],"file":"paths.js"}