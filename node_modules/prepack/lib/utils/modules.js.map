{"version":3,"sources":["../../src/utils/modules.js"],"names":["downgradeErrorsToWarnings","realm","f","savedHandler","errorHandler","handler","e","severity","handleError","ModuleTracer","Tracer","constructor","modules","logModules","evaluateForEffectsNesting","requireStack","requireSequence","uninitializedModuleIdsRequiredInEvaluateForEffects","Set","getStatistics","log","message","console","map","_","join","beginEvaluateForEffects","state","push","undefined","endEvaluateForEffects","effects","popped","pop","_callRequireAndRecord","moduleIdValue","performCall","length","value","moduleIds","has","recordModuleInitialized","_tryExtractDependencies","NullValue","UndefinedValue","ArrayValue","lengthValue","NumberValue","dependencies","logger","i","elementValue","tryQuery","intrinsics","detourCall","F","thisArgument","argumentsList","newTarget","requireInfo","getRequireInfo","moduleId","StringValue","res","$Realm","eagerlyRequireModuleDependencies","moduleDependencies","get","logError","toString","dependency","tryInitializeModule","getDefine","factoryFunction","FunctionValue","set","factoryFunctionDependencies","add","Modules","_define","Map","initializedModules","tracers","moduleTracer","statistics","SerializerStatistics","resolveInitializedModules","globalInitializedModulesMap","_getGlobalProperty","ObjectValue","properties","keys","property","descriptor","PropertyDescriptor","moduleValue","Value","mightHaveBeenDeleted","size","totalModules","name","active","$GlobalObject","_requireInfo","globalName","getGetModuleIdIfNodeIsRequireFunction","formalParameters","functions","scope","node","t","isIdentifier","callee","arguments","argument","isNumericLiteral","isStringLiteral","isMemberExpression","innerName","updateModuleId","newModuleId","getModuleId","memberExpression","object","scopedBinding","getBinding","path","dependencyIndex","Number","isInteger","kind","doesNotMatter","reference","Environment","ResolveBinding","$Environment","IsUnresolvableReference","referencedBase","base","referencedName","GlobalEnvironmentRecord","DeclarativeEnvironmentRecord","binding","bindings","initialized","assignToGlobal","identifier","callExpression","valueToNode","evaluateNodeForEffectsInGlobalEnv","applyEffects","err","FatalError","initializeMoreModules","modulesToInitialize","count","result"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { GlobalEnvironmentRecord, DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport { FatalError } from \"../errors.js\";\nimport { Realm, Tracer } from \"../realm.js\";\nimport type { Effects } from \"../realm.js\";\nimport { Get } from \"../methods/index.js\";\nimport { Environment } from \"../singletons.js\";\nimport {\n  Value,\n  FunctionValue,\n  ObjectValue,\n  NumberValue,\n  StringValue,\n  ArrayValue,\n  UndefinedValue,\n  NullValue,\n} from \"../values/index.js\";\nimport * as t from \"@babel/types\";\nimport type {\n  BabelNodeIdentifier,\n  BabelNodeLVal,\n  BabelNodeCallExpression,\n  BabelNodeNumericLiteral,\n  BabelNodeStringLiteral,\n  BabelNodeMemberExpression,\n} from \"@babel/types\";\nimport invariant from \"../invariant.js\";\nimport { Logger } from \"./logger.js\";\nimport { SerializerStatistics } from \"../serializer/statistics.js\";\nimport { PropertyDescriptor } from \"../descriptors.js\";\n\nfunction downgradeErrorsToWarnings(realm: Realm, f: () => any) {\n  let savedHandler = realm.errorHandler;\n  function handler(e) {\n    e.severity = \"Warning\";\n    realm.errorHandler = savedHandler;\n    try {\n      return realm.handleError(e);\n    } finally {\n      realm.errorHandler = handler;\n    }\n  }\n  realm.errorHandler = handler;\n  try {\n    return f();\n  } finally {\n    realm.errorHandler = savedHandler;\n  }\n}\n\nexport class ModuleTracer extends Tracer {\n  constructor(modules: Modules, logModules: boolean) {\n    super();\n    this.modules = modules;\n    this.evaluateForEffectsNesting = 0;\n    this.requireStack = [];\n    this.requireSequence = [];\n    this.logModules = logModules;\n    this.uninitializedModuleIdsRequiredInEvaluateForEffects = new Set();\n  }\n\n  modules: Modules;\n  evaluateForEffectsNesting: number;\n  requireStack: Array<number | string | void>;\n  requireSequence: Array<number | string>;\n  uninitializedModuleIdsRequiredInEvaluateForEffects: Set<number | string>;\n  // We can't say that a module has been initialized if it was initialized in a\n  // evaluate for effects context until we know the effects are applied.\n  logModules: boolean;\n\n  getStatistics(): SerializerStatistics {\n    return this.modules.getStatistics();\n  }\n\n  log(message: string): void {\n    if (this.logModules) console.log(`[modules] ${this.requireStack.map(_ => \"  \").join(\"\")}${message}`);\n  }\n\n  beginEvaluateForEffects(state: any): void {\n    if (state !== this) {\n      this.log(\">evaluate for effects\");\n      this.evaluateForEffectsNesting++;\n      this.requireStack.push(undefined);\n    }\n  }\n\n  endEvaluateForEffects(state: any, effects: void | Effects): void {\n    if (state !== this) {\n      let popped = this.requireStack.pop();\n      invariant(popped === undefined);\n      this.evaluateForEffectsNesting--;\n      this.log(\"<evaluate for effects\");\n    }\n  }\n\n  _callRequireAndRecord(moduleIdValue: number | string, performCall: () => Value): void | Value {\n    if (this.requireStack.length === 0 || this.requireStack[this.requireStack.length - 1] !== moduleIdValue) {\n      this.requireStack.push(moduleIdValue);\n      try {\n        let value = performCall();\n        if (this.modules.moduleIds.has(moduleIdValue)) this.modules.recordModuleInitialized(moduleIdValue, value);\n        return value;\n      } finally {\n        invariant(this.requireStack.pop() === moduleIdValue);\n      }\n    }\n    return undefined;\n  }\n\n  _tryExtractDependencies(value: void | Value): void | Array<Value> {\n    if (value === undefined || value instanceof NullValue || value instanceof UndefinedValue) return [];\n    if (value instanceof ArrayValue) {\n      const realm = this.modules.realm;\n      const lengthValue = Get(realm, value, \"length\");\n      if (lengthValue instanceof NumberValue) {\n        const dependencies = [];\n        const logger = this.modules.logger;\n        for (let i = 0; i < lengthValue.value; i++) {\n          const elementValue = logger.tryQuery(\n            () => Get(realm, ((value: any): ArrayValue), \"\" + i),\n            realm.intrinsics.undefined\n          );\n          dependencies.push(elementValue);\n        }\n        return dependencies;\n      }\n    }\n    return undefined;\n  }\n\n  detourCall(\n    F: FunctionValue,\n    thisArgument: void | Value,\n    argumentsList: Array<Value>,\n    newTarget: void | ObjectValue,\n    performCall: () => Value\n  ): void | Value {\n    let requireInfo = this.modules.getRequireInfo();\n    if (requireInfo !== undefined && F === requireInfo.value && argumentsList.length === 1) {\n      // Here, we handle calls of the form\n      //   require(42)\n\n      let moduleId = argumentsList[0];\n      let moduleIdValue;\n      // Do some sanity checks and request require(...) calls with bad arguments\n      if (moduleId instanceof NumberValue || moduleId instanceof StringValue) moduleIdValue = moduleId.value;\n      else return performCall();\n      // call require(...); this might cause calls to the define function\n      let res = this._callRequireAndRecord(moduleIdValue, performCall);\n      if (F.$Realm.eagerlyRequireModuleDependencies) {\n        // all dependencies of the required module should now be known\n        let dependencies = this.modules.moduleDependencies.get(moduleIdValue);\n        if (dependencies === undefined)\n          this.modules.logger.logError(moduleId, `Cannot resolve module dependencies for ${moduleIdValue.toString()}.`);\n        else\n          for (let dependency of dependencies) {\n            // We'll try to initialize module dependency on a best-effort basis,\n            // ignoring any errors. Note that tryInitializeModule applies effects on success.\n            if (dependency instanceof NumberValue || dependency instanceof StringValue)\n              this.modules.tryInitializeModule(dependency.value, `Eager initialization of module ${dependency.value}`);\n          }\n      }\n      return res;\n    } else if (F === this.modules.getDefine()) {\n      // Here, we handle calls of the form\n      //   __d(factoryFunction, moduleId, dependencyArray)\n\n      let moduleId = argumentsList[1];\n      if (moduleId instanceof NumberValue || moduleId instanceof StringValue) {\n        let moduleIdValue = moduleId.value;\n        let factoryFunction = argumentsList[0];\n        if (factoryFunction instanceof FunctionValue) {\n          let dependencies = this._tryExtractDependencies(argumentsList[2]);\n          if (dependencies !== undefined) {\n            this.modules.moduleDependencies.set(moduleIdValue, dependencies);\n            this.modules.factoryFunctionDependencies.set(factoryFunction, dependencies);\n          } else\n            this.modules.logger.logError(\n              argumentsList[2],\n              \"Third argument to define function is present but not a concrete array.\"\n            );\n        } else\n          this.modules.logger.logError(factoryFunction, \"First argument to define function is not a function value.\");\n\n        this.modules.moduleIds.add(moduleIdValue);\n      } else\n        this.modules.logger.logError(moduleId, \"Second argument to define function is not a number or string value.\");\n    }\n    return undefined;\n  }\n}\n\nexport type RequireInfo = {\n  value: FunctionValue,\n  globalName: string,\n};\n\nexport class Modules {\n  constructor(realm: Realm, logger: Logger, logModules: boolean) {\n    this.realm = realm;\n    this.logger = logger;\n    this._define = realm.intrinsics.undefined;\n    this.factoryFunctionDependencies = new Map();\n    this.moduleDependencies = new Map();\n    this.moduleIds = new Set();\n    this.initializedModules = new Map();\n    realm.tracers.push((this.moduleTracer = new ModuleTracer(this, logModules)));\n  }\n\n  realm: Realm;\n  logger: Logger;\n  _requireInfo: void | RequireInfo;\n  _define: Value;\n  factoryFunctionDependencies: Map<FunctionValue, Array<Value>>;\n  moduleDependencies: Map<number | string, Array<Value>>;\n  moduleIds: Set<number | string>;\n  initializedModules: Map<number | string, Value>;\n  active: boolean;\n  moduleTracer: ModuleTracer;\n\n  getStatistics(): SerializerStatistics {\n    invariant(this.realm.statistics instanceof SerializerStatistics, \"serialization requires SerializerStatistics\");\n    return this.realm.statistics;\n  }\n\n  resolveInitializedModules(): void {\n    let globalInitializedModulesMap = this._getGlobalProperty(\"__initializedModules\");\n    invariant(globalInitializedModulesMap instanceof ObjectValue);\n    for (let moduleId of globalInitializedModulesMap.properties.keys()) {\n      let property = globalInitializedModulesMap.properties.get(moduleId);\n      invariant(property);\n      if (property.descriptor instanceof PropertyDescriptor) {\n        let moduleValue = property.descriptor && property.descriptor.value;\n        if (moduleValue instanceof Value && !moduleValue.mightHaveBeenDeleted()) {\n          this.initializedModules.set(moduleId, moduleValue);\n        }\n      }\n    }\n    this.getStatistics().initializedModules = this.initializedModules.size;\n    this.getStatistics().totalModules = this.moduleIds.size;\n  }\n\n  _getGlobalProperty(name: string): Value {\n    if (this.active) return this.realm.intrinsics.undefined;\n    this.active = true;\n    try {\n      let realm = this.realm;\n      return this.logger.tryQuery(() => Get(realm, realm.$GlobalObject, name), realm.intrinsics.undefined);\n    } finally {\n      this.active = false;\n    }\n  }\n\n  getRequireInfo(): void | RequireInfo {\n    if (this._requireInfo === undefined)\n      for (let globalName of [\"require\", \"__r\"]) {\n        let value = this._getGlobalProperty(globalName);\n        if (value instanceof FunctionValue) {\n          this._requireInfo = { value, globalName };\n          break;\n        }\n      }\n    return this._requireInfo;\n  }\n\n  getDefine(): Value {\n    if (!(this._define instanceof FunctionValue)) this._define = this._getGlobalProperty(\"__d\");\n    return this._define;\n  }\n\n  // Returns a function that checks if a call node represents a call to a\n  // known require function, and if so, what module id that call indicates.\n  // A known require function call is either of the form\n  //   ... require(42) ...\n  // where require resolves to the global require function, or\n  //   factoryFunction(, require, , , dependencies) {\n  //     ...\n  //       ... require(dependencies[3]) ...\n  // where factoryFunction and dependencies were announced as part of the\n  // global code execution via a global module declaration call such as\n  //   global.__d(factoryFunction, , [0,2,4,6,8])\n  getGetModuleIdIfNodeIsRequireFunction(\n    formalParameters: Array<BabelNodeLVal>,\n    functions: Array<FunctionValue>\n  ): (scope: any, node: BabelNodeCallExpression) => void | number | string {\n    let realm = this.realm;\n    let logger = this.logger;\n    let modules = this;\n    return (scope: any, node: BabelNodeCallExpression) => {\n      // Are we calling a function that has a single name and a single argument?\n      if (!t.isIdentifier(node.callee) || node.arguments.length !== 1) return undefined;\n      let argument = node.arguments[0];\n      if (!argument) return undefined;\n\n      if (!t.isNumericLiteral(argument) && !t.isStringLiteral(argument) && !t.isMemberExpression(argument))\n        return undefined;\n\n      invariant(node.callee);\n      let innerName = ((node.callee: any): BabelNodeIdentifier).name;\n\n      let moduleId;\n\n      // Helper function used to give up if we ever come up with different module ids for different functions\n      let updateModuleId = newModuleId => {\n        if (moduleId !== undefined && moduleId !== newModuleId) return false;\n        moduleId = newModuleId;\n        return true;\n      };\n\n      // Helper function that retrieves module id from call argument, possibly chasing dependency array indirection\n      const getModuleId = (dependencies?: Array<Value>): void | number | string => {\n        if (t.isMemberExpression(argument)) {\n          if (dependencies !== undefined) {\n            let memberExpression = ((argument: any): BabelNodeMemberExpression);\n            if (t.isIdentifier(memberExpression.object)) {\n              let scopedBinding = scope.getBinding(((memberExpression.object: any): BabelNodeIdentifier).name);\n              if (scopedBinding && formalParameters[4] === scopedBinding.path.node) {\n                if (t.isNumericLiteral(memberExpression.property)) {\n                  let dependencyIndex = memberExpression.property.value;\n                  if (\n                    Number.isInteger(dependencyIndex) &&\n                    dependencyIndex >= 0 &&\n                    dependencyIndex < dependencies.length\n                  ) {\n                    let dependency = dependencies[dependencyIndex];\n                    if (dependency instanceof NumberValue || dependency instanceof StringValue) return dependency.value;\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          return ((argument: any): BabelNodeNumericLiteral | BabelNodeStringLiteral).value;\n        }\n      };\n\n      // Let's consider each of the function instances (closures for the same code)\n      for (let f of functions) {\n        // 1. Let's check if we have a match for a factory function like\n        //      factoryFunction(, require, , , [dependencies])\n        //    which is used with the Metro bundler\n        let scopedBinding = scope.getBinding(innerName);\n        if (scopedBinding) {\n          let dependencies = modules.factoryFunctionDependencies.get(f);\n          if (dependencies !== undefined && formalParameters[1] === scopedBinding.path.node) {\n            invariant(scopedBinding.kind === \"param\");\n            let newModuleId = getModuleId(dependencies);\n            if (newModuleId !== undefined && !updateModuleId(newModuleId)) return undefined;\n            continue;\n          }\n\n          // The name binds to some local entity, but nothing we'd know what exactly it is\n          return undefined;\n        }\n\n        // 2. Let's check if we can resolve the called function just by looking at the\n        //    function instance environment.\n        //    TODO: We should not do this if the current node is in a nested function!\n\n        // We won't have a dependency map here, so this only works for literal arguments.\n        if (!t.isNumericLiteral(argument) && !t.isStringLiteral(argument)) return undefined;\n\n        let doesNotMatter = true;\n        let reference = logger.tryQuery(\n          () => Environment.ResolveBinding(realm, innerName, doesNotMatter, f.$Environment),\n          undefined\n        );\n        if (reference === undefined) {\n          // We couldn't resolve as we came across some behavior that we cannot deal with abstractly\n          return undefined;\n        }\n        if (Environment.IsUnresolvableReference(realm, reference)) return undefined;\n        let referencedBase = reference.base;\n        let referencedName: string = (reference.referencedName: any);\n        if (typeof referencedName !== \"string\") return undefined;\n        let value;\n        if (reference.base instanceof GlobalEnvironmentRecord) {\n          value = logger.tryQuery(() => Get(realm, realm.$GlobalObject, innerName), realm.intrinsics.undefined);\n        } else {\n          invariant(referencedBase instanceof DeclarativeEnvironmentRecord);\n          let binding = referencedBase.bindings[referencedName];\n          if (!binding.initialized) return undefined;\n          value = binding.value;\n        }\n        let requireInfo = modules.getRequireInfo();\n        if (requireInfo === undefined || value !== requireInfo.value) return undefined;\n        const newModuleId = getModuleId();\n        invariant(newModuleId !== undefined);\n        if (!updateModuleId(newModuleId)) return undefined;\n      }\n\n      return moduleId;\n    };\n  }\n\n  recordModuleInitialized(moduleId: number | string, value: Value): void {\n    this.realm.assignToGlobal(\n      t.memberExpression(\n        t.memberExpression(t.identifier(\"global\"), t.identifier(\"__initializedModules\")),\n        t.identifier(\"\" + moduleId)\n      ),\n      value\n    );\n  }\n\n  tryInitializeModule(moduleId: number | string, message: string): void | Effects {\n    let realm = this.realm;\n    let requireInfo = this.getRequireInfo();\n    if (requireInfo === undefined) return undefined;\n    return downgradeErrorsToWarnings(realm, () => {\n      try {\n        let node = t.callExpression(t.identifier(requireInfo.globalName), [t.valueToNode(moduleId)]);\n\n        let effects = realm.evaluateNodeForEffectsInGlobalEnv(node);\n        realm.applyEffects(effects, message);\n        return effects;\n      } catch (err) {\n        if (err instanceof FatalError) return undefined;\n        else throw err;\n      }\n    });\n  }\n\n  initializeMoreModules(modulesToInitialize: Set<string> | \"ALL\"): void {\n    // partially evaluate all factory methods by calling require\n    let count = 0;\n    for (let moduleId of this.moduleIds) {\n      if (modulesToInitialize !== \"ALL\" && !modulesToInitialize.has(\"\" + moduleId)) continue;\n      if (this.initializedModules.has(moduleId)) continue;\n      let effects = this.tryInitializeModule(moduleId, `Speculative initialization of module ${moduleId}`);\n      if (effects === undefined) continue;\n      let result = effects.result;\n      if (!(result instanceof Value)) continue; // module might throw\n      count++;\n      this.initializedModules.set(moduleId, result);\n    }\n    if (count > 0) console.log(`=== speculatively initialized ${count} additional modules`);\n  }\n}\n"],"file":"modules.js"}