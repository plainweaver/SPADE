{"version":3,"sources":["../../src/utils/SourceMapManager.js"],"names":["SourceMapManager","constructor","buckRoot","sourceMaps","undefined","Error","_buckRoot","length","slice","map","sourceMapContents","_sourcemapCommonPrefix","_sourcemapMapDifference","originalSourcePaths","mapPaths","parsed","JSON","parse","section","sections","source","sources","push","_getAbsoluteSourcePath","filePath","_stripEmptyStringBookends","split","originalSourceCommonPrefix","_findCommonPrefix","originalSourceCPElements","mapCommonPrefix","mapCPElements","_findMapDifference","pathToInput","pathToSource","fullPath","pop","steps","step","paths","divergenceIndex","allPathsMatch","maxDivergenceIndex","Math","max","path","entry","join","commonPrefix","mapPrefix","mapPrefixUniqueElements","replace","mapDifference","i","concat","shift","relativeToAbsolute","absolute","dirRoot","separator","absoluteToRelative","relative"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { SourceFile } from \"../types.js\";\nimport invariant from \"../invariant.js\";\n\n/**\n * Sourcemap paths can come in one of two formats:\n *     - Relative: The paths include `../` and can be followed from the sourcemap's location\n *         to arrive at the original source's location. In this format, path conversion\n *         requires two different prefixes (MapDifference and CommonPrefix) that must be\n *         discovered from the input paths.\n *     - Common Directory: The paths take the format of an absolute path (`/foo/bar`) and\n *         assume there is a common prefix to the path that, when added, will make the path an\n *         valid absolute path. This prefix is passed in as the `buckRoot` argument.\n *     Example:\n *         In a directory structure with /A/B/map.js and /A/C/original.js,\n *         the sourcemaps would have the following path structures:\n *           - Relative: ../C/original.js, with `CP` = /A and 'MD' = ../\n *           - Common Directory: /C/original.js, with `buckRoot` = /A\n */\nexport class SourceMapManager {\n  constructor(buckRoot?: string, sourceMaps?: Array<SourceFile>) {\n    // Use presence of buck root argument to indicate which path format sourcemap prefixes take on.\n    if (buckRoot !== undefined) {\n      if (sourceMaps === undefined) {\n        throw new Error(\"Invalid input: Can't provide a sourcemap directory root without having sourcemaps present\");\n      }\n      this._buckRoot = buckRoot;\n      if (this._buckRoot[this._buckRoot.length - 1] === \"/\") {\n        // Remove trailing slash to prepare for prepending to internal paths.\n        this._buckRoot = this._buckRoot.slice(0, -1);\n      }\n    } else {\n      // If sourcemaps don't exist, set prefixes to undefined and break.\n      if (sourceMaps && sourceMaps.length > 0) {\n        for (let map of sourceMaps) {\n          if (map.sourceMapContents === undefined || map.sourceMapContents === \"\") {\n            this._sourcemapCommonPrefix = undefined;\n            this._sourcemapMapDifference = undefined;\n            return;\n          }\n        }\n      } else {\n        this._sourcemapCommonPrefix = undefined;\n        this._sourcemapMapDifference = undefined;\n        return;\n      }\n\n      // Extract common prefix and map difference\n      let originalSourcePaths = [];\n      let mapPaths = [];\n      for (let map of sourceMaps) {\n        invariant(map.sourceMapContents !== undefined); // Checked above.\n        let parsed = JSON.parse(map.sourceMapContents);\n        // Two formats for sourcemaps exist.\n        if (\"sections\" in parsed) {\n          for (let section of parsed.sections) {\n            for (let source of section.map.sources) {\n              originalSourcePaths.push(this._getAbsoluteSourcePath(map.filePath, source));\n            }\n          }\n        } else {\n          for (let source of parsed.sources) {\n            originalSourcePaths.push(this._getAbsoluteSourcePath(map.filePath, source));\n          }\n        }\n        mapPaths.push(this._stripEmptyStringBookends(map.filePath.split(\"/\")));\n      }\n\n      let originalSourceCommonPrefix = this._findCommonPrefix(originalSourcePaths);\n      let originalSourceCPElements = this._stripEmptyStringBookends(originalSourceCommonPrefix.split(\"/\"));\n      let mapCommonPrefix = this._findCommonPrefix(mapPaths);\n      let mapCPElements = this._stripEmptyStringBookends(mapCommonPrefix.split(\"/\"));\n\n      this._sourcemapCommonPrefix = this._findCommonPrefix([originalSourceCPElements, mapCPElements]);\n      this._sourcemapMapDifference = this._findMapDifference(this._sourcemapCommonPrefix, mapCommonPrefix);\n    }\n  }\n\n  // Prefixes used to translate between relative paths stored in AST nodes and absolute paths given to IDE.\n  _sourcemapCommonPrefix: void | string; // For paths relative to map location. (Used in Babel format)\n  _sourcemapMapDifference: void | string; // For paths relative to map location. (Used in Babel format)\n  _buckRoot: void | string; // For paths relative to directory root. (Used in Buck format)\n\n  /**\n   * Assumes that input file and sourcemap are in the same directory.\n   * Assumes pathToInput is an absolute path and pathToSource is relative.\n   * Uses pathToSource to find absolute path of original source file.\n   */\n  _getAbsoluteSourcePath(pathToInput: string, pathToSource: string): Array<string> {\n    // pathToInput is an absolute path to the file being prepacked.\n    let fullPath = this._stripEmptyStringBookends(pathToInput.split(\"/\"));\n    // Remove last entry because it is the filename, while we want the parent directory of the input file.\n    fullPath.pop();\n\n    // Traverse the path to the source file.\n    let steps = pathToSource.split(\"/\");\n    for (let step of steps) {\n      switch (step) {\n        case \".\":\n          break;\n        case \"..\":\n          fullPath.pop();\n          break;\n        default:\n          fullPath.push(step);\n          break;\n      }\n    }\n    return fullPath;\n  }\n\n  /**\n   * Finds the longest possible prefix common to all input paths.\n   * Input paths must be absolute.\n   * Input is nested array because each path must be separated into elements.\n   */\n  _findCommonPrefix(paths: Array<Array<string>>): string {\n    // Find the point at which the paths diverge.\n    let divergenceIndex = 0;\n    let allPathsMatch = true;\n    let maxDivergenceIndex = Math.max(...paths.map(path => path.length));\n\n    while (allPathsMatch && divergenceIndex < maxDivergenceIndex) {\n      let entry = paths[0][divergenceIndex]; // Arbitrary choice of 0th path, since we're checking if all entires match.\n      for (let path of paths) {\n        if (path[divergenceIndex] !== entry) {\n          allPathsMatch = false;\n          break;\n        }\n      }\n      if (allPathsMatch) divergenceIndex += 1;\n    }\n    // Edge case: if there's only one path, it will match itself, including the filename at the end.\n    // For 2+ paths, even if they all share a prefix, the filenames will not match, so this is not needed.\n    if (paths.length === 1) divergenceIndex -= 1;\n\n    // Concatenate prefix into string that's bookended by slashes for use as an absolute path prefix.\n    return `/${paths[0].slice(0, divergenceIndex).join(\"/\")}/`;\n  }\n\n  /**\n   * Finds the path that must be followed to arrive at the directory of the\n   * common prefix from the sourcemap.\n   */\n  _findMapDifference(commonPrefix: string, mapPrefix: string): string {\n    // Find difference in path between the map's location and the common prefix.\n    let mapPrefixUniqueElements = this._stripEmptyStringBookends(mapPrefix.replace(commonPrefix, \"\").split(\"/\"));\n    let mapDifference = \"\";\n    for (let i = 0; i < mapPrefixUniqueElements.length; i++) {\n      mapDifference = mapDifference.concat(\"../\");\n    }\n    return mapDifference;\n  }\n\n  /**\n   *  Takes in [\"\", \"foo\", \"bar\", \"\"] and returns [\"foo\", \"bar\"]\n   */\n  _stripEmptyStringBookends(path: Array<string>): Array<string> {\n    if (path[0] === \"\") path.shift();\n    if (path[path.length - 1] === \"\") path.pop();\n    return path;\n  }\n\n  /**\n   * Used by DebugAdapter to convert relative paths (used internally in debugging/Prepack engine)\n   * into absolute paths (used by debugging UI/IDE).\n   */\n  relativeToAbsolute(path: string): string {\n    let absolute;\n    if (this._buckRoot !== undefined) {\n      let dirRoot = this._buckRoot;\n      if (\n        // If the \"relative\" path is actually absolute, then don't prepend anything.\n        this._stripEmptyStringBookends(path.split(\"/\"))[0] ===\n        this._stripEmptyStringBookends(this._buckRoot.split(\"/\"))[0]\n      ) {\n        absolute = path;\n      } else {\n        let separator = path[0] === \"/\" ? \"\" : \"/\";\n        absolute = dirRoot + separator + path;\n      }\n    } else {\n      if (this._sourcemapCommonPrefix !== undefined && this._sourcemapMapDifference !== undefined) {\n        absolute = path.replace(this._sourcemapMapDifference, \"\");\n        invariant(this._sourcemapCommonPrefix !== undefined);\n        absolute = this._sourcemapCommonPrefix + absolute;\n      } else {\n        absolute = path;\n      }\n    }\n    return absolute;\n  }\n\n  /**\n   * Used by DebugAdapter to convert absolute paths (used by debugging UI/IDE)\n   * into relative paths (used internally in debugging/Prepack engine).\n   */\n  absoluteToRelative(path: string): string {\n    let relative;\n    if (this._buckRoot !== undefined) {\n      relative = path.replace(this._buckRoot, \"\");\n    } else {\n      if (this._sourcemapCommonPrefix !== undefined && this._sourcemapMapDifference !== undefined) {\n        relative = path.replace(this._sourcemapCommonPrefix, \"\");\n        invariant(this._sourcemapMapDifference !== undefined);\n        relative = this._sourcemapMapDifference + relative;\n      } else {\n        relative = path;\n      }\n    }\n    return relative;\n  }\n}\n"],"file":"SourceMapManager.js"}