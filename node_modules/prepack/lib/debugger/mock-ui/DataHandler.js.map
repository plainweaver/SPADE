{"version":3,"sources":["../../../src/debugger/mock-ui/DataHandler.js"],"names":["TWO_CRLF","DataHandler","constructor","_rawData","Buffer","_contentLength","handleData","data","messageProcessor","concat","length","byteLength","message","toString","slice","idx","indexOf","header","lines","split","i","pair","parseInt","isNaN"],"mappings":";;;;;;;AAAA;;;;;;;;;AASA;AAEA;AACA,MAAMA,QAAQ,GAAG,UAAjB;;AAEO,MAAMC,WAAN,CAAkB;AACvBC,EAAAA,WAAW,GAAG;AACZ,SAAKC,QAAL,GAAgB,IAAIC,MAAJ,CAAW,CAAX,CAAhB;AACA,SAAKC,cAAL,GAAsB,CAAC,CAAvB;AACD;;AAIDC,EAAAA,UAAU,CAACC,IAAD,EAAeC,gBAAf,EAAkE;AAC1E,SAAKL,QAAL,GAAgBC,MAAM,CAACK,MAAP,CAAc,CAAC,KAAKN,QAAN,EAAgBI,IAAhB,CAAd,CAAhB,CAD0E,CAE1E;;AACA,WAAO,KAAKJ,QAAL,CAAcO,MAAd,GAAuB,CAA9B,EAAiC;AAC/B;AACA,UAAI,KAAKL,cAAL,IAAuB,CAA3B,EAA8B;AAC5B;AACA,YAAI,KAAKF,QAAL,CAAcQ,UAAd,IAA4B,KAAKN,cAArC,EAAqD;AACnD;AACA,cAAIO,OAAO,GAAG,KAAKT,QAAL,CAAcU,QAAd,CAAuB,MAAvB,EAA+B,CAA/B,EAAkC,KAAKR,cAAvC,CAAd,CAFmD,CAGnD;;;AACA,eAAKF,QAAL,GAAgB,KAAKA,QAAL,CAAcW,KAAd,CAAoB,KAAKT,cAAzB,CAAhB,CAJmD,CAKnD;;AACA,eAAKA,cAAL,GAAsB,CAAC,CAAvB,CANmD,CAOnD;;AACAG,UAAAA,gBAAgB,CAACI,OAAD,CAAhB;AACA,mBATmD,CASzC;AACX;AACF,OAbD,MAaO;AACL;AACA,YAAIG,GAAG,GAAG,KAAKZ,QAAL,CAAca,OAAd,CAAsBhB,QAAtB,CAAV;;AACA,YAAIe,GAAG,KAAK,CAAC,CAAb,EAAgB;AACd,cAAIE,MAAM,GAAG,KAAKd,QAAL,CAAcU,QAAd,CAAuB,MAAvB,EAA+B,CAA/B,EAAkCE,GAAlC,CAAb;;AACA,cAAIG,KAAK,GAAGD,MAAM,CAACE,KAAP,CAAa,MAAb,CAAZ;;AACA,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACR,MAA1B,EAAkCU,CAAC,EAAnC,EAAuC;AACrC,gBAAIC,IAAI,GAAGH,KAAK,CAACE,CAAD,CAAL,CAASD,KAAT,CAAe,KAAf,CAAX;;AACA,gBAAIE,IAAI,CAAC,CAAD,CAAJ,KAAY,gBAAhB,EAAkC;AAChC,mBAAKhB,cAAL,GAAsBiB,QAAQ,CAACD,IAAI,CAAC,CAAD,CAAL,EAAU,EAAV,CAA9B,CADgC,CAEhC;;AACA,kBAAIE,KAAK,CAAC,KAAKlB,cAAN,CAAT,EAAgC,KAAKA,cAAL,GAAsB,CAAC,CAAvB;AACjC;AACF;;AACD,eAAKF,QAAL,GAAgB,KAAKA,QAAL,CAAcW,KAAd,CAAoBC,GAAG,GAAGf,QAAQ,CAACU,MAAnC,CAAhB;AACA;AACD,SAhBI,CAiBL;;AACD;;AACD;AACD;AACF;;AA/CsB","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict */\n\n//separator for messages according to the protocol\nconst TWO_CRLF = \"\\r\\n\\r\\n\";\n\nexport class DataHandler {\n  constructor() {\n    this._rawData = new Buffer(0);\n    this._contentLength = -1;\n  }\n  _rawData: Buffer;\n  _contentLength: number;\n\n  handleData(data: Buffer, messageProcessor: (message: string) => void): void {\n    this._rawData = Buffer.concat([this._rawData, data]);\n    // the following code parses a message according to the protocol.\n    while (this._rawData.length > 0) {\n      // if we know what length we are expecting\n      if (this._contentLength >= 0) {\n        // we have enough data to check for the expected message\n        if (this._rawData.byteLength >= this._contentLength) {\n          // first get the expected message\n          let message = this._rawData.toString(\"utf8\", 0, this._contentLength);\n          // reduce the buffer by the message we got\n          this._rawData = this._rawData.slice(this._contentLength);\n          // reset the content length to ensure it is extracted for the next message\n          this._contentLength = -1;\n          // process the message\n          messageProcessor(message);\n          continue; // there may be more complete messages to process\n        }\n      } else {\n        // if we don't know the length to expect, we need to extract it first\n        let idx = this._rawData.indexOf(TWO_CRLF);\n        if (idx !== -1) {\n          let header = this._rawData.toString(\"utf8\", 0, idx);\n          let lines = header.split(\"\\r\\n\");\n          for (let i = 0; i < lines.length; i++) {\n            let pair = lines[i].split(/: +/);\n            if (pair[0] === \"Content-Length\") {\n              this._contentLength = parseInt(pair[1], 10);\n              // reset the contentlength if it is invalid\n              if (isNaN(this._contentLength)) this._contentLength = -1;\n            }\n          }\n          this._rawData = this._rawData.slice(idx + TWO_CRLF.length);\n          continue;\n        }\n        // if we don't find the length we fall through and break\n      }\n      break;\n    }\n  }\n}\n"],"file":"DataHandler.js"}