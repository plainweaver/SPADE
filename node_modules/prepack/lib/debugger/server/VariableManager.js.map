{"version":3,"sources":["../../../src/debugger/server/VariableManager.js"],"names":["VariableManager","constructor","realm","_containerCache","Map","_referenceMap","ReferenceMap","_realm","getReferenceForValue","value","cachedRef","get","undefined","varRef","add","set","getVariablesByReference","reference","container","LexicalEnvironment","_getVariablesFromEnvRecord","environmentRecord","ObjectValue","_getVariablesFromObject","AbstractValue","_getAbstractValueContent","object","variables","names","properties","keys","name","binding","descriptor","Value","variable","_getVariableFromValue","push","kindVar","kind","variablesReference","contents","argCount","arg","args","envRecord","DeclarativeEnvironmentRecord","_getVariablesFromDeclarativeEnv","ObjectEnvironmentRecord","AbstractObjectValue","GlobalEnvironmentRecord","declVars","$DeclarativeRecord","objVars","$ObjectRecord","concat","env","bindings","ConcreteValue","_getVariableFromConcreteValue","_getVariableFromAbstractValue","_getAbstractValueDisplay","intrinsicName","startsWith","types","getType","PrimitiveValue","toDisplayString","getKind","evaluate","frameId","expression","evalRealm","isDirect","isStrict","contextStack","length","DebuggerError","stackIndex","context","evalString","StringValue","Functions","PerformEval","varInfo","result","displayValue","type","e","clean"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Variable, EvaluateResult } from \"./../common/types.js\";\nimport { ReferenceMap } from \"./ReferenceMap.js\";\nimport {\n  LexicalEnvironment,\n  EnvironmentRecord,\n  DeclarativeEnvironmentRecord,\n  ObjectEnvironmentRecord,\n  GlobalEnvironmentRecord,\n} from \"./../../environment.js\";\nimport {\n  Value,\n  ConcreteValue,\n  PrimitiveValue,\n  ObjectValue,\n  AbstractObjectValue,\n  AbstractValue,\n  StringValue,\n} from \"./../../values/index.js\";\nimport invariant from \"./../common/invariant.js\";\nimport type { Realm } from \"./../../realm.js\";\nimport { IsDataDescriptor } from \"./../../methods/is.js\";\nimport { DebuggerError } from \"./../common/DebuggerError.js\";\nimport { Functions } from \"./../../singletons.js\";\n\ntype VariableContainer = LexicalEnvironment | ObjectValue | AbstractValue;\n\n// This class manages the handling of variable requests in the debugger\n// The DebugProtocol specifies collections of variables are to be fetched using a\n// unique reference ID called a variablesReference. This class can generate new\n// variablesReferences to pass to the UI and then perform lookups for those\n// variablesReferences when they are requested.\nexport class VariableManager {\n  constructor(realm: Realm) {\n    this._containerCache = new Map();\n    this._referenceMap = new ReferenceMap();\n    this._realm = realm;\n  }\n  // cache for created references\n  _containerCache: Map<VariableContainer, number>;\n  // map for looking up references\n  _referenceMap: ReferenceMap<VariableContainer>;\n  _realm: Realm;\n\n  // Given a container, either returns a cached reference for that container if\n  // it exists or return a new reference\n  getReferenceForValue(value: VariableContainer): number {\n    let cachedRef = this._containerCache.get(value);\n    if (cachedRef !== undefined) {\n      return cachedRef;\n    }\n\n    let varRef = this._referenceMap.add(value);\n    this._containerCache.set(value, varRef);\n    return varRef;\n  }\n\n  // The entry point for retrieving a collection of variables by a reference\n  getVariablesByReference(reference: number): Array<Variable> {\n    let container = this._referenceMap.get(reference);\n    if (!container) return [];\n    if (container instanceof LexicalEnvironment) {\n      return this._getVariablesFromEnvRecord(container.environmentRecord);\n    } else if (container instanceof ObjectValue) {\n      return this._getVariablesFromObject(container);\n    } else if (container instanceof AbstractValue) {\n      return this._getAbstractValueContent(container);\n    } else {\n      invariant(false, \"Invalid variable container\");\n    }\n  }\n\n  _getVariablesFromObject(object: ObjectValue): Array<Variable> {\n    let variables = [];\n    let names = object.properties.keys();\n    for (let name of names) {\n      let binding = object.properties.get(name);\n      invariant(binding !== undefined);\n      if (binding.descriptor) {\n        if (IsDataDescriptor(this._realm, binding.descriptor)) {\n          let value = binding.descriptor.value;\n          if (value instanceof Value) {\n            let variable = this._getVariableFromValue(name, value);\n            variables.push(variable);\n          }\n        }\n      }\n    }\n    return variables;\n  }\n\n  _getAbstractValueContent(value: AbstractValue): Array<Variable> {\n    let kindVar: Variable = {\n      name: \"kind\",\n      value: value.kind || \"undefined\",\n      variablesReference: 0,\n    };\n    let contents: Array<Variable> = [kindVar];\n    let argCount = 1;\n    for (let arg of value.args) {\n      contents.push(this._getVariableFromValue(\"arg-\" + argCount, arg));\n      argCount++;\n    }\n    return contents;\n  }\n\n  _getVariablesFromEnvRecord(envRecord: EnvironmentRecord): Array<Variable> {\n    if (envRecord instanceof DeclarativeEnvironmentRecord) {\n      return this._getVariablesFromDeclarativeEnv(envRecord);\n    } else if (envRecord instanceof ObjectEnvironmentRecord) {\n      if (envRecord.object instanceof ObjectValue) {\n        return this._getVariablesFromObject(envRecord.object);\n      } else if (envRecord.object instanceof AbstractObjectValue) {\n        // TODO: call _getVariablesFromAbstractObject when it is implemented\n        return [];\n      } else {\n        invariant(false, \"Invalid type of object environment record\");\n      }\n    } else if (envRecord instanceof GlobalEnvironmentRecord) {\n      let declVars = this._getVariablesFromEnvRecord(envRecord.$DeclarativeRecord);\n      let objVars = this._getVariablesFromEnvRecord(envRecord.$ObjectRecord);\n      return declVars.concat(objVars);\n    } else {\n      invariant(false, \"Invalid type of environment record\");\n    }\n  }\n\n  _getVariablesFromDeclarativeEnv(env: DeclarativeEnvironmentRecord): Array<Variable> {\n    let variables = [];\n    let bindings = env.bindings;\n    for (let name in bindings) {\n      let binding = bindings[name];\n      if (binding.value) {\n        let variable = this._getVariableFromValue(name, binding.value);\n        variables.push(variable);\n      }\n    }\n    return variables;\n  }\n\n  _getVariableFromValue(name: string, value: Value): Variable {\n    if (value instanceof ConcreteValue) {\n      return this._getVariableFromConcreteValue(name, value);\n    } else if (value instanceof AbstractValue) {\n      return this._getVariableFromAbstractValue(name, value);\n    } else {\n      invariant(false, \"Value is neither concrete nor abstract\");\n    }\n  }\n\n  _getVariableFromAbstractValue(name: string, value: AbstractValue): Variable {\n    let variable: Variable = {\n      name: name,\n      value: this._getAbstractValueDisplay(value),\n      variablesReference: this.getReferenceForValue(value),\n    };\n    return variable;\n  }\n\n  _getAbstractValueDisplay(value: AbstractValue): string {\n    if (value.intrinsicName !== undefined && !value.intrinsicName.startsWith(\"_\")) {\n      return value.intrinsicName;\n    }\n    return \"Abstract \" + value.types.getType().name;\n  }\n\n  _getVariableFromConcreteValue(name: string, value: ConcreteValue): Variable {\n    if (value instanceof PrimitiveValue) {\n      let variable: Variable = {\n        name: name,\n        value: value.toDisplayString(),\n        variablesReference: 0,\n      };\n      return variable;\n    } else if (value instanceof ObjectValue) {\n      let variable: Variable = {\n        name: name,\n        value: value.getKind(),\n        variablesReference: this.getReferenceForValue(value),\n      };\n      return variable;\n    } else {\n      invariant(false, \"Concrete value must be primitive or object\");\n    }\n  }\n\n  evaluate(frameId: void | number, expression: string): EvaluateResult {\n    let evalRealm = this._realm;\n    let isDirect = false;\n    let isStrict = false;\n    if (frameId !== undefined) {\n      if (frameId < 0 || frameId >= this._realm.contextStack.length) {\n        throw new DebuggerError(\"Invalid command\", \"Invalid value for frame ID\");\n      }\n      // frameId's are in reverse order of context stack\n      let stackIndex = this._realm.contextStack.length - 1 - frameId;\n      let context = this._realm.contextStack[stackIndex];\n      isDirect = true;\n      isStrict = true;\n      evalRealm = context.realm;\n    }\n\n    let evalString = new StringValue(this._realm, expression);\n    try {\n      let value = Functions.PerformEval(this._realm, evalString, evalRealm, isStrict, isDirect);\n      let varInfo = this._getVariableFromValue(expression, value);\n      let result: EvaluateResult = {\n        kind: \"evaluate\",\n        displayValue: varInfo.value,\n        type: value.getType().name,\n        variablesReference: varInfo.variablesReference,\n      };\n      return result;\n    } catch (e) {\n      let result: EvaluateResult = {\n        kind: \"evaluate\",\n        displayValue: `Failed to evaluate: ${expression}`,\n        type: \"unknown\",\n        variablesReference: 0,\n      };\n      return result;\n    }\n  }\n\n  clean() {\n    this._containerCache = new Map();\n    this._referenceMap.clean();\n  }\n}\n"],"file":"VariableManager.js"}