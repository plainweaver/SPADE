{"version":3,"sources":["../../src/react/optimizing.js"],"names":["writeEffectsKeyOfComponentValue","realm","componentType","componentTreeState","transforms","status","BoundFunctionValue","targetFunction","$BoundTargetFunction","ECMAScriptSourceFunctionValue","prototype","ObjectValue","renderMethod","applyWriteEffectsForOptimizedComponent","_effects","evaluatedNode","writeEffects","preEvaluationComponentToWriteEffectFunction","parentOptimizedFunction","effects","writeEffectsKey","set","additionalFunctionEffects","ReconcilerFatalError","name","value","result","intrinsics","undefined","contextTypes","size","ObjectPrototype","noOpFunc","key","Properties","Set","optimizeReactComponentTreeBranches","reconciler","logger","alreadyEvaluated","react","verbose","branchedComponentTrees","length","logInformation","rootValue","branchRootValue","branchComponentType","has","clearComponentTreeState","currentOptimizedFunction","branchEffects","withNewOptimizedFunction","resolveReactComponentTree","branchComponentTreeState","optimizeReactComponentTreeRoot","componentRoot","config","statistics","Reconciler","evaluatedRootNode","evaluatedRootNodes","push","componentTreeEffects","startingComponentTreeBranches"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { type Effects, Realm } from \"../realm.js\";\nimport {\n  AbstractValue,\n  ECMAScriptSourceFunctionValue,\n  ObjectValue,\n  BoundFunctionValue,\n  FunctionValue,\n} from \"../values/index.js\";\nimport { createAdditionalEffects } from \"../serializer/utils.js\";\nimport {\n  convertFunctionalComponentToComplexClassComponent,\n  convertSimpleClassComponentToFunctionalComponent,\n  createNoopFunction,\n  createReactEvaluatedNode,\n  getComponentName,\n  getComponentTypeFromRootValue,\n  normalizeFunctionalComponentParamaters,\n  valueIsClassComponent,\n} from \"./utils.js\";\nimport {\n  type WriteEffects,\n  type ReactEvaluatedNode,\n  ReactStatistics,\n  type AdditionalFunctionTransform,\n} from \"../serializer/types.js\";\nimport { Reconciler, type ComponentTreeState } from \"./reconcilation.js\";\nimport { ReconcilerFatalError } from \"./errors.js\";\nimport { Properties } from \"../singletons.js\";\nimport { Get } from \"../methods/index.js\";\nimport invariant from \"../invariant.js\";\nimport type { ReactComponentTreeConfig } from \"../types.js\";\nimport { Logger } from \"../utils/logger.js\";\n\nfunction writeEffectsKeyOfComponentValue(\n  realm: Realm,\n  componentType: ECMAScriptSourceFunctionValue | BoundFunctionValue,\n  componentTreeState: ComponentTreeState,\n  transforms: Array<AdditionalFunctionTransform>\n): FunctionValue {\n  if (valueIsClassComponent(realm, componentType)) {\n    if (componentTreeState.status === \"SIMPLE\") {\n      // if the root component was a class and is now simple, we can convert it from a class\n      // component to a functional component\n      if (componentType instanceof BoundFunctionValue) {\n        let targetFunction = componentType.$BoundTargetFunction;\n        invariant(targetFunction instanceof ECMAScriptSourceFunctionValue);\n        convertSimpleClassComponentToFunctionalComponent(realm, targetFunction, transforms);\n        normalizeFunctionalComponentParamaters(targetFunction);\n        return targetFunction;\n      } else {\n        convertSimpleClassComponentToFunctionalComponent(realm, componentType, transforms);\n        normalizeFunctionalComponentParamaters(componentType);\n        return componentType;\n      }\n    } else {\n      let prototype = Get(realm, componentType, \"prototype\");\n      invariant(prototype instanceof ObjectValue);\n      let renderMethod = Get(realm, prototype, \"render\");\n      invariant(renderMethod instanceof ECMAScriptSourceFunctionValue);\n      return renderMethod;\n    }\n  } else {\n    if (componentTreeState.status === \"COMPLEX\") {\n      convertFunctionalComponentToComplexClassComponent(\n        realm,\n        componentType,\n        componentTreeState.componentType,\n        transforms\n      );\n      let prototype = Get(realm, componentType, \"prototype\");\n      invariant(prototype instanceof ObjectValue);\n      let renderMethod = Get(realm, prototype, \"render\");\n      invariant(renderMethod instanceof ECMAScriptSourceFunctionValue);\n      return renderMethod;\n    } else {\n      if (componentType instanceof BoundFunctionValue) {\n        let targetFunction = componentType.$BoundTargetFunction;\n        invariant(targetFunction instanceof ECMAScriptSourceFunctionValue);\n        normalizeFunctionalComponentParamaters(targetFunction);\n        return targetFunction;\n      } else {\n        normalizeFunctionalComponentParamaters(componentType);\n        return componentType;\n      }\n    }\n  }\n}\n\nfunction applyWriteEffectsForOptimizedComponent(\n  realm: Realm,\n  componentType: ECMAScriptSourceFunctionValue | BoundFunctionValue,\n  _effects: Effects,\n  componentTreeState: ComponentTreeState,\n  evaluatedNode: ReactEvaluatedNode,\n  writeEffects: WriteEffects,\n  preEvaluationComponentToWriteEffectFunction: Map<FunctionValue, FunctionValue>,\n  parentOptimizedFunction: FunctionValue | void\n): void {\n  let effects = _effects;\n  let transforms = [];\n  let writeEffectsKey = writeEffectsKeyOfComponentValue(realm, componentType, componentTreeState, transforms);\n  // NB: Must be done here because its required by cAE\n  preEvaluationComponentToWriteEffectFunction.set(componentType, writeEffectsKey);\n  let additionalFunctionEffects = createAdditionalEffects(\n    realm,\n    effects,\n    false,\n    \"ReactAdditionalFunctionEffects\",\n    writeEffects,\n    preEvaluationComponentToWriteEffectFunction,\n    writeEffectsKey,\n    parentOptimizedFunction,\n    transforms\n  );\n  if (additionalFunctionEffects === null) {\n    throw new ReconcilerFatalError(\n      `Failed to optimize React component tree for \"${evaluatedNode.name}\" due to an unsupported completion`,\n      evaluatedNode\n    );\n  }\n  effects = additionalFunctionEffects.effects;\n  let value = effects.result;\n\n  if (value === realm.intrinsics.undefined) {\n    // if we get undefined, then this component tree failed and a message was already logged\n    // in the reconciler\n    return;\n  }\n  writeEffects.set(writeEffectsKey, additionalFunctionEffects);\n  // apply contextTypes for legacy context\n  if (componentTreeState.contextTypes.size > 0) {\n    let contextTypes = new ObjectValue(realm, realm.intrinsics.ObjectPrototype);\n    let noOpFunc = createNoopFunction(realm);\n    for (let key of componentTreeState.contextTypes) {\n      Properties.Set(realm, contextTypes, key, noOpFunc, true);\n    }\n    Properties.Set(realm, componentType, \"contextTypes\", contextTypes, true);\n  }\n}\n\nfunction optimizeReactComponentTreeBranches(\n  realm: Realm,\n  reconciler: Reconciler,\n  writeEffects: WriteEffects,\n  logger: Logger,\n  alreadyEvaluated: Map<ECMAScriptSourceFunctionValue | BoundFunctionValue, ReactEvaluatedNode>,\n  preEvaluationComponentToWriteEffectFunction: Map<FunctionValue, FunctionValue>\n): void {\n  if (realm.react.verbose && reconciler.branchedComponentTrees.length > 0) {\n    logger.logInformation(`  Evaluating React component tree branches...`);\n  }\n  // for now we just use abstract props/context, in the future we'll create a new branch with a new component\n  // that used the props/context. It will extend the original component and only have a render method\n  for (let { rootValue: branchRootValue, evaluatedNode } of reconciler.branchedComponentTrees) {\n    let branchComponentType = getComponentTypeFromRootValue(realm, branchRootValue);\n    if (branchComponentType === null) {\n      evaluatedNode.status = \"UNKNOWN_TYPE\";\n      continue;\n    }\n    if (alreadyEvaluated.has(branchComponentType)) {\n      return;\n    }\n    alreadyEvaluated.set(branchComponentType, evaluatedNode);\n    reconciler.clearComponentTreeState();\n    if (realm.react.verbose) {\n      logger.logInformation(`    Evaluating ${evaluatedNode.name} (branch)`);\n    }\n    let parentOptimizedFunction = realm.currentOptimizedFunction;\n    let branchEffects = realm.withNewOptimizedFunction(\n      () => reconciler.resolveReactComponentTree(branchComponentType, null, null, evaluatedNode),\n      branchComponentType\n    );\n\n    if (realm.react.verbose) {\n      logger.logInformation(`    ✔ ${evaluatedNode.name} (branch)`);\n    }\n    let branchComponentTreeState = reconciler.componentTreeState;\n\n    applyWriteEffectsForOptimizedComponent(\n      realm,\n      branchComponentType,\n      branchEffects,\n      branchComponentTreeState,\n      evaluatedNode,\n      writeEffects,\n      preEvaluationComponentToWriteEffectFunction,\n      parentOptimizedFunction\n    );\n  }\n}\n\nexport function optimizeReactComponentTreeRoot(\n  realm: Realm,\n  componentRoot: ECMAScriptSourceFunctionValue | BoundFunctionValue | AbstractValue,\n  config: ReactComponentTreeConfig,\n  writeEffects: WriteEffects,\n  logger: Logger,\n  statistics: ReactStatistics,\n  alreadyEvaluated: Map<ECMAScriptSourceFunctionValue | BoundFunctionValue, ReactEvaluatedNode>,\n  preEvaluationComponentToWriteEffectFunction: Map<FunctionValue, FunctionValue>\n): void {\n  let reconciler = new Reconciler(realm, config, alreadyEvaluated, statistics, logger);\n  let componentType = getComponentTypeFromRootValue(realm, componentRoot);\n  if (componentType === null) {\n    return;\n  }\n  if (alreadyEvaluated.has(componentType)) {\n    return;\n  }\n  let evaluatedRootNode = createReactEvaluatedNode(\"ROOT\", getComponentName(realm, componentType));\n  statistics.evaluatedRootNodes.push(evaluatedRootNode);\n  alreadyEvaluated.set(componentType, evaluatedRootNode);\n  if (realm.react.verbose) {\n    logger.logInformation(`  Evaluating ${evaluatedRootNode.name} (root)`);\n  }\n  let parentOptimizedFunction = realm.currentOptimizedFunction;\n  let componentTreeEffects = realm.withNewOptimizedFunction(\n    () => reconciler.resolveReactComponentTree(componentType, null, null, evaluatedRootNode),\n    componentType\n  );\n  if (realm.react.verbose) {\n    logger.logInformation(`  ✔ ${evaluatedRootNode.name} (root)`);\n  }\n\n  applyWriteEffectsForOptimizedComponent(\n    realm,\n    componentType,\n    componentTreeEffects,\n    reconciler.componentTreeState,\n    evaluatedRootNode,\n    writeEffects,\n    preEvaluationComponentToWriteEffectFunction,\n    parentOptimizedFunction\n  );\n  let startingComponentTreeBranches = 0;\n  do {\n    startingComponentTreeBranches = reconciler.branchedComponentTrees.length;\n    optimizeReactComponentTreeBranches(\n      realm,\n      reconciler,\n      writeEffects,\n      logger,\n      alreadyEvaluated,\n      preEvaluationComponentToWriteEffectFunction\n    );\n  } while (startingComponentTreeBranches !== reconciler.branchedComponentTrees.length);\n}\n"],"file":"optimizing.js"}