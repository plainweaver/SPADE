{"version":3,"sources":["../../src/react/jsx.js"],"names":["convertExpressionToJSXIdentifier","expr","isRoot","type","t","jSXIdentifier","name","value","length","toLowerCase","computed","jSXMemberExpression","object","property","convertJSXExpressionToIdentifier","identifier","memberExpression","convertKeyValueToJSXAttribute","key","wrapInContainer","isStringLiteral","includes","jSXAttribute","jSXExpressionContainer"],"mappings":";;;;;;;;;AAWA;;AASA;;AACA;;;;;;AArBA;;;;;;;;AAuBO,SAASA,gCAAT,CACLC,IADK,EAELC,MAFK,EAGkD;AACvD,UAAQD,IAAI,CAACE,IAAb;AACE,SAAK,gBAAL;AACE,8BAAUD,MAAM,KAAK,KAArB,EAA6B,2EAA7B;AACA,aAAOE,CAAC,CAACC,aAAF,CAAgB,MAAhB,CAAP;;AACF,SAAK,YAAL;AACE,UAAIC,IAAI,GAAGL,IAAI,CAACK,IAAhB;AACA,+BACE;AACA;AACAJ,MAAAA,MAAM,KAAK,KAAX,IAAoB,6BAAiBI,IAAjB,CAHtB,EAIE,yEAJF;AAMA,aAAOF,CAAC,CAACC,aAAF,CAAgBC,IAAhB,CAAP;;AACF,SAAK,eAAL;AACE,UAAIC,KAAK,GAAGN,IAAI,CAACM,KAAjB;AACA,+BACE;AACA;AACAA,MAAAA,KAAK,CAACC,MAAN,GAAe,CAAf,IAAoBD,KAAK,CAAC,CAAD,CAAL,KAAaA,KAAK,CAAC,CAAD,CAAL,CAASE,WAAT,EAHnC,EAIE,6DAJF;AAMA,aAAOL,CAAC,CAACC,aAAF,CAAgBE,KAAhB,CAAP;;AACF,SAAK,kBAAL;AACE,8BAAUN,IAAI,CAACS,QAAL,KAAkB,KAA5B,EAAmC,iDAAnC;AACA,aAAON,CAAC,CAACO,mBAAF,CACLX,gCAAgC,CAACC,IAAI,CAACW,MAAN,EAAc,KAAd,CAD3B,EAEHZ,gCAAgC,CAACC,IAAI,CAACY,QAAN,EAAgB,KAAhB,CAF7B,CAAP;;AAIF;AACE,8BAAU,KAAV,EAAiB,kBAAjB;AA7BJ;AA+BD;;AAEM,SAASC,gCAAT,CACLb,IADK,EAE4C;AACjD,UAAQA,IAAI,CAACE,IAAb;AACE,SAAK,eAAL;AACE,aAAOC,CAAC,CAACW,UAAF,CAAad,IAAI,CAACK,IAAlB,CAAP;;AACF,SAAK,qBAAL;AACE,aAAOF,CAAC,CAACY,gBAAF,CACLF,gCAAgC,CAACb,IAAI,CAACW,MAAN,CAD3B,EAEJE,gCAAgC,CAACb,IAAI,CAACY,QAAN,CAF5B,CAAP;;AAIF;AACE,8BAAU,KAAV,EAAiB,kBAAjB;AATJ;AAWD;;AAEM,SAASI,6BAAT,CAAuCC,GAAvC,EAAoDjB,IAApD,EAA0F;AAC/F,MAAIkB,eAAe,GAAG,IAAtB;;AAEA,MAAIlB,IAAI,IAAIG,CAAC,CAACgB,eAAF,CAAkBnB,IAAlB,CAAR,IAAmC,OAAOA,IAAI,CAACM,KAAZ,KAAsB,QAA7D,EAAuE;AACrE,QAAIA,KAAK,GAAGN,IAAI,CAACM,KAAjB;AACAY,IAAAA,eAAe,GAAGZ,KAAK,CAACc,QAAN,CAAe,GAAf,KAAuBd,KAAK,CAACc,QAAN,CAAe,GAAf,CAAzC;AACD;;AACD,SAAOjB,CAAC,CAACkB,YAAF,CACLlB,CAAC,CAACC,aAAF,CAAgBa,GAAhB,CADK,EAELC,eAAe,GAAGf,CAAC,CAACmB,sBAAF,CAAyBtB,IAAzB,CAAH,GAAsCA,IAFhD,CAAP;AAID","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport * as t from \"@babel/types\";\nimport type {\n  BabelNodeExpression,\n  BabelNodeJSXMemberExpression,\n  BabelNodeJSXIdentifier,\n  BabelNodeIdentifier,\n  BabelNodeMemberExpression,\n  BabelNodeStringLiteral,\n} from \"@babel/types\";\nimport invariant from \"../invariant.js\";\nimport { isReactComponent } from \"./utils.js\";\n\nexport function convertExpressionToJSXIdentifier(\n  expr: BabelNodeExpression,\n  isRoot: boolean\n): BabelNodeJSXMemberExpression | BabelNodeJSXIdentifier {\n  switch (expr.type) {\n    case \"ThisExpression\":\n      invariant(isRoot === false, `invalid conversion of root expression to JSXIdentifier for ThisExpression`);\n      return t.jSXIdentifier(\"this\");\n    case \"Identifier\":\n      let name = expr.name;\n      invariant(\n        // ensure the 1st character of the string is uppercase\n        // for a component unless it is not the root\n        isRoot === false || isReactComponent(name),\n        \"invalid JSXIdentifer from Identifier, Identifier name must be uppercase\"\n      );\n      return t.jSXIdentifier(name);\n    case \"StringLiteral\":\n      let value = expr.value;\n      invariant(\n        // ensure the 1st character of the string is lowercase\n        // otherwise it will appear as a component\n        value.length > 0 && value[0] === value[0].toLowerCase(),\n        \"invalid JSXIdentifer from string, strings must be lowercase\"\n      );\n      return t.jSXIdentifier(value);\n    case \"MemberExpression\":\n      invariant(expr.computed === false, \"Cannot inline computed expressions in JSX type.\");\n      return t.jSXMemberExpression(\n        convertExpressionToJSXIdentifier(expr.object, false),\n        ((convertExpressionToJSXIdentifier(expr.property, false): any): BabelNodeJSXIdentifier)\n      );\n    default:\n      invariant(false, \"Invalid JSX type\");\n  }\n}\n\nexport function convertJSXExpressionToIdentifier(\n  expr: BabelNodeExpression\n): BabelNodeMemberExpression | BabelNodeIdentifier {\n  switch (expr.type) {\n    case \"JSXIdentifier\":\n      return t.identifier(expr.name);\n    case \"JSXMemberExpression\":\n      return t.memberExpression(\n        convertJSXExpressionToIdentifier(expr.object),\n        (convertJSXExpressionToIdentifier(expr.property): any)\n      );\n    default:\n      invariant(false, \"Invalid JSX type\");\n  }\n}\n\nexport function convertKeyValueToJSXAttribute(key: string, expr: BabelNodeExpression): BabelNode {\n  let wrapInContainer = true;\n\n  if (expr && t.isStringLiteral(expr) && typeof expr.value === \"string\") {\n    let value = expr.value;\n    wrapInContainer = value.includes('\"') || value.includes(\"'\");\n  }\n  return t.jSXAttribute(\n    t.jSXIdentifier(key),\n    wrapInContainer ? t.jSXExpressionContainer(expr) : ((expr: any): BabelNodeStringLiteral)\n  );\n}\n"],"file":"jsx.js"}