{"version":3,"sources":["../../src/serializer/ResidualFunctionInitializers.js"],"names":["ResidualFunctionInitializers","constructor","locationService","functionInitializerInfos","Map","initializers","sharedInitializers","registerValueOnlyReferencedByResidualFunctions","functionValues","val","length","infos","functionValue","info","get","undefined","set","ownId","size","toString","initializerIds","Set","push","id","map","sort","join","add","initializer","order","values","body","type","parentBody","entries","done","scrubFunctionInitializers","delete","_conditionalInitialization","containingAdditionalFunction","initializedValues","initializationStatements","t","isIfStatement","location","value","mightBeUndefined","FunctionValue","getLocation","createLocation","unshift","expressionStatement","assignmentExpression","nullExpression","ifStatement","binaryExpression","voidExpression","blockStatement","hasInitializerStatement","factorifyInitializers","nameGenerator","getInitializerStatement","initializerInfo","getContainingAdditionalFunction","ownInitializer","initializerId","i","j","concat","ast","count","file","program","node","createFunction","callExpression"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { FunctionValue, Value } from \"../values/index.js\";\nimport * as t from \"@babel/types\";\nimport type { BabelNodeStatement } from \"@babel/types\";\nimport { NameGenerator } from \"../utils/NameGenerator.js\";\nimport traverseFast from \"../utils/traverse-fast.js\";\nimport invariant from \"../invariant.js\";\nimport { voidExpression, nullExpression } from \"../utils/babelhelpers.js\";\nimport type { LocationService, SerializedBody } from \"./types.js\";\nimport { factorifyObjects } from \"./factorify.js\";\n\n// This class manages information about values\n// which are only referenced by residual functions,\n// and it provides the ability to generate initialization code for those values that\n// can be placed into the residual functions.\nexport class ResidualFunctionInitializers {\n  constructor(locationService: LocationService) {\n    this.functionInitializerInfos = new Map();\n    this.initializers = new Map();\n    this.sharedInitializers = new Map();\n    this.locationService = locationService;\n  }\n\n  // ownId: uid of the FunctionValue, initializer ids are strings of sorted lists of FunctionValues referencing the value\n  functionInitializerInfos: Map<FunctionValue, { ownId: string, initializerIds: Set<string> }>;\n  initializers: Map<string, { id: string, order: number, body: SerializedBody, values: Array<Value> }>;\n  sharedInitializers: Map<string, BabelNodeStatement>;\n  locationService: LocationService;\n\n  registerValueOnlyReferencedByResidualFunctions(functionValues: Array<FunctionValue>, val: Value): SerializedBody {\n    invariant(functionValues.length >= 1);\n    let infos = [];\n    for (let functionValue of functionValues) {\n      let info = this.functionInitializerInfos.get(functionValue);\n      if (info === undefined)\n        this.functionInitializerInfos.set(\n          functionValue,\n          (info = { ownId: this.functionInitializerInfos.size.toString(), initializerIds: new Set() })\n        );\n      infos.push(info);\n    }\n    let id = infos\n      .map(info => info.ownId)\n      .sort()\n      .join();\n    for (let info of infos) info.initializerIds.add(id);\n    let initializer = this.initializers.get(id);\n    if (initializer === undefined)\n      this.initializers.set(\n        id,\n        (initializer = {\n          id,\n          order: infos.length,\n          values: [],\n          body: { type: \"DelayInitializations\", parentBody: undefined, entries: [], done: false },\n        })\n      );\n    initializer.values.push(val);\n    return initializer.body;\n  }\n\n  scrubFunctionInitializers(): void {\n    // Deleting trivial entries in order to avoid creating empty initialization functions that serve no purpose.\n    for (let initializer of this.initializers.values())\n      if (initializer.body.entries.length === 0) this.initializers.delete(initializer.id);\n    for (let [functionValue, info] of this.functionInitializerInfos) {\n      for (let id of info.initializerIds) {\n        let initializer = this.initializers.get(id);\n        if (initializer === undefined) {\n          info.initializerIds.delete(id);\n        }\n      }\n      if (info.initializerIds.size === 0) this.functionInitializerInfos.delete(functionValue);\n    }\n  }\n\n  _conditionalInitialization(\n    containingAdditionalFunction: void | FunctionValue,\n    initializedValues: Array<Value>,\n    initializationStatements: Array<BabelNodeStatement>\n  ): BabelNodeStatement {\n    if (initializationStatements.length === 1 && t.isIfStatement(initializationStatements[0])) {\n      return initializationStatements[0];\n    }\n\n    // We have some initialization code, and it should only get executed once,\n    // so we are going to guard it.\n    // First, let's see if one of the initialized values is guaranteed to not\n    // be undefined after initialization. In that case, we can use that state-change\n    // to figure out if initialization needs to run.\n    let location;\n    for (let value of initializedValues) {\n      // function declarations get hoisted, so let's not use their initialization state as a marker\n      if (!value.mightBeUndefined() && !(value instanceof FunctionValue)) {\n        location = this.locationService.getLocation(value);\n        if (location !== undefined) break;\n      }\n    }\n    if (location === undefined) {\n      // Second, if we didn't find a non-undefined value, let's make one up.\n      // It will transition from `undefined` to `null`.\n      location = this.locationService.createLocation(containingAdditionalFunction);\n      initializationStatements.unshift(t.expressionStatement(t.assignmentExpression(\"=\", location, nullExpression)));\n    }\n    return t.ifStatement(\n      t.binaryExpression(\"===\", location, voidExpression),\n      t.blockStatement(initializationStatements)\n    );\n  }\n\n  hasInitializerStatement(functionValue: FunctionValue): boolean {\n    return !!this.functionInitializerInfos.get(functionValue);\n  }\n\n  factorifyInitializers(nameGenerator: NameGenerator): void {\n    for (const initializer of this.initializers.values()) {\n      factorifyObjects(initializer.body.entries, nameGenerator);\n    }\n  }\n\n  getInitializerStatement(functionValue: FunctionValue): void | BabelNodeStatement {\n    let initializerInfo = this.functionInitializerInfos.get(functionValue);\n    if (initializerInfo === undefined) return undefined;\n    let containingAdditionalFunction = this.locationService.getContainingAdditionalFunction(functionValue);\n\n    invariant(initializerInfo.initializerIds.size > 0);\n    let ownInitializer = this.initializers.get(initializerInfo.ownId);\n    let initializedValues;\n    let initializationStatements = [];\n    let initializers = [];\n    for (let initializerId of initializerInfo.initializerIds) {\n      let initializer = this.initializers.get(initializerId);\n      invariant(initializer !== undefined);\n      invariant(initializer.body.entries.length > 0);\n      initializers.push(initializer);\n    }\n    // Sorting initializers by the number of scopes they are required by.\n    // Note that the scope sets form a lattice, and this sorting effectively\n    // ensures that value initializers that depend on other value initializers\n    // get called in the right order.\n    initializers.sort((i, j) => j.order - i.order);\n    for (let initializer of initializers) {\n      if (initializerInfo.initializerIds.size === 1 || initializer === ownInitializer) {\n        initializedValues = initializer.values;\n      }\n      if (initializer === ownInitializer) {\n        initializationStatements = initializationStatements.concat(initializer.body.entries);\n      } else {\n        let ast = this.sharedInitializers.get(initializer.id);\n        if (ast === undefined) {\n          ast = this._conditionalInitialization(\n            containingAdditionalFunction,\n            initializer.values,\n            initializer.body.entries\n          );\n          // We inline compact initializers, as calling a function would introduce too much\n          // overhead. To determine if an initializer is compact, we count the number of\n          // nodes in the AST, and check if it exceeds a certain threshold.\n          // TODO #885: Study in more detail which threshold is the best compromise in terms of\n          // code size and performance.\n          let count = 0;\n          traverseFast(t.file(t.program([ast])), node => {\n            count++;\n            return false;\n          });\n          if (count > 24) {\n            let id = this.locationService.createFunction(containingAdditionalFunction, [ast]);\n            ast = t.expressionStatement(t.callExpression(id, []));\n          }\n          this.sharedInitializers.set(initializer.id, ast);\n        }\n        initializationStatements.push(ast);\n      }\n    }\n\n    return this._conditionalInitialization(\n      containingAdditionalFunction,\n      initializedValues || [],\n      initializationStatements\n    );\n  }\n}\n"],"file":"ResidualFunctionInitializers.js"}