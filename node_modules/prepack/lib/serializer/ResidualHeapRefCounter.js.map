{"version":3,"sources":["../../src/serializer/ResidualHeapRefCounter.js"],"names":["ResidualHeapRefCounter","ResidualHeapVisitor","constructor","realm","logger","modules","additionalFunctionValuesAndEffects","_valueToEdgeRecord","Map","_path","getResult","_shouldIgnore","val","EmptyValue","isIntrinsic","HeapInspector","isLeaf","preProcessValue","length","_updateParentOutgoingEdgeCount","push","_updateValueIncomingEdgeCount","parent","edgeRecord","get","outGoing","undefined","set","inComing","postProcessValue","pop","visitRoots"],"mappings":";;;;;;;AAgBA;;AACA;;AACA;;AACA;;;;AAnBA;;;;;;;;;AASA;;AAYA;;;AAGO,MAAMA,sBAAN,SAAqCC,wCAArC,CAAyD;AAC9DC,EAAAA,WAAW,CACTC,KADS,EAETC,MAFS,EAGTC,OAHS,EAITC,kCAJS,EAKT;AACA,UAAMH,KAAN,EAAaC,MAAb,EAAqBC,OAArB,EAA8BC,kCAA9B;AACA,SAAKC,kBAAL,GAA0B,IAAIC,GAAJ,EAA1B;AACA,SAAKC,KAAL,GAAa,EAAb;AACD;;AAGoB;AAErBC,EAAAA,SAAS,GAA+B;AACtC,WAAO,KAAKH,kBAAZ;AACD;;AAEDI,EAAAA,aAAa,CAACC,GAAD,EAAsB;AACjC,WAAOA,GAAG,YAAYC,iBAAf,IAA6BD,GAAG,CAACE,WAAJ,EAA7B,IAAkDC,6BAAcC,MAAd,CAAqBJ,GAArB,CAAzD;AACD;;AAEDK,EAAAA,eAAe,CAACL,GAAD,EAAsB;AACnC,QAAI,KAAKD,aAAL,CAAmBC,GAAnB,CAAJ,EAA6B;AAC3B,aAAO,KAAP;AACD;;AAED,QAAI,KAAKH,KAAL,CAAWS,MAAX,GAAoB,CAAxB,EAA2B;AACzB,WAAKC,8BAAL;AACD;;AACD,SAAKV,KAAL,CAAWW,IAAX,CAAgBR,GAAhB;;AAEA,WAAO,KAAKS,6BAAL,CAAmCT,GAAnC,CAAP;AACD;;AAEDO,EAAAA,8BAA8B,GAAS;AACrC,UAAMG,MAAM,GAAG,KAAKb,KAAL,CAAW,KAAKA,KAAL,CAAWS,MAAX,GAAoB,CAA/B,CAAf;;AACA,UAAMK,UAAU,GAAG,KAAKhB,kBAAL,CAAwBiB,GAAxB,CAA4BF,MAA5B,CAAnB;;AACA,4BAAUC,UAAV;AACA,MAAEA,UAAU,CAACE,QAAb;AACD;;AAEDJ,EAAAA,6BAA6B,CAACT,GAAD,EAAsB;AACjD,QAAIW,UAAU,GAAG,KAAKhB,kBAAL,CAAwBiB,GAAxB,CAA4BZ,GAA5B,CAAjB;;AACA,QAAIW,UAAU,KAAKG,SAAnB,EAA8B;AAC5B,WAAKnB,kBAAL,CAAwBoB,GAAxB,CAA4Bf,GAA5B,EAAiC;AAC/BgB,QAAAA,QAAQ,EAAE,CADqB;AAE/BH,QAAAA,QAAQ,EAAE;AAFqB,OAAjC;;AAIA,aAAO,IAAP;AACD,KAND,MAMO;AACL,QAAEF,UAAU,CAACK,QAAb;AACA,aAAO,KAAP,CAFK,CAES;AACf;AACF,GAvD6D,CAyD9D;;;AACAC,EAAAA,gBAAgB,CAACjB,GAAD,EAAmB;AACjC,QAAI,KAAKD,aAAL,CAAmBC,GAAnB,CAAJ,EAA6B;AAC3B;AACD;;AACD,4BAAU,KAAKH,KAAL,CAAWS,MAAX,GAAoB,CAA9B;;AACA,SAAKT,KAAL,CAAWqB,GAAX;AACD,GAhE6D,CAkE9D;;;AACAC,EAAAA,UAAU,GAAS;AACjB,UAAMA,UAAN;AACA,4BAAU,KAAKtB,KAAL,CAAWS,MAAX,KAAsB,CAAhC,EAAmC,gDAAnC;AACD;;AAtE6D","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Logger } from \"../utils/logger.js\";\nimport type { Modules } from \"../utils/modules.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { ObjectRefCount, AdditionalFunctionEffects } from \"./types.js\";\n\nimport invariant from \"../invariant.js\";\nimport { Value, EmptyValue, FunctionValue } from \"../values/index.js\";\nimport { HeapInspector } from \"../utils/HeapInspector.js\";\nimport { ResidualHeapVisitor } from \"./ResidualHeapVisitor.js\";\n\n/**\n * Record residual heap object's incoming and outgoing reference counts.\n */\nexport class ResidualHeapRefCounter extends ResidualHeapVisitor {\n  constructor(\n    realm: Realm,\n    logger: Logger,\n    modules: Modules,\n    additionalFunctionValuesAndEffects: Map<FunctionValue, AdditionalFunctionEffects>\n  ) {\n    super(realm, logger, modules, additionalFunctionValuesAndEffects);\n    this._valueToEdgeRecord = new Map();\n    this._path = [];\n  }\n\n  _valueToEdgeRecord: Map<Value, ObjectRefCount>;\n  _path: Array<Value>; // Contains the path of nodes from root to current visiting node.\n\n  getResult(): Map<Value, ObjectRefCount> {\n    return this._valueToEdgeRecord;\n  }\n\n  _shouldIgnore(val: Value): boolean {\n    return val instanceof EmptyValue || val.isIntrinsic() || HeapInspector.isLeaf(val);\n  }\n\n  preProcessValue(val: Value): boolean {\n    if (this._shouldIgnore(val)) {\n      return false;\n    }\n\n    if (this._path.length > 0) {\n      this._updateParentOutgoingEdgeCount();\n    }\n    this._path.push(val);\n\n    return this._updateValueIncomingEdgeCount(val);\n  }\n\n  _updateParentOutgoingEdgeCount(): void {\n    const parent = this._path[this._path.length - 1];\n    const edgeRecord = this._valueToEdgeRecord.get(parent);\n    invariant(edgeRecord);\n    ++edgeRecord.outGoing;\n  }\n\n  _updateValueIncomingEdgeCount(val: Value): boolean {\n    let edgeRecord = this._valueToEdgeRecord.get(val);\n    if (edgeRecord === undefined) {\n      this._valueToEdgeRecord.set(val, {\n        inComing: 1,\n        outGoing: 0,\n      });\n      return true;\n    } else {\n      ++edgeRecord.inComing;\n      return false; // visited node, skip its children.\n    }\n  }\n\n  // Override.\n  postProcessValue(val: Value): void {\n    if (this._shouldIgnore(val)) {\n      return;\n    }\n    invariant(this._path.length > 0);\n    this._path.pop();\n  }\n\n  // Override.\n  visitRoots(): void {\n    super.visitRoots();\n    invariant(this._path.length === 0, \"Path should be balanced empty after traversal.\");\n  }\n}\n"],"file":"ResidualHeapRefCounter.js"}