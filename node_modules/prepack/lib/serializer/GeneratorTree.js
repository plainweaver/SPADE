"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GeneratorTree = void 0;

var _invariant = _interopRequireDefault(require("../invariant.js"));

var _index = require("../values/index.js");

var _generator = require("../utils/generator.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/*  strict-local */
// This class maintains a tree containing all generators known so far,
// and information about the most specific generator that created any
// particular object.
// New sub-trees are added in chunks, at the beginning for the global generator,
// and every time the visitor handles another additional function.
class GeneratorTree {
  constructor() {
    this.parents = new Map();
    this.createdObjects = new Map();
  }

  getParent(generator) {
    let parent = this.parents.get(generator);
    (0, _invariant.default)(parent !== undefined);
    return parent;
  }

  getCreator(value) {
    return this.createdObjects.get(value);
  }

  add(parent, generator) {
    this._add(parent, generator);
  }

  _add(parent, generator) {
    (0, _invariant.default)(!this.parents.has(generator));
    this.parents.set(generator, parent);
    let effects = generator.effectsToApply;

    if (effects !== undefined) {
      (0, _invariant.default)(parent instanceof _index.FunctionValue);

      for (let createdObject of effects.createdObjects) {
        let isValidPreviousCreator = previousCreator => {
          // It's okay if we don't know about any previous creator.
          if (previousCreator === undefined) return true; // If we already recorded a newly-created object, then we must have done so for our parent

          if (previousCreator === parent) return true; // Since we are dealing with a DAG, and not a tree, we might have already the current generator as the creator

          if (previousCreator === generator) return true; // TODO: There's something else going on that is not yet understood.
          // Fix the return value once #1901 is understood and landed.

          return true; // false
        };

        (0, _invariant.default)(isValidPreviousCreator(this.createdObjects.get(createdObject))); // Update the created objects mapping to the most specific generator

        this.createdObjects.set(createdObject, generator);
      }
    }

    for (let dependency of generator.getDependencies()) this._add(generator, dependency);
  }

}

exports.GeneratorTree = GeneratorTree;
//# sourceMappingURL=GeneratorTree.js.map