{"version":3,"sources":["../../src/serializer/visitors.js"],"names":["visitName","path","state","node","modified","scope","hasBinding","name","nodes","functionInfo","unbound","get","undefined","set","push","add","ignorePath","parent","t","isLabeledStatement","isBreakStatement","isContinueStatement","ClosureRefVisitor","enter","depth","exit","ArrowFunctionExpression","lexicalDepth","CallExpression","getModuleIdIfNodeIsRequireFunction","moduleId","requireCalls","ReferencedIdentifier","innerName","usesArguments","ThisExpression","usesThis","ids","getBindingIdentifiers","left"],"mappings":";;;;;;;AAWA;;AACA;;;;AAZA;;;;;;;;;AASA;AAkBA,SAASA,SAAT,CAAmBC,IAAnB,EAAyBC,KAAzB,EAAgCC,IAAhC,EAAsCC,QAAtC,EAAgD;AAC9C;AACA,MAAIH,IAAI,CAACI,KAAL,CAAWC,UAAX,CAAsBH,IAAI,CAACI,IAA3B;AAAiC;AAAc,MAA/C,CAAJ,EAA0D,OAFZ,CAI9C;;AACA,MAAIC,KAAK,GAAGN,KAAK,CAACO,YAAN,CAAmBC,OAAnB,CAA2BC,GAA3B,CAA+BR,IAAI,CAACI,IAApC,CAAZ;AACA,MAAIC,KAAK,KAAKI,SAAd,EAAyBV,KAAK,CAACO,YAAN,CAAmBC,OAAnB,CAA2BG,GAA3B,CAA+BV,IAAI,CAACI,IAApC,EAA2CC,KAAK,GAAG,EAAnD;AACzBA,EAAAA,KAAK,CAACM,IAAN,CAAWX,IAAX;AACA,MAAIC,QAAJ,EAAcF,KAAK,CAACO,YAAN,CAAmBL,QAAnB,CAA4BW,GAA5B,CAAgCZ,IAAI,CAACI,IAArC;AACf;;AAED,SAASS,UAAT,CAAoBf,IAApB,EAA6C;AAC3C,MAAIgB,MAAM,GAAGhB,IAAI,CAACgB,MAAlB;AACA,SAAOC,CAAC,CAACC,kBAAF,CAAqBF,MAArB,KAAgCC,CAAC,CAACE,gBAAF,CAAmBH,MAAnB,CAAhC,IAA8DC,CAAC,CAACG,mBAAF,CAAsBJ,MAAtB,CAArE;AACD;;AAEM,IAAIK,iBAAiB,GAAG;AAC7B,oEAAkE;AAChEC,IAAAA,KAAK,CAACtB,IAAD,EAA0BC,KAA1B,EAAyD;AAC5DA,MAAAA,KAAK,CAACO,YAAN,CAAmBe,KAAnB;AACD,KAH+D;;AAIhEC,IAAAA,IAAI,CAACxB,IAAD,EAA0BC,KAA1B,EAAyD;AAC3DA,MAAAA,KAAK,CAACO,YAAN,CAAmBe,KAAnB;AACD;;AAN+D,GADrC;AAU7BE,EAAAA,uBAAuB,EAAE;AACvBH,IAAAA,KAAK,CAACtB,IAAD,EAA0BC,KAA1B,EAAyD;AAC5DA,MAAAA,KAAK,CAACO,YAAN,CAAmBe,KAAnB;AACAtB,MAAAA,KAAK,CAACO,YAAN,CAAmBkB,YAAnB;AACD,KAJsB;;AAKvBF,IAAAA,IAAI,CAACxB,IAAD,EAA0BC,KAA1B,EAAyD;AAC3DA,MAAAA,KAAK,CAACO,YAAN,CAAmBe,KAAnB;AACAtB,MAAAA,KAAK,CAACO,YAAN,CAAmBkB,YAAnB;AACD;;AARsB,GAVI;;AAqB7BC,EAAAA,cAAc,CAAC3B,IAAD,EAA0BC,KAA1B,EAAyD;AACrE;AACA;AACA,QAAIA,KAAK,CAAC2B,kCAAN,KAA6CjB,SAAjD,EAA4D;AAC5D,QAAIkB,QAAQ,GAAG5B,KAAK,CAAC2B,kCAAN,CAAyC5B,IAAI,CAACI,KAA9C,EAAqDJ,IAAI,CAACE,IAA1D,CAAf;AACA,QAAI2B,QAAQ,KAAKlB,SAAjB,EAA4B;AAC5BV,IAAAA,KAAK,CAACO,YAAN,CAAmBsB,YAAnB,CAAgClB,GAAhC,CAAoCZ,IAAI,CAACE,IAAzC,EAA+C2B,QAA/C;AACD,GA5B4B;;AA8B7BE,EAAAA,oBAAoB,CAAC/B,IAAD,EAA0BC,KAA1B,EAAyD;AAC3E,QAAIc,UAAU,CAACf,IAAD,CAAd,EAAsB;AAEtB,QAAIgC,SAAS,GAAGhC,IAAI,CAACE,IAAL,CAAUI,IAA1B;;AACA,QAAI0B,SAAS,KAAK,WAAlB,EAA+B;AAC7B,UAAI/B,KAAK,CAACO,YAAN,CAAmBe,KAAnB,KAA6B,CAAjC,EAAoC;AAClCtB,QAAAA,KAAK,CAACO,YAAN,CAAmByB,aAAnB,GAAmC,IAAnC;AACD,OAH4B,CAI7B;;;AACA;AACD;;AACDlC,IAAAA,SAAS,CAACC,IAAD,EAAOC,KAAP,EAAcD,IAAI,CAACE,IAAnB,EAAyB,KAAzB,CAAT;AACD,GA1C4B;;AA4C7BgC,EAAAA,cAAc,CAAClC,IAAD,EAA0BC,KAA1B,EAAyD;AACrE,QAAIA,KAAK,CAACO,YAAN,CAAmBe,KAAnB,GAA2BtB,KAAK,CAACO,YAAN,CAAmBkB,YAA9C,KAA+D,CAAnE,EAAsE;AACpEzB,MAAAA,KAAK,CAACO,YAAN,CAAmB2B,QAAnB,GAA8B,IAA9B;AACD;AACF,GAhD4B;;AAkD7B,0CAAwCnC,IAAxC,EAAiEC,KAAjE,EAAgG;AAC9F,QAAImC,GAAG,GAAGpC,IAAI,CAACqC,qBAAL,EAAV;;AACA,SAAK,IAAI/B,IAAT,IAAiB8B,GAAjB,EAAsB;AACpBrC,MAAAA,SAAS,CAACC,IAAD,EAAOC,KAAP,EAAcmC,GAAG,CAAC9B,IAAD,CAAjB,EAAyB,IAAzB,CAAT;AACD;AACF,GAvD4B;;AAyD7B,kCAAgCN,IAAhC,EAAyDC,KAAzD,EAAwF;AACtF,QAAID,IAAI,CAACE,IAAL,CAAUoC,IAAV,KAAmB,qBAAvB,EAA8C;AAC5C;AACA;AACA,YAAMF,GAAG,GAAGpC,IAAI,CAACU,GAAL,CAAS,MAAT,EAAiB2B,qBAAjB,EAAZ;;AACA,WAAK,MAAM/B,IAAX,IAAmB8B,GAAnB,EAAwB;AACtBrC,QAAAA,SAAS,CAACC,IAAD,EAAOC,KAAP,EAAcmC,GAAG,CAAC9B,IAAD,CAAjB,EAAyB,IAAzB,CAAT;AACD;AACF;AACF;;AAlE4B,CAAxB","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport { Realm } from \"../realm.js\";\nimport * as t from \"@babel/types\";\nimport type { BabelNodeCallExpression } from \"@babel/types\";\nimport type { BabelTraversePath, BabelTraverseScope } from \"@babel/traverse\";\nimport type { FunctionInfo } from \"./types.js\";\n\ntype GetModuleIdIfNodeIsRequireFunction =\n  | void\n  | ((scope: BabelTraverseScope, node: BabelNodeCallExpression) => void | number | string);\n\nexport type ClosureRefVisitorState = {\n  functionInfo: FunctionInfo,\n  realm: Realm,\n  getModuleIdIfNodeIsRequireFunction: GetModuleIdIfNodeIsRequireFunction,\n};\n\nfunction visitName(path, state, node, modified) {\n  // Is the name bound to some local identifier? If so, we don't need to do anything\n  if (path.scope.hasBinding(node.name, /*noGlobals*/ true)) return;\n\n  // Otherwise, let's record that there's an unbound identifier\n  let nodes = state.functionInfo.unbound.get(node.name);\n  if (nodes === undefined) state.functionInfo.unbound.set(node.name, (nodes = []));\n  nodes.push(node);\n  if (modified) state.functionInfo.modified.add(node.name);\n}\n\nfunction ignorePath(path: BabelTraversePath) {\n  let parent = path.parent;\n  return t.isLabeledStatement(parent) || t.isBreakStatement(parent) || t.isContinueStatement(parent);\n}\n\nexport let ClosureRefVisitor = {\n  \"FunctionDeclaration|ArrowFunctionExpression|FunctionExpression\": {\n    enter(path: BabelTraversePath, state: ClosureRefVisitorState) {\n      state.functionInfo.depth++;\n    },\n    exit(path: BabelTraversePath, state: ClosureRefVisitorState) {\n      state.functionInfo.depth--;\n    },\n  },\n\n  ArrowFunctionExpression: {\n    enter(path: BabelTraversePath, state: ClosureRefVisitorState) {\n      state.functionInfo.depth++;\n      state.functionInfo.lexicalDepth++;\n    },\n    exit(path: BabelTraversePath, state: ClosureRefVisitorState) {\n      state.functionInfo.depth--;\n      state.functionInfo.lexicalDepth--;\n    },\n  },\n\n  CallExpression(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    // Here we apply the require optimization by replacing require calls with their\n    // corresponding initialized modules.\n    if (state.getModuleIdIfNodeIsRequireFunction === undefined) return;\n    let moduleId = state.getModuleIdIfNodeIsRequireFunction(path.scope, path.node);\n    if (moduleId === undefined) return;\n    state.functionInfo.requireCalls.set(path.node, moduleId);\n  },\n\n  ReferencedIdentifier(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    if (ignorePath(path)) return;\n\n    let innerName = path.node.name;\n    if (innerName === \"arguments\") {\n      if (state.functionInfo.depth === 1) {\n        state.functionInfo.usesArguments = true;\n      }\n      // \"arguments\" bound to local scope. therefore, there's no need to visit this identifier.\n      return;\n    }\n    visitName(path, state, path.node, false);\n  },\n\n  ThisExpression(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    if (state.functionInfo.depth - state.functionInfo.lexicalDepth === 1) {\n      state.functionInfo.usesThis = true;\n    }\n  },\n\n  \"AssignmentExpression|UpdateExpression\"(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    let ids = path.getBindingIdentifiers();\n    for (let name in ids) {\n      visitName(path, state, ids[name], true);\n    }\n  },\n\n  \"ForInStatement|ForOfStatement\"(path: BabelTraversePath, state: ClosureRefVisitorState) {\n    if (path.node.left !== \"VariableDeclaration\") {\n      // `LeftHandSideExpression`s in a for-in/for-of statement perform `DestructuringAssignment` on the current loop\n      // value so we need to make sure we visit these bindings and mark them as modified.\n      const ids = path.get(\"left\").getBindingIdentifiers();\n      for (const name in ids) {\n        visitName(path, state, ids[name], true);\n      }\n    }\n  },\n};\n"],"file":"visitors.js"}