{"version":3,"sources":["../../src/serializer/Emitter.js"],"names":["Emitter","constructor","residualFunctions","referencedDeclaredValues","conditionalFeasibility","derivedIds","_mainBody","type","parentBody","undefined","entries","done","_waitingForValues","Map","_waitingForBodies","_body","_residualFunctions","_activeStack","_activeValues","Set","_activeGeneratorStack","_finalized","mustWaitForValue","val","cannotDeclare","hasBeenDeclared","activeOptimizedFunction","getActiveOptimizedFunction","optimizedFunctionWhereValueWasDeclared","get","_getReasonToWaitForDependenciesCallbacks","onActive","onFunction","addFunctionUsage","getBodyReference","onAbstractValueWithIdentifier","has","getIdentifier","onIntrinsicDerivedObject","_conditionalFeasibility","beginEmitting","dependency","targetBody","isChild","optimizedFunction","push","Value","add","Generator","includes","nestingLevel","oldBody","emit","statement","_processCurrentBody","finalizeCurrentBody","endEmitting","valuesToProcess","lastDependency","pop","delete","_processValue","_isEmittingActiveGenerator","lastBody","declaredValues","anyPropagated","b","parentDeclaredValues","key","value","set","processValues","finalize","length","size","_isGeneratorBody","body","processing","a","dependencies","func","shift","emitNowOrAfterWaitingForDependencies","currentBody","_emitAfterWaitingForGeneratorBody","_getFirstAncestorGeneratorWithActiveBody","bodyStack","activeBody","slice","reverse","find","getReasonToWaitForDependencies","dependenciesVisitor","callbacks","result","recurse","Array","isArray","values","FunctionValue","BoundFunctionValue","$BoundTargetFunction","$BoundThis","$BoundArguments","AbstractValue","hasIdentifier","argsToRecurse","kind","cf","t","f","args","ProxyValue","$ProxyTarget","$ProxyHandler","SymbolValue","$Description","ObjectValue","isIntrinsicDerivedObject","getKind","proto","$Prototype","usesOrdinaryObjectInternalPrototypeMethods","$DateValue","realm","$Realm","props","ref","getReasonToWaitForActiveValue","condition","emitAfterWaiting","delayReason","_emitAfterWaitingForValue","reason","declare","getDeclarationBody","declaredCount","getBody","isCurrentBodyOffspringOf","BodyReference"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport {\n  AbstractValue,\n  BoundFunctionValue,\n  FunctionValue,\n  ObjectValue,\n  ProxyValue,\n  SymbolValue,\n  Value,\n} from \"../values/index.js\";\nimport type { BabelNodeStatement } from \"@babel/types\";\nimport type { SerializedBody } from \"./types.js\";\nimport { Generator, type TemporalOperationEntry } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport { BodyReference } from \"./types.js\";\nimport { ResidualFunctions } from \"./ResidualFunctions.js\";\nimport { getProperty } from \"../react/utils.js\";\n\n// Type used to configure callbacks from the dependenciesVisitor of the Emitter.\ntype EmitterDependenciesVisitorCallbacks<T> = {\n  // Callback invoked whenever an \"active\" dependency is visited, i.e. a dependency which is in the process of being emitted.\n  // A return value that is not undefined indicates that the visitor should stop, and return the value as the overall result.\n  onActive?: Value => void | T,\n  // Callback invoked whenever a dependency is visited that is a FunctionValue.\n  // A return value that is not undefined indicates that the visitor should stop, and return the value as the overall result.\n  onFunction?: FunctionValue => void | T,\n  // Callback invoked whenever a dependency is visited that is an abstract value with an identifier.\n  // A return value that is not undefined indicates that the visitor should stop, and return the value as the overall result.\n  onAbstractValueWithIdentifier?: AbstractValue => void | T,\n  // Callback invoked whenever a dependency is visited that is an intrinsic object that was derived\n  // A return value that is not undefined indicates that the visitor should stop, and return the value as the overall result.\n  onIntrinsicDerivedObject?: ObjectValue => void | T,\n};\n\n// The emitter keeps track of a stack of what's currently being emitted.\n// There are two kinds of interesting dependencies the emitter is dealing with:\n// 1. Value dependencies:\n//    If an emission task depends on the result of another emission task which\n//    is still currently being emitted, then the emission task must be performed later,\n//    once the dependency is available.\n//    To this end, the emitter maintains the `_activeValues` and `_waitingForValues` datastructures.\n// 2. Generator dependencies:\n//    For each generator, there's a corresponding \"body\", i.e. a stream of babel statements\n//    that the emitter is appending to.\n//    There's always a \"current\" body that is currently being emitted to.\n//    There's also a distinguished `mainBody` to which all statements get directly or indirectly appended.\n//    If there are multiple generators/bodies involved, then they form a stack.\n//    Nested bodies are usually composed into an instruction emitted to the outer body.\n//    For example, two nested generators may yield the then and else-branch of an `if` statement.\n//    When an emission is supposed to target a body that is the current body, i.e. when it sits\n//    lower on the stack, then the emission task gets delayed until the next emission task on\n//    the lower body entry is finished.\n//    To this end, the emitter maintains the `_activeGeneratorStack` and `_waitingForBodies` datastructures.\nexport class Emitter {\n  constructor(\n    residualFunctions: ResidualFunctions,\n    referencedDeclaredValues: Map<Value, void | FunctionValue>,\n    conditionalFeasibility: Map<AbstractValue, { t: boolean, f: boolean }>,\n    derivedIds: Map<string, TemporalOperationEntry>\n  ) {\n    this._mainBody = { type: \"MainGenerator\", parentBody: undefined, entries: [], done: false };\n    this._waitingForValues = new Map();\n    this._waitingForBodies = new Map();\n    this._body = this._mainBody;\n    this._residualFunctions = residualFunctions;\n    this._activeStack = [];\n    this._activeValues = new Set();\n    this._activeGeneratorStack = [this._mainBody];\n    this._finalized = false;\n    let mustWaitForValue = (val: AbstractValue | ObjectValue) => {\n      if (this.cannotDeclare()) return false;\n      if (this.hasBeenDeclared(val)) return false;\n      let activeOptimizedFunction = this.getActiveOptimizedFunction();\n      if (activeOptimizedFunction === undefined) return true;\n      let optimizedFunctionWhereValueWasDeclared = referencedDeclaredValues.get(val);\n      return optimizedFunctionWhereValueWasDeclared === activeOptimizedFunction;\n    };\n    this._getReasonToWaitForDependenciesCallbacks = {\n      onActive: val => val, // cyclic dependency; we need to wait until this value has finished emitting\n      onFunction: val => {\n        // Functions are currently handled in a special way --- they are all defined ahead of time. Thus, we never have to wait for functions.\n        this._residualFunctions.addFunctionUsage(val, this.getBodyReference());\n        return undefined;\n      },\n      onAbstractValueWithIdentifier: val =>\n        derivedIds.has(val.getIdentifier()) && mustWaitForValue(val) ? val : undefined,\n      onIntrinsicDerivedObject: val => (mustWaitForValue(val) ? val : undefined),\n    };\n    this._conditionalFeasibility = conditionalFeasibility;\n  }\n\n  _finalized: boolean;\n  _activeStack: Array<string | Generator | Value>;\n  _activeValues: Set<Value>;\n  _activeGeneratorStack: Array<SerializedBody>; // Contains all the active generator bodies in stack order.\n  _residualFunctions: ResidualFunctions;\n  _waitingForValues: Map<Value, Array<{ body: SerializedBody, dependencies: Array<Value>, func: () => void }>>;\n  _waitingForBodies: Map<SerializedBody, Array<{ dependencies: Array<Value>, func: () => void }>>;\n  _body: SerializedBody;\n  _mainBody: SerializedBody;\n  _getReasonToWaitForDependenciesCallbacks: EmitterDependenciesVisitorCallbacks<Value>;\n  _conditionalFeasibility: Map<AbstractValue, { t: boolean, f: boolean }>;\n\n  // Begin to emit something. Such sessions can be nested.\n  // The dependency indicates what is being emitted; until this emission ends, other parties might have to wait for the dependency.\n  // The targetBody is a wrapper that holds the sequence of statements that are going to be emitted.\n  // If isChild, then we are starting a new emitting session as a branch off the previously active emitting session.\n  beginEmitting(\n    dependency: string | Generator | Value,\n    targetBody: SerializedBody,\n    isChild: boolean = false\n  ): SerializedBody {\n    invariant(!this._finalized);\n    invariant((targetBody.type === \"OptimizedFunction\") === !!targetBody.optimizedFunction);\n    this._activeStack.push(dependency);\n    if (dependency instanceof Value) {\n      invariant(!this._activeValues.has(dependency));\n      this._activeValues.add(dependency);\n    } else if (dependency instanceof Generator) {\n      invariant(!this._activeGeneratorStack.includes(targetBody));\n      this._activeGeneratorStack.push(targetBody);\n    }\n    if (isChild) {\n      targetBody.parentBody = this._body;\n      targetBody.nestingLevel = (this._body.nestingLevel || 0) + 1;\n    }\n    let oldBody = this._body;\n    this._body = targetBody;\n    return oldBody;\n  }\n  emit(statement: BabelNodeStatement): void {\n    invariant(!this._finalized);\n    this._body.entries.push(statement);\n    this._processCurrentBody();\n  }\n  finalizeCurrentBody(): void {\n    invariant(!this._finalized);\n    this._processCurrentBody();\n  }\n  // End to emit something. The parameters dependency and isChild must match a previous call to beginEmitting.\n  // oldBody should be the value returned by the previous matching beginEmitting call.\n  // valuesToProcess is filled with values that have been newly declared since the last corresponding beginEmitting call;\n  // other values not yet have been emitted as they might be waiting for valuesToProcess;\n  // processValues(valuesToProcess) should be called once the returned body has been embedded in the outer context.\n  endEmitting(\n    dependency: string | Generator | Value,\n    oldBody: SerializedBody,\n    valuesToProcess: void | Set<AbstractValue | ObjectValue>,\n    isChild: boolean = false\n  ): SerializedBody {\n    invariant(!this._finalized);\n    let lastDependency = this._activeStack.pop();\n    invariant(dependency === lastDependency);\n    if (dependency instanceof Value) {\n      invariant(this._activeValues.has(dependency));\n      this._activeValues.delete(dependency);\n      this._processValue(dependency);\n    } else if (dependency instanceof Generator) {\n      invariant(this._isEmittingActiveGenerator());\n      this._activeGeneratorStack.pop();\n    }\n    let lastBody = this._body;\n    this._body = oldBody;\n    if (isChild) {\n      invariant(lastBody.parentBody === oldBody);\n      invariant((lastBody.nestingLevel || 0) > 0);\n      invariant(!lastBody.done);\n      lastBody.done = true;\n      // When we are done processing a body, we can propogate all declared abstract values\n      // to its parent, possibly unlocking further processing...\n      if (lastBody.declaredValues) {\n        let anyPropagated = true;\n        for (let b = lastBody; b.done && b.parentBody !== undefined && anyPropagated; b = b.parentBody) {\n          anyPropagated = false;\n          let parentDeclaredValues = b.parentBody.declaredValues;\n          if (parentDeclaredValues === undefined) b.parentBody.declaredValues = parentDeclaredValues = new Map();\n          invariant(b.declaredValues);\n          for (let [key, value] of b.declaredValues) {\n            if (!parentDeclaredValues.has(key)) {\n              parentDeclaredValues.set(key, value);\n              if (valuesToProcess !== undefined) valuesToProcess.add(key);\n              anyPropagated = true;\n            }\n          }\n        }\n      }\n    }\n\n    return lastBody;\n  }\n  processValues(valuesToProcess: Set<AbstractValue | ObjectValue>): void {\n    for (let value of valuesToProcess) this._processValue(value);\n  }\n  finalize(): void {\n    invariant(!this._finalized);\n    invariant(this._activeGeneratorStack.length === 1);\n    invariant(this._activeGeneratorStack[0] === this._body);\n    invariant(this._body === this._mainBody);\n    this._processCurrentBody();\n    this._activeGeneratorStack.pop();\n    this._finalized = true;\n    invariant(this._waitingForBodies.size === 0);\n    invariant(this._waitingForValues.size === 0);\n    invariant(this._activeStack.length === 0);\n    invariant(this._activeValues.size === 0);\n    invariant(this._activeGeneratorStack.length === 0);\n  }\n  /**\n   * Emitter is emitting in two modes:\n   * 1. Emitting to entries in current active generator\n   * 2. Emitting to body of another scope(generator or residual function)\n   * This function checks the first condition above.\n   */\n  _isEmittingActiveGenerator(): boolean {\n    invariant(this._activeGeneratorStack.length > 0);\n    return this._activeGeneratorStack[this._activeGeneratorStack.length - 1] === this._body;\n  }\n  _isGeneratorBody(body: SerializedBody): boolean {\n    return body.type === \"MainGenerator\" || body.type === \"Generator\" || body.type === \"OptimizedFunction\";\n  }\n  _processCurrentBody(): void {\n    if (!this._isEmittingActiveGenerator() || this._body.processing) {\n      return;\n    }\n    let a = this._waitingForBodies.get(this._body);\n    if (a === undefined) return;\n    this._body.processing = true;\n    while (a.length > 0) {\n      let { dependencies, func } = a.shift();\n      this.emitNowOrAfterWaitingForDependencies(dependencies, func, this._body);\n    }\n    this._waitingForBodies.delete(this._body);\n    this._body.processing = false;\n  }\n  _processValue(value: Value): void {\n    let a = this._waitingForValues.get(value);\n    if (a === undefined) return;\n    let currentBody = this._body;\n    while (a.length > 0) {\n      let { body, dependencies, func } = a.shift();\n      // If body is not generator body no need to wait for it.\n      if (this._isGeneratorBody(body) && body !== currentBody) {\n        this._emitAfterWaitingForGeneratorBody(body, dependencies, func);\n      } else {\n        this.emitNowOrAfterWaitingForDependencies(dependencies, func, body);\n      }\n    }\n    this._waitingForValues.delete(value);\n  }\n\n  // Find the first ancestor in input generator body stack that is in current active stack.\n  // It can always find one because the bottom one in the stack is the main generator.\n  _getFirstAncestorGeneratorWithActiveBody(bodyStack: Array<SerializedBody>): SerializedBody {\n    const activeBody = bodyStack\n      .slice()\n      .reverse()\n      .find(body => this._activeGeneratorStack.includes(body));\n    invariant(activeBody);\n    return activeBody;\n  }\n\n  // Serialization of a statement related to a value MUST be delayed if\n  // the creation of the value's identity requires the availability of either:\n  // 1. a value that is also currently being serialized\n  //    (tracked by `_activeValues`).\n  // 2. a time-dependent value that is declared by some generator entry\n  //    that has not yet been processed\n  //    (tracked by `declaredValues` in bodies)\n  getReasonToWaitForDependencies(dependencies: Value | Array<Value>): void | Value {\n    return this.dependenciesVisitor(dependencies, this._getReasonToWaitForDependenciesCallbacks);\n  }\n\n  // Visitor of dependencies that require delaying serialization\n  dependenciesVisitor<T>(\n    dependencies: Value | Array<Value>,\n    callbacks: EmitterDependenciesVisitorCallbacks<T>\n  ): void | T {\n    invariant(!this._finalized);\n\n    let result;\n    let recurse = value => this.dependenciesVisitor(value, callbacks);\n\n    if (Array.isArray(dependencies)) {\n      let values = ((dependencies: any): Array<Value>);\n      for (let value of values) {\n        result = recurse(value);\n        if (result !== undefined) return result;\n      }\n      return undefined;\n    }\n\n    let val = ((dependencies: any): Value);\n    if (this._activeValues.has(val)) {\n      // If a value is active and it's a function, then we still shouldn't wait on it.\n      if (val instanceof FunctionValue && !(val instanceof BoundFunctionValue)) {\n        // We ran into a function value.\n        result = callbacks.onFunction ? callbacks.onFunction(val) : undefined;\n        return result;\n      }\n      // We ran into a cyclic dependency, where the value we are dependending on is still in the process of being emitted.\n      result = callbacks.onActive ? callbacks.onActive(val) : undefined;\n      if (result !== undefined) return result;\n    }\n\n    if (val instanceof BoundFunctionValue) {\n      result = recurse(val.$BoundTargetFunction);\n      if (result !== undefined) return result;\n      result = recurse(val.$BoundThis);\n      if (result !== undefined) return result;\n      result = recurse(val.$BoundArguments);\n      if (result !== undefined) return result;\n    } else if (val instanceof FunctionValue) {\n      // We ran into a function value.\n      result = callbacks.onFunction ? callbacks.onFunction(val) : undefined;\n      if (result !== undefined) return result;\n    } else if (val instanceof AbstractValue) {\n      if (val.hasIdentifier()) {\n        // We ran into an abstract value that might have to be declared.\n        result = callbacks.onAbstractValueWithIdentifier ? callbacks.onAbstractValueWithIdentifier(val) : undefined;\n        if (result !== undefined) return result;\n      }\n      let argsToRecurse;\n      if (val.kind === \"conditional\") {\n        let cf = this._conditionalFeasibility.get(val);\n        invariant(cf !== undefined);\n        argsToRecurse = [];\n        if (cf.t && cf.f) argsToRecurse.push(val.args[0]);\n        if (cf.t) argsToRecurse.push(val.args[1]);\n        if (cf.f) argsToRecurse.push(val.args[2]);\n      } else argsToRecurse = val.args;\n      result = recurse(argsToRecurse);\n      if (result !== undefined) return result;\n    } else if (val instanceof ProxyValue) {\n      result = recurse(val.$ProxyTarget);\n      if (result !== undefined) return result;\n      result = recurse(val.$ProxyHandler);\n      if (result !== undefined) return result;\n    } else if (val instanceof SymbolValue) {\n      if (val.$Description instanceof Value) {\n        result = recurse(val.$Description);\n        if (result !== undefined) return result;\n      }\n    } else if (val instanceof ObjectValue && ObjectValue.isIntrinsicDerivedObject(val)) {\n      result = callbacks.onIntrinsicDerivedObject ? callbacks.onIntrinsicDerivedObject(val) : undefined;\n      if (result !== undefined) return result;\n    } else if (val instanceof ObjectValue) {\n      let kind = val.getKind();\n      switch (kind) {\n        case \"Object\":\n          let proto = val.$Prototype;\n          if (\n            proto instanceof ObjectValue &&\n            // if this is falsy, prototype chain might be cyclic\n            proto.usesOrdinaryObjectInternalPrototypeMethods()\n          ) {\n            result = recurse(val.$Prototype);\n            if (result !== undefined) return result;\n          }\n          break;\n        case \"Date\":\n          invariant(val.$DateValue !== undefined);\n          result = recurse(val.$DateValue);\n          if (result !== undefined) return result;\n          break;\n        case \"ReactElement\":\n          let realm = val.$Realm;\n          let type = getProperty(realm, val, \"type\");\n          let props = getProperty(realm, val, \"props\");\n          let key = getProperty(realm, val, \"key\");\n          let ref = getProperty(realm, val, \"ref\");\n          result = recurse(type);\n          if (result !== undefined) return result;\n          result = recurse(props);\n          if (result !== undefined) return result;\n          result = recurse(key);\n          if (result !== undefined) return result;\n          result = recurse(ref);\n          if (result !== undefined) return result;\n          break;\n        default:\n          break;\n      }\n    }\n\n    return undefined;\n  }\n\n  // Wait for a known-to-be active value if a condition is met.\n  getReasonToWaitForActiveValue(value: Value, condition: boolean): void | Value {\n    invariant(!this._finalized);\n    invariant(this._activeValues.has(value));\n    return condition ? value : undefined;\n  }\n  emitAfterWaiting(\n    delayReason: void | Value | SerializedBody,\n    dependencies: Array<Value>,\n    func: () => void,\n    targetBody: SerializedBody\n  ): void {\n    if (delayReason === undefined && this._isGeneratorBody(targetBody)) {\n      delayReason = targetBody;\n    }\n\n    if (delayReason === undefined || delayReason === this._body) {\n      if (targetBody === this._body) {\n        // Emit into current body.\n        func();\n      } else {\n        invariant(!this._isGeneratorBody(targetBody));\n        // TODO: Check if effects really don't matter here,\n        // since we are going to emit something in an out-of-band body\n        // that might depend on applied effects.\n        const oldBody = this.beginEmitting(targetBody.type, targetBody);\n        func();\n        this.endEmitting(targetBody.type, oldBody);\n      }\n    } else {\n      invariant(delayReason !== undefined);\n      if (delayReason instanceof Value) {\n        this._emitAfterWaitingForValue(delayReason, dependencies, targetBody, func);\n      } else if (this._isGeneratorBody(delayReason)) {\n        // delayReason is a generator body.\n        this._emitAfterWaitingForGeneratorBody(delayReason, dependencies, func);\n      } else {\n        // Unknown delay reason.\n        invariant(false);\n      }\n    }\n  }\n  _emitAfterWaitingForValue(\n    reason: Value,\n    dependencies: Array<Value>,\n    targetBody: SerializedBody,\n    func: () => void\n  ): void {\n    invariant(!this._finalized);\n    invariant(!(reason instanceof AbstractValue && this.hasBeenDeclared(reason)) || this._activeValues.has(reason));\n    let a = this._waitingForValues.get(reason);\n    if (a === undefined) this._waitingForValues.set(reason, (a = []));\n    a.push({ body: targetBody, dependencies, func });\n  }\n  _emitAfterWaitingForGeneratorBody(reason: SerializedBody, dependencies: Array<Value>, func: () => void): void {\n    invariant(this._isGeneratorBody(reason));\n    invariant(!this._finalized);\n    invariant(this._activeGeneratorStack.includes(reason));\n    let b = this._waitingForBodies.get(reason);\n    if (b === undefined) {\n      this._waitingForBodies.set(reason, (b = []));\n    }\n    b.push({ dependencies, func });\n  }\n  emitNowOrAfterWaitingForDependencies(dependencies: Array<Value>, func: () => void, targetBody: SerializedBody): void {\n    this.emitAfterWaiting(this.getReasonToWaitForDependencies(dependencies), dependencies, func, targetBody);\n  }\n  declare(value: AbstractValue | ObjectValue): void {\n    invariant(!this._finalized);\n    invariant(!this._activeValues.has(value));\n    invariant(value instanceof ObjectValue || value.hasIdentifier());\n    invariant(this._isEmittingActiveGenerator());\n    invariant(!this.cannotDeclare());\n    invariant(!this._body.done);\n    if (this._body.declaredValues === undefined) this._body.declaredValues = new Map();\n    this._body.declaredValues.set(value, this._body);\n    this._processValue(value);\n  }\n  getActiveOptimizedFunction(): void | FunctionValue {\n    // Whether we are directly or indirectly emitting to an optimized function\n    for (let b = this._body; b !== undefined; b = b.parentBody)\n      if (b.type === \"OptimizedFunction\") return b.optimizedFunction;\n    return undefined;\n  }\n  cannotDeclare(): boolean {\n    // Bodies of the following types will never contain any (temporal) abstract value declarations.\n    return this._body.type === \"DelayInitializations\" || this._body.type === \"LazyObjectInitializer\";\n  }\n  hasBeenDeclared(value: AbstractValue | ObjectValue): boolean {\n    return this.getDeclarationBody(value) !== undefined;\n  }\n  getDeclarationBody(value: AbstractValue | ObjectValue): void | SerializedBody {\n    for (let b = this._body; b !== undefined; b = b.parentBody) {\n      if (b.declaredValues !== undefined && b.declaredValues.has(value)) {\n        return b;\n      }\n    }\n    return undefined;\n  }\n  declaredCount(): number {\n    let declaredValues = this._body.declaredValues;\n    return declaredValues === undefined ? 0 : declaredValues.size;\n  }\n  getBody(): SerializedBody {\n    return this._body;\n  }\n  isCurrentBodyOffspringOf(targetBody: SerializedBody): boolean {\n    let currentBody = this._body;\n    while (currentBody !== undefined) {\n      if (currentBody === targetBody) {\n        return true;\n      }\n      currentBody = currentBody.parentBody;\n    }\n    return false;\n  }\n  getBodyReference(): BodyReference {\n    invariant(!this._finalized);\n    return new BodyReference(this._body, this._body.entries.length);\n  }\n}\n"],"file":"Emitter.js"}