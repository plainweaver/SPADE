{"version":3,"sources":["../../src/serializer/ResidualFunctions.js"],"names":["ResidualFunctions","constructor","realm","options","modules","requireReturns","locationService","prelude","factoryNameGenerator","residualFunctionInfos","residualFunctionInstances","residualClassMethodInstances","additionalFunctionValueInfos","additionalFunctionValueNestedFunctions","referentializer","functionPrototypes","Map","firstFunctionUsages","functions","classes","functionInstances","residualFunctionInitializers","ResidualFunctionInitializers","instance","values","undefined","has","functionValue","addFunctionInstance","additionalFunctionPreludes","keys","set","getStatistics","statistics","SerializerStatistics","push","code","$ECMAScriptCode","setFunctionPrototype","prototypeId","addFunctionUsage","val","bodyReference","_shouldUseFactoryFunction","funcBody","instances","length","shouldInlineFunction","scopeInstances","size","shouldInline","start","end","bodySize","functionInfo","get","usesArguments","hasAnyLeakedIds","scope","leakedIds","_getIdentifierReplacements","residualFunctionBindings","unbound","res","name","nodes","residualFunctionBinding","declarativeEnvironmentRecord","value","serializedValue","replacement","referentialized","node","_getCallReplacements","requireCalls","modified","callNode","moduleId","callee","requireCallsReplaced","_hasRewrittenFunctionInstance","rewrittenAdditionalFunctions","find","_generateFactoryFunctionInfos","factoryFunctionInfos","functionBody","factoryId","suffix","__originalName","debugNames","t","identifier","generate","getLocation","functionUniqueTag","uniqueOrderedTag","anyContainingAdditionalFunction","every","containingAdditionalFunction","_sortFunctionByOriginalOrdering","functionEntries","sort","funcA","funcB","funcAUniqueTag","funcBUniqueTag","_createFunctionExpression","params","body","isLexical","Object","assign","arrowFunctionExpression","functionExpression","spliceFunctions","scrubFunctionInitializers","functionBodies","additionalFunctionModifiedBindingsSegment","getModifiedBindingsSegment","additionalFunction","getFunctionBody","getPrelude","b","Array","from","entries","unstrictFunctionBodies","strictFunctionBodies","registerFunctionStrictness","strict","isFunctionExpression","isArrowFunctionExpression","funcNodes","defineFunction","funcId","funcOrClassNode","initializationStatements","initializationBody","prototype","apply","isCallExpression","isClassExpression","variableDeclaration","variableDeclarator","id","memberExpression","funcValue","funcInfo","scopes","Set","residualBinding","modifiedBindings","add","bodySegment","referentializationScope","init","getReferentializedScopeInitialization","numericLiteral","additionalFunctionInfo","$FormalParameters","$ThisMode","rewrittenBody","blockStatement","classMethodInstance","methodType","classMethodKeyNode","classSuperNode","classMethodComputed","classPrototype","classMethodIsStatic","isConstructor","ObjectValue","isExpression","isIdentifier","_getOrCreateClassNode","classMethod","unshift","superClass","ECMAScriptSourceFunctionValue","$Strict","usesThis","normalInstances","additionalFunctionNestedInstances","naiveProcessInstances","instancesToSplice","functionClones","hasEmptyConstructor","$HasEmptyConstructor","methodParams","slice","ResidualFunctionInstantiator","instantiate","scopeInitialization","concat","funcOrClassNodeBody","isBlockStatement","factoryInfo","factoryNames","sameResidualBindings","isDifferent","lastBinding","firstBinding","factoryParams","key","scopeName","scopeNameId","factoryNode","factoryNodeBody","factoryDeclaration","insertionPoint","functionId","hasFunctionArg","flatArgs","map","FunctionValue","funcNode","firstUsage","hasInitializerStatement","isNotEarlierThan","callArgs","thisExpression","flatArg","param","type","FatalError","childBody","returnStatement","callExpression","nullExpression","referentializationState","createCapturedScopesPrelude","createLeakedIds","reverse","BodyReference","splice","index","initializerStatement","getInitializerStatement","classExpression","classBody"],"mappings":";;;;;;;AAWA;;AACA;;AACA;;AAEA;;AAgBA;;AAQA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AACA;;;;;;AA/CA;;;;;;;;AAsDO,MAAMA,iBAAN,CAAwB;AAC7BC,EAAAA,WAAW,CACTC,KADS,EAETC,OAFS,EAGTC,OAHS,EAITC,cAJS,EAKTC,eALS,EAMTC,OANS,EAOTC,oBAPS,EAQTC,qBARS,EASTC,yBATS,EAUTC,4BAVS,EAWTC,4BAXS,EAYTC,sCAZS,EAaTC,eAbS,EAcT;AACA,SAAKZ,KAAL,GAAaA,KAAb;AACA,SAAKE,OAAL,GAAeA,OAAf;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKC,eAAL,GAAuBA,eAAvB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,oBAAL,GAA4BA,oBAA5B;AACA,SAAKO,kBAAL,GAA0B,IAAIC,GAAJ,EAA1B;AACA,SAAKC,mBAAL,GAA2B,IAAID,GAAJ,EAA3B;AACA,SAAKE,SAAL,GAAiB,IAAIF,GAAJ,EAAjB;AACA,SAAKG,OAAL,GAAe,IAAIH,GAAJ,EAAf;AACA,SAAKI,iBAAL,GAAyB,EAAzB;AACA,SAAKC,4BAAL,GAAoC,IAAIC,0DAAJ,CAAiChB,eAAjC,CAApC;AACA,SAAKG,qBAAL,GAA6BA,qBAA7B;AACA,SAAKC,yBAAL,GAAiCA,yBAAjC;AACA,SAAKC,4BAAL,GAAoCA,4BAApC;AACA,SAAKC,4BAAL,GAAoCA,4BAApC;AACA,SAAKE,eAAL,GAAuBA,eAAvB;;AACA,SAAK,IAAIS,QAAT,IAAqBb,yBAAyB,CAACc,MAA1B,EAArB,EAAyD;AACvD,8BAAUD,QAAQ,KAAKE,SAAvB;AACA,UAAI,CAACb,4BAA4B,CAACc,GAA7B,CAAiCH,QAAQ,CAACI,aAA1C,CAAL,EAA+D,KAAKC,mBAAL,CAAyBL,QAAzB;AAChE;;AACD,SAAKV,sCAAL,GAA8CA,sCAA9C;AACA,SAAKgB,0BAAL,GAAkC,IAAIb,GAAJ,EAAlC;;AACA,SAAK,IAAIW,aAAT,IAA0Bf,4BAA4B,CAACkB,IAA7B,EAA1B,EAA+D;AAC7D,WAAKD,0BAAL,CAAgCE,GAAhC,CAAoCJ,aAApC,EAAmD,EAAnD;AACD;AACF;;AAsBDK,EAAAA,aAAa,GAAyB;AACpC,4BAAU,KAAK9B,KAAL,CAAW+B,UAAX,YAAiCC,gCAA3C,EAAiE,6CAAjE;AACA,WAAO,KAAKhC,KAAL,CAAW+B,UAAlB;AACD;;AAEDL,EAAAA,mBAAmB,CAACL,QAAD,EAAmC;AACpD,SAAKH,iBAAL,CAAuBe,IAAvB,CAA4BZ,QAA5B;AACA,QAAIa,IAAI,GAAGb,QAAQ,CAACI,aAAT,CAAuBU,eAAlC;AACA,4BAAUD,IAAI,IAAI,IAAlB;AACA,6BAAa,KAAKlB,SAAlB,EAA6BkB,IAA7B,EAAmC,MAAM,EAAzC,EAA6CD,IAA7C,CAAkDZ,QAAlD;AACD;;AAEDe,EAAAA,oBAAoB,CAACrC,WAAD,EAA6BsC,WAA7B,EAAqE;AACvF,SAAKxB,kBAAL,CAAwBgB,GAAxB,CAA4B9B,WAA5B,EAAyCsC,WAAzC;AACD;;AAEDC,EAAAA,gBAAgB,CAACC,GAAD,EAAqBC,aAArB,EAAyD;AACvE,QAAI,CAAC,KAAKzB,mBAAL,CAAyBS,GAAzB,CAA6Be,GAA7B,CAAL,EAAwC,KAAKxB,mBAAL,CAAyBc,GAAzB,CAA6BU,GAA7B,EAAkCC,aAAlC;AACzC;;AAEDC,EAAAA,yBAAyB,CAACC,QAAD,EAAoCC,SAApC,EAAiF;AACxG,4BAAUA,SAAS,CAACC,MAAV,GAAmB,CAA7B;;AACA,aAASC,oBAAT,GAAyC;AACvC,UAAIF,SAAS,CAAC,CAAD,CAAT,CAAaG,cAAb,CAA4BC,IAA5B,GAAmC,CAAvC,EAA0C,OAAO,KAAP;AAC1C,UAAIC,YAAY,GAAG,IAAnB;;AACA,UAAIN,QAAQ,CAACO,KAAT,IAAkBP,QAAQ,CAACQ,GAA/B,EAAoC;AAClC,YAAIC,QAAQ,GAAGT,QAAQ,CAACQ,GAAT,GAAeR,QAAQ,CAACO,KAAvC;AACAD,QAAAA,YAAY,GAAGG,QAAQ,IAAI,EAA3B;AACD;;AACD,aAAOH,YAAP;AACD;;AACD,QAAII,YAAY,GAAG,KAAK7C,qBAAL,CAA2B8C,GAA3B,CAA+BX,QAA/B,CAAnB;AACA,4BAAUU,YAAV;AACA,QAAI;AAAEE,MAAAA;AAAF,QAAoBF,YAAxB;AACA,QAAIG,eAAe,GAAG,KAAtB;;AACA,SAAK,MAAMlC,QAAX,IAAuBsB,SAAvB,EACE,KAAK,MAAMa,KAAX,IAAoBnC,QAAQ,CAACyB,cAAT,CAAwBxB,MAAxB,EAApB,EAAsD,IAAIkC,KAAK,CAACC,SAAN,CAAgBb,MAAhB,GAAyB,CAA7B,EAAgCW,eAAe,GAAG,IAAlB;;AACxF,WAAO,CAACV,oBAAoB,EAArB,IAA2BF,SAAS,CAACC,MAAV,GAAmB,CAA9C,IAAmD,CAACU,aAApD,IAAqE,CAACC,eAA7E;AACD;;AAEDG,EAAAA,0BAA0B,CACxBhB,QADwB,EAExBiB,wBAFwB,EAGe;AACvC,QAAIP,YAAY,GAAG,KAAK7C,qBAAL,CAA2B8C,GAA3B,CAA+BX,QAA/B,CAAnB;AACA,4BAAUU,YAAV;AACA,QAAI;AAAEQ,MAAAA;AAAF,QAAcR,YAAlB;AACA,QAAIS,GAAG,GAAG,IAAI/C,GAAJ,EAAV;;AACA,SAAK,IAAI,CAACgD,IAAD,EAAOC,KAAP,CAAT,IAA0BH,OAA1B,EAAmC;AACjC,UAAII,uBAAuB,GAAGL,wBAAwB,CAACN,GAAzB,CAA6BS,IAA7B,CAA9B;AACA,UAAIE,uBAAuB,KAAKzC,SAAhC,EAA2C,SAFV,CAIjC;AACA;AACA;;AACA,UACEyC,uBAAuB,CAACC,4BAAxB,KAAyD,IAAzD,IACAD,uBAAuB,CAACE,KAAxB,KAAkC3C,SAFpC,EAGE;AACA;AACD;;AAED,UAAI4C,eAAe,GAAGH,uBAAuB,CAACG,eAA9C;AACA,8BAAUA,eAAe,KAAK5C,SAA9B;AACA,UAAI6C,WAAW,GAAG,kDAChBD,eADgB,EAEhBH,uBAAuB,CAACK,eAAxB,GAA0C9C,SAA1C,GAAsDyC,uBAAuB,CAACE,KAF9D,CAAlB;;AAIA,WAAK,IAAII,IAAT,IAAiBP,KAAjB,EAAwBF,GAAG,CAAChC,GAAJ,CAAQyC,IAAR,EAAcF,WAAd;AACzB;;AACD,WAAOP,GAAP;AACD;;AAEDU,EAAAA,oBAAoB,CAAC7B,QAAD,EAAiE;AACnF,QAAIU,YAAY,GAAG,KAAK7C,qBAAL,CAA2B8C,GAA3B,CAA+BX,QAA/B,CAAnB;AACA,4BAAUU,YAAV;AACA,QAAI;AAAEoB,MAAAA,YAAF;AAAgBC,MAAAA;AAAhB,QAA6BrB,YAAjC;AACA,QAAIS,GAAG,GAAG,IAAI/C,GAAJ,EAAV;;AACA,SAAK,IAAI,CAAC4D,QAAD,EAAWC,QAAX,CAAT,IAAiCH,YAAjC,EAA+C;AAC7C,WAAK1C,aAAL,GAAqB0C,YAArB;AACA,UAAIC,QAAQ,CAACjD,GAAT,CAAakD,QAAQ,CAACE,MAAT,CAAgBd,IAA7B,CAAJ,EAAwC;AAExC,UAAIM,WAAW,GAAG,KAAKjE,cAAL,CAAoBkD,GAApB,CAAwB,KAAKsB,QAA7B,CAAlB;;AACA,UAAIP,WAAW,KAAK7C,SAApB,EAA+B;AAC7B,aAAKO,aAAL,GAAqB+C,oBAArB;AACAhB,QAAAA,GAAG,CAAChC,GAAJ,CAAQ6C,QAAR,EAAkBN,WAAlB;AACD;AACF;;AACD,WAAOP,GAAP;AACD,GAzJ4B,CA2J7B;;;AACAiB,EAAAA,6BAA6B,CAC3BC,4BAD2B,EAE3BpC,SAF2B,EAGlB;AACT,WAAOA,SAAS,CAACqC,IAAV,CAAe3D,QAAQ,IAAI0D,4BAA4B,CAACvD,GAA7B,CAAiCH,QAAQ,CAACI,aAA1C,CAA3B,MAAyFF,SAAhG;AACD;;AAED0D,EAAAA,6BAA6B,CAC3BF,4BAD2B,EAEO;AAClC,UAAMG,oBAAoB,GAAG,IAAIpE,GAAJ,EAA7B;;AACA,SAAK,MAAM,CAACqE,YAAD,EAAexC,SAAf,CAAX,IAAwC,KAAK3B,SAA7C,EAAwD;AACtD,8BAAU2B,SAAS,CAACC,MAAV,GAAmB,CAA7B;AAEA,UAAIwC,SAAJ;AACA,YAAMC,MAAM,GAAG1C,SAAS,CAAC,CAAD,CAAT,CAAalB,aAAb,CAA2B6D,cAA3B,IAA6C,KAAKtF,KAAL,CAAWuF,UAAxD,GAAqE,iBAArE,GAAyF,EAAxG;;AACA,UAAI,KAAK9C,yBAAL,CAA+B0C,YAA/B,EAA6CxC,SAA7C,CAAJ,EAA6D;AAC3D;AACA,gCAAU,CAAC,KAAKmC,6BAAL,CAAmCC,4BAAnC,EAAiEpC,SAAjE,CAAX;AACAyC,QAAAA,SAAS,GAAGI,CAAC,CAACC,UAAF,CAAa,KAAKnF,oBAAL,CAA0BoF,QAA1B,CAAmCL,MAAnC,CAAb,CAAZ;AACD,OAJD,MAIO;AACL;AACAD,QAAAA,SAAS,GAAG,KAAKhF,eAAL,CAAqBuF,WAArB,CAAiChD,SAAS,CAAC,CAAD,CAAT,CAAalB,aAA9C,CAAZ;AACD;;AAED,YAAMmE,iBAAiB,GAAKT,YAAF,CAA2CU,gBAArE;AACA,8BAAUD,iBAAV;AAEA,YAAMxC,YAAY,GAAG,KAAK7C,qBAAL,CAA2B8C,GAA3B,CAA+B8B,YAA/B,CAArB;AACA,8BAAU/B,YAAV;AACA,UAAI0C,+BAA+B,GAAG,CAACnD,SAAS,CAACoD,KAAV,CACrC1E,QAAQ,IAAIA,QAAQ,CAAC2E,4BAAT,KAA0CzE,SADjB,CAAvC;AAGA2D,MAAAA,oBAAoB,CAACrD,GAArB,CAAyB+D,iBAAzB,EAA4C;AAAER,QAAAA,SAAF;AAAahC,QAAAA,YAAb;AAA2B0C,QAAAA;AAA3B,OAA5C;AACD;;AACD,WAAOZ,oBAAP;AACD,GAhM4B,CAkM7B;AACA;;;AACAe,EAAAA,+BAA+B,CAACC,eAAD,EAAmF;AAChHA,IAAAA,eAAe,CAACC,IAAhB,CAAqB,CAACC,KAAD,EAAQC,KAAR,KAAkB;AACrC,YAAMC,cAAc,GAAKF,KAAK,CAAC,CAAD,CAAP,CAAuCP,gBAA9D;AACA,8BAAUS,cAAV;AAEA,YAAMC,cAAc,GAAKF,KAAK,CAAC,CAAD,CAAP,CAAuCR,gBAA9D;AACA,8BAAUU,cAAV;AACA,aAAOD,cAAc,GAAGC,cAAxB;AACD,KAPD;AAQD;;AAEDC,EAAAA,yBAAyB,CACvBC,MADuB,EAEvBC,IAFuB,EAGvBC,SAHuB,EAIyC;AAChE;AACAD,IAAAA,IAAI,GAAKE,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,IAAlB,CAAT;AACA,WAAOC,SAAS,GAAGnB,CAAC,CAACsB,uBAAF,CAA0BL,MAA1B,EAAkCC,IAAlC,CAAH,GAA6ClB,CAAC,CAACuB,kBAAF,CAAqB,IAArB,EAA2BN,MAA3B,EAAmCC,IAAnC,CAA7D;AACD;;AAEDM,EAAAA,eAAe,CACbjC,4BADa,EAEY;AACzB,SAAK5D,4BAAL,CAAkC8F,yBAAlC;AAEA,QAAIC,cAAc,GAAG,IAAIpG,GAAJ,EAArB,CAHyB,CAIzB;;AACA,QAAIqG,yCAAwF,GAAG,IAAIrG,GAAJ,EAA/F;;AACA,QAAIsG,0BAA0B,GAAGC,kBAAkB,IACjD,yBAAaF,yCAAb,EAAwDE,kBAAxD,EAA4E,MAAM,EAAlF,CADF;;AAEA,QAAIC,eAAe,GAAIjG,QAAD,IACpB,yBAAa6F,cAAb,EAA6B7F,QAA7B,EAAuC,MAAM,EAA7C,CADF;;AAEA,QAAIkG,UAAU,GAAIlG,QAAD,IAA2D;AAC1E,UAAIgG,kBAAkB,GAAGhG,QAAQ,CAAC2E,4BAAlC;AACA,UAAIwB,CAAJ;;AACA,UAAIH,kBAAkB,KAAK9F,SAA3B,EAAsC;AACpCiG,QAAAA,CAAC,GAAG,KAAK7F,0BAAL,CAAgC0B,GAAhC,CAAoCgE,kBAApC,CAAJ;AACA,gCAAUG,CAAC,KAAKjG,SAAhB;AACD,OAHD,MAGO;AACLiG,QAAAA,CAAC,GAAG,KAAKnH,OAAT;AACD;;AACD,aAAOmH,CAAP;AACD,KAVD;;AAYA,QAAItB,eAA0E,GAAGuB,KAAK,CAACC,IAAN,CAC/E,KAAK1G,SAAL,CAAe2G,OAAf,EAD+E,CAAjF;;AAGA,SAAK1B,+BAAL,CAAqCC,eAArC;;AACA,SAAKpE,aAAL,GAAqBd,SAArB,GAAiCkF,eAAe,CAACtD,MAAjD;AACA,QAAIgF,sBAA6F,GAAG,EAApG;AACA,QAAIC,oBAA2F,GAAG,EAAlG;;AACA,QAAIC,0BAA0B,GAAG,CAC/BxD,IAD+B,EAM/ByD,MAN+B,KAO5B;AACH,UAAIvC,CAAC,CAACwC,oBAAF,CAAuB1D,IAAvB,KAAgCkB,CAAC,CAACyC,yBAAF,CAA4B3D,IAA5B,CAApC,EAAuE;AACrE,SAACyD,MAAM,GAAGF,oBAAH,GAA0BD,sBAAjC,EAAyD3F,IAAzD,CACIqC,IADJ;AAGD;AACF,KAbD;;AAcA,QAAI4D,SAA0D,GAAG,IAAIpH,GAAJ,EAAjE;;AACA,QAAIqH,cAAc,GAAG,CACnB9G,QADmB,EAEnB+G,MAFmB,EAGnBC,eAHmB,KAQhB;AACH,UAAI;AAAE5G,QAAAA;AAAF,UAAoBJ,QAAxB;;AAEA,UAAIA,QAAQ,CAACiH,wBAAT,CAAkC1F,MAAlC,GAA2C,CAA/C,EAAkD;AAChD;AACA,YAAI2F,kBAAkB,GAAGjB,eAAe,CAACjG,QAAD,CAAxC;AACAoG,QAAAA,KAAK,CAACe,SAAN,CAAgBvG,IAAhB,CAAqBwG,KAArB,CAA2BF,kBAA3B,EAA+ClH,QAAQ,CAACiH,wBAAxD;AACD;;AAED,UAAI5B,IAAJ;;AACA,UAAIlB,CAAC,CAACwC,oBAAF,CAAuBK,eAAvB,CAAJ,EAA6C;AAC3CH,QAAAA,SAAS,CAACrG,GAAV,CAAcJ,aAAd,EAA+B4G,eAA/B;AACA3B,QAAAA,IAAI,GAAGa,UAAU,CAAClG,QAAD,CAAjB;AACD,OAHD,MAGO;AACL,gCACEmE,CAAC,CAACkD,gBAAF,CAAmBL,eAAnB,KACE7C,CAAC,CAACmD,iBAAF,CAAoBN,eAApB,CADF,IAEE7C,CAAC,CAACyC,yBAAF,CAA4BI,eAA5B,CAHJ,EADK,CAKF;;AACH3B,QAAAA,IAAI,GAAGY,eAAe,CAACjG,QAAD,CAAtB;AACD;;AACDqF,MAAAA,IAAI,CAACzE,IAAL,CAAUuD,CAAC,CAACoD,mBAAF,CAAsB,KAAtB,EAA6B,CAACpD,CAAC,CAACqD,kBAAF,CAAqBT,MAArB,EAA6BC,eAA7B,CAAD,CAA7B,CAAV;AACA,UAAIhG,WAAW,GAAG,KAAKxB,kBAAL,CAAwBwC,GAAxB,CAA4B5B,aAA5B,CAAlB;;AACA,UAAIY,WAAW,KAAKd,SAApB,EAA+B;AAC7B,YAAIuH,EAAE,GAAG,KAAK1I,eAAL,CAAqBuF,WAArB,CAAiClE,aAAjC,CAAT;AACA,gCAAUqH,EAAE,KAAKvH,SAAjB;AACAmF,QAAAA,IAAI,CAACzE,IAAL,CACEuD,CAAC,CAACoD,mBAAF,CAAsB,KAAtB,EAA6B,CAC3BpD,CAAC,CAACqD,kBAAF,CAAqBxG,WAArB,EAAkCmD,CAAC,CAACuD,gBAAF,CAAmBD,EAAnB,EAAuBtD,CAAC,CAACC,UAAF,CAAa,WAAb,CAAvB,CAAlC,CAD2B,CAA7B,CADF;AAKD;AACF,KAxCD,CA5CyB,CAsFzB;;;AACA,SAAK,IAAI,CAACuD,SAAD,EAAYC,QAAZ,CAAT,IAAkC,KAAKvI,4BAAvC,EAAqE;AACnE,UAAIwI,MAAM,GAAG,IAAIC,GAAJ,EAAb;;AACA,WAAK,IAAI,GAAGC,eAAH,CAAT,IAAgCH,QAAQ,CAACI,gBAAzC,EAA2D;AACzD,YAAI7F,KAAK,GAAG4F,eAAe,CAAC5F,KAA5B;AACA,YAAIA,KAAK,KAAKjC,SAAV,IAAuB2H,MAAM,CAAC1H,GAAP,CAAWgC,KAAX,CAA3B,EAA8C;AAC9C0F,QAAAA,MAAM,CAACI,GAAP,CAAW9F,KAAX;AAEA,gCAAU4F,eAAe,CAAC/E,eAA1B,EALyD,CAOzD;;AACA,YAAIkF,WAAW,GAAGnC,0BAA0B,CAAC4B,SAAD,CAA5C,CARyD,CAUzD;AACA;;AACA,YAAIxF,KAAK,CAACgG,uBAAN,KAAkCR,SAAtC,EAAiD;AAC/C,cAAIS,IAAI,GAAG,KAAK7I,eAAL,CAAqB8I,qCAArB,CAA2DlG,KAA3D,EAAkEgC,CAAC,CAACmE,cAAF,CAAiBnG,KAAK,CAACsF,EAAvB,CAAlE,CAAX,CAD+C,CAE/C;;AACArB,UAAAA,KAAK,CAACe,SAAN,CAAgBvG,IAAhB,CAAqBwG,KAArB,CAA2Bc,WAA3B,EAAwCE,IAAxC;AACD;AACF;AACF,KA3GwB,CA6GzB;;;AACA,SAAK,IAAI,CAACT,SAAD,EAAYY,sBAAZ,CAAT,IAAgD,KAAKlJ,4BAAL,CAAkCiH,OAAlC,EAAhD,EAA6F;AAC3F,UAAI;AAAEtG,QAAAA;AAAF,UAAeuI,sBAAnB;AACA,UAAInI,aAAa,GAAKuH,SAAtB;AACA,UAAIvC,MAAM,GAAGhF,aAAa,CAACoI,iBAA3B;AACA,UAAIlD,SAAS,GAAGlF,aAAa,CAACqI,SAAd,KAA4B,SAA5C;AACA,8BAAUrD,MAAM,KAAKlF,SAArB;AAEA,UAAIwI,aAAa,GAAGhF,4BAA4B,CAAC1B,GAA7B,CAAiC2F,SAAjC,CAApB;AACA,8BAAUe,aAAV,EAR2F,CAU3F;AACA;;AACA,UAAI5E,YAAY,GAAGK,CAAC,CAACwE,cAAF,CAAiBD,aAAjB,CAAnB;AACA,UAAI1B,eAAJ;;AAEA,UAAI,KAAK5H,4BAAL,CAAkCe,GAAlC,CAAsCwH,SAAtC,CAAJ,EAAsD;AACpD,YAAIiB,mBAAmB,GAAG,KAAKxJ,4BAAL,CAAkC4C,GAAlC,CAAsC2F,SAAtC,CAA1B;AACA,gCAAUiB,mBAAV;AACA,YAAI;AACFC,UAAAA,UADE;AAEFC,UAAAA,kBAFE;AAGFC,UAAAA,cAHE;AAIFC,UAAAA,mBAJE;AAKFC,UAAAA,cALE;AAMFC,UAAAA;AANE,YAOAN,mBAPJ;AASA,YAAIO,aAAa,GAAGN,UAAU,KAAK,aAAnC;AACA,gCAAUI,cAAc,YAAYG,kBAApC;AACA,gCAAUN,kBAAkB,KAAK3E,CAAC,CAACkF,YAAF,CAAeP,kBAAf,KAAsC3E,CAAC,CAACmF,YAAF,CAAeR,kBAAf,CAA3C,CAA5B,EAdoD,CAepD;;AACA9B,QAAAA,eAAe,GAAG,KAAKuC,qBAAL,CAA2BN,cAA3B,CAAlB;AACA,YAAIO,WAAW,GAAGrF,CAAC,CAACqF,WAAF,CAChBX,UADgB,EAEhBC,kBAFgB,EAGhB1D,MAHgB,EAIhBtB,YAJgB,EAKhBkF,mBALgB,EAMhBE,mBANgB,CAAlB,CAjBoD,CAyBpD;;AACA,YAAIC,aAAJ,EAAmB;AACjBnC,UAAAA,eAAe,CAAC3B,IAAhB,CAAqBA,IAArB,CAA0BoE,OAA1B,CAAkCD,WAAlC;AACD,SAFD,MAEO;AACLxC,UAAAA,eAAe,CAAC3B,IAAhB,CAAqBA,IAArB,CAA0BzE,IAA1B,CAA+B4I,WAA/B;AACD,SA9BmD,CA+BpD;;;AACA,YAAI,CAACL,aAAL,EAAoB;AAClB;AACD,SAlCmD,CAmCpD;;;AACA,YAAIJ,cAAc,KAAK7I,SAAvB,EAAkC;AAChC8G,UAAAA,eAAe,CAAC0C,UAAhB,GAA6BX,cAA7B;AACD;AACF,OAvCD,MAuCO;AACL/B,QAAAA,eAAe,GAAG1B,SAAS,GACvBnB,CAAC,CAACsB,uBAAF,CAA0BL,MAA1B,EAAkCtB,YAAlC,CADuB,GAEvBK,CAAC,CAACuB,kBAAF,CAAqB,IAArB,EAA2BN,MAA3B,EAAmCtB,YAAnC,CAFJ;AAGD;;AACD,UAAI2D,EAAE,GAAG,KAAK1I,eAAL,CAAqBuF,WAArB,CAAiCqD,SAAjC,CAAT;AACA,8BAAUF,EAAE,KAAKvH,SAAjB;AAEAuG,MAAAA,0BAA0B,CACxBO,eADwB,EAExBW,SAAS,YAAYgC,oCAArB,IAAsDhC,SAAS,CAACiC,OAFxC,CAA1B;AAIA9C,MAAAA,cAAc,CAAC9G,QAAD,EAAWyH,EAAX,EAAeT,eAAf,CAAd;AACD,KAjLwB,CAmLzB;;;AACA,UAAMnD,oBAAoB,GAAG,KAAKD,6BAAL,CAAmCF,4BAAnC,CAA7B;;AACA,SAAK,IAAI,CAACrC,QAAD,EAAWC,SAAX,CAAT,IAAkCuD,eAAlC,EAAmD;AACjD,UAAI9C,YAAY,GAAG,KAAK7C,qBAAL,CAA2B8C,GAA3B,CAA+BX,QAA/B,CAAnB;AACA,8BAAUU,YAAV;AACA,UAAI;AAAEQ,QAAAA,OAAF;AAAWsH,QAAAA;AAAX,UAAwB9H,YAA5B;AACA,UAAIqD,MAAM,GAAG9D,SAAS,CAAC,CAAD,CAAT,CAAalB,aAAb,CAA2BoI,iBAAxC;AACA,8BAAUpD,MAAM,KAAKlF,SAArB,EALiD,CAOjD;;AACA,UAAI4J,eAAe,GAAG,EAAtB;AACA,UAAIC,iCAAiC,GAAG,EAAxC;;AACA,WAAK,IAAI/J,QAAT,IAAqBsB,SAArB,EAAgC;AAC9B,YAAI,KAAKhC,sCAAL,CAA4Ca,GAA5C,CAAgDH,QAAQ,CAACI,aAAzD,CAAJ,EACE2J,iCAAiC,CAACnJ,IAAlC,CAAuCZ,QAAvC,EADF,KAEK8J,eAAe,CAAClJ,IAAhB,CAAqBZ,QAArB;AACN;;AAED,UAAIgK,qBAAqB,GAAGC,iBAAiB,IAAI;AAC/C,aAAKxJ,aAAL,GAAqByJ,cAArB,IAAuCD,iBAAiB,CAAC1I,MAAzD;;AAEA,aAAK,IAAIvB,QAAT,IAAqBiK,iBAArB,EAAwC;AACtC,cAAI;AAAE7J,YAAAA,aAAF;AAAiBkC,YAAAA,wBAAjB;AAA2Cb,YAAAA;AAA3C,cAA8DzB,QAAlE;AACA,cAAIgH,eAAJ;;AAEA,cAAI,KAAK5H,4BAAL,CAAkCe,GAAlC,CAAsCC,aAAtC,CAAJ,EAA0D;AACxD,gBAAIwI,mBAAmB,GAAG,KAAKxJ,4BAAL,CAAkC4C,GAAlC,CAAsC5B,aAAtC,CAA1B;AACA,oCAAUwI,mBAAV;AACA,gBAAI;AACFG,cAAAA,cADE;AAEFD,cAAAA,kBAFE;AAGFD,cAAAA,UAHE;AAIFG,cAAAA,mBAJE;AAKFC,cAAAA,cALE;AAMFC,cAAAA;AANE,gBAOAN,mBAPJ;AASA,gBAAIO,aAAa,GAAGN,UAAU,KAAK,aAAnC;AACA,oCAAUI,cAAc,YAAYG,kBAApC;AACA,oCAAUN,kBAAV;AACA,oCAAU3E,CAAC,CAACkF,YAAF,CAAeP,kBAAf,KAAsC3E,CAAC,CAACmF,YAAF,CAAeR,kBAAf,CAAhD,EAfwD,CAgBxD;;AACA9B,YAAAA,eAAe,GAAG,KAAKuC,qBAAL,CAA2BN,cAA3B,CAAlB,CAjBwD,CAkBxD;AACA;;AACA,gBAAIkB,mBAAmB,GAAG,CAAC,CAAC/J,aAAa,CAACgK,oBAA1C;;AACA,gBAAI,CAACjB,aAAD,IAAmBA,aAAa,IAAI,CAACgB,mBAAzC,EAA+D;AAC7D,kBAAIE,YAAY,GAAGjF,MAAM,CAACkF,KAAP,EAAnB;AACA,kBAAId,WAAW,GAAG,IAAIe,0DAAJ,CAChB1G,oBADgB,EAEhB,KAAKxB,0BAAL,CAAgChB,QAAhC,EAA0CiB,wBAA1C,CAFgB,EAGhB,KAAKY,oBAAL,CAA0B7B,QAA1B,CAHgB,EAIhB8C,CAAC,CAACqF,WAAF,CACEX,UADF,EAEEC,kBAFF,EAGEuB,YAHF,EAIEhJ,QAJF,EAKE2H,mBALF,EAMEE,mBANF,CAJgB,EAYhBsB,WAZgB,EAAlB,CAF6D,CAgB7D;;AACA,kBAAIrB,aAAJ,EAAmB;AACjBnC,gBAAAA,eAAe,CAAC3B,IAAhB,CAAqBA,IAArB,CAA0BoE,OAA1B,CAAkCD,WAAlC;AACD,eAFD,MAEO;AACLxC,gBAAAA,eAAe,CAAC3B,IAAhB,CAAqBA,IAArB,CAA0BzE,IAA1B,CAA+B4I,WAA/B;AACD;AACF,aA3CuD,CA4CxD;;;AACA,gBAAI,CAACL,aAAL,EAAoB;AAClB;AACD,aA/CuD,CAgDxD;;;AACA,gBAAIJ,cAAc,KAAK7I,SAAvB,EAAkC;AAChC8G,cAAAA,eAAe,CAAC0C,UAAhB,GAA6BX,cAA7B;AACD;AACF,WApDD,MAoDO;AACL,gBAAIzD,SAAS,GAAGtF,QAAQ,CAACI,aAAT,CAAuBqI,SAAvB,KAAqC,SAArD;AACAzB,YAAAA,eAAe,GAAG,IAAIuD,0DAAJ,CAChB1G,oBADgB,EAEhB,KAAKxB,0BAAL,CAAgChB,QAAhC,EAA0CiB,wBAA1C,CAFgB,EAGhB,KAAKY,oBAAL,CAA0B7B,QAA1B,CAHgB,EAIhB,KAAK8D,yBAAL,CAA+BC,MAA/B,EAAuC/D,QAAvC,EAAiDiE,SAAjD,CAJgB,EAKhBkF,WALgB,EAAlB;AAOA,gBAAIC,mBAAmB,GAAG,EAA1B;;AACA,iBAAK,IAAItI,KAAT,IAAkBV,cAAc,CAACxB,MAAf,EAAlB,EAA2C;AACzCwK,cAAAA,mBAAmB,GAAGA,mBAAmB,CAACC,MAApB,CACpB,KAAKnL,eAAL,CAAqB8I,qCAArB,CAA2DlG,KAA3D,EAAkEgC,CAAC,CAACmE,cAAF,CAAiBnG,KAAK,CAACsF,EAAvB,CAAlE,CADoB,CAAtB;AAGD;;AAED,gBAAIgD,mBAAmB,CAAClJ,MAApB,GAA6B,CAAjC,EAAoC;AAClC,kBAAIoJ,mBAAmB,GAAK3D,eAAe,CAAC3B,IAA5C;AACA,sCAAUlB,CAAC,CAACyG,gBAAF,CAAmBD,mBAAnB,CAAV;AACAA,cAAAA,mBAAmB,CAACtF,IAApB,GAA2BoF,mBAAmB,CAACC,MAApB,CAA2BC,mBAAmB,CAACtF,IAA/C,CAA3B;AACD;AACF;;AACD,cAAIoC,EAAE,GAAG,KAAK1I,eAAL,CAAqBuF,WAArB,CAAiClE,aAAjC,CAAT;AACA,kCAAUqH,EAAE,KAAKvH,SAAjB;AAEAuG,UAAAA,0BAA0B,CAACO,eAAD,EAAkB5G,aAAa,CAACwJ,OAAhC,CAA1B;AACA,kCAAUnC,EAAE,KAAKvH,SAAjB;AACA,kCAAU8G,eAAe,KAAK9G,SAA9B;AACA4G,UAAAA,cAAc,CAAC9G,QAAD,EAAWyH,EAAX,EAAeT,eAAf,CAAd;AACD;AACF,OAzFD;;AA2FA,UAAI+C,iCAAiC,CAACxI,MAAlC,GAA2C,CAA/C,EAAkDyI,qBAAqB,CAACD,iCAAD,CAArB;;AAClD,UAAID,eAAe,CAACvI,MAAhB,GAAyB,CAAzB,IAA8B,CAAC,KAAKH,yBAAL,CAA+BC,QAA/B,EAAyCyI,eAAzC,CAAnC,EAA8F;AAC5FE,QAAAA,qBAAqB,CAACF,eAAD,CAArB;AACA,aAAKrJ,aAAL,GAAqByJ,cAArB;AACD,OAHD,MAGO,IAAIJ,eAAe,CAACvI,MAAhB,GAAyB,CAA7B,EAAgC;AACrC,cAAMgD,iBAAiB,GAAKlD,QAAF,CAAuCmD,gBAAjE;AACA,gCAAUD,iBAAV;AACA,cAAMsG,WAAW,GAAGhH,oBAAoB,CAAC7B,GAArB,CAAyBuC,iBAAzB,CAApB;AACA,gCAAUsG,WAAV;AACA,cAAM;AAAE9G,UAAAA;AAAF,YAAgB8G,WAAtB,CALqC,CAOrC;;AACA,YAAIC,YAA2B,GAAG,EAAlC;AACA,YAAIC,oBAAoB,GAAG,IAAItL,GAAJ,EAA3B;;AACA,aAAK,IAAIgD,IAAT,IAAiBF,OAAO,CAAChC,IAAR,EAAjB,EAAiC;AAC/B,cAAIyK,WAAW,GAAG,KAAlB;AACA,cAAIC,WAAJ;AAEA,cAAIC,YAAY,GAAGpB,eAAe,CAAC,CAAD,CAAf,CAAmBxH,wBAAnB,CAA4CN,GAA5C,CAAgDS,IAAhD,CAAnB;AACA,kCAAUyI,YAAV;;AACA,cAAIA,YAAY,CAAC9H,QAAjB,EAA2B;AACzB;AACA2H,YAAAA,oBAAoB,CAACvK,GAArB,CAAyBiC,IAAzB,EAA+ByI,YAA/B;AACA;AACD;;AAED,2BAAyCpB,eAAzC,EAA0D;AAAA,gBAAjD;AAAExH,cAAAA;AAAF,aAAiD;AACxD,gBAAIyF,eAAe,GAAGzF,wBAAwB,CAACN,GAAzB,CAA6BS,IAA7B,CAAtB;AAEA,oCAAUsF,eAAV;AACA,oCAAU,CAACA,eAAe,CAAC3E,QAA3B;;AACA,gBAAI,CAAC6H,WAAL,EAAkB;AAChBA,cAAAA,WAAW,GAAGlD,eAAd;AACD,aAFD,MAEO,IAAI,CAAC,oCAAuB,KAAKpJ,KAA5B,EAAmCoJ,eAAnC,EAAoDkD,WAApD,CAAL,EAAuE;AAC5ED,cAAAA,WAAW,GAAG,IAAd;AACA;AACD;AACF;;AAED,cAAIA,WAAJ,EAAiB;AACfF,YAAAA,YAAY,CAAClK,IAAb,CAAkB6B,IAAlB;AACD,WAFD,MAEO;AACL,oCAAUwI,WAAV;AACAF,YAAAA,oBAAoB,CAACvK,GAArB,CAAyBiC,IAAzB,EAA+BwI,WAA/B;AACD;AACF;;AAED,YAAIE,aAAmC,GAAG,EAA1C;;AACA,aAAK,IAAIC,GAAT,IAAgBN,YAAhB,EAA8B;AAC5BK,UAAAA,aAAa,CAACvK,IAAd,CAAmBuD,CAAC,CAACC,UAAF,CAAagH,GAAb,CAAnB;AACD;;AAED,YAAIX,mBAAmB,GAAG,EAA1B;;AACA,aAAK,IAAI,CAACY,SAAD,EAAYlJ,KAAZ,CAAT,IAA+B2H,eAAe,CAAC,CAAD,CAAf,CAAmBrI,cAAlD,EAAkE;AAChE,cAAI6J,WAAW,GAAGnH,CAAC,CAACC,UAAF,CAAaiH,SAAb,CAAlB;AACAF,UAAAA,aAAa,CAACvK,IAAd,CAAmB0K,WAAnB;AACAb,UAAAA,mBAAmB,GAAGA,mBAAmB,CAACC,MAApB,CACpB,KAAKnL,eAAL,CAAqB8I,qCAArB,CAA2DlG,KAA3D,EAAkEmJ,WAAlE,CADoB,CAAtB;AAGD;;AAEDH,QAAAA,aAAa,GAAGA,aAAa,CAACT,MAAd,CAAqBtF,MAArB,EAA6BkF,KAA7B,EAAhB;AACA,YAAIiB,WAAW,GAAG,IAAIhB,0DAAJ,CAChB1G,oBADgB,EAEhB,KAAKxB,0BAAL,CAAgChB,QAAhC,EAA0C0J,oBAA1C,CAFgB,EAGhB,KAAK7H,oBAAL,CAA0B7B,QAA1B,CAHgB,EAIhB,KAAK8D,yBAAL,CAA+BgG,aAA/B,EAA8C9J,QAA9C,EAAwD,KAAxD,CAJgB,EAKhBmJ,WALgB,EAAlB;;AAOA,YAAIC,mBAAmB,CAAClJ,MAApB,GAA6B,CAAjC,EAAoC;AAClC,cAAIiK,eAAe,GAAKD,WAAW,CAAClG,IAApC;AACA,kCAAUlB,CAAC,CAACyG,gBAAF,CAAmBY,eAAnB,CAAV;AACAA,UAAAA,eAAe,CAACnG,IAAhB,GAAuBoF,mBAAmB,CAACC,MAApB,CAA2Bc,eAAe,CAACnG,IAA3C,CAAvB;AACD,SArEoC,CAuErC;;;AACA,YAAIoG,kBAAkB,GAAGtH,CAAC,CAACoD,mBAAF,CAAsB,KAAtB,EAA6B,CAACpD,CAAC,CAACqD,kBAAF,CAAqBzD,SAArB,EAAgCwH,WAAhC,CAAD,CAA7B,CAAzB;AACA,aAAKvM,OAAL,CAAa4B,IAAb,CAAkB6K,kBAAlB;AAEAhF,QAAAA,0BAA0B,CAAC8E,WAAD,EAAczB,eAAe,CAAC,CAAD,CAAf,CAAmB1J,aAAnB,CAAiCwJ,OAA/C,CAA1B;;AAEA,aAAK,IAAI5J,QAAT,IAAqB8J,eAArB,EAAsC;AACpC,cAAI;AAAE1J,YAAAA,aAAF;AAAiBkC,YAAAA,wBAAjB;AAA2CoJ,YAAAA;AAA3C,cAA8D1L,QAAlE;AACA,cAAI2L,UAAU,GAAG,KAAK5M,eAAL,CAAqBuF,WAArB,CAAiClE,aAAjC,CAAjB;AACA,kCAAUuL,UAAU,KAAKzL,SAAzB;AACA,cAAI0L,cAAc,GAAG,KAArB;AACA,cAAIC,QAAoC,GAAGf,YAAY,CAACgB,GAAb,CAAiBrJ,IAAI,IAAI;AAClE,gBAAIsF,eAAe,GAAGzF,wBAAwB,CAACN,GAAzB,CAA6BS,IAA7B,CAAtB;AACA,oCAAUsF,eAAV;AACA,gBAAIjF,eAAe,GAAGiF,eAAe,CAACjF,eAAtC;AACA8I,YAAAA,cAAc,GACZA,cAAc,IAAK7D,eAAe,CAAClF,KAAhB,IAAyBkF,eAAe,CAAClF,KAAhB,YAAiCkJ,oBAD/E;AAEA,oCAAUjJ,eAAV;AACA,mBAAOA,eAAP;AACD,WAR0C,CAA3C;AASA,cAAIZ,eAAe,GAAG,KAAtB;;AACA,eAAK,MAAMC,KAAX,IAAoBnC,QAAQ,CAACyB,cAAT,CAAwBxB,MAAxB,EAApB,EAAsD;AACpD4L,YAAAA,QAAQ,CAACjL,IAAT,CAAcuD,CAAC,CAACmE,cAAF,CAAiBnG,KAAK,CAACsF,EAAvB,CAAd;AACA,gBAAItF,KAAK,CAACC,SAAN,CAAgBb,MAAhB,GAAyB,CAA7B,EAAgCW,eAAe,GAAG,IAAlB;AACjC;;AACD,cAAI8J,QAAJ;AACA,cAAIC,UAAU,GAAG,KAAKvM,mBAAL,CAAyBsC,GAAzB,CAA6B5B,aAA7B,CAAjB,CApBoC,CAqBpC;;AACA,kCAAUsL,cAAc,KAAKxL,SAA7B;;AACA,eACE;AACA;AACA,eAAKJ,4BAAL,CAAkCoM,uBAAlC,CAA0D9L,aAA1D,KACAyJ,QADA,IAEA+B,cAFA,IAGCK,UAAU,KAAK/L,SAAf,IAA4B,CAAC+L,UAAU,CAACE,gBAAX,CAA4BT,cAA5B,CAH9B,IAIA,KAAKlM,kBAAL,CAAwBwC,GAAxB,CAA4B5B,aAA5B,MAA+CF,SAJ/C,IAKAgC,eARF,EASE;AACA,gBAAIkK,QAA6D,GAAG,CAACjI,CAAC,CAACkI,cAAF,EAAD,CAApE;;AACA,iBAAK,IAAIC,OAAT,IAAoBT,QAApB,EAA8BO,QAAQ,CAACxL,IAAT,CAAc0L,OAAd;;AAC9B,iBAAK,IAAIC,KAAT,IAAkBnH,MAAlB,EAA0B;AACxB,kBAAImH,KAAK,CAACC,IAAN,KAAe,YAAnB,EAAiC;AAC/B,sBAAM,IAAIC,kBAAJ,CAAe,8DAAf,CAAN;AACD;;AACDL,cAAAA,QAAQ,CAACxL,IAAT,CAAgB2L,KAAhB;AACD;;AAED,gBAAIhJ,MAAM,GAAGY,CAAC,CAACuD,gBAAF,CAAmB3D,SAAnB,EAA8BI,CAAC,CAACC,UAAF,CAAa,MAAb,CAA9B,CAAb;AAEA,gBAAIsI,SAAS,GAAGvI,CAAC,CAACwE,cAAF,CAAiB,CAACxE,CAAC,CAACwI,eAAF,CAAkBxI,CAAC,CAACyI,cAAF,CAAiBrJ,MAAjB,EAAyB6I,QAAzB,CAAlB,CAAD,CAAjB,CAAhB;AAEAJ,YAAAA,QAAQ,GAAG7H,CAAC,CAACuB,kBAAF,CAAqB,IAArB,EAA2BN,MAA3B,EAAmCsH,SAAnC,CAAX;AACAjG,YAAAA,0BAA0B,CAACuF,QAAD,EAAW5L,aAAa,CAACwJ,OAAzB,CAA1B;AACD,WAzBD,MAyBO;AACLoC,YAAAA,QAAQ,GAAG7H,CAAC,CAACyI,cAAF,CACTzI,CAAC,CAACuD,gBAAF,CAAmB3D,SAAnB,EAA8BI,CAAC,CAACC,UAAF,CAAa,MAAb,CAA9B,CADS,EAET,CAACyI,4BAAD,EAAiBnC,MAAjB,CAAwBmB,QAAxB,CAFS,CAAX;AAID;;AAED/E,UAAAA,cAAc,CAAC9G,QAAD,EAAW2L,UAAX,EAAuBK,QAAvB,CAAd;AACD;AACF;AACF;;AAED,SAAK,IAAI7D,uBAAT,IAAoC,KAAK5I,eAAL,CAAqBuN,uBAArB,CAA6CvM,IAA7C,EAApC,EAAyF;AACvF,UAAIvB,OAAJ,CADuF,CAEvF;;AACA,UAAImJ,uBAAuB,KAAK,QAAhC,EAA0C;AACxC,YAAInC,kBAAkB,GAAGmC,uBAAzB;AACAnJ,QAAAA,OAAO,GAAG,KAAKsB,0BAAL,CAAgC0B,GAAhC,CAAoCgE,kBAApC,CAAV;AACA,gCAAUhH,OAAO,KAAKkB,SAAtB;AACD,OAJD,MAIO;AACLlB,QAAAA,OAAO,GAAG,KAAKA,OAAf;AACD;;AACDA,MAAAA,OAAO,CAACyK,OAAR,CACE,GAAG,KAAKlK,eAAL,CAAqBwN,2BAArB,CAAiD5E,uBAAjD,CADL,EAEE,GAAG,KAAK5I,eAAL,CAAqByN,eAArB,CAAqC7E,uBAArC,CAFL;AAID;;AAED,SAAK,IAAInI,QAAT,IAAqB,KAAKH,iBAAL,CAAuBoN,OAAvB,EAArB,EAAuD;AACrD,UAAInJ,YAAY,GAAG+B,cAAc,CAAC7D,GAAf,CAAmBhC,QAAnB,CAAnB;;AACA,UAAI8D,YAAY,KAAK5D,SAArB,EAAgC;AAC9B,YAAIwL,cAAc,GAAG1L,QAAQ,CAAC0L,cAA9B;AACA,gCAAUA,cAAc,YAAYwB,qBAApC,EAF8B,CAG9B;AACA;;AACAxB,QAAAA,cAAc,CAACrG,IAAf,CAAoBiB,OAApB,CAA4B6G,MAA5B,CAAmCzB,cAAc,CAAC0B,KAAlD,EAAyD,CAAzD,EAA4D,GAAGtJ,YAA/D;AACD;AACF,KAtcwB,CAwczB;;;AACA,SAAK,IAAI,CAAC1D,aAAD,EAAgB4L,QAAhB,CAAT,IAAsCnF,SAAtC,EAAiD;AAC/C,UAAIwG,oBAAoB,GAAG,KAAKvN,4BAAL,CAAkCwN,uBAAlC,CAA0DlN,aAA1D,CAA3B;;AACA,UAAIiN,oBAAoB,KAAKnN,SAA7B,EAAwC;AACtC,gCAAUiE,CAAC,CAACwC,oBAAF,CAAuBqF,QAAvB,CAAV;AACA,YAAIrD,cAAuC,GAAKqD,QAAF,CAA+C3G,IAA7F;AACAsD,QAAAA,cAAc,CAACtD,IAAf,CAAoBoE,OAApB,CAA4B4D,oBAA5B;AACD;AACF;;AAED,SAAK,IAAI,CAACrH,kBAAD,EAAqBX,IAArB,CAAT,IAAuCe,KAAK,CAACC,IAAN,CAAW3C,4BAA4B,CAAC4C,OAA7B,EAAX,EAAmD2G,OAAnD,EAAvC,EAAqG;AACnG,UAAI1E,sBAAsB,GAAG,KAAKlJ,4BAAL,CAAkC2C,GAAlC,CAAsCgE,kBAAtC,CAA7B;AACA,8BAAUuC,sBAAV,EAFmG,CAGnG;;AACA,UAAIL,WAAW,GAAGpC,yCAAyC,CAAC9D,GAA1C,CAA8CgE,kBAA9C,CAAlB,CAJmG,CAKnG;;AACA,UAAIiB,wBAAwB,GAAGhB,eAAe,CAACsC,sBAAsB,CAACvI,QAAxB,CAA9C;AACA,UAAIhB,OAAO,GAAG,KAAKsB,0BAAL,CAAgC0B,GAAhC,CAAoCgE,kBAApC,CAAd;AACA,8BAAUhH,OAAO,KAAKkB,SAAtB;AACA,UAAIwL,cAAc,GAAGnD,sBAAsB,CAACvI,QAAvB,CAAgC0L,cAArD;AACA,8BAAUA,cAAV,EAVmG,CAWnG;;AACAA,MAAAA,cAAc,CAACrG,IAAf,CAAoBiB,OAApB,CAA4B6G,MAA5B,CAAmCzB,cAAc,CAAC0B,KAAlD,EAAyD,CAAzD,EAA4D,GAAGnG,wBAA/D;AACA,UAAIiB,WAAJ,EAAiB7C,IAAI,CAACoE,OAAL,CAAa,GAAGvB,WAAhB;AACjB7C,MAAAA,IAAI,CAACoE,OAAL,CAAa,GAAGzK,OAAhB;AACD;;AAED,WAAO;AAAEuH,MAAAA,sBAAF;AAA0BC,MAAAA;AAA1B,KAAP;AACD;;AACD+C,EAAAA,qBAAqB,CAACN,cAAD,EAAwD;AAC3E,QAAI,CAAC,KAAKrJ,OAAL,CAAaO,GAAb,CAAiB8I,cAAjB,CAAL,EAAuC;AACrC,UAAIjC,eAAe,GAAG7C,CAAC,CAACoJ,eAAF,CAAkB,IAAlB,EAAwB,IAAxB,EAA8BpJ,CAAC,CAACqJ,SAAF,CAAY,EAAZ,CAA9B,EAA+C,EAA/C,CAAtB;AACA,WAAK5N,OAAL,CAAaY,GAAb,CAAiByI,cAAjB,EAAiCjC,eAAjC;AACA,aAAOA,eAAP;AACD,KAJD,MAIO;AACL,UAAIA,eAAe,GAAG,KAAKpH,OAAL,CAAaoC,GAAb,CAAiBiH,cAAjB,CAAtB;AACA,8BAAUjC,eAAe,IAAI7C,CAAC,CAACmD,iBAAF,CAAoBN,eAApB,CAA7B;AACA,aAAOA,eAAP;AACD;AACF;;AA1sB4B","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { FatalError } from \"../errors.js\";\nimport { Realm } from \"../realm.js\";\nimport { FunctionValue, ECMAScriptSourceFunctionValue, ObjectValue } from \"../values/index.js\";\nimport type { SerializerOptions } from \"../options.js\";\nimport * as t from \"@babel/types\";\nimport type {\n  BabelNodeCallExpression,\n  BabelNodeClassMethod,\n  BabelNodeClassExpression,\n  BabelNodeExpression,\n  BabelNodeStatement,\n  BabelNodeIdentifier,\n  BabelNodeBlockStatement,\n  BabelNodeLVal,\n  BabelNodeSpreadElement,\n  BabelNodeFunctionExpression,\n  BabelNodeArrowFunctionExpression,\n} from \"@babel/types\";\nimport type { FunctionBodyAstNode } from \"../types.js\";\nimport type { NameGenerator } from \"../utils/NameGenerator.js\";\nimport invariant from \"../invariant.js\";\nimport type {\n  ResidualFunctionBinding,\n  FunctionInfo,\n  FactoryFunctionInfo,\n  FunctionInstance,\n  AdditionalFunctionInfo,\n} from \"./types.js\";\nimport { BodyReference, AreSameResidualBinding } from \"./types.js\";\nimport { SerializerStatistics } from \"./statistics.js\";\nimport { ResidualFunctionInstantiator, type Replacement, getReplacement } from \"./ResidualFunctionInstantiator.js\";\nimport { Modules } from \"../utils/modules.js\";\nimport { ResidualFunctionInitializers } from \"./ResidualFunctionInitializers.js\";\nimport { nullExpression } from \"../utils/babelhelpers.js\";\nimport type { LocationService, ClassMethodInstance } from \"./types.js\";\nimport { Referentializer } from \"./Referentializer.js\";\nimport { getOrDefault } from \"./utils.js\";\n\ntype ResidualFunctionsResult = {\n  unstrictFunctionBodies: Array<BabelNodeFunctionExpression | BabelNodeArrowFunctionExpression>,\n  strictFunctionBodies: Array<BabelNodeFunctionExpression | BabelNodeArrowFunctionExpression>,\n};\n\nexport class ResidualFunctions {\n  constructor(\n    realm: Realm,\n    options: SerializerOptions,\n    modules: Modules,\n    requireReturns: Map<number | string, Replacement>,\n    locationService: LocationService,\n    prelude: Array<BabelNodeStatement>,\n    factoryNameGenerator: NameGenerator,\n    residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>,\n    residualFunctionInstances: Map<FunctionValue, FunctionInstance>,\n    residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>,\n    additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>,\n    additionalFunctionValueNestedFunctions: Set<FunctionValue>,\n    referentializer: Referentializer\n  ) {\n    this.realm = realm;\n    this.modules = modules;\n    this.requireReturns = requireReturns;\n    this.locationService = locationService;\n    this.prelude = prelude;\n    this.factoryNameGenerator = factoryNameGenerator;\n    this.functionPrototypes = new Map();\n    this.firstFunctionUsages = new Map();\n    this.functions = new Map();\n    this.classes = new Map();\n    this.functionInstances = [];\n    this.residualFunctionInitializers = new ResidualFunctionInitializers(locationService);\n    this.residualFunctionInfos = residualFunctionInfos;\n    this.residualFunctionInstances = residualFunctionInstances;\n    this.residualClassMethodInstances = residualClassMethodInstances;\n    this.additionalFunctionValueInfos = additionalFunctionValueInfos;\n    this.referentializer = referentializer;\n    for (let instance of residualFunctionInstances.values()) {\n      invariant(instance !== undefined);\n      if (!additionalFunctionValueInfos.has(instance.functionValue)) this.addFunctionInstance(instance);\n    }\n    this.additionalFunctionValueNestedFunctions = additionalFunctionValueNestedFunctions;\n    this.additionalFunctionPreludes = new Map();\n    for (let functionValue of additionalFunctionValueInfos.keys()) {\n      this.additionalFunctionPreludes.set(functionValue, []);\n    }\n  }\n\n  realm: Realm;\n  modules: Modules;\n  requireReturns: Map<number | string, Replacement>;\n  locationService: LocationService;\n  prelude: Array<BabelNodeStatement>;\n  factoryNameGenerator: NameGenerator;\n  functionPrototypes: Map<FunctionValue, BabelNodeIdentifier>;\n  firstFunctionUsages: Map<FunctionValue, BodyReference>;\n  functions: Map<BabelNodeBlockStatement, Array<FunctionInstance>>;\n  classes: Map<ObjectValue, BabelNodeClassExpression>;\n  functionInstances: Array<FunctionInstance>;\n  residualFunctionInitializers: ResidualFunctionInitializers;\n  residualFunctionInfos: Map<BabelNodeBlockStatement, FunctionInfo>;\n  residualFunctionInstances: Map<FunctionValue, FunctionInstance>;\n  residualClassMethodInstances: Map<FunctionValue, ClassMethodInstance>;\n  additionalFunctionValueInfos: Map<FunctionValue, AdditionalFunctionInfo>;\n  additionalFunctionValueNestedFunctions: Set<FunctionValue>;\n  referentializer: Referentializer;\n  additionalFunctionPreludes: Map<FunctionValue, Array<BabelNodeStatement>>;\n\n  getStatistics(): SerializerStatistics {\n    invariant(this.realm.statistics instanceof SerializerStatistics, \"serialization requires SerializerStatistics\");\n    return this.realm.statistics;\n  }\n\n  addFunctionInstance(instance: FunctionInstance): void {\n    this.functionInstances.push(instance);\n    let code = instance.functionValue.$ECMAScriptCode;\n    invariant(code != null);\n    getOrDefault(this.functions, code, () => []).push(instance);\n  }\n\n  setFunctionPrototype(constructor: FunctionValue, prototypeId: BabelNodeIdentifier): void {\n    this.functionPrototypes.set(constructor, prototypeId);\n  }\n\n  addFunctionUsage(val: FunctionValue, bodyReference: BodyReference): void {\n    if (!this.firstFunctionUsages.has(val)) this.firstFunctionUsages.set(val, bodyReference);\n  }\n\n  _shouldUseFactoryFunction(funcBody: BabelNodeBlockStatement, instances: Array<FunctionInstance>): boolean {\n    invariant(instances.length > 0);\n    function shouldInlineFunction(): boolean {\n      if (instances[0].scopeInstances.size > 0) return false;\n      let shouldInline = true;\n      if (funcBody.start && funcBody.end) {\n        let bodySize = funcBody.end - funcBody.start;\n        shouldInline = bodySize <= 30;\n      }\n      return shouldInline;\n    }\n    let functionInfo = this.residualFunctionInfos.get(funcBody);\n    invariant(functionInfo);\n    let { usesArguments } = functionInfo;\n    let hasAnyLeakedIds = false;\n    for (const instance of instances)\n      for (const scope of instance.scopeInstances.values()) if (scope.leakedIds.length > 0) hasAnyLeakedIds = true;\n    return !shouldInlineFunction() && instances.length > 1 && !usesArguments && !hasAnyLeakedIds;\n  }\n\n  _getIdentifierReplacements(\n    funcBody: BabelNodeBlockStatement,\n    residualFunctionBindings: Map<string, ResidualFunctionBinding>\n  ): Map<BabelNodeIdentifier, Replacement> {\n    let functionInfo = this.residualFunctionInfos.get(funcBody);\n    invariant(functionInfo);\n    let { unbound } = functionInfo;\n    let res = new Map();\n    for (let [name, nodes] of unbound) {\n      let residualFunctionBinding = residualFunctionBindings.get(name);\n      if (residualFunctionBinding === undefined) continue;\n\n      // Let's skip bindings that are referring to\n      // 1) something global (without an environment record), and\n      // 2) have not been assigned a value (which would mean that they have a var/let binding and Prepack will take the liberty to rename them).\n      if (\n        residualFunctionBinding.declarativeEnvironmentRecord === null &&\n        residualFunctionBinding.value === undefined\n      ) {\n        continue;\n      }\n\n      let serializedValue = residualFunctionBinding.serializedValue;\n      invariant(serializedValue !== undefined);\n      let replacement = getReplacement(\n        serializedValue,\n        residualFunctionBinding.referentialized ? undefined : residualFunctionBinding.value\n      );\n      for (let node of nodes) res.set(node, replacement);\n    }\n    return res;\n  }\n\n  _getCallReplacements(funcBody: BabelNodeBlockStatement): Map<BabelNode, Replacement> {\n    let functionInfo = this.residualFunctionInfos.get(funcBody);\n    invariant(functionInfo);\n    let { requireCalls, modified } = functionInfo;\n    let res = new Map();\n    for (let [callNode, moduleId] of requireCalls) {\n      this.getStatistics().requireCalls++;\n      if (modified.has(callNode.callee.name)) continue;\n\n      let replacement = this.requireReturns.get(\"\" + moduleId);\n      if (replacement !== undefined) {\n        this.getStatistics().requireCallsReplaced++;\n        res.set(callNode, replacement);\n      }\n    }\n    return res;\n  }\n\n  // Note: this function takes linear time. Please do not call it inside loop.\n  _hasRewrittenFunctionInstance(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>,\n    instances: Array<FunctionInstance>\n  ): boolean {\n    return instances.find(instance => rewrittenAdditionalFunctions.has(instance.functionValue)) !== undefined;\n  }\n\n  _generateFactoryFunctionInfos(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>\n  ): Map<number, FactoryFunctionInfo> {\n    const factoryFunctionInfos = new Map();\n    for (const [functionBody, instances] of this.functions) {\n      invariant(instances.length > 0);\n\n      let factoryId;\n      const suffix = instances[0].functionValue.__originalName || this.realm.debugNames ? \"factoryFunction\" : \"\";\n      if (this._shouldUseFactoryFunction(functionBody, instances)) {\n        // Rewritten function should never use factory function.\n        invariant(!this._hasRewrittenFunctionInstance(rewrittenAdditionalFunctions, instances));\n        factoryId = t.identifier(this.factoryNameGenerator.generate(suffix));\n      } else {\n        // For inline function body case, use the first function as the factory function.\n        factoryId = this.locationService.getLocation(instances[0].functionValue);\n      }\n\n      const functionUniqueTag = ((functionBody: any): FunctionBodyAstNode).uniqueOrderedTag;\n      invariant(functionUniqueTag);\n\n      const functionInfo = this.residualFunctionInfos.get(functionBody);\n      invariant(functionInfo);\n      let anyContainingAdditionalFunction = !instances.every(\n        instance => instance.containingAdditionalFunction === undefined\n      );\n      factoryFunctionInfos.set(functionUniqueTag, { factoryId, functionInfo, anyContainingAdditionalFunction });\n    }\n    return factoryFunctionInfos;\n  }\n\n  // Preserve residual functions' ordering based on its ast dfs traversal order.\n  // This is necessary to prevent unexpected code locality issues.\n  _sortFunctionByOriginalOrdering(functionEntries: Array<[BabelNodeBlockStatement, Array<FunctionInstance>]>): void {\n    functionEntries.sort((funcA, funcB) => {\n      const funcAUniqueTag = ((funcA[0]: any): FunctionBodyAstNode).uniqueOrderedTag;\n      invariant(funcAUniqueTag);\n\n      const funcBUniqueTag = ((funcB[0]: any): FunctionBodyAstNode).uniqueOrderedTag;\n      invariant(funcBUniqueTag);\n      return funcAUniqueTag - funcBUniqueTag;\n    });\n  }\n\n  _createFunctionExpression(\n    params: Array<BabelNodeLVal>,\n    body: BabelNodeBlockStatement,\n    isLexical: boolean\n  ): BabelNodeFunctionExpression | BabelNodeArrowFunctionExpression {\n    // Additional statements might be inserted at the beginning of the body, so we clone it.\n    body = ((Object.assign({}, body): any): BabelNodeBlockStatement);\n    return isLexical ? t.arrowFunctionExpression(params, body) : t.functionExpression(null, params, body);\n  }\n\n  spliceFunctions(\n    rewrittenAdditionalFunctions: Map<FunctionValue, Array<BabelNodeStatement>>\n  ): ResidualFunctionsResult {\n    this.residualFunctionInitializers.scrubFunctionInitializers();\n\n    let functionBodies = new Map();\n    // these need to get spliced in at the end\n    let additionalFunctionModifiedBindingsSegment: Map<FunctionValue, Array<BabelNodeStatement>> = new Map();\n    let getModifiedBindingsSegment = additionalFunction =>\n      getOrDefault(additionalFunctionModifiedBindingsSegment, additionalFunction, () => []);\n    let getFunctionBody = (instance: FunctionInstance): Array<BabelNodeStatement> =>\n      getOrDefault(functionBodies, instance, () => []);\n    let getPrelude = (instance: FunctionInstance): Array<BabelNodeStatement> => {\n      let additionalFunction = instance.containingAdditionalFunction;\n      let b;\n      if (additionalFunction !== undefined) {\n        b = this.additionalFunctionPreludes.get(additionalFunction);\n        invariant(b !== undefined);\n      } else {\n        b = this.prelude;\n      }\n      return b;\n    };\n\n    let functionEntries: Array<[BabelNodeBlockStatement, Array<FunctionInstance>]> = Array.from(\n      this.functions.entries()\n    );\n    this._sortFunctionByOriginalOrdering(functionEntries);\n    this.getStatistics().functions = functionEntries.length;\n    let unstrictFunctionBodies: Array<BabelNodeFunctionExpression | BabelNodeArrowFunctionExpression> = [];\n    let strictFunctionBodies: Array<BabelNodeFunctionExpression | BabelNodeArrowFunctionExpression> = [];\n    let registerFunctionStrictness = (\n      node:\n        | BabelNodeFunctionExpression\n        | BabelNodeArrowFunctionExpression\n        | BabelNodeClassMethod\n        | BabelNodeClassExpression,\n      strict: boolean\n    ) => {\n      if (t.isFunctionExpression(node) || t.isArrowFunctionExpression(node)) {\n        (strict ? strictFunctionBodies : unstrictFunctionBodies).push(\n          ((node: any): BabelNodeFunctionExpression | BabelNodeArrowFunctionExpression)\n        );\n      }\n    };\n    let funcNodes: Map<FunctionValue, BabelNodeFunctionExpression> = new Map();\n    let defineFunction = (\n      instance: FunctionInstance,\n      funcId: BabelNodeIdentifier,\n      funcOrClassNode:\n        | BabelNodeCallExpression\n        | BabelNodeFunctionExpression\n        | BabelNodeArrowFunctionExpression\n        | BabelNodeClassExpression\n    ) => {\n      let { functionValue } = instance;\n\n      if (instance.initializationStatements.length > 0) {\n        // always add initialization statements to insertion point\n        let initializationBody = getFunctionBody(instance);\n        Array.prototype.push.apply(initializationBody, instance.initializationStatements);\n      }\n\n      let body;\n      if (t.isFunctionExpression(funcOrClassNode)) {\n        funcNodes.set(functionValue, ((funcOrClassNode: any): BabelNodeFunctionExpression));\n        body = getPrelude(instance);\n      } else {\n        invariant(\n          t.isCallExpression(funcOrClassNode) ||\n            t.isClassExpression(funcOrClassNode) ||\n            t.isArrowFunctionExpression(funcOrClassNode)\n        ); // .bind call\n        body = getFunctionBody(instance);\n      }\n      body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(funcId, funcOrClassNode)]));\n      let prototypeId = this.functionPrototypes.get(functionValue);\n      if (prototypeId !== undefined) {\n        let id = this.locationService.getLocation(functionValue);\n        invariant(id !== undefined);\n        body.push(\n          t.variableDeclaration(\"var\", [\n            t.variableDeclarator(prototypeId, t.memberExpression(id, t.identifier(\"prototype\"))),\n          ])\n        );\n      }\n    };\n\n    // Emit code for ModifiedBindings for additional functions\n    for (let [funcValue, funcInfo] of this.additionalFunctionValueInfos) {\n      let scopes = new Set();\n      for (let [, residualBinding] of funcInfo.modifiedBindings) {\n        let scope = residualBinding.scope;\n        if (scope === undefined || scopes.has(scope)) continue;\n        scopes.add(scope);\n\n        invariant(residualBinding.referentialized);\n\n        // Find the proper prelude to emit to (global vs additional function's prelude)\n        let bodySegment = getModifiedBindingsSegment(funcValue);\n\n        // binding has been referentialized, so setup the scope to be able to\n        // access bindings from other __captured_scopes initializers\n        if (scope.referentializationScope !== funcValue) {\n          let init = this.referentializer.getReferentializedScopeInitialization(scope, t.numericLiteral(scope.id));\n          // flow forces me to do this\n          Array.prototype.push.apply(bodySegment, init);\n        }\n      }\n    }\n\n    // Process Additional Functions\n    for (let [funcValue, additionalFunctionInfo] of this.additionalFunctionValueInfos.entries()) {\n      let { instance } = additionalFunctionInfo;\n      let functionValue = ((funcValue: any): ECMAScriptSourceFunctionValue);\n      let params = functionValue.$FormalParameters;\n      let isLexical = functionValue.$ThisMode === \"lexical\";\n      invariant(params !== undefined);\n\n      let rewrittenBody = rewrittenAdditionalFunctions.get(funcValue);\n      invariant(rewrittenBody);\n\n      // rewritten functions shouldn't have references fixed up because the body,\n      // consists of serialized code. For simplicity we emit their instances in a naive way\n      let functionBody = t.blockStatement(rewrittenBody);\n      let funcOrClassNode;\n\n      if (this.residualClassMethodInstances.has(funcValue)) {\n        let classMethodInstance = this.residualClassMethodInstances.get(funcValue);\n        invariant(classMethodInstance);\n        let {\n          methodType,\n          classMethodKeyNode,\n          classSuperNode,\n          classMethodComputed,\n          classPrototype,\n          classMethodIsStatic,\n        } = classMethodInstance;\n\n        let isConstructor = methodType === \"constructor\";\n        invariant(classPrototype instanceof ObjectValue);\n        invariant(classMethodKeyNode && (t.isExpression(classMethodKeyNode) || t.isIdentifier(classMethodKeyNode)));\n        // we use the classPrototype as the key to get the class expression ast node\n        funcOrClassNode = this._getOrCreateClassNode(classPrototype);\n        let classMethod = t.classMethod(\n          methodType,\n          classMethodKeyNode,\n          params,\n          functionBody,\n          classMethodComputed,\n          classMethodIsStatic\n        );\n        // add the class method to the class expression node body\n        if (isConstructor) {\n          funcOrClassNode.body.body.unshift(classMethod);\n        } else {\n          funcOrClassNode.body.body.push(classMethod);\n        }\n        // we only return the funcOrClassNode if this is the constructor\n        if (!isConstructor) {\n          continue;\n        }\n        // handle the class super\n        if (classSuperNode !== undefined) {\n          funcOrClassNode.superClass = classSuperNode;\n        }\n      } else {\n        funcOrClassNode = isLexical\n          ? t.arrowFunctionExpression(params, functionBody)\n          : t.functionExpression(null, params, functionBody);\n      }\n      let id = this.locationService.getLocation(funcValue);\n      invariant(id !== undefined);\n\n      registerFunctionStrictness(\n        funcOrClassNode,\n        funcValue instanceof ECMAScriptSourceFunctionValue && funcValue.$Strict\n      );\n      defineFunction(instance, id, funcOrClassNode);\n    }\n\n    // Process normal functions\n    const factoryFunctionInfos = this._generateFactoryFunctionInfos(rewrittenAdditionalFunctions);\n    for (let [funcBody, instances] of functionEntries) {\n      let functionInfo = this.residualFunctionInfos.get(funcBody);\n      invariant(functionInfo);\n      let { unbound, usesThis } = functionInfo;\n      let params = instances[0].functionValue.$FormalParameters;\n      invariant(params !== undefined);\n\n      // Split instances into normal or nested in an additional function\n      let normalInstances = [];\n      let additionalFunctionNestedInstances = [];\n      for (let instance of instances) {\n        if (this.additionalFunctionValueNestedFunctions.has(instance.functionValue))\n          additionalFunctionNestedInstances.push(instance);\n        else normalInstances.push(instance);\n      }\n\n      let naiveProcessInstances = instancesToSplice => {\n        this.getStatistics().functionClones += instancesToSplice.length;\n\n        for (let instance of instancesToSplice) {\n          let { functionValue, residualFunctionBindings, scopeInstances } = instance;\n          let funcOrClassNode;\n\n          if (this.residualClassMethodInstances.has(functionValue)) {\n            let classMethodInstance = this.residualClassMethodInstances.get(functionValue);\n            invariant(classMethodInstance);\n            let {\n              classSuperNode,\n              classMethodKeyNode,\n              methodType,\n              classMethodComputed,\n              classPrototype,\n              classMethodIsStatic,\n            } = classMethodInstance;\n\n            let isConstructor = methodType === \"constructor\";\n            invariant(classPrototype instanceof ObjectValue);\n            invariant(classMethodKeyNode);\n            invariant(t.isExpression(classMethodKeyNode) || t.isIdentifier(classMethodKeyNode));\n            // we use the classPrototype as the key to get the class expression ast node\n            funcOrClassNode = this._getOrCreateClassNode(classPrototype);\n            // if we are dealing with a constructor, don't serialize it if the original\n            // had an empty user-land constructor (because we create a constructor behind the scenes for them)\n            let hasEmptyConstructor = !!functionValue.$HasEmptyConstructor;\n            if (!isConstructor || (isConstructor && !hasEmptyConstructor)) {\n              let methodParams = params.slice();\n              let classMethod = new ResidualFunctionInstantiator(\n                factoryFunctionInfos,\n                this._getIdentifierReplacements(funcBody, residualFunctionBindings),\n                this._getCallReplacements(funcBody),\n                t.classMethod(\n                  methodType,\n                  classMethodKeyNode,\n                  methodParams,\n                  funcBody,\n                  classMethodComputed,\n                  classMethodIsStatic\n                )\n              ).instantiate();\n\n              // add the class method to the class expression node body\n              if (isConstructor) {\n                funcOrClassNode.body.body.unshift(classMethod);\n              } else {\n                funcOrClassNode.body.body.push(classMethod);\n              }\n            }\n            // we only return the funcOrClassNode if this is the constructor\n            if (!isConstructor) {\n              continue;\n            }\n            // handle the class super\n            if (classSuperNode !== undefined) {\n              funcOrClassNode.superClass = classSuperNode;\n            }\n          } else {\n            let isLexical = instance.functionValue.$ThisMode === \"lexical\";\n            funcOrClassNode = new ResidualFunctionInstantiator(\n              factoryFunctionInfos,\n              this._getIdentifierReplacements(funcBody, residualFunctionBindings),\n              this._getCallReplacements(funcBody),\n              this._createFunctionExpression(params, funcBody, isLexical)\n            ).instantiate();\n\n            let scopeInitialization = [];\n            for (let scope of scopeInstances.values()) {\n              scopeInitialization = scopeInitialization.concat(\n                this.referentializer.getReferentializedScopeInitialization(scope, t.numericLiteral(scope.id))\n              );\n            }\n\n            if (scopeInitialization.length > 0) {\n              let funcOrClassNodeBody = ((funcOrClassNode.body: any): BabelNodeBlockStatement);\n              invariant(t.isBlockStatement(funcOrClassNodeBody));\n              funcOrClassNodeBody.body = scopeInitialization.concat(funcOrClassNodeBody.body);\n            }\n          }\n          let id = this.locationService.getLocation(functionValue);\n          invariant(id !== undefined);\n\n          registerFunctionStrictness(funcOrClassNode, functionValue.$Strict);\n          invariant(id !== undefined);\n          invariant(funcOrClassNode !== undefined);\n          defineFunction(instance, id, funcOrClassNode);\n        }\n      };\n\n      if (additionalFunctionNestedInstances.length > 0) naiveProcessInstances(additionalFunctionNestedInstances);\n      if (normalInstances.length > 0 && !this._shouldUseFactoryFunction(funcBody, normalInstances)) {\n        naiveProcessInstances(normalInstances);\n        this.getStatistics().functionClones--;\n      } else if (normalInstances.length > 0) {\n        const functionUniqueTag = ((funcBody: any): FunctionBodyAstNode).uniqueOrderedTag;\n        invariant(functionUniqueTag);\n        const factoryInfo = factoryFunctionInfos.get(functionUniqueTag);\n        invariant(factoryInfo);\n        const { factoryId } = factoryInfo;\n\n        // filter included variables to only include those that are different\n        let factoryNames: Array<string> = [];\n        let sameResidualBindings = new Map();\n        for (let name of unbound.keys()) {\n          let isDifferent = false;\n          let lastBinding;\n\n          let firstBinding = normalInstances[0].residualFunctionBindings.get(name);\n          invariant(firstBinding);\n          if (firstBinding.modified) {\n            // Must modify for traversal\n            sameResidualBindings.set(name, firstBinding);\n            continue;\n          }\n\n          for (let { residualFunctionBindings } of normalInstances) {\n            let residualBinding = residualFunctionBindings.get(name);\n\n            invariant(residualBinding);\n            invariant(!residualBinding.modified);\n            if (!lastBinding) {\n              lastBinding = residualBinding;\n            } else if (!AreSameResidualBinding(this.realm, residualBinding, lastBinding)) {\n              isDifferent = true;\n              break;\n            }\n          }\n\n          if (isDifferent) {\n            factoryNames.push(name);\n          } else {\n            invariant(lastBinding);\n            sameResidualBindings.set(name, lastBinding);\n          }\n        }\n\n        let factoryParams: Array<BabelNodeLVal> = [];\n        for (let key of factoryNames) {\n          factoryParams.push(t.identifier(key));\n        }\n\n        let scopeInitialization = [];\n        for (let [scopeName, scope] of normalInstances[0].scopeInstances) {\n          let scopeNameId = t.identifier(scopeName);\n          factoryParams.push(scopeNameId);\n          scopeInitialization = scopeInitialization.concat(\n            this.referentializer.getReferentializedScopeInitialization(scope, scopeNameId)\n          );\n        }\n\n        factoryParams = factoryParams.concat(params).slice();\n        let factoryNode = new ResidualFunctionInstantiator(\n          factoryFunctionInfos,\n          this._getIdentifierReplacements(funcBody, sameResidualBindings),\n          this._getCallReplacements(funcBody),\n          this._createFunctionExpression(factoryParams, funcBody, false)\n        ).instantiate();\n\n        if (scopeInitialization.length > 0) {\n          let factoryNodeBody = ((factoryNode.body: any): BabelNodeBlockStatement);\n          invariant(t.isBlockStatement(factoryNodeBody));\n          factoryNodeBody.body = scopeInitialization.concat(factoryNodeBody.body);\n        }\n\n        // factory functions do not depend on any nested generator scope, so they go to the prelude\n        let factoryDeclaration = t.variableDeclaration(\"var\", [t.variableDeclarator(factoryId, factoryNode)]);\n        this.prelude.push(factoryDeclaration);\n\n        registerFunctionStrictness(factoryNode, normalInstances[0].functionValue.$Strict);\n\n        for (let instance of normalInstances) {\n          let { functionValue, residualFunctionBindings, insertionPoint } = instance;\n          let functionId = this.locationService.getLocation(functionValue);\n          invariant(functionId !== undefined);\n          let hasFunctionArg = false;\n          let flatArgs: Array<BabelNodeExpression> = factoryNames.map(name => {\n            let residualBinding = residualFunctionBindings.get(name);\n            invariant(residualBinding);\n            let serializedValue = residualBinding.serializedValue;\n            hasFunctionArg =\n              hasFunctionArg || (residualBinding.value && residualBinding.value instanceof FunctionValue);\n            invariant(serializedValue);\n            return serializedValue;\n          });\n          let hasAnyLeakedIds = false;\n          for (const scope of instance.scopeInstances.values()) {\n            flatArgs.push(t.numericLiteral(scope.id));\n            if (scope.leakedIds.length > 0) hasAnyLeakedIds = true;\n          }\n          let funcNode;\n          let firstUsage = this.firstFunctionUsages.get(functionValue);\n          // todo: why can this be undefined?\n          invariant(insertionPoint !== undefined);\n          if (\n            // The same free variables in shared instances may refer to objects with different initialization values\n            // so a stub forward function is needed during delay initializations.\n            this.residualFunctionInitializers.hasInitializerStatement(functionValue) ||\n            usesThis ||\n            hasFunctionArg ||\n            (firstUsage === undefined || !firstUsage.isNotEarlierThan(insertionPoint)) ||\n            this.functionPrototypes.get(functionValue) !== undefined ||\n            hasAnyLeakedIds\n          ) {\n            let callArgs: Array<BabelNodeExpression | BabelNodeSpreadElement> = [t.thisExpression()];\n            for (let flatArg of flatArgs) callArgs.push(flatArg);\n            for (let param of params) {\n              if (param.type !== \"Identifier\") {\n                throw new FatalError(\"TODO: do not know how to deal with non-Identifier parameters\");\n              }\n              callArgs.push(((param: any): BabelNodeIdentifier));\n            }\n\n            let callee = t.memberExpression(factoryId, t.identifier(\"call\"));\n\n            let childBody = t.blockStatement([t.returnStatement(t.callExpression(callee, callArgs))]);\n\n            funcNode = t.functionExpression(null, params, childBody);\n            registerFunctionStrictness(funcNode, functionValue.$Strict);\n          } else {\n            funcNode = t.callExpression(\n              t.memberExpression(factoryId, t.identifier(\"bind\")),\n              [nullExpression].concat(flatArgs)\n            );\n          }\n\n          defineFunction(instance, functionId, funcNode);\n        }\n      }\n    }\n\n    for (let referentializationScope of this.referentializer.referentializationState.keys()) {\n      let prelude;\n      // Get the prelude for this additional function value\n      if (referentializationScope !== \"GLOBAL\") {\n        let additionalFunction = referentializationScope;\n        prelude = this.additionalFunctionPreludes.get(additionalFunction);\n        invariant(prelude !== undefined);\n      } else {\n        prelude = this.prelude;\n      }\n      prelude.unshift(\n        ...this.referentializer.createCapturedScopesPrelude(referentializationScope),\n        ...this.referentializer.createLeakedIds(referentializationScope)\n      );\n    }\n\n    for (let instance of this.functionInstances.reverse()) {\n      let functionBody = functionBodies.get(instance);\n      if (functionBody !== undefined) {\n        let insertionPoint = instance.insertionPoint;\n        invariant(insertionPoint instanceof BodyReference);\n        // v8 seems to do something clever with array splicing, so this potentially\n        // expensive operations seems to be actually cheap.\n        insertionPoint.body.entries.splice(insertionPoint.index, 0, ...functionBody);\n      }\n    }\n\n    // Inject initializer code for indexed vars into functions (for delay initializations)\n    for (let [functionValue, funcNode] of funcNodes) {\n      let initializerStatement = this.residualFunctionInitializers.getInitializerStatement(functionValue);\n      if (initializerStatement !== undefined) {\n        invariant(t.isFunctionExpression(funcNode));\n        let blockStatement: BabelNodeBlockStatement = ((funcNode: any): BabelNodeFunctionExpression).body;\n        blockStatement.body.unshift(initializerStatement);\n      }\n    }\n\n    for (let [additionalFunction, body] of Array.from(rewrittenAdditionalFunctions.entries()).reverse()) {\n      let additionalFunctionInfo = this.additionalFunctionValueInfos.get(additionalFunction);\n      invariant(additionalFunctionInfo);\n      // Modified bindings initializers of optimized function\n      let bodySegment = additionalFunctionModifiedBindingsSegment.get(additionalFunction);\n      // initializers from Referentialization\n      let initializationStatements = getFunctionBody(additionalFunctionInfo.instance);\n      let prelude = this.additionalFunctionPreludes.get(additionalFunction);\n      invariant(prelude !== undefined);\n      let insertionPoint = additionalFunctionInfo.instance.insertionPoint;\n      invariant(insertionPoint);\n      // TODO: I think this inserts things in the wrong place\n      insertionPoint.body.entries.splice(insertionPoint.index, 0, ...initializationStatements);\n      if (bodySegment) body.unshift(...bodySegment);\n      body.unshift(...prelude);\n    }\n\n    return { unstrictFunctionBodies, strictFunctionBodies };\n  }\n  _getOrCreateClassNode(classPrototype: ObjectValue): BabelNodeClassExpression {\n    if (!this.classes.has(classPrototype)) {\n      let funcOrClassNode = t.classExpression(null, null, t.classBody([]), []);\n      this.classes.set(classPrototype, funcOrClassNode);\n      return funcOrClassNode;\n    } else {\n      let funcOrClassNode = this.classes.get(classPrototype);\n      invariant(funcOrClassNode && t.isClassExpression(funcOrClassNode));\n      return funcOrClassNode;\n    }\n  }\n}\n"],"file":"ResidualFunctions.js"}