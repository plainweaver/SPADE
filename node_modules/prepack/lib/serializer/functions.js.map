{"version":3,"sources":["../../src/serializer/functions.js"],"names":["Functions","constructor","realm","moduleTracer","_writeEffects","Map","_noopFunction","undefined","_optimizedFunctionId","reactFunctionMap","_unwrapAbstract","value","elements","values","getElements","possibleValues","filter","element","EmptyValue","UndefinedValue","length","_optimizedFunctionEntryOfValue","AbstractValue","ObjectValue","config","rootComponent","validConfig","intrinsics","validRootComponent","ECMAScriptSourceFunctionValue","BoundFunctionValue","location","expressionLocation","result","handleError","CompilerDiagnostic","currentLocation","FatalError","_generateInitialAdditionalFunctions","globalKey","recordedAdditionalFunctions","globalRecordedAdditionalFunctionsMap","modules","logger","tryQuery","$GlobalObject","funcId","Properties","GetOwnPropertyKeysArray","property","properties","get","descriptor","PropertyDescriptor","entry","push","_generateOptimizedFunctionsFromRealm","valueToOptimize","argModel","optimizedFunctions","isValid","error","optimizeReactComponentTreeRoots","statistics","recordedReactRootValues","react","verbose","logInformation","alreadyEvaluated","componentRoot","getDeclaringOptimizedFunction","functionValue","optimizedFunctionValue","additionalEffects","createdObjects","effects","has","processCollectedNestedOptimizedFunctions","collectedNestedOptimizedFunctionEffects","additionalFunctionEffects","set","_withEmptyOptimizedFunctionList","func","oldRealmOptimizedFunctions","currentOptimizedFunctionId","t1","tracers","beginOptimizingFunction","withNewOptimizedFunction","t2","endOptimizingFunction","oldValue","model","checkThatFunctionsAreIndependent","additionalFunctionsToProcess","additionalFunctionStack","additionalFunctions","Set","map","recordWriteEffectsForOptimizedFunctionAndNestedFunctions","call","Utils","createModelledFunctionCall","logCompilerDiagnostic","msg","evaluatePure","evaluateForEffectsInGlobalEnv","sideEffectType","binding","withEffectsAppliedInGlobalEnv","newOptFuncs","newEntry","add","pop","funcObject","conflicts","isParentOf","possibleParent","fun","parentAdditionalFunction","fun1","FunctionValue","fun1Location","fun1Name","getDebugName","e1","AbruptCompletion","fun2","fun2Location","fun2Name","reportFn","reportWriteConflicts","modifiedProperties","withPossibleParentEffectsApplied","toExecute","optimizedFunction","funEffects","parentEffects","newToExecute","size","diagnostic","getAdditionalFunctionValuesToEffects","f1name","f2name","pbs","f1IsParentOfF2","call2","reportConflict","object","key","originalLocation","firstLocationString","secondLocationString","propString","objectString","writtenObjects","forEach","val","m","oldReportObjectGetOwnProperties","reportObjectGetOwnProperties","ob","oldReportPropertyAccess","reportPropertyAccess","pb","isWrite","refuseSerializationOnPropertyBinding","Array","isArray","keyString","Value","toDisplayString"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type { BabelNodeSourceLocation } from \"@babel/types\";\nimport { AbruptCompletion } from \"../completions.js\";\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport invariant from \"../invariant.js\";\nimport { type Effects, type PropertyBindings, Realm } from \"../realm.js\";\nimport type { PropertyBinding, ReactComponentTreeConfig } from \"../types.js\";\nimport { ignoreErrorsIn } from \"../utils/errors.js\";\nimport {\n  AbstractObjectValue,\n  AbstractValue,\n  BoundFunctionValue,\n  ECMAScriptSourceFunctionValue,\n  FunctionValue,\n  ObjectValue,\n  UndefinedValue,\n  EmptyValue,\n  Value,\n} from \"../values/index.js\";\nimport { Get } from \"../methods/index.js\";\nimport { ModuleTracer } from \"../utils/modules.js\";\nimport { createAdditionalEffects } from \"./utils.js\";\nimport { ReactStatistics } from \"./types\";\nimport type { AdditionalFunctionEffects, WriteEffects } from \"./types\";\nimport { convertConfigObjectToReactComponentTreeConfig, valueIsKnownReactAbstraction } from \"../react/utils.js\";\nimport { optimizeReactComponentTreeRoot } from \"../react/optimizing.js\";\nimport { handleReportedSideEffect } from \"./utils.js\";\nimport type { ArgModel } from \"../types.js\";\nimport { optionalStringOfLocation } from \"../utils/babelhelpers\";\nimport { Properties, Utils } from \"../singletons.js\";\nimport { PropertyDescriptor } from \"../descriptors.js\";\n\ntype AdditionalFunctionEntry = {\n  value: ECMAScriptSourceFunctionValue | AbstractValue,\n  config?: ReactComponentTreeConfig,\n  argModel?: ArgModel,\n};\n\nexport class Functions {\n  constructor(realm: Realm, moduleTracer: ModuleTracer) {\n    this.realm = realm;\n    this.moduleTracer = moduleTracer;\n    this._writeEffects = new Map();\n    this._noopFunction = undefined;\n    this._optimizedFunctionId = 0;\n    this.reactFunctionMap = new Map();\n  }\n\n  realm: Realm;\n  moduleTracer: ModuleTracer;\n  _writeEffects: WriteEffects;\n  _noopFunction: void | ECMAScriptSourceFunctionValue;\n  _optimizedFunctionId: number;\n  reactFunctionMap: Map<FunctionValue, FunctionValue>;\n\n  _unwrapAbstract(value: AbstractValue): Value {\n    let elements = value.values.getElements();\n    if (elements) {\n      let possibleValues = [...elements].filter(\n        element => !(element instanceof EmptyValue || element instanceof UndefinedValue)\n      );\n      if (possibleValues.length === 1) {\n        return possibleValues[0];\n      }\n    }\n    return value;\n  }\n\n  _optimizedFunctionEntryOfValue(value: Value): AdditionalFunctionEntry | void {\n    let realm = this.realm;\n    // if we conditionally called __optimize, we may have an AbstractValue that is the union of Empty or Undefined and\n    // a function/component to optimize\n    if (value instanceof AbstractValue) {\n      value = this._unwrapAbstract(value);\n    }\n    invariant(value instanceof ObjectValue);\n    // React component tree logic\n    let config = Get(realm, value, \"config\");\n    let rootComponent = Get(realm, value, \"rootComponent\");\n    let validConfig = config instanceof ObjectValue || config === realm.intrinsics.undefined;\n    let validRootComponent =\n      rootComponent instanceof ECMAScriptSourceFunctionValue ||\n      rootComponent instanceof BoundFunctionValue ||\n      (rootComponent instanceof AbstractValue && valueIsKnownReactAbstraction(this.realm, rootComponent));\n\n    if (validConfig && validRootComponent) {\n      return {\n        value: ((rootComponent: any): AbstractValue | ECMAScriptSourceFunctionValue),\n        config: convertConfigObjectToReactComponentTreeConfig(realm, ((config: any): ObjectValue | UndefinedValue)),\n      };\n    }\n\n    let location = optionalStringOfLocation(value.expressionLocation);\n    let result = realm.handleError(\n      new CompilerDiagnostic(\n        `Optimized Function Value ${location} is an not a function or react element`,\n        realm.currentLocation,\n        \"PP0033\",\n        \"Warning\"\n      )\n    );\n    // Here we can recover by ignoring the __optimize call and emit correct code\n    if (result !== \"Recover\") throw new FatalError(\"Optimized Function Values must be functions or react elements\");\n  }\n\n  _generateInitialAdditionalFunctions(globalKey: string): Array<AdditionalFunctionEntry> {\n    let recordedAdditionalFunctions: Array<AdditionalFunctionEntry> = [];\n    let realm = this.realm;\n    let globalRecordedAdditionalFunctionsMap = this.moduleTracer.modules.logger.tryQuery(\n      () => Get(realm, realm.$GlobalObject, globalKey),\n      realm.intrinsics.undefined\n    );\n    invariant(globalRecordedAdditionalFunctionsMap instanceof ObjectValue);\n    for (let funcId of Properties.GetOwnPropertyKeysArray(realm, globalRecordedAdditionalFunctionsMap, true, false)) {\n      let property = globalRecordedAdditionalFunctionsMap.properties.get(funcId);\n      if (property) {\n        invariant(property.descriptor instanceof PropertyDescriptor);\n        let value = property.descriptor.value;\n        invariant(value !== undefined);\n        let entry = this._optimizedFunctionEntryOfValue(value);\n        if (entry) recordedAdditionalFunctions.push(entry);\n      }\n    }\n    return recordedAdditionalFunctions;\n  }\n\n  _generateOptimizedFunctionsFromRealm(): Array<AdditionalFunctionEntry> {\n    let realm = this.realm;\n    let recordedAdditionalFunctions = [];\n    for (let [valueToOptimize, argModel] of realm.optimizedFunctions) {\n      let value = valueToOptimize instanceof AbstractValue ? this._unwrapAbstract(valueToOptimize) : valueToOptimize;\n      invariant(value instanceof ECMAScriptSourceFunctionValue);\n      // Check for case where __optimize was called in speculative context where effects were discarded\n      if (!value.isValid()) {\n        let error = new CompilerDiagnostic(\n          \"Called __optimize on function in failed speculative context\",\n          value.expressionLocation,\n          \"PP1008\",\n          \"RecoverableError\"\n        );\n        if (realm.handleError(error) !== \"Recover\") throw new FatalError();\n      } else {\n        recordedAdditionalFunctions.push({ value, argModel });\n      }\n    }\n    return recordedAdditionalFunctions;\n  }\n\n  optimizeReactComponentTreeRoots(statistics: ReactStatistics): void {\n    let logger = this.moduleTracer.modules.logger;\n    let recordedReactRootValues = this._generateInitialAdditionalFunctions(\"__reactComponentTrees\");\n    // Get write effects of the components\n    if (this.realm.react.verbose) {\n      logger.logInformation(`Evaluating ${recordedReactRootValues.length} React component tree roots...`);\n    }\n    let alreadyEvaluated = new Map();\n    for (let { value: componentRoot, config } of recordedReactRootValues) {\n      invariant(config);\n      optimizeReactComponentTreeRoot(\n        this.realm,\n        componentRoot,\n        config,\n        this._writeEffects,\n        logger,\n        statistics,\n        alreadyEvaluated,\n        this.reactFunctionMap\n      );\n    }\n  }\n\n  // Note: this may only be used by nested optimized functions that are known to be evaluated inside of their parent\n  // optimized function's __optimize call (e.g. array.map/filter). In this case, lexical nesting is equivalent to the\n  // nesting of __optimize calls.\n  getDeclaringOptimizedFunction(functionValue: ECMAScriptSourceFunctionValue): void | FunctionValue {\n    for (let [optimizedFunctionValue, additionalEffects] of this._writeEffects) {\n      // CreatedObjects is all objects created by this optimized function but not\n      // nested optimized functions.\n      let createdObjects = additionalEffects.effects.createdObjects;\n      if (createdObjects.has(functionValue)) return optimizedFunctionValue;\n    }\n  }\n\n  processCollectedNestedOptimizedFunctions(): void {\n    for (let [functionValue, effects] of this.realm.collectedNestedOptimizedFunctionEffects) {\n      let additionalFunctionEffects = createAdditionalEffects(\n        this.realm,\n        effects,\n        true,\n        \"AdditionalFunctionEffects\",\n        this._writeEffects,\n        this.reactFunctionMap,\n        functionValue,\n        this.getDeclaringOptimizedFunction(functionValue)\n      );\n      invariant(additionalFunctionEffects !== null);\n      this._writeEffects.set(functionValue, additionalFunctionEffects);\n    }\n  }\n\n  _withEmptyOptimizedFunctionList(\n    { value, argModel }: AdditionalFunctionEntry,\n    func: (ECMAScriptSourceFunctionValue, ArgModel | void) => void\n  ): void {\n    let oldRealmOptimizedFunctions = this.realm.optimizedFunctions;\n    this.realm.optimizedFunctions = new Map();\n    let currentOptimizedFunctionId = this._optimizedFunctionId++;\n    invariant(value instanceof ECMAScriptSourceFunctionValue);\n    for (let t1 of this.realm.tracers) t1.beginOptimizingFunction(currentOptimizedFunctionId, value);\n    this.realm.withNewOptimizedFunction(() => func(value, argModel), value);\n    for (let t2 of this.realm.tracers) t2.endOptimizingFunction(currentOptimizedFunctionId);\n    for (let [oldValue, model] of oldRealmOptimizedFunctions) this.realm.optimizedFunctions.set(oldValue, model);\n  }\n\n  checkThatFunctionsAreIndependent(): void {\n    let additionalFunctionsToProcess = this._generateOptimizedFunctionsFromRealm();\n    // When we find declarations of nested optimized functions, we need to apply the parent\n    // effects.\n    let additionalFunctionStack = [];\n    let additionalFunctions = new Set(additionalFunctionsToProcess.map(entry => entry.value));\n\n    let recordWriteEffectsForOptimizedFunctionAndNestedFunctions = (\n      functionValue: ECMAScriptSourceFunctionValue,\n      argModel: ArgModel | void\n    ) => {\n      additionalFunctionStack.push(functionValue);\n      let call = Utils.createModelledFunctionCall(this.realm, functionValue, argModel);\n      let realm = this.realm;\n\n      let logCompilerDiagnostic = (msg: string, location: ?BabelNodeSourceLocation) => {\n        let error = new CompilerDiagnostic(msg, location, \"PP1007\", \"Warning\");\n        realm.handleError(error);\n      };\n      let effects: Effects = realm.evaluatePure(\n        () => realm.evaluateForEffectsInGlobalEnv(call, undefined, \"additional function\"),\n        /*bubbles*/ true,\n        (sideEffectType, binding, expressionLocation) =>\n          handleReportedSideEffect(logCompilerDiagnostic, sideEffectType, binding, expressionLocation)\n      );\n      invariant(effects);\n      let additionalFunctionEffects = createAdditionalEffects(\n        this.realm,\n        effects,\n        true,\n        \"AdditionalFunctionEffects\",\n        this._writeEffects,\n        this.reactFunctionMap,\n        functionValue,\n        this.getDeclaringOptimizedFunction(functionValue)\n      );\n      invariant(additionalFunctionEffects);\n      effects = additionalFunctionEffects.effects;\n      if (this._writeEffects.has(functionValue)) {\n        let error = new CompilerDiagnostic(\n          \"Trying to optimize a function with two parent optimized functions, which is not currently allowed.\",\n          functionValue.expressionLocation,\n          \"PP1009\",\n          \"RecoverableError\"\n        );\n        // we can recover by assuming one set of effects to show further diagnostics\n        if (realm.handleError(error) !== \"Recover\") throw new FatalError();\n      } else {\n        this._writeEffects.set(functionValue, additionalFunctionEffects);\n      }\n\n      // Conceptually this will ensure that the nested additional function is defined\n      // although for later cases, we'll apply the effects of the parents only.\n      this.realm.withEffectsAppliedInGlobalEnv(() => {\n        let newOptFuncs = this._generateOptimizedFunctionsFromRealm();\n        for (let newEntry of newOptFuncs) {\n          additionalFunctions.add(newEntry.value);\n          this._withEmptyOptimizedFunctionList(newEntry, recordWriteEffectsForOptimizedFunctionAndNestedFunctions);\n        }\n        // Now we have to remember the stack of effects that need to be applied to deal with\n        // this additional function.\n        return null;\n      }, additionalFunctionEffects.effects);\n      invariant(additionalFunctionStack.pop() === functionValue);\n    };\n\n    for (let funcObject of additionalFunctionsToProcess) {\n      this._withEmptyOptimizedFunctionList(funcObject, recordWriteEffectsForOptimizedFunctionAndNestedFunctions);\n    }\n    invariant(additionalFunctionStack.length === 0);\n\n    // check that functions are independent\n    let conflicts: Map<BabelNodeSourceLocation, CompilerDiagnostic> = new Map();\n    let isParentOf = (possibleParent, fun) => {\n      if (fun === undefined) return false;\n      let effects = this._writeEffects.get(fun);\n      invariant(effects !== undefined);\n      if (effects.parentAdditionalFunction !== undefined) {\n        if (effects.parentAdditionalFunction === possibleParent) return true;\n        return isParentOf(possibleParent, effects.parentAdditionalFunction);\n      }\n      return false;\n    };\n    for (let fun1 of additionalFunctions) {\n      invariant(fun1 instanceof FunctionValue);\n      let fun1Location = fun1.expressionLocation;\n      let fun1Name = fun1.getDebugName() || optionalStringOfLocation(fun1Location);\n      // Also do argument validation here\n      let additionalFunctionEffects = this._writeEffects.get(fun1);\n      invariant(additionalFunctionEffects !== undefined);\n      let e1 = additionalFunctionEffects.effects;\n      invariant(e1 !== undefined);\n      if (e1.result instanceof AbruptCompletion) {\n        let error = new CompilerDiagnostic(\n          `Additional function ${fun1Name} will terminate abruptly`,\n          e1.result.location,\n          \"PP1002\",\n          \"RecoverableError\"\n        );\n        // We generate correct code in this case, but the user probably doesn't want us to emit an unconditional throw\n        if (this.realm.handleError(error) !== \"Recover\") throw new FatalError();\n      }\n      for (let fun2 of additionalFunctions) {\n        if (fun1 === fun2) continue;\n        invariant(fun2 instanceof FunctionValue);\n        let fun2Location = fun2.expressionLocation;\n        let fun2Name = fun2.getDebugName() || optionalStringOfLocation(fun2Location);\n        let reportFn = () => {\n          this.reportWriteConflicts(\n            fun1Name,\n            fun2Name,\n            conflicts,\n            e1.modifiedProperties,\n            isParentOf(fun1, fun2),\n            Utils.createModelledFunctionCall(this.realm, fun2)\n          );\n          return null;\n        };\n        // Recursively apply all parent effects\n        let withPossibleParentEffectsApplied = (toExecute, optimizedFunction) => {\n          let funEffects = this._writeEffects.get(optimizedFunction);\n          invariant(funEffects !== undefined);\n          let parentAdditionalFunction = funEffects.parentAdditionalFunction;\n          if (parentAdditionalFunction !== undefined) {\n            let parentEffects = this._writeEffects.get(parentAdditionalFunction);\n            invariant(parentEffects !== undefined);\n            let newToExecute = () => this.realm.withEffectsAppliedInGlobalEnv(toExecute, parentEffects.effects);\n            withPossibleParentEffectsApplied(newToExecute, parentAdditionalFunction);\n          } else {\n            toExecute();\n          }\n        };\n        withPossibleParentEffectsApplied(reportFn, fun2);\n      }\n    }\n    if (conflicts.size > 0) {\n      for (let diagnostic of conflicts.values())\n        if (this.realm.handleError(diagnostic) !== \"Recover\") throw new FatalError();\n    }\n  }\n\n  getAdditionalFunctionValuesToEffects(): Map<FunctionValue, AdditionalFunctionEffects> {\n    return this._writeEffects;\n  }\n\n  reportWriteConflicts(\n    f1name: string,\n    f2name: string,\n    conflicts: Map<BabelNodeSourceLocation, CompilerDiagnostic>,\n    pbs: PropertyBindings,\n    f1IsParentOfF2: boolean,\n    call2: void => Value\n  ): void {\n    let reportConflict = (\n      location: BabelNodeSourceLocation,\n      object: string = \"\",\n      key?: string,\n      originalLocation: BabelNodeSourceLocation | void | null\n    ) => {\n      let firstLocationString = optionalStringOfLocation(originalLocation);\n      let secondLocationString = optionalStringOfLocation(location);\n      let propString = key ? ` \"${key}\"` : \"\";\n      let objectString = object ? ` on object \"${object}\" ` : \"\";\n      if (!objectString && key) objectString = \" on <unnamed object> \";\n      let error = new CompilerDiagnostic(\n        `Write to property${propString}${objectString}at optimized function ${f1name}${firstLocationString} conflicts with access in function ${f2name}${secondLocationString}`,\n        location,\n        \"PP1003\",\n        \"RecoverableError\"\n      );\n      conflicts.set(location, error);\n    };\n    let writtenObjects: Set<ObjectValue | AbstractObjectValue> = new Set();\n    pbs.forEach((val, key, m) => {\n      writtenObjects.add(key.object);\n    });\n    let oldReportObjectGetOwnProperties = this.realm.reportObjectGetOwnProperties;\n    this.realm.reportObjectGetOwnProperties = (ob: ObjectValue | AbstractObjectValue) => {\n      let location = this.realm.currentLocation;\n      invariant(location);\n      if (writtenObjects.has(ob) && !conflicts.has(location))\n        reportConflict(location, ob.getDebugName(), undefined, ob.expressionLocation);\n    };\n    let oldReportPropertyAccess = this.realm.reportPropertyAccess;\n    this.realm.reportPropertyAccess = (pb: PropertyBinding, isWrite: boolean) => {\n      if (ObjectValue.refuseSerializationOnPropertyBinding(pb)) return;\n      let location = this.realm.currentLocation;\n      if (!location) return; // happens only when accessing an additional function property\n      if (pbs.has(pb) && (!f1IsParentOfF2 || isWrite) && !conflicts.has(location)) {\n        let originalLocation =\n          pb.descriptor instanceof PropertyDescriptor && pb.descriptor.value && !Array.isArray(pb.descriptor.value)\n            ? pb.descriptor.value.expressionLocation\n            : undefined;\n        let keyString = pb.key instanceof Value ? pb.key.toDisplayString() : pb.key;\n        reportConflict(location, pb.object ? pb.object.getDebugName() : undefined, keyString, originalLocation);\n      }\n    };\n    try {\n      ignoreErrorsIn(this.realm, () => this.realm.evaluateForEffectsInGlobalEnv(call2));\n    } finally {\n      this.realm.reportPropertyAccess = oldReportPropertyAccess;\n      this.realm.reportObjectGetOwnProperties = oldReportObjectGetOwnProperties;\n    }\n  }\n}\n"],"file":"functions.js"}