"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResidualOperationSerializer = void 0;

var _realm = require("../realm.js");

var _generator = require("../utils/generator.js");

var _PreludeGenerator = require("../utils/PreludeGenerator.js");

var _babelhelpers = require("../utils/babelhelpers.js");

var _invariant = _interopRequireDefault(require("../invariant.js"));

var t = _interopRequireWildcard(require("@babel/types"));

var _index = require("../values/index.js");

var _singletons = require("../singletons.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
function serializeBody(generator, context, valuesToProcess) {
  let statements = context.serializeGenerator(generator, valuesToProcess);
  if (statements.length === 1 && statements[0].type === "BlockStatement") return statements[0];
  return t.blockStatement(statements);
}

function isSelfReferential(value, pathNode) {
  if (value === pathNode) return true;

  if (value instanceof _index.AbstractValue && pathNode !== undefined) {
    for (let v of value.args) {
      if (isSelfReferential(v, pathNode)) return true;
    }
  }

  return false;
}

class ResidualOperationSerializer {
  constructor(realm, preludeGenerator) {
    this.realm = realm;
    this.preludeGenerator = preludeGenerator;
  }

  getErrorStatement(message) {
    if (this.realm.invariantMode === "throw") return t.throwStatement(t.newExpression(this.preludeGenerator.memoizeReference("Error"), [message]));else {
      let targetReference = this.realm.invariantMode;
      let args = [message];
      let i = targetReference.indexOf("+");

      if (i !== -1) {
        let s = targetReference.substr(i + 1);
        let x = Number.parseInt(s, 10);
        args.push(isNaN(x) ? t.stringLiteral(s) : t.numericLiteral(x));
        targetReference = targetReference.substr(0, i);
      }

      return t.expressionStatement(t.callExpression(this.preludeGenerator.memoizeReference(targetReference), args));
    }
  }

  serializeStatement(operationDescriptor, nodes, context, valuesToProcess, declaredId) {
    let {
      data,
      type
    } = operationDescriptor;
    let babelNode;

    switch (type) {
      case "ASSUME_CALL":
        babelNode = this._serializeAssumeCall(data, nodes);
        break;

      case "CONCRETE_MODEL":
        babelNode = this._serializeConcreteModel(data, nodes);
        break;

      case "CONDITIONAL_PROPERTY_ASSIGNMENT":
        babelNode = this._serializeConditionalPropertyAssignment(data, nodes, context, valuesToProcess);
        break;

      case "CONDITIONAL_THROW":
        babelNode = this._serializeConditionalThrow(data, nodes, context);
        break;

      case "CONSOLE_LOG":
        babelNode = this._serializeConsoleLog(data, nodes);
        break;

      case "DEFINE_PROPERTY":
        babelNode = this._serializeDefineProperty(data, nodes, context);
        break;

      case "DO_WHILE":
        babelNode = this._serializeDoWhile(data, nodes, context, valuesToProcess);
        break;

      case "EMIT_CALL":
        babelNode = this._serializeEmitCall(data, nodes);
        break;

      case "EMIT_PROPERTY_ASSIGNMENT":
        babelNode = this._serializeEmitPropertyAssignment(data, nodes, context);
        break;

      case "FOR_IN":
        babelNode = this._serializeForIn(data, nodes);
        break;

      case "GLOBAL_ASSIGNMENT":
        babelNode = this._serializeGlobalAssignment(data, nodes);
        break;

      case "GLOBAL_DELETE":
        babelNode = this._serializeGlobalDelete(data, nodes);
        break;

      case "JOIN_GENERATORS":
        babelNode = this._serializeJoinGenerators(data, nodes, context, valuesToProcess);
        break;

      case "LOCAL_ASSIGNMENT":
        babelNode = this._serializeLocalAssignment(data, nodes, context, valuesToProcess);
        break;

      case "NOOP":
        babelNode = t.emptyStatement();
        break;

      case "OBJECT_SET_PARTIAL":
        babelNode = this._serializeObjectSetPartial(data, nodes);
        break;

      case "PROPERTY_ASSIGNMENT":
        babelNode = this._serializePropertyAssignment(data, nodes, context, valuesToProcess);
        break;

      case "PROPERTY_DELETE":
        babelNode = this._serializePropertyDelete(data, nodes);
        break;

      case "THROW":
        babelNode = this._serializeThrow(data, nodes);
        break;
      // Invariants

      case "INVARIANT":
        babelNode = this._serializeInvariant(data, nodes);
        break;
      // React

      case "REACT_SSR_REGEX_CONSTANT":
        return t.variableDeclaration("var", [t.variableDeclarator(t.identifier("matchHtmlRegExp"), t.regExpLiteral("[\"'&<>]"))]);

      case "REACT_SSR_PREV_TEXT_NODE":
        return t.variableDeclaration("var", [t.variableDeclarator(t.identifier("previousWasTextNode"), t.booleanLiteral(false))]);

      default:
        let babelNodeExpression = this.serializeExpression(operationDescriptor, nodes, context);
        if (declaredId !== undefined) babelNode = this._serializeDerivedOperationDescriptor(declaredId, babelNodeExpression);else babelNode = this._serializeVoidOperationDescriptor(babelNodeExpression);
        return babelNode;
    }

    (0, _invariant.default)(declaredId === undefined);
    return babelNode;
  }

  serializeExpression(operationDescriptor, nodes, context, valuesToProcess) {
    let {
      data,
      type
    } = operationDescriptor;
    let babelNode;

    switch (type) {
      case "IDENTIFIER":
        babelNode = this._serializeIdentifier(data, nodes);
        break;

      case "REBUILT_OBJECT":
        babelNode = this._serializeRebuiltObject(data, nodes);
        break;

      case "BINARY_EXPRESSION":
        babelNode = this._serializeBinaryExpression(data, nodes);
        break;

      case "LOGICAL_EXPRESSION":
        babelNode = this._serializeLogicalExpression(data, nodes);
        break;

      case "CONDITIONAL_EXPRESSION":
        babelNode = this._serializeConditionalExpression(data, nodes);
        break;

      case "UNARY_EXPRESSION":
        babelNode = this._serializeUnaryExpression(data, nodes);
        break;

      case "ABSTRACT_PROPERTY":
        babelNode = this._serializeAbstractProperty(data, nodes);
        break;

      case "ABSTRACT_FROM_TEMPLATE":
        babelNode = this._serializeAbstractFromTemplate(data, nodes);
        break;

      case "COERCE_TO_STRING":
        babelNode = this._serializeCoerceToString(data, nodes);
        break;

      case "OBJECT_ASSIGN":
        babelNode = this._serializeObjectAssign(data, nodes);
        break;

      case "SINGLE_ARG":
        babelNode = this._serializeSingleArg(data, nodes);
        break;

      case "CALL_BAILOUT":
        babelNode = this._serializeCallBailout(data, nodes);
        break;

      case "EMIT_CALL_AND_CAPTURE_RESULT":
        babelNode = this._serializeEmitCallAndCaptureResults(data, nodes);
        break;

      case "NEW_EXPRESSION":
        babelNode = this._serializeNewExpression(data, nodes);
        break;

      case "FOR_STATEMENT_FUNC":
        babelNode = this._serializeForFunctionCall(data, nodes);
        break;

      case "GET_BINDING":
        babelNode = this._serializeGetBinding(data, nodes, context);
        break;

      case "UNKNOWN_ARRAY_METHOD_CALL":
        babelNode = this._serializeUnknownArrayMethodCall(data, nodes);
        break;

      case "UNKNOWN_ARRAY_METHOD_PROPERTY_CALL":
        babelNode = this._serializeUnknownArrayMethodPropertyCall(data, nodes);
        break;

      case "UNKNOWN_ARRAY_LENGTH":
        babelNode = this._serializeUnknownArrayLength(data, nodes);
        break;

      case "UNKNOWN_ARRAY_GET_PARTIAL":
        babelNode = this._serializeUnknownArrayGetPartial(data, nodes);
        break;

      case "OBJECT_GET_PARTIAL":
        babelNode = this._serializeObjectGetPartial(data, nodes);
        break;

      case "ABSTRACT_OBJECT_GET_PARTIAL":
        babelNode = this._serializeAbstractObjectGetPartial(data, nodes);
        break;

      case "ABSTRACT_OBJECT_GET_PROTO_OF":
        babelNode = this._serializeAbstractObjectGetProtoOf(data, nodes);
        break;

      case "ABSTRACT_OBJECT_GET":
        babelNode = this._serializeAbstractObjectGet(data, nodes);
        break;

      case "OBJECT_PROTO_HAS_OWN_PROPERTY":
        babelNode = this._serializeObjectProtoHasOwnProperty(data, nodes);
        break;

      case "OBJECT_PROTO_GET_OWN_PROPERTY_DESCRIPTOR":
        babelNode = this._serializeObjectProtoGetOwnPropertyDescriptor(data, nodes);
        break;

      case "DIRECT_CALL_WITH_ARG_LIST":
        babelNode = this._serializeDirectCallWithArgList(data, nodes);
        break;

      case "CALL_ABSTRACT_FUNC":
        babelNode = this._serializeCallAbstractFunc(data, nodes);
        break;

      case "CALL_ABSTRACT_FUNC_THIS":
        babelNode = this._serializeCallAbstractFuncThis(data, nodes);
        break;

      case "LOGICAL_PROPERTY_ASSIGNMENT":
        babelNode = this._serializeLogicalPropertyAssignment(data, nodes);
        break;

      case "UPDATE_INCREMENTOR":
        babelNode = this._serializeUpdateIncrementor(data, nodes);
        break;

      case "MODULES_REQUIRE":
        babelNode = this._serializeModulesRequires(data, nodes);
        break;

      case "RESIDUAL_CALL":
        babelNode = this._serializeResidualCall(data, nodes);
        break;

      case "CANNOT_BECOME_OBJECT":
        babelNode = this._serializeCannotBecomeObject(data, nodes);
        break;

      case "WIDENED_IDENTIFIER":
        babelNode = this._serializeIdentifier(data, nodes);
        break;

      case "WIDEN_PROPERTY":
        babelNode = this._serializeWidenProperty(data, nodes);
        break;

      case "WIDEN_PROPERTY_ASSIGNMENT":
        babelNode = this._serializeWidenPropertyAssignment(data, nodes);
        break;
      // Invariants

      case "DERIVED_ABSTRACT_INVARIANT":
        babelNode = this._serializeDerivedAbstractInvariant(data, nodes);
        break;

      case "PROPERTY_INVARIANT":
        babelNode = this._serializePropertyInvariant(data, nodes);
        break;

      case "INVARIANT_APPEND":
        babelNode = this._serializeInvariantAppend(data, nodes);
        break;

      case "FULL_INVARIANT":
        babelNode = this._serializeFullInvariant(data, nodes);
        break;

      case "FULL_INVARIANT_ABSTRACT":
        babelNode = this._serializeFullInvariantAbstract(data, nodes);
        break;

      case "FULL_INVARIANT_FUNCTION":
        babelNode = this._serializeFullInvariantFunction(data, nodes);
        break;
      // React

      case "REACT_DEFAULT_PROPS_HELPER":
        babelNode = this._serializeReactDefaultPropsHelper(data, nodes);
        break;

      case "REACT_SSR_RENDER_VALUE_HELPER":
        babelNode = this._serializeReactRenderValueHelper(data, nodes);
        break;

      case "REACT_SSR_TEMPLATE_LITERAL":
        babelNode = this._serializeReactSSRTemplateLiteral(data, nodes);
        break;

      case "REACT_TEMPORAL_FUNC":
        babelNode = this._serializeReactTemporalFunc(data, nodes);
        break;

      case "REACT_CREATE_CONTEXT_PROVIDER":
        babelNode = this._serializeReactCreateContextProvider(data, nodes);
        break;

      case "REACT_NATIVE_STRING_LITERAL":
        babelNode = this._serializeReactNativeStringLiteral(data, nodes);
        break;

      case "REACT_RELAY_MOCK_CONTAINER":
        babelNode = this._serializeReactRelayMockContainer(data, nodes);
        break;
      // FB Mocks

      case "FB_MOCKS_BOOTLOADER_LOAD_MODULES":
        babelNode = this._serializeFBMocksBootloaderLoadModules(data, nodes);
        break;

      case "FB_MOCKS_MAGIC_GLOBAL_FUNCTION":
        babelNode = this._serializeFBMocksMagicGlobalFunction(data, nodes);
        break;
      // Babel helpers

      case "BABEL_HELPERS_OBJECT_WITHOUT_PROPERTIES":
        babelNode = this._serializeBabelHelpersObjectWithoutProperties(data, nodes);
        break;

      default:
        (0, _invariant.default)(false, `operation descriptor "type" not recognized when serializing operation descriptor`);
    }

    return babelNode;
  }

  _serializeAssumeCall({}, [c, s]) {
    let errorLiteral = s.type === "StringLiteral" ? s : t.stringLiteral("Assumption violated");
    return t.ifStatement(t.unaryExpression("!", c), t.blockStatement([t.throwStatement(t.newExpression(t.identifier("Error"), [errorLiteral]))]));
  }

  _serializeWidenPropertyAssignment({}, [o, propName, v]) {
    return t.assignmentExpression("=", (0, _babelhelpers.memberExpressionHelper)(o, propName), v);
  }

  _serializeWidenAbstractProperty({}, [o, p]) {
    return (0, _babelhelpers.memberExpressionHelper)(o, p);
  }

  _serializeWidenProperty({}, [o, propName]) {
    return (0, _babelhelpers.memberExpressionHelper)(o, propName);
  }

  _serializeAbstractObjectGet({
    propertyGetter
  }, [o, P]) {
    return propertyGetter !== undefined ? t.callExpression(t.memberExpression(t.identifier("global"), t.identifier("__prop_" + propertyGetter)), [o, P]) : (0, _babelhelpers.memberExpressionHelper)(o, P);
  }

  _serializeAbstractObjectGetProtoOf({}, [p]) {
    (0, _invariant.default)(this.realm.preludeGenerator !== undefined);
    let getPrototypeOf = this.realm.preludeGenerator.memoizeReference("Object.getPrototypeOf");
    return this.realm.isCompatibleWith(this.realm.MOBILE_JSC_VERSION) || this.realm.isCompatibleWith("mobile") ? t.memberExpression(p, _babelhelpers.protoExpression) : t.callExpression(getPrototypeOf, [p]);
  }

  _serializeCannotBecomeObject({}, [n]) {
    let callFunc = t.identifier("global.__cannotBecomeObject");
    return t.callExpression(callFunc, [n]);
  }

  _serializeResidualCall({}, nodes) {
    return t.callExpression(nodes[0], nodes.slice(1));
  }

  _serializeModulesRequires({}, [propName]) {
    return t.callExpression(t.identifier("require"), [propName]);
  }

  _serializeConcreteModel({}, [valueNode, propName]) {
    let propString = propName.value;
    return t.expressionStatement(t.assignmentExpression("=", this.preludeGenerator.globalReference(propString, false), valueNode));
  }

  _serializeConsoleLog({}, [propName, ...nodes]) {
    let propString = propName.value;
    return t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("console"), t.identifier(propString)), [...nodes]));
  }

  _serializeDoWhile({
    generator,
    value
  }, nodes, context, valuesToProcess) {
    (0, _invariant.default)(context !== undefined);
    (0, _invariant.default)(valuesToProcess !== undefined);
    (0, _invariant.default)(value !== undefined);
    let testId = value.intrinsicName;
    (0, _invariant.default)(testId !== undefined);
    (0, _invariant.default)(generator !== undefined);
    let statements = context.serializeGenerator(generator, valuesToProcess);
    let block = t.blockStatement(statements);
    return t.doWhileStatement(t.identifier(testId), block);
  }

  _serializeForIn({
    boundName,
    lh
  }, [obj, tgt, src]) {
    (0, _invariant.default)(boundName !== undefined);
    (0, _invariant.default)(lh !== undefined);
    return t.forInStatement(lh, obj, t.blockStatement([t.expressionStatement(t.assignmentExpression("=", (0, _babelhelpers.memberExpressionHelper)(tgt, boundName), (0, _babelhelpers.memberExpressionHelper)(src, boundName)))]));
  }

  _serializeFullInvariant({}, [propName, objectNode, valueNode]) {
    return t.binaryExpression("!==", (0, _babelhelpers.memberExpressionHelper)(objectNode, propName), valueNode);
  }

  _serializeFullInvariantFunction({}, [propName, objectNode]) {
    return t.binaryExpression("!==", t.unaryExpression("typeof", (0, _babelhelpers.memberExpressionHelper)(objectNode, propName), true), t.stringLiteral("function"));
  }

  _serializeFullInvariantAbstract({
    concreteComparisons,
    typeComparisons
  }, [propName, valueNode]) {
    (0, _invariant.default)(concreteComparisons !== undefined);
    (0, _invariant.default)(typeComparisons !== undefined); // Create `object.property !== concreteValue`

    let checks = concreteComparisons.map(concreteValue => t.binaryExpression("!==", valueNode, t.valueToNode(concreteValue.serialize()))); // Create `typeof object.property !== typeValue`

    checks = checks.concat([...typeComparisons].map(typeValue => {
      let typeString = _singletons.Utils.typeToString(typeValue);

      (0, _invariant.default)(typeString !== undefined, typeValue);
      return t.binaryExpression("!==", t.unaryExpression("typeof", valueNode, true), t.stringLiteral(typeString));
    }));
    return checks.reduce((expr, newCondition) => t.logicalExpression("&&", expr, newCondition));
  }

  _serializeInvariantAppend({}, [propName, objectNode]) {
    return (0, _babelhelpers.memberExpressionHelper)(objectNode, propName);
  }

  _serializePropertyInvariant({
    state
  }, [propName, objectNode]) {
    (0, _invariant.default)(state !== undefined);
    let n = t.callExpression(t.memberExpression(this.preludeGenerator.memoizeReference("Object.prototype.hasOwnProperty"), t.identifier("call")), [objectNode, propName]);

    if (state !== "MISSING") {
      n = t.unaryExpression("!", n, true);
      if (state === "DEFINED") n = t.logicalExpression("||", n, t.binaryExpression("===", (0, _babelhelpers.memberExpressionHelper)(objectNode, propName), t.valueToNode(undefined)));
    }

    return n;
  }

  _serializeUpdateIncrementor({
    incrementor
  }, [oldValNode]) {
    (0, _invariant.default)(incrementor !== undefined);
    return t.binaryExpression(incrementor, oldValNode, t.numericLiteral(1));
  }

  _serializeDerivedAbstractInvariant({}, [typeOfStringNode, typeofNode]) {
    let typeofString = typeOfStringNode.value;
    let condition = t.binaryExpression("!==", t.unaryExpression("typeof", typeofNode), t.stringLiteral(typeofString));

    if (typeofString === "object") {
      condition = t.logicalExpression("&&", condition, t.binaryExpression("!==", t.unaryExpression("typeof", typeofNode), t.stringLiteral("function")));
      condition = t.logicalExpression("||", condition, t.binaryExpression("===", typeofNode, _babelhelpers.nullExpression));
    }

    return condition;
  }

  _serializeInvariant({
    appendLastToInvariantOperationDescriptor,
    violationConditionOperationDescriptor
  }, nodes) {
    (0, _invariant.default)(violationConditionOperationDescriptor !== undefined);
    let messageComponents = [t.stringLiteral("Prepack model invariant violation ("), t.numericLiteral(this.preludeGenerator.nextInvariantId++)];

    if (appendLastToInvariantOperationDescriptor) {
      let propName = nodes[0];
      let last = nodes.pop();
      messageComponents.push(t.stringLiteral("): "));
      messageComponents.push(this.serializeExpression(appendLastToInvariantOperationDescriptor, [propName, last]));
    } else {
      messageComponents.push(t.stringLiteral(")"));
    }

    let throwString = messageComponents[0];

    for (let i = 1; i < messageComponents.length; i++) throwString = t.binaryExpression("+", throwString, messageComponents[i]);

    let condition = this.serializeExpression(violationConditionOperationDescriptor, nodes);
    let consequent = this.getErrorStatement(throwString);
    return t.ifStatement(condition, consequent);
  }

  _serializeReactRelayMockContainer({}, [reactRelayIdent, propName, ...otherArgs]) {
    let propString = propName.value;
    return t.callExpression(t.memberExpression(reactRelayIdent, t.identifier(propString)), otherArgs);
  }

  _serializePropertyAssignment({
    path
  }, [o, p, v, e], context, valuesToProcess) {
    (0, _invariant.default)(path instanceof _index.AbstractValue);
    (0, _invariant.default)(path.operationDescriptor !== undefined);
    let lh = this.serializeExpression(path.operationDescriptor, [o, p], context, valuesToProcess);
    return t.expressionStatement(t.assignmentExpression("=", lh, v));
  }

  _serializeConditionalPropertyAssignment({
    path,
    value
  }, [o, v, e, keyKey], context, valuesToProcess) {
    (0, _invariant.default)(value instanceof _index.AbstractValue);
    (0, _invariant.default)(path instanceof _index.AbstractValue);
    let mightHaveBeenDeleted = value.mightHaveBeenDeleted();
    let mightBeUndefined = value.mightBeUndefined();
    (0, _invariant.default)(path.operationDescriptor !== undefined);
    let lh = this.serializeExpression(path.operationDescriptor, [o, keyKey], context, valuesToProcess);
    let r = t.expressionStatement(t.assignmentExpression("=", lh, v));

    if (mightHaveBeenDeleted) {
      // If v === __empty || (v === undefined  && !(key.key in o))  then delete it
      let emptyTest = t.binaryExpression("===", v, e);
      let undefinedTest = t.binaryExpression("===", v, _babelhelpers.voidExpression);
      let inTest = t.unaryExpression("!", t.binaryExpression("in", keyKey, o));
      let guard = t.logicalExpression("||", emptyTest, t.logicalExpression("&&", undefinedTest, inTest));
      let deleteIt = t.expressionStatement(t.unaryExpression("delete", lh));
      return t.ifStatement(mightBeUndefined ? emptyTest : guard, deleteIt, r);
    }

    return r;
  }

  _serializeLogicalPropertyAssignment({
    propertyBinding,
    value
  }, [o, n]) {
    (0, _invariant.default)(value instanceof _index.Value);
    (0, _invariant.default)(propertyBinding !== undefined);

    if (typeof propertyBinding.key === "string" && value.mightHaveBeenDeleted() && isSelfReferential(value, propertyBinding.pathNode)) {
      let inTest = t.binaryExpression("in", t.stringLiteral(propertyBinding.key), o);
      let addEmpty = t.conditionalExpression(inTest, n, _babelhelpers.emptyExpression);
      n = t.logicalExpression("||", n, addEmpty);
    }

    return n;
  }

  _serializeLocalAssignment({
    value
  }, [v], context, valuesToProcess) {
    (0, _invariant.default)(value instanceof _index.AbstractValue);
    (0, _invariant.default)(value.operationDescriptor !== undefined);
    let id = this.serializeExpression(value.operationDescriptor, [], context, valuesToProcess);
    return t.expressionStatement(t.assignmentExpression("=", id, v));
  }

  _serializeReactNativeStringLiteral({}, [propName]) {
    return propName;
  }

  _serializeReactCreateContextProvider({}, [consumerNode]) {
    return t.memberExpression(consumerNode, t.identifier("Provider"));
  }

  _serializeReactTemporalFunc({}, [renderNode, ..._args]) {
    return t.callExpression(renderNode, _args);
  }

  _serializeCallAbstractFunc({}, nodes) {
    let fun_args = nodes.slice(1);
    return t.callExpression(nodes[0], fun_args);
  }

  _serializeCallAbstractFuncThis({}, nodes) {
    let fun_args = nodes.slice(1);
    return t.callExpression(t.memberExpression(nodes[0], t.identifier("call")), fun_args);
  }

  _serializeDirectCallWithArgList({}, nodes) {
    let fun_args = nodes.slice(1);
    return t.callExpression(nodes[0], fun_args);
  }

  _serializeObjectProtoHasOwnProperty({}, [methodNode, objectNode, nameNode]) {
    return t.callExpression(t.memberExpression(methodNode, t.identifier("call")), [objectNode, nameNode]);
  }

  _serializeRebuiltObject({}, [node, propName]) {
    let propString = propName.value;
    return t.isValidIdentifier(propString) ? t.memberExpression(node, t.identifier(propString), false) : t.memberExpression(node, propName, true);
  }

  _serializeGlobalDelete({}, [propName]) {
    let propString = propName.value;
    return t.expressionStatement(t.unaryExpression("delete", this.preludeGenerator.globalReference(propString, false)));
  }

  _serializeDefineProperty({
    object,
    descriptor
  }, [propName], context) {
    let propString = propName.value;
    (0, _invariant.default)(object !== undefined);
    (0, _invariant.default)(descriptor !== undefined);
    (0, _invariant.default)(context !== undefined);
    return context.emitDefinePropertyBody(object, propString, descriptor);
  }

  _serializeFBMocksMagicGlobalFunction({}, [propName, ...args]) {
    let propString = propName.value;
    return t.callExpression(t.identifier(propString), args);
  }

  _serializeFBMocksBootloaderLoadModules({}, args) {
    return t.callExpression(t.memberExpression(t.identifier("Bootloader"), t.identifier("loadModules")), args);
  }

  _serializeUnknownArrayGetPartial({}, [o, p]) {
    return (0, _babelhelpers.memberExpressionHelper)(o, p);
  }

  _serializeObjectGetPartial({}, [o, p]) {
    return (0, _babelhelpers.memberExpressionHelper)(o, p);
  }

  _serializeAbstractObjectGetPartial({}, [o, p]) {
    return (0, _babelhelpers.memberExpressionHelper)(o, p);
  }

  _serializeObjectSetPartial({}, [objectNode, keyNode, valueNode]) {
    return t.expressionStatement(t.assignmentExpression("=", (0, _babelhelpers.memberExpressionHelper)(objectNode, keyNode), valueNode));
  }

  _serializeIdentifier({
    id
  }, nodes) {
    (0, _invariant.default)(id !== undefined);
    return t.identifier(id);
  }

  _serializeCoerceToString({}, [p]) {
    return t.binaryExpression("+", t.stringLiteral(""), p);
  }

  _serializeBabelHelpersObjectWithoutProperties({}, [methodNode, objNode, propRemoveNode]) {
    return t.callExpression(methodNode, [objNode, propRemoveNode]);
  }

  _serializeReactDefaultPropsHelper({}, [methodNode, ..._args]) {
    return t.callExpression(methodNode, _args);
  }

  _serializeUnknownArrayMethodCall({}, [methodNode, ..._args]) {
    return t.callExpression(methodNode, _args);
  }

  _serializeUnknownArrayLength({}, [o]) {
    return t.memberExpression(o, t.identifier("length"), false);
  }

  _serializeUnknownArrayMethodPropertyCall({}, [objNode, propName, ..._args]) {
    let propString = propName.value;
    return t.callExpression(t.memberExpression(objNode, t.identifier(propString)), _args);
  }

  _serializeThrow({}, [argument]) {
    return t.throwStatement(argument);
  }

  _serializeConditionalThrow({
    value
  }, nodes, context) {
    (0, _invariant.default)(value instanceof _index.Value);

    function createStatement(val) {
      (0, _invariant.default)(context !== undefined);

      if (!(val instanceof _index.AbstractValue) || val.kind !== "conditional") {
        return t.throwStatement(context.serializeValue(val));
      }

      let [cond, trueVal, falseVal] = val.args;
      let condVal = context.serializeValue(cond);
      let trueStat, falseStat;
      if (trueVal instanceof _index.EmptyValue) trueStat = t.blockStatement([]);else trueStat = createStatement(trueVal);
      if (falseVal instanceof _index.EmptyValue) falseStat = t.blockStatement([]);else falseStat = createStatement(falseVal);
      return t.ifStatement(condVal, trueStat, falseStat);
    }

    return createStatement(value);
  }

  _serializeReactSSRTemplateLiteral({
    quasis
  }, valueNodes) {
    (0, _invariant.default)(quasis !== undefined);
    return t.templateLiteral(quasis, valueNodes);
  }

  _serializeReactRenderValueHelper({}, [helperNode, valueNode]) {
    return t.callExpression(helperNode, [valueNode]);
  }

  _serializePropertyDelete({}, [objectNode, propName]) {
    return t.expressionStatement(t.unaryExpression("delete", (0, _babelhelpers.memberExpressionHelper)(objectNode, propName)));
  }

  _serializeGetBinding({
    binding
  }, nodes, context) {
    (0, _invariant.default)(binding !== undefined);
    (0, _invariant.default)(context !== undefined);
    return context.serializeBinding(binding);
  }

  _serializeForFunctionCall({
    usesThis
  }, [func, thisExpr]) {
    return usesThis ? t.callExpression(t.memberExpression(func, t.identifier("call")), [thisExpr]) : t.callExpression(func, []);
  }

  _serializeNewExpression({}, [constructorNode, ...argListNodes]) {
    return t.newExpression(constructorNode, argListNodes);
  }

  _serializeEmitCall({
    callFunctionRef
  }, nodes) {
    (0, _invariant.default)(callFunctionRef !== undefined);
    let callFunction = this.preludeGenerator.memoizeReference(callFunctionRef);
    return t.expressionStatement(t.callExpression(callFunction, [...nodes]));
  }

  _serializeEmitCallAndCaptureResults({
    callFunctionRef
  }, nodes) {
    (0, _invariant.default)(callFunctionRef !== undefined);
    let callFunction = this.preludeGenerator.memoizeReference(callFunctionRef);
    return t.callExpression(callFunction, nodes);
  }

  _serializeObjectProtoGetOwnPropertyDescriptor({}, [funcNode, ...args]) {
    return t.callExpression(funcNode, args);
  }

  _serializeCallBailout({
    propRef,
    thisArg
  }, nodes) {
    let callFunc;
    let argStart = 1;

    if (thisArg instanceof _index.Value) {
      if (typeof propRef === "string") {
        callFunc = (0, _babelhelpers.memberExpressionHelper)(nodes[0], propRef);
      } else {
        callFunc = (0, _babelhelpers.memberExpressionHelper)(nodes[0], nodes[1]);
        argStart = 2;
      }
    } else {
      callFunc = nodes[0];
    }

    let fun_args = nodes.slice(argStart);
    return t.callExpression(callFunc, fun_args);
  }

  _serializeJoinGenerators({
    generators
  }, [cond], context, valuesToProcess) {
    (0, _invariant.default)(context !== undefined);
    (0, _invariant.default)(valuesToProcess !== undefined);
    (0, _invariant.default)(generators !== undefined);
    let [generator1, generator2] = generators;
    let block1 = generator1.empty() ? null : serializeBody(generator1, context, valuesToProcess);
    let block2 = generator2.empty() ? null : serializeBody(generator2, context, valuesToProcess);
    if (block1) return t.ifStatement(cond, block1, block2);
    (0, _invariant.default)(block2);
    return t.ifStatement(t.unaryExpression("!", cond), block2);
  }

  _serializeEmitPropertyAssignment({
    value
  }, [objectNode, valueNode, propName], context) {
    (0, _invariant.default)(context !== undefined);
    (0, _invariant.default)(value instanceof _index.Value);
    return context.getPropertyAssignmentStatement((0, _babelhelpers.memberExpressionHelper)(objectNode, propName), value, value.mightHaveBeenDeleted(),
    /* deleteIfMightHaveBeenDeleted */
    true);
  }

  _serializeGlobalAssignment({}, [valueNode, propName]) {
    let propString = propName.value;
    return t.expressionStatement(t.assignmentExpression("=", this.preludeGenerator.globalReference(propString, false), valueNode));
  }

  _serializeSingleArg({}, [o]) {
    return o;
  }

  _serializeAbstractProperty({}, [o, propName]) {
    return (0, _babelhelpers.memberExpressionHelper)(o, propName);
  }

  _serializeUnaryExpression({
    unaryOperator,
    prefix
  }, [x, y]) {
    (0, _invariant.default)(unaryOperator !== undefined);
    return t.unaryExpression(unaryOperator, x, prefix);
  }

  _serializeBinaryExpression({
    binaryOperator
  }, [x, y]) {
    (0, _invariant.default)(binaryOperator !== undefined);
    return t.binaryExpression(binaryOperator, x, y);
  }

  _serializeLogicalExpression({
    logicalOperator
  }, [x, y]) {
    (0, _invariant.default)(logicalOperator !== undefined);
    return t.logicalExpression(logicalOperator, x, y);
  }

  _serializeConditionalExpression({}, [c, x, y]) {
    return t.conditionalExpression(c, x, y);
  }

  _serializeDerivedOperationDescriptor(id, babelNode) {
    return t.variableDeclaration("var", [t.variableDeclarator(t.identifier(id), babelNode)]);
  }

  _serializeVoidOperationDescriptor(babelNode) {
    return t.expressionStatement(babelNode);
  }

  _serializeAbstractFromTemplate({
    templateSource
  }, nodes) {
    let templateArguments = {};
    let i = 0;

    for (let node of nodes) templateArguments[_PreludeGenerator.Placeholders[i++]] = node;

    (0, _invariant.default)(templateSource !== undefined);
    return this.preludeGenerator.buildExpression(templateSource, templateArguments);
  }

  _serializeObjectAssign({}, [targetNode, ...sourceNodes]) {
    return t.callExpression(this.preludeGenerator.memoizeReference("Object.assign"), [targetNode, ...sourceNodes]);
  }

}

exports.ResidualOperationSerializer = ResidualOperationSerializer;
//# sourceMappingURL=ResidualOperationSerializer.js.map