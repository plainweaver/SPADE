{"version":3,"sources":["../../src/serializer/ResidualFunctionInstantiator.js"],"names":["canShareFunctionBody","duplicateFunctionInfo","anyContainingAdditionalFunction","unbound","modified","usesThis","functionInfo","size","getReplacement","node","value","truthiness","undefined","mightNotBeFalse","mightNotBeTrue","isPure","type","unaryExpression","argument","binaryExpression","left","right","ResidualFunctionInstantiator","constructor","factoryFunctionInfos","identifierReplacements","callReplacements","root","instantiate","_replace","_getLiteralTruthiness","replacement","get","classExpression","superClass","body","length","objectExpression","properties","every","property","key","arrayExpression","elements","element","operator","_replaceIdentifier","_replaceJSXIdentifier","_replaceLabeledStatement","newBody","res","Object","assign","_replaceCallExpression","_replaceFallback","_replaceFunctionExpression","functionExpression","functionTag","uniqueOrderedTag","factoryId","t","callExpression","memberExpression","identifier","nullExpression","_replaceIfStatement","testTruthiness","test","consequent","alternate","emptyStatement","_replaceConditionalExpression","_replaceLogicalExpression","leftTruthiness","_replaceWhileStatement","newNode","subNode","newSubNode","Array","isArray","newArray","i","elementNode","newElementNode","slice"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport * as t from \"@babel/types\";\nimport { convertExpressionToJSXIdentifier } from \"../react/jsx\";\nimport type Value from \"../values/Value.js\";\nimport type {\n  BabelNodeBinaryExpression,\n  BabelNodeCallExpression,\n  BabelNodeFunctionExpression,\n  BabelNodeExpression,\n  BabelNodeClassMethod,\n  BabelNodeArrowFunctionExpression,\n  BabelNodeWhileStatement,\n  BabelNodeJSXIdentifier,\n  BabelNodeJSXMemberExpression,\n  BabelNodeConditionalExpression,\n  BabelNodeIfStatement,\n  BabelNodeLogicalExpression,\n  BabelNodeBooleanLiteral,\n  BabelNodeNumericLiteral,\n  BabelNodeStringLiteral,\n  BabelNodeUnaryExpression,\n  BabelNodeClassExpression,\n  BabelNodeObjectExpression,\n  BabelNodeArrayExpression,\n  BabelNodeSpreadElement,\n  BabelNodeLabeledStatement,\n} from \"@babel/types\";\nimport type { FunctionBodyAstNode } from \"../types.js\";\nimport type { FactoryFunctionInfo } from \"./types.js\";\nimport { nullExpression } from \"../utils/babelhelpers\";\n\nfunction canShareFunctionBody(duplicateFunctionInfo: FactoryFunctionInfo): boolean {\n  if (duplicateFunctionInfo.anyContainingAdditionalFunction) {\n    // If the function is referenced by an optimized function,\n    // it may get emitted within that optimized function,\n    // and then the function name is not generally available in arbitrary other code\n    // where we'd like to replace the body with a reference to the extracted function body.\n    // TODO: Revisit interplay of factory function concept, scope concept, and optimized functions.\n    return false;\n  }\n\n  // Only share function when:\n  // 1. it does not access any free variables.\n  // 2. it does not use \"this\".\n  const { unbound, modified, usesThis } = duplicateFunctionInfo.functionInfo;\n  return unbound.size === 0 && modified.size === 0 && !usesThis;\n}\n\nexport type Truthiness = void | boolean; // undefined means unknown\n\nexport type Replacement = {\n  node: BabelNodeExpression,\n  truthiness: Truthiness,\n};\n\nexport function getReplacement(node: BabelNodeExpression, value: void | Value): Replacement {\n  let truthiness;\n  if (value !== undefined)\n    if (!value.mightNotBeFalse()) truthiness = false;\n    else if (!value.mightNotBeTrue()) truthiness = true;\n  return { node, truthiness };\n}\n\nexport function isPure(node: BabelNodeExpression | BabelNodeSpreadElement): boolean {\n  switch (node.type) {\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n      return true;\n    case \"UnaryExpression\":\n    case \"SpreadElement\":\n      let unaryExpression = ((node: any): BabelNodeUnaryExpression | BabelNodeSpreadElement);\n      return isPure(unaryExpression.argument);\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      let binaryExpression = ((node: any): BabelNodeLogicalExpression | BabelNodeBinaryExpression);\n      return isPure(binaryExpression.left) && isPure(binaryExpression.right);\n    default:\n      return false;\n  }\n}\n\n// This class instantiates residual functions by replacing certain nodes,\n// i.e. bindings to captured scopes that need to get renamed to variable ids.\n// The original nodes are never mutated; instead, nodes are cloned as needed.\n// Along the way, some trivial code optimizations are performed as well.\nexport class ResidualFunctionInstantiator<\n  T: BabelNodeClassMethod | BabelNodeFunctionExpression | BabelNodeArrowFunctionExpression\n> {\n  factoryFunctionInfos: Map<number, FactoryFunctionInfo>;\n  identifierReplacements: Map<BabelNodeIdentifier, Replacement>;\n  callReplacements: Map<BabelNodeCallExpression, Replacement>;\n  root: T;\n\n  constructor(\n    factoryFunctionInfos: Map<number, FactoryFunctionInfo>,\n    identifierReplacements: Map<BabelNodeIdentifier, Replacement>,\n    callReplacements: Map<BabelNodeCallExpression, Replacement>,\n    root: T\n  ) {\n    this.factoryFunctionInfos = factoryFunctionInfos;\n    this.identifierReplacements = identifierReplacements;\n    this.callReplacements = callReplacements;\n    this.root = root;\n  }\n\n  instantiate(): T {\n    return ((this._replace(this.root): any): T);\n  }\n\n  _getLiteralTruthiness(node: BabelNodeExpression): Truthiness {\n    switch (node.type) {\n      case \"BooleanLiteral\":\n      case \"NumericLiteral\":\n      case \"StringLiteral\":\n        return !!((node: any): BabelNodeBooleanLiteral | BabelNodeNumericLiteral | BabelNodeStringLiteral).value;\n      case \"Identifier\": {\n        let replacement = this.identifierReplacements.get(node);\n        if (replacement !== undefined) return replacement.truthiness;\n        return undefined;\n      }\n      case \"CallExpression\": {\n        let replacement = this.callReplacements.get(node);\n        if (replacement !== undefined) return replacement.truthiness;\n        return undefined;\n      }\n      case \"FunctionExpression\":\n      case \"ArrowFunctionExpression\":\n      case \"RegExpLiteral\":\n        return true;\n      case \"ClassExpression\":\n        let classExpression = ((node: any): BabelNodeClassExpression);\n        return classExpression.superClass === null && classExpression.body.body.length === 0 ? true : undefined;\n      case \"ObjectExpression\":\n        let objectExpression = ((node: any): BabelNodeObjectExpression);\n        return objectExpression.properties.every(property => isPure(property.key) && isPure(property.value))\n          ? true\n          : undefined;\n      case \"ArrayExpression\":\n        let arrayExpression = ((node: any): BabelNodeArrayExpression);\n        return arrayExpression.elements.every(element => element === undefined || isPure(element)) ? true : undefined;\n      case \"NullLiteral\":\n        return false;\n      case \"UnaryExpression\":\n        let unaryExpression = ((node: any): BabelNodeUnaryExpression);\n        return unaryExpression.operator === \"void\" && isPure(unaryExpression.argument) ? false : undefined;\n      default:\n        return undefined;\n    }\n  }\n\n  _replaceIdentifier(node: BabelNodeIdentifier): BabelNode {\n    let replacement = this.identifierReplacements.get(node);\n    if (replacement !== undefined) return replacement.node;\n    return node; // nothing else to replace in an identifier\n  }\n\n  _replaceJSXIdentifier(node: BabelNodeJSXIdentifier | BabelNodeJSXMemberExpression): BabelNode {\n    let replacement = this.identifierReplacements.get(node);\n    if (replacement !== undefined) return convertExpressionToJSXIdentifier(replacement.node, true);\n    return node; // nothing else to replace in an identifier\n  }\n\n  _replaceLabeledStatement(node: BabelNodeLabeledStatement): BabelNode {\n    // intentionally ignore embedded identifier\n    let newBody = this._replace(node.body);\n    if (newBody !== node.body) {\n      let res = Object.assign({}, node);\n      res.body = newBody;\n      return res;\n    }\n    return node; // nothing else to replace in a labeled statement\n  }\n\n  _replaceCallExpression(node: BabelNodeCallExpression): BabelNode {\n    let replacement = this.callReplacements.get(node);\n    if (replacement !== undefined) return replacement.node;\n    return this._replaceFallback(node);\n  }\n\n  _replaceFunctionExpression(node: BabelNodeFunctionExpression): BabelNode {\n    // Our goal is replacing duplicate nested function so skip root residual function itself.\n    if (this.root !== node) {\n      const functionExpression: BabelNodeFunctionExpression = node;\n      const functionTag = ((functionExpression.body: any): FunctionBodyAstNode).uniqueOrderedTag;\n      // Un-interpreted nested function?\n      if (functionTag !== undefined) {\n        // Un-interpreted nested function.\n\n        const duplicateFunctionInfo = this.factoryFunctionInfos.get(functionTag);\n        if (duplicateFunctionInfo && canShareFunctionBody(duplicateFunctionInfo)) {\n          const { factoryId } = duplicateFunctionInfo;\n          return t.callExpression(t.memberExpression(factoryId, t.identifier(\"bind\")), [nullExpression]);\n        }\n      }\n    }\n\n    return this._replaceFallback(node);\n  }\n\n  _replaceIfStatement(node: BabelNodeIfStatement): BabelNode {\n    let testTruthiness = this._getLiteralTruthiness(node.test);\n    if (testTruthiness === true) {\n      // Strictly speaking this is not safe: Annex B.3.4 allows FunctionDeclarations as the body of IfStatements in sloppy mode,\n      // which have weird hoisting behavior: `console.log(typeof f); if (true) function f(){} console.log(typeof f)` will print 'undefined', 'function', but\n      // `console.log(typeof f); function f(){} console.log(typeof f)` will print 'function', 'function'.\n      // However, Babylon can't parse these, so it doesn't come up.\n      return this._replace(node.consequent);\n    } else if (testTruthiness === false) {\n      if (node.alternate !== null) {\n        return this._replace(node.alternate);\n      } else {\n        return t.emptyStatement();\n      }\n    }\n\n    return this._replaceFallback(node);\n  }\n\n  _replaceConditionalExpression(node: BabelNodeConditionalExpression): BabelNode {\n    let testTruthiness = this._getLiteralTruthiness(node.test);\n    if (testTruthiness !== undefined) {\n      return testTruthiness ? this._replace(node.consequent) : this._replace(node.alternate);\n    }\n\n    return this._replaceFallback(node);\n  }\n\n  _replaceLogicalExpression(node: BabelNodeLogicalExpression): BabelNode {\n    let leftTruthiness = this._getLiteralTruthiness(node.left);\n    if (node.operator === \"&&\" && leftTruthiness !== undefined) {\n      return leftTruthiness ? this._replace(node.right) : this._replace(node.left);\n    } else if (node.operator === \"||\" && leftTruthiness !== undefined) {\n      return leftTruthiness ? this._replace(node.left) : this._replace(node.right);\n    }\n\n    return this._replaceFallback(node);\n  }\n\n  _replaceWhileStatement(node: BabelNodeWhileStatement): BabelNode {\n    let testTruthiness = this._getLiteralTruthiness(node.test);\n    if (testTruthiness === false) {\n      return t.emptyStatement();\n    }\n\n    return this._replaceFallback(node);\n  }\n\n  _replaceFallback(node: BabelNode): BabelNode {\n    let newNode;\n    for (let key in node) {\n      let subNode = (node: any)[key];\n      if (!subNode) continue;\n      let newSubNode;\n      if (Array.isArray(subNode)) {\n        let newArray;\n        for (let i = 0; i < subNode.length; i++) {\n          let elementNode = subNode[i];\n          if (!elementNode) continue;\n          let newElementNode = this._replace(elementNode);\n          if (newElementNode !== elementNode) {\n            if (newArray === undefined) newArray = subNode.slice(0);\n            newArray[i] = newElementNode;\n          }\n        }\n        if (newArray === undefined) continue;\n        newSubNode = newArray;\n      } else if (subNode.type) {\n        newSubNode = this._replace(subNode);\n        if (newSubNode === subNode) continue;\n      } else continue;\n\n      if (newNode === undefined) newNode = Object.assign({}, node);\n      newNode[key] = newSubNode;\n    }\n    return newNode || node;\n  }\n\n  _replace(node: BabelNode): BabelNode {\n    switch (node.type) {\n      case \"Identifier\":\n        return this._replaceIdentifier(node);\n      case \"LabeledStatement\":\n        return this._replaceLabeledStatement(node);\n      case \"BreakStatement\":\n      case \"ContinueStatement\":\n        return node;\n      case \"JSXIdentifier\":\n      case \"JSXMemberExpressions\":\n        return this._replaceJSXIdentifier(node);\n      case \"CallExpression\":\n        return this._replaceCallExpression(node);\n      case \"FunctionExpression\":\n        return this._replaceFunctionExpression(node);\n      case \"IfStatement\":\n        return this._replaceIfStatement(node);\n      case \"ConditionalExpression\":\n        return this._replaceConditionalExpression(node);\n      case \"LogicalExpression\":\n        return this._replaceLogicalExpression(node);\n      case \"WhileStatement\":\n        return this._replaceWhileStatement(node);\n      default:\n        return this._replaceFallback(node);\n    }\n  }\n}\n"],"file":"ResidualFunctionInstantiator.js"}