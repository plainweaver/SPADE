{"version":3,"sources":["../../src/serializer/ResidualOptimizedFunctions.js"],"names":["ResidualOptimizedFunctions","constructor","generatorTree","optimizedFunctionsAndEffects","residualValues","_generatorTree","_optimizedFunctionsAndEffects","_residualValues","_isDefinedInsideFunction","childFunction","maybeParentFunctions","maybeParentFunction","maybeParentFunctionInfo","get","effects","createdObjects","has","env","$Environment","parent","envRecord","environmentRecord","FunctionEnvironmentRecord","$FunctionObject","_definesFunctions","possibleParentFunction","functions","func","tryGetOptimizedFunctionRoot","val","scopes","undefined","tryGetOutermostOptimizedFunction","functionValues","Set","scope","s","Generator","getParent","FunctionValue","add","outermostAdditionalFunctions","functionValue","f","size","possibleRoots","length","possibleRoot","shift","additionalFunctionEffects","parentAdditionalFunction","push"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { FunctionValue } from \"../values/index.js\";\nimport type { AdditionalFunctionEffects } from \"./types\";\nimport invariant from \"../invariant.js\";\nimport { GeneratorTree } from \"./GeneratorTree\";\nimport type { Scope } from \"./types.js\";\nimport { FunctionEnvironmentRecord } from \"../environment\";\nimport type { Value } from \"../values/index\";\nimport { Generator } from \"../utils/generator\";\n\nexport class ResidualOptimizedFunctions {\n  constructor(\n    generatorTree: GeneratorTree,\n    optimizedFunctionsAndEffects: Map<FunctionValue, AdditionalFunctionEffects>,\n    residualValues: Map<Value, Set<Scope>>\n  ) {\n    this._generatorTree = generatorTree;\n    this._optimizedFunctionsAndEffects = optimizedFunctionsAndEffects;\n    this._residualValues = residualValues;\n  }\n\n  _generatorTree: GeneratorTree;\n  _optimizedFunctionsAndEffects: Map<FunctionValue, AdditionalFunctionEffects>;\n  _residualValues: Map<Value, Set<Scope>>;\n\n  _isDefinedInsideFunction(childFunction: FunctionValue, maybeParentFunctions: Set<FunctionValue>): boolean {\n    for (let maybeParentFunction of maybeParentFunctions) {\n      if (childFunction === maybeParentFunction) {\n        continue;\n      }\n      // for optimized functions, we should use created objects\n      let maybeParentFunctionInfo = this._optimizedFunctionsAndEffects.get(maybeParentFunction);\n      if (maybeParentFunctionInfo && maybeParentFunctionInfo.effects.createdObjects.has(childFunction)) return true;\n      else {\n        // for other functions, check environment records\n        let env = childFunction.$Environment;\n        while (env.parent !== null) {\n          let envRecord = env.environmentRecord;\n          if (envRecord instanceof FunctionEnvironmentRecord && envRecord.$FunctionObject === maybeParentFunction)\n            return true;\n          env = env.parent;\n        }\n      }\n    }\n    return false;\n  }\n\n  // Check if an optimized function defines the given set of functions.\n  _definesFunctions(possibleParentFunction: FunctionValue, functions: Set<FunctionValue>): boolean {\n    let maybeParentFunctionInfo = this._optimizedFunctionsAndEffects.get(possibleParentFunction);\n    invariant(maybeParentFunctionInfo);\n    let createdObjects = maybeParentFunctionInfo.effects.createdObjects;\n    for (let func of functions) if (func !== possibleParentFunction && !createdObjects.has(func)) return false;\n    return true;\n  }\n\n  // Try and get the root optimized function when passed in an optimized function\n  // that may or may not be nested in the tree of said root, or is the root optimized function\n  tryGetOptimizedFunctionRoot(val: Value): void | FunctionValue {\n    let scopes = this._residualValues.get(val);\n    invariant(scopes !== undefined);\n    return this.tryGetOutermostOptimizedFunction(scopes);\n  }\n\n  // Try and get the optimized function that contains all the scopes passed in (may be one of the\n  // scopes passed in)\n  tryGetOutermostOptimizedFunction(scopes: Set<Scope>): void | FunctionValue {\n    let functionValues = new Set();\n    invariant(scopes !== undefined);\n    for (let scope of scopes) {\n      let s = scope;\n      while (s instanceof Generator) {\n        s = this._generatorTree.getParent(s);\n      }\n      if (s === \"GLOBAL\") return undefined;\n      invariant(s instanceof FunctionValue);\n      functionValues.add(s);\n    }\n    let outermostAdditionalFunctions = new Set();\n\n    // Get the set of optimized functions that may be the root\n\n    for (let functionValue of functionValues) {\n      if (this._optimizedFunctionsAndEffects.has(functionValue)) {\n        if (!this._isDefinedInsideFunction(functionValue, functionValues))\n          outermostAdditionalFunctions.add(functionValue);\n      } else {\n        let f = this.tryGetOptimizedFunctionRoot(functionValue);\n        if (f === undefined) return undefined;\n        if (!this._isDefinedInsideFunction(f, functionValues)) outermostAdditionalFunctions.add(f);\n      }\n    }\n    if (outermostAdditionalFunctions.size === 1) return [...outermostAdditionalFunctions][0];\n\n    // See if any of the outermost (or any of their parents) are the outermost optimized function\n    let possibleRoots = [...outermostAdditionalFunctions];\n    while (possibleRoots.length > 0) {\n      let possibleRoot = possibleRoots.shift();\n      if (this._definesFunctions(possibleRoot, outermostAdditionalFunctions)) return possibleRoot;\n      let additionalFunctionEffects = this._optimizedFunctionsAndEffects.get(possibleRoot);\n      invariant(additionalFunctionEffects);\n      let parent = additionalFunctionEffects.parentAdditionalFunction;\n      if (parent) possibleRoots.push(parent);\n    }\n    return undefined;\n  }\n}\n"],"file":"ResidualOptimizedFunctions.js"}