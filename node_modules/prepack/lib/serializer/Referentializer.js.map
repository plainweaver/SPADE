{"version":3,"sources":["../../src/serializer/Referentializer.js"],"names":["Referentializer","constructor","realm","options","scopeNameGenerator","scopeBindingNameGenerator","leakedNameGenerator","residualOptimizedFunctions","_options","referentializationState","Map","_leakedNameGenerator","_residualOptimizedFunctions","getStatistics","statistics","SerializerStatistics","_createReferentializationState","capturedScopeInstanceIdx","capturedScopesArray","t","identifier","generate","capturedScopeAccessFunctionId","serializedScopes","_getReferentializationState","referentializationScope","bind","createLeakedIds","leakedIds","scopeBinding","values","push","length","variableDeclaration","map","id","variableDeclarator","createCapturedScopesPrelude","accessFunctionDeclaration","_createCaptureScopeAccessFunction","undefined","_createCapturedScopesArrayInitialization","cases","initializationCases","initializationValues","expr","arrayExpression","key","code","has","set","scopeIDs","value","ic","get","size","body","selectorParam","captured","selectorExpression","memberExpression","forEach","i","consequent","expressionStatement","assignmentExpression","breakStatement","switchCase","numericLiteral","invariantLevel","throwStatement","newExpression","stringLiteral","switchStatement","returnStatement","factoryFunction","functionExpression","blockStatement","accessFunctionId","_getReferentializationScope","residualBinding","potentialReferentializationScopes","scopes","parentOptimizedFunction","tryGetOutermostOptimizedFunction","scope","_getSerializedBindingScopeInstance","declarativeEnvironmentRecord","refState","name","getReferentializedScopeInitialization","scopeName","capturedScope","state","funcName","scopeArray","init","logicalExpression","callExpression","referentializeLeakedBinding","hasLeaked","serializedBindingId","serializedValue","serializedUnscopedLocation","referentialized","referentializeModifiedBinding","modified","variableIndexInScope","indexExpression","capturedScopeExpression","cleanInstance","instance","initializationStatements","b","residualFunctionBindings","binding","referentialize","residualBindings","scopeInstances"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { DeclarativeEnvironmentRecord } from \"../environment.js\";\nimport type { SerializerOptions } from \"../options.js\";\nimport * as t from \"@babel/types\";\nimport generate from \"@babel/generator\";\nimport type { BabelNodeStatement, BabelNodeExpression, BabelNodeIdentifier } from \"@babel/types\";\nimport { NameGenerator } from \"../utils/NameGenerator\";\nimport invariant from \"../invariant.js\";\nimport type { ResidualFunctionBinding, ScopeBinding, FunctionInstance } from \"./types.js\";\nimport type { ReferentializationScope, Scope } from \"./types.js\";\nimport { SerializerStatistics } from \"./statistics.js\";\nimport { getOrDefault } from \"./utils.js\";\nimport { Realm } from \"../realm.js\";\nimport type { ResidualOptimizedFunctions } from \"./ResidualOptimizedFunctions\";\n\ntype ReferentializationState = {|\n  capturedScopeInstanceIdx: number,\n  capturedScopesArray: BabelNodeIdentifier,\n  capturedScopeAccessFunctionId: BabelNodeIdentifier,\n  serializedScopes: Map<DeclarativeEnvironmentRecord, ScopeBinding>,\n|};\n\n/*\n * This class helps fixup names in residual functions for variables that these\n * functions capture from parent scopes.\n * For each ReferentializationScope it creates a _get_scope_binding function\n * that contains the initialization for all of that scope's FunctionInstances\n * which will contain a switch statement with all the initializations.\n */\nexport class Referentializer {\n  constructor(\n    realm: Realm,\n    options: SerializerOptions,\n    scopeNameGenerator: NameGenerator,\n    scopeBindingNameGenerator: NameGenerator,\n    leakedNameGenerator: NameGenerator,\n    residualOptimizedFunctions: ResidualOptimizedFunctions\n  ) {\n    this._options = options;\n    this.scopeNameGenerator = scopeNameGenerator;\n    this.scopeBindingNameGenerator = scopeBindingNameGenerator;\n\n    this.referentializationState = new Map();\n    this._leakedNameGenerator = leakedNameGenerator;\n    this.realm = realm;\n\n    this._residualOptimizedFunctions = residualOptimizedFunctions;\n  }\n\n  _options: SerializerOptions;\n  scopeNameGenerator: NameGenerator;\n  scopeBindingNameGenerator: NameGenerator;\n  realm: Realm;\n\n  _newCapturedScopeInstanceIdx: number;\n  referentializationState: Map<ReferentializationScope, ReferentializationState>;\n  _leakedNameGenerator: NameGenerator;\n  _residualOptimizedFunctions: ResidualOptimizedFunctions;\n\n  getStatistics(): SerializerStatistics {\n    invariant(this.realm.statistics instanceof SerializerStatistics, \"serialization requires SerializerStatistics\");\n    return this.realm.statistics;\n  }\n\n  _createReferentializationState(): ReferentializationState {\n    return {\n      capturedScopeInstanceIdx: 0,\n      capturedScopesArray: t.identifier(this.scopeNameGenerator.generate(\"main\")),\n      capturedScopeAccessFunctionId: t.identifier(this.scopeBindingNameGenerator.generate(\"get_scope_binding\")),\n      serializedScopes: new Map(),\n    };\n  }\n\n  _getReferentializationState(referentializationScope: ReferentializationScope): ReferentializationState {\n    return getOrDefault(\n      this.referentializationState,\n      referentializationScope,\n      this._createReferentializationState.bind(this)\n    );\n  }\n\n  createLeakedIds(referentializationScope: ReferentializationScope): Array<BabelNodeStatement> {\n    const leakedIds = [];\n    const serializedScopes = this._getReferentializationState(referentializationScope).serializedScopes;\n    for (const scopeBinding of serializedScopes.values()) leakedIds.push(...scopeBinding.leakedIds);\n    if (leakedIds.length === 0) return [];\n    return [t.variableDeclaration(\"var\", leakedIds.map(id => t.variableDeclarator(id)))];\n  }\n\n  createCapturedScopesPrelude(referentializationScope: ReferentializationScope): Array<BabelNodeStatement> {\n    let accessFunctionDeclaration = this._createCaptureScopeAccessFunction(referentializationScope);\n    if (accessFunctionDeclaration === undefined) return [];\n    return [accessFunctionDeclaration, this._createCapturedScopesArrayInitialization(referentializationScope)];\n  }\n\n  // Generate a shared function for accessing captured scope bindings.\n  // TODO: skip generating this function if the captured scope is not shared by multiple residual functions.\n  _createCaptureScopeAccessFunction(referentializationScope: ReferentializationScope): void | BabelNodeStatement {\n    // One switch case for one scope.\n    const cases = [];\n    const serializedScopes = this._getReferentializationState(referentializationScope).serializedScopes;\n    type InitializationCase = {|\n      scopeIDs: Array<number>,\n      value: BabelNodeExpression,\n    |};\n    const initializationCases: Map<string, InitializationCase> = new Map();\n    for (const scopeBinding of serializedScopes.values()) {\n      if (scopeBinding.initializationValues.length === 0) continue;\n      const expr = t.arrayExpression((scopeBinding.initializationValues: any));\n      const key = generate(expr, {}, \"\").code;\n      if (!initializationCases.has(key)) {\n        initializationCases.set(key, {\n          scopeIDs: [scopeBinding.id],\n          value: expr,\n        });\n      } else {\n        const ic = initializationCases.get(key);\n        invariant(ic);\n        ic.scopeIDs.push(scopeBinding.id);\n      }\n    }\n    if (initializationCases.size === 0) return undefined;\n\n    const body = [];\n    const selectorParam = t.identifier(\"__selector\");\n    const captured = t.identifier(\"__captured\");\n    const capturedScopesArray = this._getReferentializationState(referentializationScope).capturedScopesArray;\n    const selectorExpression = t.memberExpression(capturedScopesArray, selectorParam, /*Indexer syntax*/ true);\n    for (const ic of initializationCases.values()) {\n      ic.scopeIDs.forEach((id, i) => {\n        let consequent: Array<BabelNodeStatement> = [];\n        if (i === ic.scopeIDs.length - 1) {\n          consequent = [t.expressionStatement(t.assignmentExpression(\"=\", captured, ic.value)), t.breakStatement()];\n        }\n        cases.push(t.switchCase(t.numericLiteral(id), consequent));\n      });\n    }\n    // Default case.\n    if (this.realm.invariantLevel >= 1) {\n      cases.push(\n        t.switchCase(null, [\n          t.throwStatement(t.newExpression(t.identifier(\"Error\"), [t.stringLiteral(\"Unknown scope selector\")])),\n        ])\n      );\n    }\n\n    body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(captured)]));\n    body.push(t.switchStatement(selectorParam, cases));\n    body.push(t.expressionStatement(t.assignmentExpression(\"=\", selectorExpression, captured)));\n    body.push(t.returnStatement(captured));\n    const factoryFunction = t.functionExpression(null, [selectorParam], t.blockStatement(body));\n    const accessFunctionId = this._getReferentializationState(referentializationScope).capturedScopeAccessFunctionId;\n    return t.variableDeclaration(\"var\", [t.variableDeclarator(accessFunctionId, factoryFunction)]);\n  }\n\n  _getReferentializationScope(residualBinding: ResidualFunctionBinding): ReferentializationScope {\n    if (residualBinding.potentialReferentializationScopes.has(\"GLOBAL\")) return \"GLOBAL\";\n    if (residualBinding.potentialReferentializationScopes.size > 1) {\n      // Here we know potentialReferentializationScopes cannot contain \"GLOBAL\"; Set<FunctionValue> is\n      // compatible with Set<FunctionValue | Generator>\n      let scopes = ((residualBinding.potentialReferentializationScopes: any): Set<Scope>);\n      let parentOptimizedFunction = this._residualOptimizedFunctions.tryGetOutermostOptimizedFunction(scopes);\n      return parentOptimizedFunction || \"GLOBAL\";\n    }\n    for (let scope of residualBinding.potentialReferentializationScopes) return scope;\n    invariant(false);\n  }\n\n  _getSerializedBindingScopeInstance(residualBinding: ResidualFunctionBinding): ScopeBinding {\n    let declarativeEnvironmentRecord = residualBinding.declarativeEnvironmentRecord;\n    invariant(declarativeEnvironmentRecord);\n\n    let referentializationScope = this._getReferentializationScope(residualBinding);\n\n    // figure out if this is accessed only from additional functions\n    let refState: ReferentializationState = this._getReferentializationState(referentializationScope);\n    let scope = refState.serializedScopes.get(declarativeEnvironmentRecord);\n    if (!scope) {\n      scope = {\n        name: this.scopeNameGenerator.generate(),\n        id: refState.capturedScopeInstanceIdx++,\n        initializationValues: [],\n        leakedIds: [],\n        referentializationScope,\n      };\n      refState.serializedScopes.set(declarativeEnvironmentRecord, scope);\n    }\n\n    invariant(scope.referentializationScope === referentializationScope);\n    invariant(!residualBinding.scope || residualBinding.scope === scope);\n    residualBinding.scope = scope;\n    return scope;\n  }\n\n  getReferentializedScopeInitialization(\n    scope: ScopeBinding,\n    scopeName: BabelNodeExpression\n  ): Array<BabelNodeStatement> {\n    const capturedScope = scope.capturedScope;\n    invariant(capturedScope);\n    const state = this._getReferentializationState(scope.referentializationScope);\n    const funcName = state.capturedScopeAccessFunctionId;\n    const scopeArray = state.capturedScopesArray;\n    // First get scope array entry and check if it's already initialized.\n    // Only if not yet, then call the initialization function.\n    const init = t.logicalExpression(\n      \"||\",\n      t.memberExpression(scopeArray, scopeName, true),\n      t.callExpression(funcName, [scopeName])\n    );\n    return [t.variableDeclaration(\"var\", [t.variableDeclarator(t.identifier(capturedScope), init)])];\n  }\n\n  referentializeLeakedBinding(residualBinding: ResidualFunctionBinding): void {\n    invariant(residualBinding.hasLeaked);\n    // When simpleClosures is enabled, then space for captured mutable bindings is allocated upfront.\n    let serializedBindingId = t.identifier(this._leakedNameGenerator.generate(residualBinding.name));\n    let scope = this._getSerializedBindingScopeInstance(residualBinding);\n    scope.leakedIds.push(serializedBindingId);\n    residualBinding.serializedValue = residualBinding.serializedUnscopedLocation = serializedBindingId;\n\n    this.getStatistics().referentialized++;\n  }\n\n  referentializeModifiedBinding(residualBinding: ResidualFunctionBinding): void {\n    invariant(residualBinding.modified);\n\n    // Space for captured mutable bindings is allocated lazily.\n    let scope = this._getSerializedBindingScopeInstance(residualBinding);\n    let capturedScope = \"__captured\" + scope.name;\n    // Save the serialized value for initialization at the top of\n    // the factory.\n    // This can serialize more variables than are necessary to execute\n    // the function because every function serializes every\n    // modified variable of its parent scope. In some cases it could be\n    // an improvement to split these variables into multiple\n    // scopes.\n    const variableIndexInScope = scope.initializationValues.length;\n    const indexExpression = t.numericLiteral(variableIndexInScope);\n    invariant(residualBinding.serializedValue);\n    scope.initializationValues.push(residualBinding.serializedValue);\n    scope.capturedScope = capturedScope;\n\n    // Replace binding usage with scope references\n\n    // The rewritten .serializedValue refers to a local capturedScope variable\n    // which is only accessible from within residual functions where code\n    // to create this variable is emitted.\n    residualBinding.serializedValue = t.memberExpression(\n      t.identifier(capturedScope),\n      indexExpression,\n      true // Array style access.\n    );\n\n    // .serializedUnscopedLocation is initialized with a more general expressions\n    // that can be used outside of residual functions.\n    // TODO: Creating these expressions just in case looks expensive. Measure, and potentially only create lazily.\n    const state = this._getReferentializationState(scope.referentializationScope);\n    const funcName = state.capturedScopeAccessFunctionId;\n    const scopeArray = state.capturedScopesArray;\n    // First get scope array entry and check if it's already initialized.\n    // Only if not yet, then call the initialization function.\n    const scopeName = t.numericLiteral(scope.id);\n    const capturedScopeExpression = t.logicalExpression(\n      \"||\",\n      t.memberExpression(scopeArray, scopeName, true),\n      t.callExpression(funcName, [scopeName])\n    );\n    residualBinding.serializedUnscopedLocation = t.memberExpression(\n      capturedScopeExpression,\n      indexExpression,\n      true // Array style access.\n    );\n\n    this.getStatistics().referentialized++;\n  }\n\n  // Cleans all scopes between passes of the serializer\n  cleanInstance(instance: FunctionInstance): void {\n    instance.initializationStatements = [];\n    for (let b of ((instance: any): FunctionInstance).residualFunctionBindings.values()) {\n      let binding = ((b: any): ResidualFunctionBinding);\n      if (binding.referentialized && binding.declarativeEnvironmentRecord) {\n        let declarativeEnvironmentRecord = binding.declarativeEnvironmentRecord;\n        let referentializationScope = this._getReferentializationScope(binding);\n\n        let refState = this.referentializationState.get(referentializationScope);\n        if (refState) {\n          let scope = refState.serializedScopes.get(declarativeEnvironmentRecord);\n          if (scope) {\n            scope.initializationValues = [];\n            scope.leakedIds = [];\n          }\n        }\n      }\n      delete binding.serializedValue;\n    }\n  }\n\n  referentialize(instance: FunctionInstance): void {\n    let residualBindings = instance.residualFunctionBindings;\n\n    for (let residualBinding of residualBindings.values()) {\n      if (residualBinding === undefined) continue;\n      if (residualBinding.modified) {\n        // Initialize captured scope at function call instead of globally\n        if (!residualBinding.declarativeEnvironmentRecord) residualBinding.referentialized = true;\n        if (!residualBinding.referentialized) {\n          if (!residualBinding.hasLeaked) this._getSerializedBindingScopeInstance(residualBinding);\n          residualBinding.referentialized = true;\n        }\n\n        invariant(residualBinding.referentialized);\n        if (residualBinding.declarativeEnvironmentRecord && residualBinding.scope) {\n          instance.scopeInstances.set(residualBinding.scope.name, residualBinding.scope);\n        }\n      }\n    }\n  }\n\n  _createCapturedScopesArrayInitialization(referentializationScope: ReferentializationScope): BabelNodeStatement {\n    return t.variableDeclaration(\"var\", [\n      t.variableDeclarator(\n        this._getReferentializationState(referentializationScope).capturedScopesArray,\n        t.newExpression(t.identifier(\"Array\"), [\n          t.numericLiteral(this._getReferentializationState(referentializationScope).capturedScopeInstanceIdx),\n        ])\n      ),\n    ]);\n  }\n}\n"],"file":"Referentializer.js"}