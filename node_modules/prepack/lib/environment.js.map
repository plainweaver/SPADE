{"version":3,"sources":["../src/environment.js"],"names":["deriveGetBinding","realm","binding","types","TypesDomain","topVal","values","ValuesDomain","generator","undefined","deriveAbstract","materializeBinding","realmGenerator","value","intrinsics","emitBindingAssignment","leakBinding","environment","hasLeaked","mutable","recordModifiedBinding","EnvironmentRecord","constructor","isReadOnly","id","nextId","creatingOptimizedFunction","currentOptimizedFunction","HasBinding","N","CreateMutableBinding","D","isGlobal","CreateImmutableBinding","S","skipRecord","InitializeBinding","V","SetMutableBinding","GetBindingValue","DeleteBinding","HasThisBinding","GetThisBinding","HasSuperBinding","WithBaseObject","BindThisValue","DeclarativeEnvironmentRecord","bindings","Object","create","frozen","envRec","initialized","deletable","name","mightHaveBeenCaptured","strict","empty","_S","createErrorThrowCompletion","ReferenceError","Leak","TypeError","ObjectEnvironmentRecord","obj","object","foundBinding","withEnvironment","unscopables","SymbolUnscopables","ObjectValue","AbstractObjectValue","blocked","To","ToBooleanPartial","throwIfNotConcrete","configValue","BooleanValue","Properties","DefinePropertyOrThrow","PropertyDescriptor","writable","enumerable","configurable","Set","$Delete","FunctionEnvironmentRecord","$ThisBindingStatus","$ThisValue","$HomeObject","GetSuperBase","home","$GetPrototypeOf","GlobalEnvironmentRecord","DclRec","$DeclarativeRecord","ObjRec","$ObjectRecord","globalObject","existingProp","status","varNames","$VarNames","indexOf","splice","$GlobalThisValue","HasVarDeclaration","varDeclaredNames","HasLexicalDeclaration","HasRestrictedGlobalProperty","$GetOwnProperty","ThrowIfMightHaveBeenDeleted","$Realm","CanDeclareGlobalVar","hasProperty","CanDeclareGlobalFunction","CreateGlobalVarBinding","extensible","push","CreateGlobalFunctionBinding","desc","uid","LexicalEnvironment","destroyed","_uid","destroy","environmentRecord","assignToGlobal","globalAst","rvalue","globalValue","evaluate","PutValue","evaluateCompletionDeref","ast","strictCode","metadata","result","evaluateCompletion","Reference","Environment","GetValue","err","AbruptCompletion","Error","FatalError","evaluateAbstractCompletion","evaluateAbstract","Completion","concatenateAndParse","sources","sourceType","asts","code","directives","source","node","statistics","parsing","measure","fileContents","filePath","sourceMapContents","length","fixupSourceLocations","fixupFilenames","concat","program","body","e","ThrowCompletion","error","message","_SafeGetDataPropertyValue","StringValue","location","start","line","column","end","diagnostic","CompilerDiagnostic","handleError","t","file","executeSources","onParse","context","ExecutionContext","lexicalEnvironment","variableEnvironment","pushContext","res","evaluation","popContext","onDestroyScope","activeLexicalEnvironments","size","execute","filename","map","loc","positionInfos","Map","smc","SourceMapConsumer","fixupLocation","fixupComments","leadingComments","innerComments","trailingComments","getPositionInfo","position","info","get","set","originalPosition","originalPositionFor","newLine","newColumn","rewritten","fixupPosition","pos","posInfo","otherInfo","posOriginalPosition","deltaLine","Math","max","deltaColumn","locStart","locEnd","startInfo","endInfo","startOriginalPosition","endOriginalPosition","originalSource","comments","c","debuggerInstance","checkForActions","debugReproManager","addSourceFile","Value","type","currentLocation","testTimeout","evaluator","evaluators","evaluatedNodes","evaluateDeref","isValidBaseValue","val","AbstractValue","mightBecomeAnObject","base","getType","PrimitiveValue","SymbolValue","NumberValue","IntegralValue","refName","thisValue","referencedName","mightNotBeString","mightNotBeNumber","isSimpleObject","isInPureScope"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport type {\n  BabelNode,\n  BabelNodeComment,\n  BabelNodeFile,\n  BabelNodeLVal,\n  BabelNodePosition,\n  BabelNodeSourceLocation,\n} from \"@babel/types\";\nimport type { Realm } from \"./realm.js\";\nimport type { SourceFile, SourceType } from \"./types.js\";\nimport * as t from \"@babel/types\";\n\nimport { AbruptCompletion, Completion, ThrowCompletion } from \"./completions.js\";\nimport { CompilerDiagnostic, FatalError } from \"./errors.js\";\nimport { ExecutionContext } from \"./realm.js\";\nimport {\n  AbstractValue,\n  NullValue,\n  SymbolValue,\n  BooleanValue,\n  FunctionValue,\n  NumberValue,\n  IntegralValue,\n  ObjectValue,\n  AbstractObjectValue,\n  StringValue,\n  UndefinedValue,\n  Value,\n} from \"./values/index.js\";\nimport parse from \"./utils/parse.js\";\nimport invariant from \"./invariant.js\";\nimport traverseFast from \"./utils/traverse-fast.js\";\nimport { HasProperty, Get, IsExtensible, HasOwnProperty, IsDataDescriptor } from \"./methods/index.js\";\nimport { Environment, Leak, Properties, To } from \"./singletons.js\";\nimport { TypesDomain, ValuesDomain } from \"./domains/index.js\";\nimport PrimitiveValue from \"./values/PrimitiveValue.js\";\nimport { createOperationDescriptor } from \"./utils/generator.js\";\n\nimport { SourceMapConsumer, type NullableMappedPosition } from \"source-map\";\nimport { PropertyDescriptor } from \"./descriptors.js\";\n\nfunction deriveGetBinding(realm: Realm, binding: Binding) {\n  let types = TypesDomain.topVal;\n  let values = ValuesDomain.topVal;\n  invariant(realm.generator !== undefined);\n  return realm.generator.deriveAbstract(types, values, [], createOperationDescriptor(\"GET_BINDING\", { binding }));\n}\n\nexport function materializeBinding(realm: Realm, binding: Binding): void {\n  let realmGenerator = realm.generator;\n  invariant(realmGenerator !== undefined);\n  let value = binding.value;\n  if (value !== undefined && value !== realm.intrinsics.undefined) realmGenerator.emitBindingAssignment(binding, value);\n}\nexport function leakBinding(binding: Binding): void {\n  let realm = binding.environment.realm;\n  if (!binding.hasLeaked) {\n    if (binding.mutable) {\n      realm.recordModifiedBinding(binding).hasLeaked = true;\n    } else {\n      binding.hasLeaked = true;\n    }\n    materializeBinding(realm, binding);\n  }\n\n  // Havoc the binding\n  if (binding.mutable === true) {\n    // For mutable, i.e. non-const bindings, the actual value is no longer directly available.\n    // Thus, we reset the value to undefined to prevent any use of the last known value.\n    binding.value = undefined;\n  }\n}\n\n// ECMA262 8.1.1\nexport class EnvironmentRecord {\n  realm: Realm;\n  isReadOnly: boolean;\n  $NewTarget: void | ObjectValue;\n  id: number;\n  creatingOptimizedFunction: FunctionValue | void;\n\n  static nextId: number = 0;\n\n  constructor(realm: Realm) {\n    invariant(realm, \"expected realm\");\n    this.realm = realm;\n    this.isReadOnly = false;\n    this.id = EnvironmentRecord.nextId++;\n    this.creatingOptimizedFunction = realm.currentOptimizedFunction;\n  }\n\n  HasBinding(N: string): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  CreateMutableBinding(N: string, D: boolean, isGlobal?: boolean): Value {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  CreateImmutableBinding(N: string, S: boolean, isGlobal?: boolean, skipRecord?: boolean): Value {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  InitializeBinding(N: string, V: Value, skipRecord?: boolean): Value {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  GetBindingValue(N: string, S: boolean): Value {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  DeleteBinding(N: string): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  HasThisBinding(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  HasSuperBinding(): boolean {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  WithBaseObject(): Value {\n    invariant(false, \"abstract method; please override\");\n  }\n\n  BindThisValue(\n    V: NullValue | ObjectValue | AbstractObjectValue | UndefinedValue\n  ): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    invariant(false, \"abstract method; please override\");\n  }\n}\n\nexport type Binding = {\n  value?: Value,\n  initialized?: boolean,\n  mutable?: boolean,\n  deletable?: boolean,\n  strict?: boolean,\n  // back-references to the environment containing the binding and the key\n  // used to access this binding\n  environment: EnvironmentRecord,\n  name: string,\n  isGlobal: boolean,\n  mightHaveBeenCaptured: boolean,\n  // bindings that are assigned to inside loops with abstract termination conditions need temporal locations\n  phiNode?: AbstractValue,\n  hasLeaked: boolean,\n};\n\n// ECMA262 8.1.1.1\nexport class DeclarativeEnvironmentRecord extends EnvironmentRecord {\n  constructor(realm: Realm) {\n    super(realm);\n    this.bindings = (Object.create(null): any);\n    this.frozen = false;\n  }\n\n  bindings: { [name: string]: Binding };\n  // Frozen Records cannot have bindings created or deleted but can have bindings updated\n  frozen: boolean;\n\n  // ECMA262 8.1.1.1.1\n  HasBinding(N: string): boolean {\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec has a binding for the name that is the value of N, return true.\n    if (envRec.bindings[N]) return true;\n\n    // 3. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.2\n  CreateMutableBinding(N: string, D: boolean, isGlobal: boolean = false): Value {\n    invariant(!this.frozen);\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec does not already have a binding for N.\n    invariant(!envRec.bindings[N], `shouldn't have the binding ${N}`);\n\n    // 3. Create a mutable binding in envRec for N and record that it is uninitialized. If D is true, record that the newly created binding may be deleted by a subsequent DeleteBinding call.\n    this.bindings[N] = realm.recordModifiedBinding({\n      initialized: false,\n      mutable: true,\n      deletable: D,\n      environment: envRec,\n      name: N,\n      isGlobal: isGlobal,\n      mightHaveBeenCaptured: false,\n      hasLeaked: false,\n    });\n\n    // 4. Return NormalCompletion(empty).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.1.3\n  CreateImmutableBinding(N: string, S: boolean, isGlobal: boolean = false, skipRecord: boolean = false): Value {\n    invariant(!this.frozen);\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec does not already have a binding for N.\n    invariant(!envRec.bindings[N], `shouldn't have the binding ${N}`);\n\n    // 3. Create an immutable binding in envRec for N and record that it is uninitialized. If S is true, record that the newly created binding is a strict binding.\n    let binding = {\n      initialized: false,\n      strict: S,\n      deletable: false,\n      environment: envRec,\n      name: N,\n      isGlobal: isGlobal,\n      mightHaveBeenCaptured: false,\n      hasLeaked: false,\n    };\n    this.bindings[N] = skipRecord ? binding : realm.recordModifiedBinding(binding);\n\n    // 4. Return NormalCompletion(empty).\n    return realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.1.4\n  InitializeBinding(N: string, V: Value, skipRecord: boolean = false): Value {\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. Assert: envRec must have an uninitialized binding for N.\n    invariant(binding && binding.initialized !== true, `shouldn't have the binding ${N}`);\n\n    // 3. Set the bound value for N in envRec to V.\n    if (!skipRecord) this.realm.recordModifiedBinding(binding, V).value = V;\n    else binding.value = V;\n\n    // 4. Record that the binding for N in envRec has been initialized.\n    binding.initialized = true;\n\n    // 5. Return NormalCompletion(empty).\n    return this.realm.intrinsics.empty;\n  }\n\n  // ECMA262 8.1.1.1.5\n  SetMutableBinding(N: string, V: Value, _S: boolean): Value {\n    let S = _S;\n    // We can mutate frozen bindings because of captured bindings.\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. If envRec does not have a binding for N, then\n    if (!binding) {\n      // a. If S is true, throw a ReferenceError exception.\n      if (S) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${N} not found`);\n      }\n\n      // b. Perform envRec.CreateMutableBinding(N, true).\n      envRec.CreateMutableBinding(N, true);\n\n      // c. Perform envRec.InitializeBinding(N, V).\n      envRec.InitializeBinding(N, V);\n\n      // d. Return NormalCompletion(empty).\n      return this.realm.intrinsics.empty;\n    }\n\n    // 3. If the binding for N in envRec is a strict binding, let S be true.\n    if (binding.strict === true) S = true;\n\n    // 4. If the binding for N in envRec has not yet been initialized, throw a ReferenceError exception.\n    if (binding.initialized !== true) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError, `${N} has not yet been initialized`);\n    } else if (binding.mutable) {\n      // 5. Else if the binding for N in envRec is a mutable binding, change its bound value to V.\n      if (binding.hasLeaked) {\n        Leak.value(realm, V);\n        invariant(realm.generator);\n        realm.generator.emitBindingAssignment(binding, V);\n      } else {\n        realm.recordModifiedBinding(binding, V).value = V;\n      }\n    } else {\n      // 6. Else,\n      // a. Assert: This is an attempt to change the value of an immutable binding.\n\n      // b. If S is true, throw a TypeError exception.\n      if (S) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError, \"attempt to change immutable binding\");\n      }\n    }\n\n    // 7. Return NormalCompletion(empty).\n    return this.realm.intrinsics.empty;\n  }\n\n  // ECMA262 8.1.1.1.6\n  GetBindingValue(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    let binding = envRec.bindings[N];\n\n    // 2. Assert: envRec has a binding for N.\n    invariant(binding, \"expected binding\");\n\n    // 3. If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.\n    if (!binding.initialized) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Return the value currently bound to N in envRec.\n    if (binding.hasLeaked && binding.mutable) {\n      return deriveGetBinding(realm, binding);\n    }\n    invariant(binding.value);\n    return binding.value;\n  }\n\n  // ECMA262 8.1.1.1.7\n  DeleteBinding(N: string): boolean {\n    invariant(!this.frozen);\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec has a binding for the name that is the value of N.\n    invariant(envRec.bindings[N], \"expected binding to exist\");\n\n    // 3. If the binding for N in envRec cannot be deleted, return false.\n    if (!envRec.bindings[N].deletable) return false;\n\n    // 4. Remove the binding for N from envRec.\n    this.realm.recordModifiedBinding(envRec.bindings[N]).value = undefined;\n    delete envRec.bindings[N];\n\n    // 5. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.1.8\n  HasThisBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.9\n  HasSuperBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.1.10\n  WithBaseObject(): Value {\n    // 1. Return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n}\n\n// ECMA262 8.1.1.2\nexport class ObjectEnvironmentRecord extends EnvironmentRecord {\n  object: ObjectValue | AbstractObjectValue;\n  withEnvironment: boolean;\n\n  constructor(realm: Realm, obj: ObjectValue | AbstractObjectValue) {\n    super(realm);\n    this.object = obj;\n  }\n\n  // ECMA262 8.1.1.2.1\n  HasBinding(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = this.object;\n\n    // 3. Let foundBinding be ? HasProperty(bindings, N).\n    let foundBinding = HasProperty(realm, bindings, N);\n\n    // 4. If foundBinding is false, return false.\n    if (!foundBinding) return false;\n\n    // 5. If the withEnvironment flag of envRec is false, return true.\n    if (!envRec.withEnvironment) return true;\n\n    // 6. Let unscopables be ? Get(bindings, @@unscopables).\n    let unscopables = Get(realm, bindings, realm.intrinsics.SymbolUnscopables);\n\n    // 7. If Type(unscopables) is Object, then\n    if (unscopables instanceof ObjectValue || unscopables instanceof AbstractObjectValue) {\n      // a. Let blocked be ToBoolean(? Get(unscopables, N)).\n      let blocked = To.ToBooleanPartial(realm, Get(realm, unscopables, N));\n\n      // b. If blocked is true, return false.\n      if (blocked) return false;\n    }\n    unscopables.throwIfNotConcrete();\n\n    // 8. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.2.2\n  CreateMutableBinding(N: string, D: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. If D is true, let configValue be true; otherwise let configValue be false.\n    let configValue = D ? true : false;\n\n    // 4. Return ? DefinePropertyOrThrow(bindings, N, PropertyDescriptor{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: configValue}).\n    return new BooleanValue(\n      realm,\n      Properties.DefinePropertyOrThrow(\n        realm,\n        bindings,\n        N,\n        new PropertyDescriptor({\n          value: realm.intrinsics.undefined,\n          writable: true,\n          enumerable: true,\n          configurable: configValue,\n        })\n      )\n    );\n  }\n\n  // ECMA262 8.1.1.2.3\n  CreateImmutableBinding(N: string, S: boolean): Value {\n    // The concrete Environment Record method CreateImmutableBinding is never used within this specification in association with object Environment Records.\n    invariant(false);\n  }\n\n  // ECMA262 8.1.1.2.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec must have an uninitialized binding for N.\n    // 3. Record that the binding for N in envRec has been initialized.\n\n    // 4. Return ? envRec.SetMutableBinding(N, V, false).\n    return envRec.SetMutableBinding(N, V, false);\n  }\n\n  // ECMA262 8.1.1.2.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Return ? Set(bindings, N, V, S).\n    return new BooleanValue(realm, Properties.Set(realm, bindings, N, V, S));\n  }\n\n  // ECMA262 8.1.1.2.6\n  GetBindingValue(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Let value be ? HasProperty(bindings, N).\n    let value = HasProperty(realm, bindings, N);\n\n    // 4. If value is false, then\n    if (!value) {\n      // a. If S is false, return the value undefined; otherwise throw a ReferenceError exception.\n      if (!S) {\n        return realm.intrinsics.undefined;\n      } else {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n      }\n    }\n\n    // 5. Return ? Get(bindings, N).\n    return Get(realm, bindings, N);\n  }\n\n  // ECMA262 8.1.1.2.7\n  DeleteBinding(N: string): boolean {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    let bindings = envRec.object;\n\n    // 3. Return ? bindings.[[Delete]](N).\n    return bindings.$Delete(N);\n  }\n\n  // ECMA262 8.1.1.2.8\n  HasThisBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.2.9\n  HasSuperBinding(): boolean {\n    // 1. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.2.10\n  WithBaseObject(): Value {\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If the withEnvironment flag of envRec is true, return the binding object for envRec.\n    if (envRec.withEnvironment) return envRec.object;\n\n    // 3. Otherwise, return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n}\n\n// ECMA262 8.1.1.3\nexport class FunctionEnvironmentRecord extends DeclarativeEnvironmentRecord {\n  $ThisBindingStatus: \"lexical\" | \"initialized\" | \"uninitialized\";\n  $ThisValue: UndefinedValue | NullValue | ObjectValue | AbstractObjectValue;\n  $HomeObject: void | ObjectValue;\n  $FunctionObject: FunctionValue;\n\n  // ECMA262 8.1.1.3.1\n  BindThisValue(\n    V: NullValue | ObjectValue | AbstractObjectValue | UndefinedValue\n  ): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    let realm = this.realm;\n\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec.[[ThisBindingStatus]] is not \"lexical\".\n    invariant(envRec.$ThisBindingStatus !== \"lexical\", \"this binding status shouldn't be lexical\");\n\n    // 3. If envRec.[[ThisBindingStatus]] is \"initialized\", throw a ReferenceError exception.\n    if (envRec.$ThisBindingStatus === \"initialized\") {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Set envRec.[[ThisValue]] to V.\n    envRec.$ThisValue = V;\n\n    // 5. Set envRec.[[ThisBindingStatus]] to \"initialized\".\n    envRec.$ThisBindingStatus = \"initialized\";\n\n    // 6. Return V.\n    return V;\n  }\n\n  // ECMA262 8.1.1.3.2\n  HasThisBinding(): boolean {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec.[[ThisBindingStatus]] is \"lexical\", return false; otherwise, return true.\n    return envRec.$ThisBindingStatus === \"lexical\" ? false : true;\n  }\n\n  // ECMA262 8.1.1.3.3\n  HasSuperBinding(): boolean {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. If envRec.[[ThisBindingStatus]] is \"lexical\", return false.\n    if (envRec.$ThisBindingStatus === \"lexical\") return false;\n\n    // 3. If envRec.[[HomeObject]] has the value undefined, return false; otherwise, return true.\n    if (envRec.$HomeObject === undefined) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  // ECMA262 8.1.1.3.4\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    let realm = this.realm;\n\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Assert: envRec.[[ThisBindingStatus]] is not \"lexical\".\n    invariant(envRec.$ThisBindingStatus !== \"lexical\", \"this binding status shouldn't be lexical\");\n\n    // 3. If envRec.[[ThisBindingStatus]] is \"uninitialized\", throw a ReferenceError exception.\n    if (envRec.$ThisBindingStatus === \"uninitialized\") {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.ReferenceError);\n    }\n\n    // 4. Return envRec.[[ThisValue]].\n    return envRec.$ThisValue;\n  }\n\n  // ECMA262 8.1.1.3.5\n  GetSuperBase(): ObjectValue | AbstractObjectValue | NullValue | UndefinedValue {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let home be the value of envRec.[[HomeObject]].\n    let home = envRec.$HomeObject;\n\n    // 3. If home has the value undefined, return undefined.\n    if (home === undefined) return this.realm.intrinsics.undefined;\n\n    // 4. Assert: Type(home) is Object.\n    invariant(home instanceof ObjectValue, \"expected object value\");\n\n    // 5. Return ? home.[[GetPrototypeOf]]().\n    return home.$GetPrototypeOf();\n  }\n}\n\n// ECMA262 8.1.1.4\nexport class GlobalEnvironmentRecord extends EnvironmentRecord {\n  $DeclarativeRecord: EnvironmentRecord;\n  $ObjectRecord: ObjectEnvironmentRecord;\n  $VarNames: Array<string>;\n  $GlobalThisValue: ObjectValue;\n\n  // ECMA262 8.1.1.4.1\n  HasBinding(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, return true.\n    if (DclRec.HasBinding(N)) return true;\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.HasBinding(N).\n    return ObjRec.HasBinding(N);\n  }\n\n  // ECMA262 8.1.1.4.2\n  CreateMutableBinding(N: string, D: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.\n    if (DclRec.HasBinding(N)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Return DclRec.CreateMutableBinding(N, D).\n    return DclRec.CreateMutableBinding(N, D, true);\n  }\n\n  // ECMA262 8.1.1.4.3\n  CreateImmutableBinding(N: string, S: boolean): Value {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.\n    if (DclRec.HasBinding(N)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Return DclRec.CreateImmutableBinding(N, S).\n    return DclRec.CreateImmutableBinding(N, S, true);\n  }\n\n  // ECMA262 8.1.1.4.4\n  InitializeBinding(N: string, V: Value): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.InitializeBinding(N, V).\n      return DclRec.InitializeBinding(N, V);\n    }\n\n    // 4. Assert: If the binding exists, it must be in the object Environment Record.\n\n    // 5. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 6. Return ? ObjRec.InitializeBinding(N, V).\n    return ObjRec.InitializeBinding(N, V);\n  }\n\n  // ECMA262 8.1.1.4.5\n  SetMutableBinding(N: string, V: Value, S: boolean): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.SetMutableBinding(N, V, S).\n      return DclRec.SetMutableBinding(N, V, S);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.SetMutableBinding(N, V, S).\n    return ObjRec.SetMutableBinding(N, V, S);\n  }\n\n  // ECMA262 8.1.1.4.6\n  GetBindingValue(N: string, S: boolean): Value {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.GetBindingValue(N, S).\n      return DclRec.GetBindingValue(N, S);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Return ? ObjRec.GetBindingValue(N, S).\n    return ObjRec.GetBindingValue(N, S);\n  }\n\n  // ECMA262 8.1.1.4.7\n  DeleteBinding(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (DclRec.HasBinding(N)) {\n      // a. Return DclRec.DeleteBinding(N).\n      return DclRec.DeleteBinding(N);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 5. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 6. Let existingProp be ? HasOwnProperty(globalObject, N).\n    let existingProp = HasOwnProperty(realm, globalObject, N);\n\n    // 7. If existingProp is true, then\n    if (existingProp) {\n      // a. Let status be ? ObjRec.DeleteBinding(N).\n      let status = ObjRec.DeleteBinding(N);\n\n      // b. If status is true, then\n      if (status) {\n        // i. Let varNames be envRec.[[VarNames]].\n        let varNames = envRec.$VarNames;\n\n        // ii. If N is an element of varNames, remove that element from the varNames.\n        if (varNames.indexOf(N) >= 0) {\n          varNames.splice(varNames.indexOf(N), 1);\n        }\n      }\n\n      // c. Return status.\n      return status;\n    }\n\n    // 8. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.8\n  HasThisBinding(): boolean {\n    // 1. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.9\n  HasSuperBinding(): boolean {\n    // 1. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.10\n  WithBaseObject(): Value {\n    // 1. Return undefined.\n    return this.realm.intrinsics.undefined;\n  }\n\n  // ECMA262 8.1.1.4.11\n  GetThisBinding(): NullValue | ObjectValue | AbstractObjectValue | UndefinedValue {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    invariant(envRec.$GlobalThisValue);\n    // 2. Return envRec.[[GlobalThisValue]].\n    return envRec.$GlobalThisValue;\n  }\n\n  // ECMA262 8.1.1.4.12\n  HasVarDeclaration(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 3. If varDeclaredNames contains the value of N, return true.\n    if (varDeclaredNames.indexOf(N) >= 0) return true;\n\n    // 4. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.4.13\n  HasLexicalDeclaration(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    let DclRec = envRec.$DeclarativeRecord;\n\n    // 3. Return DclRec.HasBinding(N).\n    return DclRec.HasBinding(N);\n  }\n\n  // ECMA262 8.1.1.4.14\n  HasRestrictedGlobalProperty(N: string): boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined, return false.\n    if (!existingProp) return false;\n    Properties.ThrowIfMightHaveBeenDeleted(existingProp);\n    existingProp = existingProp.throwIfNotConcrete(globalObject.$Realm);\n\n    // 6. If existingProp.[[Configurable]] is true, return false.\n    if (existingProp.configurable) return false;\n\n    // 7. Return true.\n    return true;\n  }\n\n  // ECMA262 8.1.1.4.15\n  CanDeclareGlobalVar(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).\n    let hasProperty = HasOwnProperty(realm, globalObject, N);\n\n    // 5. If hasProperty is true, return true.\n    if (hasProperty) return true;\n\n    // 6. Return ? IsExtensible(globalObject).\n    return IsExtensible(realm, globalObject);\n  }\n\n  // ECMA262 8.1.1.4.16\n  CanDeclareGlobalFunction(N: string): boolean {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n\n    // 5. If existingProp is undefined, return ? IsExtensible(globalObject).\n    if (!existingProp) return IsExtensible(realm, globalObject);\n    Properties.ThrowIfMightHaveBeenDeleted(existingProp);\n    existingProp = existingProp.throwIfNotConcrete(globalObject.$Realm);\n\n    // 6. If existingProp.[[Configurable]] is true, return true.\n    if (existingProp.configurable) return true;\n\n    // 7. If IsDataDescriptor(existingProp) is true and existingProp has attribute values {[[Writable]]: true, [[Enumerable]]: true}, return true.\n    if (IsDataDescriptor(realm, existingProp) && existingProp.writable && existingProp.enumerable) {\n      return true;\n    }\n\n    // 8. Return false.\n    return false;\n  }\n\n  // ECMA262 8.1.1.4.17\n  CreateGlobalVarBinding(N: string, D: boolean) {\n    let realm = this.realm;\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).\n    let hasProperty = HasOwnProperty(realm, globalObject, N);\n\n    // 5. Let extensible be ? IsExtensible(globalObject).\n    let extensible = IsExtensible(realm, globalObject);\n\n    // 6. If hasProperty is false and extensible is true, then\n    if (!hasProperty && extensible) {\n      // a. Perform ? ObjRec.CreateMutableBinding(N, D).\n      ObjRec.CreateMutableBinding(N, D);\n\n      // b. Perform ? ObjRec.InitializeBinding(N, undefined).\n      ObjRec.InitializeBinding(N, this.realm.intrinsics.undefined);\n    }\n\n    // 7. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 8. If varDeclaredNames does not contain the value of N, then\n    if (varDeclaredNames.indexOf(N) < 0) {\n      // a. Append N to varDeclaredNames.\n      varDeclaredNames.push(N);\n    }\n\n    // 9. Return NormalCompletion(empty).\n  }\n\n  // ECMA262 8.1.1.4.18\n  CreateGlobalFunctionBinding(N: string, V: Value, D: boolean): void {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    let envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    let ObjRec = envRec.$ObjectRecord;\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    let globalObject = ObjRec.object;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    let existingProp = globalObject.$GetOwnProperty(N);\n    if (existingProp) {\n      existingProp = existingProp.throwIfNotConcrete(globalObject.$Realm);\n    }\n\n    // 5. If existingProp is undefined or existingProp.[[Configurable]] is true, then\n    let desc;\n    if (!existingProp || existingProp.configurable) {\n      // a. Let desc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D}.\n      desc = new PropertyDescriptor({ value: V, writable: true, enumerable: true, configurable: D });\n    } else {\n      // 6. Else,\n      Properties.ThrowIfMightHaveBeenDeleted(existingProp);\n      // a. Let desc be the PropertyDescriptor{[[Value]]: V }.\n      desc = new PropertyDescriptor({ value: V });\n    }\n\n    // 7. Perform ? DefinePropertyOrThrow(globalObject, N, desc).\n    Properties.DefinePropertyOrThrow(this.realm, globalObject, N, desc);\n\n    // 8. Record that the binding for N in ObjRec has been initialized.\n\n    // 9. Perform ? Set(globalObject, N, V, false).\n    Properties.Set(this.realm, globalObject, N, V, false);\n\n    // 10. Let varDeclaredNames be envRec.[[VarNames]].\n    let varDeclaredNames = envRec.$VarNames;\n\n    // 11. If varDeclaredNames does not contain the value of N, then\n    if (varDeclaredNames.indexOf(N) < 0) {\n      // a. Append N to varDeclaredNames.\n      varDeclaredNames.push(N);\n    }\n\n    // 12. Return NormalCompletion(empty).\n  }\n}\n\n// ECMA262 8.1\nlet uid = 0;\nexport class LexicalEnvironment {\n  constructor(realm: Realm) {\n    invariant(realm, \"expected realm\");\n    this.realm = realm;\n    this.destroyed = false;\n    this._uid = uid++;\n  }\n\n  // For debugging it is convenient to have an ID for each of these.\n  _uid: number;\n  destroyed: boolean;\n  environmentRecord: EnvironmentRecord;\n  parent: null | LexicalEnvironment;\n  realm: Realm;\n\n  destroy(): void {\n    this.destroyed = true;\n    // Once the containing environment is destroyed, we can no longer add or remove entries from the environmentRecord\n    // (but we can update existing values).\n    if (this.environmentRecord instanceof DeclarativeEnvironmentRecord) {\n      this.environmentRecord.frozen = true;\n    }\n  }\n\n  assignToGlobal(globalAst: BabelNodeLVal, rvalue: Value): void {\n    let globalValue = this.evaluate(globalAst, false);\n    Properties.PutValue(this.realm, globalValue, rvalue);\n  }\n\n  evaluateCompletionDeref(ast: BabelNode, strictCode: boolean, metadata?: any): AbruptCompletion | Value {\n    let result = this.evaluateCompletion(ast, strictCode, metadata);\n    if (result instanceof Reference) result = Environment.GetValue(this.realm, result);\n    return result;\n  }\n\n  evaluateCompletion(ast: BabelNode, strictCode: boolean, metadata?: any): AbruptCompletion | Value | Reference {\n    try {\n      return this.evaluate(ast, strictCode, metadata);\n    } catch (err) {\n      if (err instanceof AbruptCompletion) return err;\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      throw new FatalError(err);\n    }\n  }\n\n  evaluateAbstractCompletion(ast: BabelNode, strictCode: boolean, metadata?: any): Completion | Value | Reference {\n    try {\n      return this.evaluateAbstract(ast, strictCode, metadata);\n    } catch (err) {\n      if (err instanceof Completion) return err;\n      if (err instanceof Error)\n        // rethrowing Error should preserve stack trace\n        throw err;\n      // let's wrap into a proper Error to create stack trace\n      if (err instanceof Object) throw new FatalError(err.constructor.name + \": \" + err);\n      throw new FatalError(err);\n    }\n  }\n\n  concatenateAndParse(\n    sources: Array<SourceFile>,\n    sourceType: SourceType = \"script\"\n  ): [BabelNodeFile, { [string]: string }] {\n    let asts = [];\n    let code = {};\n    let directives = [];\n    for (let source of sources) {\n      try {\n        let node = this.realm.statistics.parsing.measure(() =>\n          parse(this.realm, source.fileContents, source.filePath, sourceType)\n        );\n\n        let sourceMapContents = source.sourceMapContents;\n        if (sourceMapContents && sourceMapContents.length > 0) {\n          this.realm.statistics.fixupSourceLocations.measure(() => this.fixupSourceLocations(node, sourceMapContents));\n        }\n\n        this.realm.statistics.fixupFilenames.measure(() => this.fixupFilenames(node));\n\n        asts = asts.concat(node.program.body);\n        code[source.filePath] = source.fileContents;\n        directives = directives.concat(node.program.directives);\n      } catch (e) {\n        if (e instanceof ThrowCompletion) {\n          let error = e.value;\n          if (error instanceof ObjectValue) {\n            let message = error._SafeGetDataPropertyValue(\"message\");\n            if (message instanceof StringValue) {\n              message.value = `Syntax error: ${message.value}`;\n              e.location.source = source.filePath;\n              // the position was not located properly on the\n              // syntax errors happen on one given position, so start position = end position\n              e.location.start = { line: e.location.line, column: e.location.column };\n              e.location.end = { line: e.location.line, column: e.location.column };\n              let diagnostic = new CompilerDiagnostic(message.value, e.location, \"PP1004\", \"FatalError\");\n              this.realm.handleError(diagnostic);\n              throw new FatalError(message.value);\n            }\n          }\n        }\n        throw e;\n      }\n    }\n    return [t.file(t.program(asts, directives)), code];\n  }\n\n  executeSources(\n    sources: Array<SourceFile>,\n    sourceType: SourceType = \"script\",\n    onParse: void | (BabelNodeFile => void) = undefined\n  ): [AbruptCompletion | Value, { [string]: string }] {\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n    this.realm.pushContext(context);\n    let res, code;\n    try {\n      let ast;\n      [ast, code] = this.concatenateAndParse(sources, sourceType);\n      if (onParse) onParse(ast);\n      res = this.realm.statistics.evaluation.measure(() => this.evaluateCompletion(ast, false));\n    } finally {\n      this.realm.popContext(context);\n      this.realm.onDestroyScope(context.lexicalEnvironment);\n      if (!this.destroyed) this.realm.onDestroyScope(this);\n      invariant(\n        this.realm.activeLexicalEnvironments.size === 0,\n        `expected 0 active lexical environments, got ${this.realm.activeLexicalEnvironments.size}`\n      );\n    }\n    if (res instanceof AbruptCompletion) return [res, code];\n\n    return [Environment.GetValue(this.realm, res), code];\n  }\n\n  execute(\n    code: string,\n    filename: string,\n    map: string = \"\",\n    sourceType: SourceType = \"script\",\n    onParse: void | (BabelNodeFile => void) = undefined\n  ): AbruptCompletion | Value {\n    let context = new ExecutionContext();\n    context.lexicalEnvironment = this;\n    context.variableEnvironment = this;\n    context.realm = this.realm;\n\n    this.realm.pushContext(context);\n\n    let ast, res;\n    try {\n      try {\n        ast = parse(this.realm, code, filename, sourceType);\n      } catch (e) {\n        if (e instanceof ThrowCompletion) return e;\n        throw e;\n      }\n      if (onParse) onParse(ast);\n      if (map.length > 0) this.fixupSourceLocations(ast, map);\n      this.fixupFilenames(ast);\n      res = this.evaluateCompletion(ast, false);\n    } finally {\n      this.realm.popContext(context);\n      // Avoid destroying \"this\" scope as execute may be called many times.\n      if (context.lexicalEnvironment !== this) this.realm.onDestroyScope(context.lexicalEnvironment);\n      invariant(\n        this.realm.activeLexicalEnvironments.size === 1,\n        `expected 1 active lexical environment, got ${this.realm.activeLexicalEnvironments.size}`\n      );\n    }\n    if (res instanceof AbruptCompletion) return res;\n\n    return Environment.GetValue(this.realm, res);\n  }\n\n  fixupSourceLocations(ast: BabelNode, map: string): void {\n    invariant(ast.loc);\n    const source = ast.loc.source;\n    invariant(source !== undefined);\n    const positionInfos = new Map();\n\n    const smc = new SourceMapConsumer(map);\n    traverseFast(ast, node => {\n      fixupLocation(node.loc);\n      fixupComments(node.leadingComments);\n      fixupComments(node.innerComments);\n      fixupComments(node.trailingComments);\n      return false;\n    });\n\n    type PositionInfo = {\n      originalPosition: NullableMappedPosition,\n      newLine: number,\n      newColumn: number,\n      rewritten: boolean,\n    };\n    function getPositionInfo(position: BabelNodePosition): PositionInfo {\n      let info = positionInfos.get(position);\n      if (info === undefined)\n        positionInfos.set(\n          position,\n          (info = {\n            originalPosition: smc.originalPositionFor(position),\n            newLine: position.line,\n            newColumn: position.column,\n            rewritten: false,\n          })\n        );\n      return info;\n    }\n    function fixupPosition(pos: BabelNodePosition, posInfo: PositionInfo, otherInfo: PositionInfo): void {\n      if (posInfo.rewritten) return;\n      let posOriginalPosition = posInfo.originalPosition;\n      if (posOriginalPosition.source == null) {\n        invariant(otherInfo.originalPosition.source != null);\n\n        let deltaLine = posInfo.newLine - otherInfo.newLine;\n        pos.line = Math.max(1, otherInfo.originalPosition.line + deltaLine);\n\n        let deltaColumn = posInfo.newColumn - otherInfo.newColumn;\n        pos.column = Math.max(0, otherInfo.originalPosition.column + deltaColumn);\n      } else {\n        invariant(typeof posOriginalPosition.line === \"number\");\n        pos.line = posOriginalPosition.line;\n        invariant(typeof posOriginalPosition.column === \"number\");\n        pos.column = posOriginalPosition.column;\n      }\n      posInfo.rewritten = true;\n    }\n    function fixupLocation(loc: ?BabelNodeSourceLocation): void {\n      if (loc == null) return;\n      // Bail out when location already got fixed up or doesn't have source\n      if (loc.source === undefined || loc.source !== source) return;\n\n      let locStart = loc.start;\n      let locEnd = loc.end;\n      let startInfo = getPositionInfo(locStart);\n      let endInfo = getPositionInfo(locEnd);\n      let startOriginalPosition = startInfo.originalPosition;\n      let endOriginalPosition = endInfo.originalPosition;\n\n      // Sanity checks on the positions supplied directly by the Babel parser\n      invariant(startInfo.newLine <= endInfo.newLine);\n      invariant(startInfo.newLine !== endInfo.newLine || startInfo.newColumn <= endInfo.newColumn);\n\n      let originalSource = startOriginalPosition.source || endOriginalPosition.source;\n      if (originalSource) {\n        fixupPosition(locStart, startInfo, endInfo);\n        fixupPosition(locEnd, endInfo, startInfo);\n\n        // NOTE: Babel only persists the start position of most nodes in source maps\n        // (only block statements also get their end positions persisted).\n        // Thus, end positions tend to be mostly wrong (in fact often so wrong\n        // that they point before the start position).\n        // The best way to deal with that is to never print end positions in user-facing\n        // messages, or use them for any reason.\n\n        invariant(loc.source !== originalSource);\n        loc.source = originalSource;\n      }\n    }\n    function fixupComments(comments: ?Array<BabelNodeComment>) {\n      if (!comments) return;\n      for (let c of comments) fixupLocation(c.loc);\n    }\n  }\n\n  fixupFilenames(ast: BabelNode): void {\n    traverseFast(ast, node => {\n      let loc = node.loc;\n      if (loc && loc.source) (loc: any).filename = loc.source;\n      else node.loc = null;\n      fixupComments(node.leadingComments);\n      fixupComments(node.innerComments);\n      fixupComments(node.trailingComments);\n      return false;\n    });\n\n    function fixupComments(comments: ?Array<BabelNodeComment>): void {\n      if (!comments) return;\n      for (let c of comments) {\n        let loc = c.loc;\n        if (loc && loc.source) (loc: any).filename = loc.source;\n        else (c: any).loc = null;\n      }\n    }\n  }\n\n  evaluate(ast: BabelNode, strictCode: boolean, metadata?: any): Value | Reference {\n    if (this.realm.debuggerInstance) {\n      this.realm.debuggerInstance.checkForActions(ast);\n    }\n    if (this.realm.debugReproManager) {\n      if (ast.loc !== undefined && ast.loc !== null && ast.loc.source) {\n        this.realm.debugReproManager.addSourceFile(ast.loc.source);\n      }\n    }\n\n    let res = this.evaluateAbstract(ast, strictCode, metadata);\n    invariant(res instanceof Value || res instanceof Reference, ast.type);\n    return res;\n  }\n\n  evaluateAbstract(ast: BabelNode, strictCode: boolean, metadata?: any): Value | Reference {\n    this.realm.currentLocation = ast.loc;\n    this.realm.testTimeout();\n\n    let evaluator = this.realm.evaluators[(ast.type: string)];\n    if (evaluator) {\n      this.realm.statistics.evaluatedNodes++;\n      let result = evaluator(ast, strictCode, this, this.realm, metadata);\n      return result;\n    }\n\n    throw new TypeError(`Unsupported node type ${ast.type}`);\n  }\n\n  evaluateDeref(ast: BabelNode, strictCode: boolean, metadata?: any): Value {\n    let result = this.evaluate(ast, strictCode, metadata);\n    if (result instanceof Reference) result = Environment.GetValue(this.realm, result);\n    return result;\n  }\n}\n\n// ECMA262 6.2.3\n// A Reference is a resolved name or property binding. A Reference consists of three components, the base value,\n// the referenced name and the Boolean valued strict reference flag. The base value is either undefined, an Object,\n// a Boolean, a String, a Symbol, a Number, or an Environment Record. A base value of undefined indicates that the\n// Reference could not be resolved to a binding. The referenced name is a String or Symbol value.\nexport type BaseValue =\n  | void\n  | ObjectValue\n  | BooleanValue\n  | StringValue\n  | SymbolValue\n  | NumberValue\n  | IntegralValue\n  | EnvironmentRecord;\nexport type ReferenceName = string | SymbolValue;\n\nexport function isValidBaseValue(val: Value) {\n  return val instanceof AbstractValue || val instanceof ObjectValue || mightBecomeAnObject(val);\n}\n\nexport function mightBecomeAnObject(base: Value): boolean {\n  let type = base.getType();\n  // The top Value type might be able to become an object. We let it\n  // pass and error later if it can't.\n  return (\n    type === Value ||\n    type === PrimitiveValue ||\n    type === BooleanValue ||\n    type === StringValue ||\n    type === SymbolValue ||\n    type === NumberValue ||\n    type === IntegralValue\n  );\n}\n\nexport class Reference {\n  base: BaseValue | AbstractValue;\n  referencedName: ReferenceName | AbstractValue;\n  strict: boolean;\n  thisValue: void | Value;\n\n  constructor(\n    base: BaseValue | AbstractValue,\n    refName: ReferenceName | AbstractValue,\n    strict: boolean,\n    thisValue?: void | Value\n  ) {\n    invariant(\n      base instanceof AbstractObjectValue ||\n        base === undefined ||\n        base instanceof ObjectValue ||\n        base instanceof EnvironmentRecord ||\n        mightBecomeAnObject(base)\n    );\n    this.base = base;\n    this.referencedName = refName;\n    invariant(\n      !(refName instanceof AbstractValue) ||\n        !(refName.mightNotBeString() && refName.mightNotBeNumber() && !refName.isSimpleObject()) ||\n        refName.$Realm.isInPureScope()\n    );\n    this.strict = strict;\n    this.thisValue = thisValue;\n    invariant(thisValue === undefined || !(base instanceof EnvironmentRecord));\n  }\n}\n"],"file":"environment.js"}