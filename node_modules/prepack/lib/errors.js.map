{"version":3,"sources":["../src/errors.js"],"names":["CompilerDiagnostic","Error","constructor","message","location","errorCode","severity","sourceFilePaths","FatalError","undefined","InfeasiblePathError","InvariantError","NestedOptimizedFunctionSideEffect"],"mappings":";;;;;;;AAAA;;;;;;;;;AASA;AAIA;AACA;AACA;AACA;AAKA;AACA;AACO,MAAMA,kBAAN,SAAiCC,KAAjC,CAAuC;AAC5CC,EAAAA,WAAW,CACTC,OADS,EAETC,QAFS,EAGTC,SAHS,EAITC,QAJS,EAKTC,eALS,EAMT;AACA,UAAMJ,OAAN;AAEA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKE,QAAL,GAAgBA,QAAhB;AACA,SAAKD,SAAL,GAAiBA,SAAjB;AACA,SAAKE,eAAL,GAAuBA,eAAvB;AACD;;AAd2C,C,CAwB9C;AACA;AACA;;;;;AACO,MAAMC,UAAN,SAAyBP,KAAzB,CAA+B;AACpCC,EAAAA,WAAW,CAACC,OAAD,EAAmB;AAC5B,UAAMA,OAAO,KAAKM,SAAZ,GAAwB,0CAAxB,GAAqEN,OAA3E;AACD;;AAHmC,C,CAMtC;AACA;;;;;AACO,MAAMO,mBAAN,SAAkCT,KAAlC,CAAwC;AAC7CC,EAAAA,WAAW,GAAG;AACZ,UAAM,0BAAN;AACD;;AAH4C,C,CAM/C;;;;;AACO,MAAMS,cAAN,SAA6BV,KAA7B,CAAmC;AACxCC,EAAAA,WAAW,CAACC,OAAD,EAAkB;AAC3B,UAAMA,OAAN;AACD;;AAHuC;;;;AAQ1C;AACA;AACA;AACA;AACA;AACO,MAAMS,iCAAN,SAAgDX,KAAhD,CAAsD","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict */\n\nimport type { BabelNodeSourceLocation } from \"@babel/types\";\n\n// Information: Just an informative message with no semantic implications whatsoever.\n// Warning: Prepack will produce code that matches the behavior of the original code, but the original code might have an error.\n// RecoverableError: Prepack might produce code that deviates in behavior from the original code, if the original code is not well behaved.\n// FatalError: Prepack is unable to produce code that could possibly match the behavior of the original code.\nexport type Severity = \"FatalError\" | \"RecoverableError\" | \"Warning\" | \"Information\";\nexport type ErrorHandlerResult = \"Fail\" | \"Recover\";\nexport type ErrorCode = \"PP0001\";\n\n// This is the error format used to report errors to the caller-supplied\n// error-handler\nexport class CompilerDiagnostic extends Error {\n  constructor(\n    message: string,\n    location: ?BabelNodeSourceLocation,\n    errorCode: string,\n    severity: Severity,\n    sourceFilePaths?: { sourceMaps: Array<string>, sourceFiles: Array<{ absolute: string, relative: string }> }\n  ) {\n    super(message);\n\n    this.location = location;\n    this.severity = severity;\n    this.errorCode = errorCode;\n    this.sourceFilePaths = sourceFilePaths;\n  }\n\n  callStack: void | string;\n  location: ?BabelNodeSourceLocation;\n  severity: Severity;\n  errorCode: string;\n  // For repro bundles, we need to pass the names of all sourcefiles/sourcemaps touched by Prepack back to the CLI.\n  sourceFilePaths: void | { sourceMaps: Array<string>, sourceFiles: Array<{ absolute: string, relative: string }> };\n}\n\n// This error is thrown to exit Prepack when an ErrorHandler returns 'FatalError'\n// This should just be a class but Babel classes doesn't work with\n// built-in super classes.\nexport class FatalError extends Error {\n  constructor(message?: string) {\n    super(message === undefined ? \"A fatal error occurred while prepacking.\" : message);\n  }\n}\n\n// This error is thrown when exploring a path whose entry conditon implies that an earlier path conditon must be false.\n// Such paths are infeasible (dead) and must be elided from the evaluation.\nexport class InfeasiblePathError extends Error {\n  constructor() {\n    super(\"Infeasible path explored\");\n  }\n}\n\n// This error is thrown when a false invariant is encountered. This error should never be swallowed.\nexport class InvariantError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport type ErrorHandler = (error: CompilerDiagnostic, suppressDiagnostics: boolean) => ErrorHandlerResult;\n\n// When a side-effect occurs when evaluating a pure nested optimized function, we stop execution of that function\n// and catch the error to properly handle the according logic (either bail-out or report the error).\n// Ideally this should extend FatalError, but that will mean re-working every call-site that catches FatalError\n// and make it treat NestedOptimizedFunctionSideEffect errors differently, which isn't ideal so maybe a better\n// FatalError catching/handling process is needed throughout the codebase at some point.\nexport class NestedOptimizedFunctionSideEffect extends Error {}\n"],"file":"errors.js"}