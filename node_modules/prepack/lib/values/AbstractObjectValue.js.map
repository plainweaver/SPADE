{"version":3,"sources":["../../src/values/AbstractObjectValue.js"],"names":["AbstractObjectValue","AbstractValue","constructor","realm","types","values","hashValue","args","operationDescriptor","optionalArgs","isTop","element","getElements","ObjectValue","getTemplate","isPartialObject","reportIntrospectionError","FatalError","temporalAlias","temporalValue","hasStringOrSymbolProperties","isSimpleObject","cachedIsSimpleObject","undefined","_elementsAreSimpleObjects","result","mightBeFinalObject","shape","mightNotBeFinalObject","mightBeFalse","mightNotBeFalse","makePartial","makeSimple","option","getType","obj","$Realm","intrinsics","ObjectPrototype","intrinsicName","intrinsicNameGenerated","_templateFor","ValuesDomain","getSnapshot","options","isIntrinsic","kind","c","l","r","ls","rs","absVal","createFromConditionalOp","expressionLocation","makeFinal","throwIfNotObject","usesOrdinaryObjectInternalPrototypeMethods","$GetPrototypeOf","error","CompilerDiagnostic","currentLocation","handleError","elements","size","cv","cond","ob1","ob2","p1","p2","joinedObject","NullValue","primitiveValue","Value","isTypeCompatibleWith","PrimitiveValue","createFromBuildFunction","p","createFromBinaryOp","$IsExtensible","$GetOwnProperty","_P","P","StringValue","value","d1","d2","Join","joinDescriptors","throwIfNotConcrete","desc","d1Value","d2Value","dValue","Widen","widenValues","first","joinedDescriptor","$DefineOwnProperty","_Desc","Desc","firstExistingDesc","PropertyDescriptor","writable","enumerable","configurable","newVal","oldVal1","empty","oldVal2","newVal1","newVal2","result1","result2","sawTrue","sawFalse","d","dval","$HasProperty","hasProp","doesNotHaveProp","$Get","Receiver","generateAbstractGet","ob","type","ArrayValue","NumberValue","shapeContainer","propertyShape","propertyGetter","instantRender","enabled","react","getPropertyShape","getAbstractType","getGetter","createTemporalWithWidenedNumericProperty","propAbsVal","createTemporalFromBuildFunction","skipInvariant","isPure","isInPureScope","Leak","evaluateWithPossibleThrowCompletion","TypesDomain","topVal","evaluateWithAbstractConditional","evaluateForEffects","SimpleNormalCompletion","$GetPartial","$Set","V","$SetPartial","BooleanValue","generator","emitPropertyAssignment","$Delete","newDesc1","newDesc2","v","newDesc","$OwnPropertyKeys","getOwnPropertyKeysEvenIfPartial"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { CompilerDiagnostic, FatalError } from \"../errors.js\";\nimport type { Realm } from \"../realm.js\";\nimport type { Descriptor, PropertyKeyValue, ShapeInformationInterface } from \"../types.js\";\nimport {\n  AbstractValue,\n  type AbstractValueKind,\n  ArrayValue,\n  BooleanValue,\n  NullValue,\n  NumberValue,\n  ObjectValue,\n  PrimitiveValue,\n  StringValue,\n  Value,\n} from \"./index.js\";\nimport { TypesDomain, ValuesDomain } from \"../domains/index.js\";\nimport { IsDataDescriptor } from \"../methods/index.js\";\nimport { Leak, Join, Widen } from \"../singletons.js\";\nimport invariant from \"../invariant.js\";\nimport { createOperationDescriptor, type OperationDescriptor } from \"../utils/generator.js\";\nimport { construct_empty_effects } from \"../realm.js\";\nimport { SimpleNormalCompletion } from \"../completions.js\";\nimport { cloneDescriptor, equalDescriptors, PropertyDescriptor } from \"../descriptors.js\";\n\nexport default class AbstractObjectValue extends AbstractValue {\n  constructor(\n    realm: Realm,\n    types: TypesDomain,\n    values: ValuesDomain,\n    hashValue: number,\n    args: Array<Value>,\n    operationDescriptor?: OperationDescriptor,\n    optionalArgs?: {| kind?: AbstractValueKind, intrinsicName?: string, shape?: ShapeInformationInterface |}\n  ) {\n    super(realm, types, values, hashValue, args, operationDescriptor, optionalArgs);\n    if (!values.isTop()) {\n      for (let element of this.values.getElements()) invariant(element instanceof ObjectValue);\n    }\n  }\n\n  cachedIsSimpleObject: void | boolean;\n  functionResultType: void | typeof Value;\n\n  getTemplate(): ObjectValue {\n    for (let element of this.values.getElements()) {\n      invariant(element instanceof ObjectValue);\n      if (element.isPartialObject()) {\n        return element;\n      } else {\n        break;\n      }\n    }\n    AbstractValue.reportIntrospectionError(this);\n    throw new FatalError();\n  }\n\n  set temporalAlias(temporalValue: AbstractObjectValue) {\n    if (this.values.isTop()) {\n      AbstractValue.reportIntrospectionError(this);\n      throw new FatalError();\n    }\n    for (let element of this.values.getElements()) {\n      invariant(element instanceof ObjectValue);\n      element.temporalAlias = temporalValue;\n    }\n  }\n\n  hasStringOrSymbolProperties(): boolean {\n    if (this.values.isTop()) return false;\n    for (let element of this.values.getElements()) {\n      invariant(element instanceof ObjectValue);\n      if (element.hasStringOrSymbolProperties()) return true;\n    }\n    return false;\n  }\n\n  isPartialObject(): boolean {\n    // At the very least, the identity of the object is unknown\n    return true;\n  }\n\n  isSimpleObject(): boolean {\n    if (this.cachedIsSimpleObject === undefined) this.cachedIsSimpleObject = this._elementsAreSimpleObjects();\n    return this.cachedIsSimpleObject;\n  }\n\n  _elementsAreSimpleObjects(): boolean {\n    if (this.values.isTop()) return false;\n    let result;\n    for (let element of this.values.getElements()) {\n      invariant(element instanceof ObjectValue);\n      if (result === undefined) {\n        result = element.isSimpleObject();\n      } else if (result !== element.isSimpleObject()) {\n        AbstractValue.reportIntrospectionError(this);\n        throw new FatalError();\n      }\n    }\n    if (result === undefined) {\n      AbstractValue.reportIntrospectionError(this);\n      throw new FatalError();\n    }\n    return result;\n  }\n\n  mightBeFinalObject(): boolean {\n    // modeled objects are always read-only\n    if (this.shape) return true;\n    if (this.values.isTop()) return false;\n    for (let element of this.values.getElements()) {\n      invariant(element instanceof ObjectValue);\n      if (element.mightBeFinalObject()) return true;\n    }\n    return false;\n  }\n\n  mightNotBeFinalObject(): boolean {\n    // modeled objects are always read-only\n    if (this.shape) return false;\n    if (this.values.isTop()) return false;\n    for (let element of this.values.getElements()) {\n      invariant(element instanceof ObjectValue);\n      if (element.mightNotBeFinalObject()) return true;\n    }\n    return false;\n  }\n\n  mightBeFalse(): boolean {\n    return false;\n  }\n\n  mightNotBeFalse(): boolean {\n    return true;\n  }\n\n  makePartial(): void {\n    if (this.values.isTop()) {\n      AbstractValue.reportIntrospectionError(this);\n      throw new FatalError();\n    }\n    for (let element of this.values.getElements()) {\n      invariant(element instanceof ObjectValue);\n      element.makePartial();\n    }\n  }\n\n  makeSimple(option?: string | Value): void {\n    if (this.values.isTop() && this.getType() === ObjectValue) {\n      let obj = new ObjectValue(this.$Realm, this.$Realm.intrinsics.ObjectPrototype);\n      obj.intrinsicName = this.intrinsicName;\n      obj.intrinsicNameGenerated = true;\n      obj.makePartial();\n      obj._templateFor = this;\n      this.values = new ValuesDomain(obj);\n    }\n    if (!this.values.isTop()) {\n      for (let element of this.values.getElements()) {\n        invariant(element instanceof ObjectValue);\n        element.makeSimple(option);\n      }\n    }\n    this.cachedIsSimpleObject = true;\n  }\n\n  // Use this only if it is known that only the string properties of the snapshot will be accessed.\n  getSnapshot(options?: { removeProperties: boolean }): AbstractObjectValue {\n    if (this.isIntrinsic()) return this; // already temporal\n    if (this.values.isTop()) return this; // always the same\n    if (this.kind === \"conditional\") {\n      let [c, l, r] = this.args;\n      invariant(l instanceof ObjectValue || l instanceof AbstractObjectValue);\n      let ls = l.getSnapshot(options);\n      invariant(r instanceof ObjectValue || r instanceof AbstractObjectValue);\n      let rs = r.getSnapshot(options);\n      invariant(c instanceof AbstractValue);\n      let absVal = AbstractValue.createFromConditionalOp(this.$Realm, c, ls, rs, this.expressionLocation);\n      invariant(absVal instanceof AbstractObjectValue);\n      return absVal;\n    }\n    // If this is some other kind of abstract object we don't know how to make a copy, so just make this final\n    this.makeFinal();\n    return this;\n  }\n\n  makeFinal(): void {\n    if (this.shape) return;\n    if (this.values.isTop()) {\n      AbstractValue.reportIntrospectionError(this);\n      throw new FatalError();\n    }\n    for (let element of this.values.getElements()) {\n      invariant(element instanceof ObjectValue);\n      element.makeFinal();\n    }\n  }\n\n  throwIfNotObject(): AbstractObjectValue {\n    return this;\n  }\n\n  usesOrdinaryObjectInternalPrototypeMethods(): boolean {\n    return true;\n  }\n\n  // ECMA262 9.1.1\n  $GetPrototypeOf(): ObjectValue | AbstractObjectValue | NullValue {\n    let realm = this.$Realm;\n    if (this.values.isTop()) {\n      let error = new CompilerDiagnostic(\n        \"prototype access on unknown object\",\n        this.$Realm.currentLocation,\n        \"PP0032\",\n        \"FatalError\"\n      );\n      this.$Realm.handleError(error);\n      throw new FatalError();\n    }\n    invariant(this.kind !== \"widened\", \"widening currently always leads to top values\");\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$GetPrototypeOf();\n      }\n      invariant(false);\n    } else if (this.kind === \"conditional\") {\n      // this is the join of two concrete/abstract objects\n      // use this join condition for the join of the two property values\n      let [cond, ob1, ob2] = this.args;\n      invariant(cond instanceof AbstractValue);\n      invariant(ob1 instanceof ObjectValue || ob1 instanceof AbstractObjectValue);\n      invariant(ob2 instanceof ObjectValue || ob2 instanceof AbstractObjectValue);\n      let p1 = ob1.$GetPrototypeOf();\n      let p2 = ob2.$GetPrototypeOf();\n      let joinedObject = AbstractValue.createFromConditionalOp(realm, cond, p1, p2);\n      invariant(\n        joinedObject instanceof AbstractObjectValue ||\n          joinedObject instanceof ObjectValue ||\n          joinedObject instanceof NullValue\n      );\n      return joinedObject;\n    } else if (this.kind === \"explicit conversion to object\") {\n      let primitiveValue = this.args[0];\n      invariant(!Value.isTypeCompatibleWith(primitiveValue.getType(), PrimitiveValue));\n      let result = AbstractValue.createFromBuildFunction(\n        realm,\n        ObjectValue,\n        [primitiveValue],\n        createOperationDescriptor(\"ABSTRACT_OBJECT_GET_PROTO_OF\")\n      );\n      invariant(result instanceof AbstractObjectValue);\n      return result;\n    } else {\n      let joinedObject;\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        let p = cv.$GetPrototypeOf();\n        if (joinedObject === undefined) {\n          joinedObject = p;\n        } else {\n          let cond = AbstractValue.createFromBinaryOp(realm, \"===\", this, cv, this.expressionLocation);\n          joinedObject = AbstractValue.createFromConditionalOp(realm, cond, p, joinedObject);\n        }\n      }\n      invariant(\n        joinedObject instanceof AbstractObjectValue ||\n          joinedObject instanceof ObjectValue ||\n          joinedObject instanceof NullValue\n      );\n      return joinedObject;\n    }\n  }\n\n  // ECMA262 9.1.3\n  $IsExtensible(): boolean {\n    return false;\n  }\n\n  // ECMA262 9.1.5\n  $GetOwnProperty(_P: PropertyKeyValue): Descriptor | void {\n    let P = _P;\n    if (P instanceof StringValue) P = P.value;\n\n    if (this.values.isTop()) {\n      let error = new CompilerDiagnostic(\n        \"property access on unknown object\",\n        this.$Realm.currentLocation,\n        \"PP0031\",\n        \"FatalError\"\n      );\n      this.$Realm.handleError(error);\n      throw new FatalError();\n    }\n\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$GetOwnProperty(P);\n      }\n      invariant(false);\n    } else if (this.kind === \"conditional\") {\n      // this is the join of two concrete/abstract objects\n      // use this join condition for the join of the two property values\n      let [cond, ob1, ob2] = this.args;\n      invariant(cond instanceof AbstractValue);\n      invariant(ob1 instanceof ObjectValue || ob1 instanceof AbstractObjectValue);\n      invariant(ob2 instanceof ObjectValue || ob2 instanceof AbstractObjectValue);\n      let d1 = ob1.$GetOwnProperty(P);\n      let d2 = ob2.$GetOwnProperty(P);\n      return Join.joinDescriptors(this.$Realm, cond, d1, d2);\n    } else if (this.kind === \"widened\") {\n      // This abstract object was created by repeated assignments of freshly allocated objects to the same binding inside a loop\n      let [ob1, ob2] = this.args; // ob1: summary of iterations 1...n, ob2: summary of iteration n+1\n      invariant(ob1 instanceof ObjectValue);\n      invariant(ob2 instanceof ObjectValue);\n      let d1 = ob1.$GetOwnProperty(P);\n      let d2 = ob2.$GetOwnProperty(P);\n      if (d1 === undefined || d2 === undefined) {\n        // We do not handle the case where different loop iterations result in different kinds of propperties\n        AbstractValue.reportIntrospectionError(this, P);\n        throw new FatalError();\n      }\n      d1 = d1.throwIfNotConcrete(this.$Realm);\n      d2 = d2.throwIfNotConcrete(this.$Realm);\n      if (!equalDescriptors(d1, d2)) {\n        AbstractValue.reportIntrospectionError(this, P);\n        throw new FatalError();\n      }\n      let desc = cloneDescriptor(d1);\n      invariant(desc !== undefined);\n      if (IsDataDescriptor(this.$Realm, desc)) {\n        // Values may be different, i.e. values may be loop variant, so the widened value summarizes the entire loop\n        // equalDescriptors guarantees that both have value props and if you have a value prop is value is defined.\n        let d1Value = d1.value;\n        invariant(d1Value instanceof Value);\n        let d2Value = d2.value;\n        invariant(d2Value instanceof Value);\n        let dValue = Widen.widenValues(this.$Realm, d1Value, d2Value);\n        invariant(dValue instanceof Value);\n        desc.value = dValue;\n      } else {\n        // In this case equalDescriptors guarantees exact equality betwee d1 and d2.\n        // Inlining the accessors will eventually bring in data properties if the accessors have loop variant behavior\n      }\n      return desc;\n    } else {\n      let first = true;\n      let joinedDescriptor;\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        let desc = cv.$GetOwnProperty(P);\n        if (first) {\n          first = false;\n          joinedDescriptor = desc;\n        } else {\n          let cond = AbstractValue.createFromBinaryOp(this.$Realm, \"===\", this, cv, this.expressionLocation);\n          invariant(cond instanceof AbstractValue);\n          joinedDescriptor = Join.joinDescriptors(this.$Realm, cond, desc, joinedDescriptor);\n        }\n      }\n      return joinedDescriptor;\n    }\n  }\n\n  // ECMA262 9.1.6\n  $DefineOwnProperty(_P: PropertyKeyValue, _Desc: Descriptor): boolean {\n    let P = _P;\n    if (P instanceof StringValue) P = P.value;\n    if (this.values.isTop()) {\n      AbstractValue.reportIntrospectionError(this, P);\n      throw new FatalError();\n    }\n\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$DefineOwnProperty(P, _Desc);\n      }\n      invariant(false);\n    } else {\n      let Desc = _Desc.throwIfNotConcrete(this.$Realm);\n      if (!IsDataDescriptor(this.$Realm, Desc)) {\n        AbstractValue.reportIntrospectionError(this, P);\n        throw new FatalError();\n      }\n      // Extract the first existing descriptor to get its existing attributes as defaults.\n      let firstExistingDesc;\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        firstExistingDesc = cv.$GetOwnProperty(P);\n        if (firstExistingDesc) {\n          break;\n        }\n      }\n      if (firstExistingDesc) {\n        firstExistingDesc = firstExistingDesc.throwIfNotConcrete(this.$Realm);\n      }\n      let desc = new PropertyDescriptor({\n        value: Desc.value !== undefined ? Desc.value : this.$Realm.intrinsics.undefined,\n        writable: Desc.writable !== undefined ? Desc.writable : firstExistingDesc ? firstExistingDesc.writable : false,\n        enumerable:\n          Desc.enumerable !== undefined ? Desc.enumerable : firstExistingDesc ? firstExistingDesc.enumerable : false,\n        configurable:\n          Desc.configurable !== undefined\n            ? Desc.configurable\n            : firstExistingDesc\n              ? firstExistingDesc.configurable\n              : false,\n      });\n      let newVal = desc.value;\n      if (this.kind === \"conditional\") {\n        // this is the join of two concrete/abstract objects\n        // use this join condition for the join of the two property values\n        let [cond, ob1, ob2] = this.args;\n        invariant(cond instanceof AbstractValue);\n        invariant(ob1 instanceof ObjectValue || ob1 instanceof AbstractObjectValue);\n        invariant(ob2 instanceof ObjectValue || ob2 instanceof AbstractObjectValue);\n        let d1 = ob1.$GetOwnProperty(P);\n        let d2 = ob2.$GetOwnProperty(P);\n        if (d1 !== undefined) {\n          d1 = d1.throwIfNotConcrete(this.$Realm);\n          if (!equalDescriptors(d1, desc)) {\n            AbstractValue.reportIntrospectionError(this, P);\n            throw new FatalError();\n          }\n        }\n        if (d2 !== undefined) {\n          d2 = d2.throwIfNotConcrete(this.$Realm);\n          if (!equalDescriptors(d2, desc)) {\n            AbstractValue.reportIntrospectionError(this, P);\n            throw new FatalError();\n          }\n        }\n        let oldVal1 = d1 === undefined || d1.value === undefined ? this.$Realm.intrinsics.empty : d1.value;\n        let oldVal2 = d2 === undefined || d2.value === undefined ? this.$Realm.intrinsics.empty : d2.value;\n        invariant(oldVal1 instanceof Value);\n        invariant(oldVal2 instanceof Value);\n        let newVal1 = AbstractValue.createFromConditionalOp(this.$Realm, cond, newVal, oldVal1);\n        let newVal2 = AbstractValue.createFromConditionalOp(this.$Realm, cond, oldVal2, newVal);\n        desc.value = newVal1;\n        let result1 = ob1.$DefineOwnProperty(P, desc);\n        desc.value = newVal2;\n        let result2 = ob2.$DefineOwnProperty(P, desc);\n        if (result1 !== result2) {\n          AbstractValue.reportIntrospectionError(this, P);\n          throw new FatalError();\n        }\n        return result1;\n      } else {\n        invariant(newVal instanceof Value);\n        let sawTrue = false;\n        let sawFalse = false;\n        for (let cv of elements) {\n          invariant(cv instanceof ObjectValue);\n          let d = cv.$GetOwnProperty(P);\n          if (d !== undefined) {\n            d = d.throwIfNotConcrete(this.$Realm);\n            if (!equalDescriptors(d, desc)) {\n              AbstractValue.reportIntrospectionError(this, P);\n              throw new FatalError();\n            }\n          }\n          let dval = d === undefined || d.value === undefined ? this.$Realm.intrinsics.empty : d.value;\n          invariant(dval instanceof Value);\n          let cond = AbstractValue.createFromBinaryOp(this.$Realm, \"===\", this, cv, this.expressionLocation);\n          desc.value = AbstractValue.createFromConditionalOp(this.$Realm, cond, newVal, dval);\n          if (cv.$DefineOwnProperty(P, desc)) {\n            sawTrue = true;\n          } else sawFalse = true;\n        }\n        if (sawTrue && sawFalse) {\n          AbstractValue.reportIntrospectionError(this, P);\n          throw new FatalError();\n        }\n        return sawTrue;\n      }\n    }\n  }\n\n  // ECMA262 9.1.7\n  $HasProperty(_P: PropertyKeyValue): boolean {\n    let P = _P;\n    if (P instanceof StringValue) P = P.value;\n    if (this.values.isTop()) {\n      let error = new CompilerDiagnostic(\n        \"property access on unknown object\",\n        this.$Realm.currentLocation,\n        \"PP0031\",\n        \"FatalError\"\n      );\n      this.$Realm.handleError(error);\n      throw new FatalError();\n    }\n\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$HasProperty(P);\n      }\n      invariant(false);\n    } else {\n      let hasProp = false;\n      let doesNotHaveProp = false;\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        if (cv.$HasProperty(P)) hasProp = true;\n        else doesNotHaveProp = true;\n      }\n      if (hasProp && doesNotHaveProp) {\n        AbstractValue.reportIntrospectionError(this, P);\n        throw new FatalError();\n      }\n      return hasProp;\n    }\n  }\n\n  // ECMA262 9.1.8\n  $Get(_P: PropertyKeyValue, Receiver: Value): Value {\n    let P = _P;\n    if (P instanceof StringValue) P = P.value;\n\n    if (this.values.isTop()) {\n      let generateAbstractGet = () => {\n        let ob = Receiver;\n        if (this.kind === \"explicit conversion to object\") ob = this.args[0];\n        let type = Value;\n        if (P === \"length\" && Value.isTypeCompatibleWith(this.getType(), ArrayValue)) type = NumberValue;\n        // shape logic\n        let shapeContainer = this.kind === \"explicit conversion to object\" ? this.args[0] : this;\n        invariant(shapeContainer instanceof AbstractValue);\n        let realm = this.$Realm;\n        let shape = shapeContainer.shape;\n        let propertyShape, propertyGetter;\n        // propertyShape expects only a string value\n        if (\n          (realm.instantRender.enabled || realm.react.enabled) &&\n          shape !== undefined &&\n          (typeof P === \"string\" || P instanceof StringValue)\n        ) {\n          propertyShape = shape.getPropertyShape(P instanceof StringValue ? P.value : P);\n          if (propertyShape !== undefined) {\n            type = propertyShape.getAbstractType();\n            propertyGetter = propertyShape.getGetter();\n          }\n        }\n        // P can also be a SymbolValue\n        if (typeof P === \"string\") {\n          P = new StringValue(this.$Realm, P);\n        }\n        // Create an temporal array with widened properties\n        if (type === ArrayValue) {\n          return ArrayValue.createTemporalWithWidenedNumericProperty(\n            realm,\n            [ob, P],\n            createOperationDescriptor(\"ABSTRACT_OBJECT_GET\", { propertyGetter })\n          );\n        }\n        let propAbsVal = AbstractValue.createTemporalFromBuildFunction(\n          realm,\n          type,\n          [ob, P],\n          createOperationDescriptor(\"ABSTRACT_OBJECT_GET\", { propertyGetter }),\n          {\n            skipInvariant: true,\n            isPure: true,\n            shape: propertyShape,\n          }\n        );\n        return propAbsVal;\n      };\n      if (this.isSimpleObject() && this.isIntrinsic()) {\n        return generateAbstractGet();\n      } else if (this.$Realm.isInPureScope()) {\n        // This object might have leaked to a getter.\n        Leak.value(this.$Realm, Receiver);\n        // The getter might throw anything.\n        return this.$Realm.evaluateWithPossibleThrowCompletion(\n          generateAbstractGet,\n          TypesDomain.topVal,\n          ValuesDomain.topVal\n        );\n      }\n      let error = new CompilerDiagnostic(\n        \"property access on unknown object\",\n        this.$Realm.currentLocation,\n        \"PP0031\",\n        \"FatalError\"\n      );\n      this.$Realm.handleError(error);\n      throw new FatalError();\n    }\n\n    let realm = this.$Realm;\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$Get(P, Receiver);\n      }\n      invariant(false);\n    } else if (this.kind === \"conditional\") {\n      // this is the join of two concrete/abstract objects\n      // use this join condition for the join of the two property values\n      let [cond, ob1, ob2] = this.args;\n      invariant(cond instanceof AbstractValue);\n      invariant(ob1 instanceof ObjectValue || ob1 instanceof AbstractObjectValue);\n      invariant(ob2 instanceof ObjectValue || ob2 instanceof AbstractObjectValue);\n      // Evaluate the effect of each getter separately and join the result.\n      return realm.evaluateWithAbstractConditional(\n        cond,\n        () => realm.evaluateForEffects(() => ob1.$Get(P, Receiver), undefined, \"ConditionalGet/1\"),\n        () => realm.evaluateForEffects(() => ob2.$Get(P, Receiver), undefined, \"ConditionalGet/2\")\n      );\n    } else {\n      let result;\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        let cond = AbstractValue.createFromBinaryOp(this.$Realm, \"===\", this, cv, this.expressionLocation);\n        invariant(cond instanceof AbstractValue);\n        result = realm.evaluateWithAbstractConditional(\n          cond,\n          () => realm.evaluateForEffects(() => cv.$Get(P, Receiver), undefined, \"AbstractGet\"),\n          () => construct_empty_effects(realm, result === undefined ? undefined : new SimpleNormalCompletion(result))\n        );\n      }\n      invariant(result !== undefined);\n      return result;\n    }\n  }\n\n  $GetPartial(P: AbstractValue | PropertyKeyValue, Receiver: Value): Value {\n    if (!(P instanceof AbstractValue)) return this.$Get(P, Receiver);\n    if (this.values.isTop() || !this.isSimpleObject()) {\n      if (this.isSimpleObject() && this.isIntrinsic()) {\n        return AbstractValue.createTemporalFromBuildFunction(\n          this.$Realm,\n          Value,\n          [this, P],\n          createOperationDescriptor(\"ABSTRACT_OBJECT_GET_PARTIAL\"),\n          { skipInvariant: true, isPure: true }\n        );\n      }\n      if (this.$Realm.isInPureScope()) {\n        // If we're in a pure scope, we can leak the key and the instance,\n        // and leave the residual property access in place.\n        // We assume that if the receiver is different than this object,\n        // then we only got here because there can be no other keys with\n        // this name on earlier parts of the prototype chain.\n        // We have to leak since the property may be a getter or setter,\n        // which can run unknown code that has access to Receiver and\n        // (even in pure mode) can modify it in unknown ways.\n        Leak.value(this.$Realm, Receiver);\n        // Coercion can only have effects on anything reachable from the key.\n        Leak.value(this.$Realm, P);\n        return AbstractValue.createTemporalFromBuildFunction(\n          this.$Realm,\n          Value,\n          [Receiver, P],\n          createOperationDescriptor(\"ABSTRACT_OBJECT_GET_PARTIAL\"),\n          { skipInvariant: true, isPure: true }\n        );\n      }\n      let error = new CompilerDiagnostic(\n        \"property access on unknown object\",\n        this.$Realm.currentLocation,\n        \"PP0031\",\n        \"FatalError\"\n      );\n      this.$Realm.handleError(error);\n      throw new FatalError();\n    }\n\n    let realm = this.$Realm;\n\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$GetPartial(P, Receiver);\n      }\n      invariant(false);\n    } else if (this.kind === \"conditional\") {\n      // this is the join of two concrete/abstract objects\n      // use this join condition for the join of the two property values\n      let [cond, ob1, ob2] = this.args;\n      invariant(cond instanceof AbstractValue);\n      invariant(ob1 instanceof ObjectValue || ob1 instanceof AbstractObjectValue);\n      invariant(ob2 instanceof ObjectValue || ob2 instanceof AbstractObjectValue);\n      // Evaluate the effect of each getter separately and join the result.\n      return realm.evaluateWithAbstractConditional(\n        cond,\n        () => realm.evaluateForEffects(() => ob1.$GetPartial(P, Receiver), undefined, \"ConditionalGet/1\"),\n        () => realm.evaluateForEffects(() => ob2.$GetPartial(P, Receiver), undefined, \"ConditionalGet/2\")\n      );\n    } else {\n      let result;\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        let cond = AbstractValue.createFromBinaryOp(this.$Realm, \"===\", this, cv, this.expressionLocation);\n        invariant(cond instanceof AbstractValue);\n        result = realm.evaluateWithAbstractConditional(\n          cond,\n          () => realm.evaluateForEffects(() => cv.$GetPartial(P, Receiver), undefined, \"AbstractGet\"),\n          () => construct_empty_effects(realm, result === undefined ? undefined : new SimpleNormalCompletion(result))\n        );\n      }\n      invariant(result !== undefined);\n      return result;\n    }\n  }\n\n  // ECMA262 9.1.9\n  $Set(P: PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    if (this.values.isTop()) {\n      return this.$SetPartial(P, V, Receiver);\n    }\n\n    let realm = this.$Realm;\n    let elements = this.values.getElements();\n\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$Set(P, V, Receiver);\n      }\n      invariant(false);\n    } else if (this.kind === \"conditional\") {\n      // this is the join of two concrete/abstract objects\n      // use this join condition for the join of the two property values\n      let [cond, ob1, ob2] = this.args;\n      invariant(cond instanceof AbstractValue);\n      invariant(ob1 instanceof ObjectValue || ob1 instanceof AbstractObjectValue);\n      invariant(ob2 instanceof ObjectValue || ob2 instanceof AbstractObjectValue);\n      // Evaluate the effect of each setter separately and join the effects.\n      let result = realm.evaluateWithAbstractConditional(\n        cond,\n        () =>\n          realm.evaluateForEffects(\n            () => new BooleanValue(realm, ob1.$Set(P, V, Receiver)),\n            undefined,\n            \"ConditionalSet/1\"\n          ),\n        () =>\n          realm.evaluateForEffects(\n            () => new BooleanValue(realm, ob2.$Set(P, V, Receiver)),\n            undefined,\n            \"ConditionalSet/2\"\n          )\n      );\n      if (!(result instanceof BooleanValue)) {\n        let error = new CompilerDiagnostic(\n          \"object could have both succeeded and failed updating\",\n          realm.currentLocation,\n          \"PP0041\",\n          \"RecoverableError\"\n        );\n        if (realm.handleError(error) === \"Recover\") {\n          return true;\n        }\n        throw new FatalError();\n      }\n      return result.value;\n    } else {\n      let sawTrue = false;\n      let sawFalse = false;\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        // Evaluate the effect of each setter separately and join the effects.\n        let cond = AbstractValue.createFromBinaryOp(this.$Realm, \"===\", this, cv, this.expressionLocation);\n        invariant(cond instanceof AbstractValue);\n        realm.evaluateWithAbstractConditional(\n          cond,\n          () =>\n            realm.evaluateForEffects(\n              () => {\n                if (cv.$Set(P, V, Receiver)) {\n                  sawTrue = true;\n                } else {\n                  sawFalse = true;\n                }\n                return realm.intrinsics.empty;\n              },\n              undefined,\n              \"AbstractSet\"\n            ),\n          () => construct_empty_effects(realm)\n        );\n      }\n      if (sawTrue && sawFalse) {\n        let error = new CompilerDiagnostic(\n          \"object could have both succeeded and failed updating\",\n          realm.currentLocation,\n          \"PP0041\",\n          \"RecoverableError\"\n        );\n        if (realm.handleError(error) === \"Recover\") {\n          return true;\n        }\n      }\n      return sawTrue;\n    }\n  }\n\n  $SetPartial(_P: AbstractValue | PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    let P = _P;\n    if (!this.values.isTop() && !(P instanceof AbstractValue)) return this.$Set(P, V, Receiver);\n    if (this.values.isTop()) {\n      if (this.$Realm.isInPureScope()) {\n        // If we're in a pure scope, we can leak the key and the instance,\n        // and leave the residual property assignment in place.\n        // We assume that if the receiver is different than this object,\n        // then we only got here because there can be no other keys with\n        // this name on earlier parts of the prototype chain.\n        // We have to leak since the property may be a getter or setter,\n        // which can run unknown code that has access to Receiver and\n        // (even in pure mode) can modify it in unknown ways.\n        Leak.value(this.$Realm, Receiver);\n        // We also need to leaked the value since it might leak to a setter.\n        Leak.value(this.$Realm, V);\n        this.$Realm.evaluateWithPossibleThrowCompletion(\n          () => {\n            let generator = this.$Realm.generator;\n            invariant(generator);\n\n            if (typeof P !== \"string\" && !(P instanceof StringValue)) {\n              // Coercion can only have effects on anything reachable from the key.\n              Leak.value(this.$Realm, P);\n            }\n            generator.emitPropertyAssignment(Receiver, P, V);\n            return this.$Realm.intrinsics.undefined;\n          },\n          TypesDomain.topVal,\n          ValuesDomain.topVal\n        );\n        // The emitted assignment might throw at runtime but if it does, that\n        // is handled by evaluateWithPossibleThrowCompletion. Anything that\n        // happens after this, can assume we didn't throw and therefore,\n        // we return true here.\n        return true;\n      }\n      let error = new CompilerDiagnostic(\n        \"property access on unknown object\",\n        this.$Realm.currentLocation,\n        \"PP0031\",\n        \"FatalError\"\n      );\n      this.$Realm.handleError(error);\n      throw new FatalError();\n    }\n\n    let realm = this.$Realm;\n    let elements = this.values.getElements();\n\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$SetPartial(P, V, Receiver);\n      }\n      invariant(false);\n    } else if (this.kind === \"conditional\") {\n      // this is the join of two concrete/abstract objects\n      // use this join condition for the join of the two property values\n      let [cond, ob1, ob2] = this.args;\n      invariant(cond instanceof AbstractValue);\n      invariant(ob1 instanceof ObjectValue || ob1 instanceof AbstractObjectValue);\n      invariant(ob2 instanceof ObjectValue || ob2 instanceof AbstractObjectValue);\n      // Evaluate the effect of each setter separately and join the effects.\n      let result = realm.evaluateWithAbstractConditional(\n        cond,\n        () =>\n          realm.evaluateForEffects(\n            () => new BooleanValue(realm, ob1.$SetPartial(P, V, Receiver)),\n            undefined,\n            \"ConditionalSet/1\"\n          ),\n        () =>\n          realm.evaluateForEffects(\n            () => new BooleanValue(realm, ob2.$SetPartial(P, V, Receiver)),\n            undefined,\n            \"ConditionalSet/2\"\n          )\n      );\n      if (!(result instanceof BooleanValue)) {\n        let error = new CompilerDiagnostic(\n          \"object could have both succeeded and failed updating\",\n          realm.currentLocation,\n          \"PP0041\",\n          \"RecoverableError\"\n        );\n        if (realm.handleError(error) === \"Recover\") {\n          return true;\n        }\n        throw new FatalError();\n      }\n      return result.value;\n    } else {\n      let sawTrue = false;\n      let sawFalse = false;\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        // Evaluate the effect of each setter separately and join the effects.\n        let cond = AbstractValue.createFromBinaryOp(this.$Realm, \"===\", this, cv, this.expressionLocation);\n        invariant(cond instanceof AbstractValue);\n        realm.evaluateWithAbstractConditional(\n          cond,\n          () =>\n            realm.evaluateForEffects(\n              () => {\n                if (cv.$SetPartial(P, V, Receiver)) {\n                  sawTrue = true;\n                } else {\n                  sawFalse = true;\n                }\n                return realm.intrinsics.empty;\n              },\n              undefined,\n              \"AbstractSet\"\n            ),\n          () => construct_empty_effects(realm)\n        );\n      }\n      if (sawTrue && sawFalse) {\n        let error = new CompilerDiagnostic(\n          \"object could have both succeeded and failed updating\",\n          realm.currentLocation,\n          \"PP0041\",\n          \"RecoverableError\"\n        );\n        if (realm.handleError(error) === \"Recover\") {\n          return true;\n        }\n      }\n      return sawTrue;\n    }\n  }\n\n  // ECMA262 9.1.10\n  $Delete(_P: PropertyKeyValue): boolean {\n    let P = _P;\n    if (P instanceof StringValue) P = P.value;\n    if (this.values.isTop()) {\n      AbstractValue.reportIntrospectionError(this, P);\n      throw new FatalError();\n    }\n\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$Delete(P);\n      }\n      invariant(false);\n    } else if (this.kind === \"conditional\") {\n      // this is the join of two concrete/abstract objects\n      // use this join condition for the join of the two property values\n      let [cond, ob1, ob2] = this.args;\n      invariant(cond instanceof AbstractValue);\n      invariant(ob1 instanceof ObjectValue || ob1 instanceof AbstractObjectValue);\n      invariant(ob2 instanceof ObjectValue || ob2 instanceof AbstractObjectValue);\n      let d1 = ob1.$GetOwnProperty(P);\n      let d2 = ob2.$GetOwnProperty(P);\n      let oldVal1 =\n        d1 === undefined ? this.$Realm.intrinsics.empty : IsDataDescriptor(this.$Realm, d1) ? d1.value : undefined;\n      let oldVal2 =\n        d2 === undefined ? this.$Realm.intrinsics.empty : IsDataDescriptor(this.$Realm, d2) ? d2.value : undefined;\n      if (oldVal1 === undefined || oldVal2 === undefined) {\n        AbstractValue.reportIntrospectionError(this, P);\n        throw new FatalError();\n      }\n      invariant(oldVal1 instanceof Value);\n      invariant(oldVal2 instanceof Value);\n      let newVal1 = AbstractValue.createFromConditionalOp(this.$Realm, cond, this.$Realm.intrinsics.empty, oldVal1);\n      let newVal2 = AbstractValue.createFromConditionalOp(this.$Realm, cond, oldVal2, this.$Realm.intrinsics.empty);\n      let result1 = true;\n      let result2 = true;\n      if (d1 !== undefined) {\n        d1 = d1.throwIfNotConcrete(this.$Realm);\n        let newDesc1 = cloneDescriptor(d1);\n        invariant(newDesc1);\n        newDesc1 = newDesc1.throwIfNotConcrete(this.$Realm);\n        newDesc1.value = newVal1;\n        result1 = ob1.$DefineOwnProperty(P, newDesc1);\n      }\n      if (d2 !== undefined) {\n        d2 = d2.throwIfNotConcrete(this.$Realm);\n        let newDesc2 = cloneDescriptor(d2);\n        invariant(newDesc2);\n        newDesc2 = newDesc2.throwIfNotConcrete(this.$Realm);\n        newDesc2.value = newVal2;\n        result2 = ob2.$DefineOwnProperty(P, newDesc2);\n      }\n      if (result1 !== result2) {\n        AbstractValue.reportIntrospectionError(this, P);\n        throw new FatalError();\n      }\n      return result1;\n    } else {\n      let sawTrue = false;\n      let sawFalse = false;\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        let d = cv.$GetOwnProperty(P);\n        if (d === undefined) continue;\n        if (!IsDataDescriptor(this.$Realm, d)) {\n          AbstractValue.reportIntrospectionError(this, P);\n          throw new FatalError();\n        }\n        let cond = AbstractValue.createFromBinaryOp(this.$Realm, \"===\", this, cv, this.expressionLocation);\n        let dval = d.value;\n        invariant(dval instanceof Value);\n        let v = AbstractValue.createFromConditionalOp(this.$Realm, cond, this.$Realm.intrinsics.empty, dval);\n        let newDesc = cloneDescriptor(d);\n        invariant(newDesc);\n        newDesc.value = v;\n        if (cv.$DefineOwnProperty(P, newDesc)) sawTrue = true;\n        else sawFalse = true;\n      }\n      if (sawTrue && sawFalse) {\n        let error = new CompilerDiagnostic(\n          \"object could have both succeeded and failed updating\",\n          this.$Realm.currentLocation,\n          \"PP0041\",\n          \"RecoverableError\"\n        );\n        if (this.$Realm.handleError(error) === \"Recover\") {\n          return true;\n        }\n      }\n      return sawTrue;\n    }\n  }\n\n  $OwnPropertyKeys(getOwnPropertyKeysEvenIfPartial?: boolean = false): Array<PropertyKeyValue> {\n    if (this.values.isTop()) {\n      AbstractValue.reportIntrospectionError(this);\n      throw new FatalError();\n    }\n    let elements = this.values.getElements();\n    if (elements.size === 1) {\n      for (let cv of elements) {\n        invariant(cv instanceof ObjectValue);\n        return cv.$OwnPropertyKeys(getOwnPropertyKeysEvenIfPartial);\n      }\n      invariant(false);\n    } else {\n      AbstractValue.reportIntrospectionError(this);\n      throw new FatalError();\n    }\n  }\n}\n"],"file":"AbstractObjectValue.js"}