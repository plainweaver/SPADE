{"version":3,"sources":["../../src/values/ProxyValue.js"],"names":["FindPropertyKey","realm","keys","key","i","length","ProxyValue","ObjectValue","constructor","getTrackedPropertyNames","trackedPropertyNames","isSimpleObject","usesOrdinaryObjectInternalPrototypeMethods","$GetPrototypeOf","$Realm","handler","$ProxyHandler","NullValue","createErrorThrowCompletion","intrinsics","TypeError","target","$ProxyTarget","trap","UndefinedValue","handlerProto","extensibleTarget","targetProto","$SetPrototypeOf","V","booleanTrapResult","To","ToBooleanPartial","$IsExtensible","targetResult","$PreventExtensions","targetIsExtensible","$GetOwnProperty","P","trapResultObj","StringValue","targetDesc","undefined","Properties","ThrowIfMightHaveBeenDeleted","throwIfNotConcrete","configurable","resultDesc","ToPropertyDescriptor","CompletePropertyDescriptor","valid","IsCompatiblePropertyDescriptor","$DefineOwnProperty","Desc","descObj","FromPropertyDescriptor","settingConfigFalse","$HasProperty","$Get","Receiver","trapResult","writable","targetValue","value","Value","get","$Set","set","$Delete","$OwnPropertyKeys","trapResultArray","Create","CreateListFromArrayLike","targetKeys","SymbolValue","targetConfigurableKeys","targetNonconfigurableKeys","desc","push","uncheckedResultKeys","slice","index","splice","concat"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow */\n\nimport { Realm } from \"../realm.js\";\nimport {\n  Value,\n  AbstractObjectValue,\n  SymbolValue,\n  NullValue,\n  ObjectValue,\n  UndefinedValue,\n  StringValue,\n} from \"./index.js\";\nimport type { Descriptor, PropertyKeyValue } from \"../types.js\";\nimport invariant from \"../invariant.js\";\nimport { SameValuePartial, SamePropertyKey } from \"../methods/abstract.js\";\nimport { GetMethod } from \"../methods/get.js\";\nimport { IsExtensible, IsPropertyKey, IsDataDescriptor, IsAccessorDescriptor } from \"../methods/is.js\";\nimport { Create, Properties, To } from \"../singletons.js\";\nimport { Call } from \"../methods/call.js\";\n\nfunction FindPropertyKey(realm: Realm, keys: Array<PropertyKeyValue>, key: PropertyKeyValue): number {\n  for (let i = 0; i < keys.length; ++i) {\n    if (SamePropertyKey(realm, key, keys[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nexport default class ProxyValue extends ObjectValue {\n  $ProxyTarget: NullValue | ObjectValue;\n  $ProxyHandler: NullValue | ObjectValue;\n\n  constructor(realm: Realm) {\n    super(realm);\n  }\n\n  static trackedPropertyNames = ObjectValue.trackedPropertyNames.concat([\"$ProxyTarget\", \"$ProxyHandler\"]);\n\n  getTrackedPropertyNames(): Array<string> {\n    return ProxyValue.trackedPropertyNames;\n  }\n\n  isSimpleObject(): boolean {\n    return false;\n  }\n\n  usesOrdinaryObjectInternalPrototypeMethods(): boolean {\n    return false;\n  }\n\n  // ECMA262 9.5.1\n  $GetPrototypeOf(): NullValue | AbstractObjectValue | ObjectValue {\n    let realm = this.$Realm;\n\n    // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 2. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected an object\");\n\n    // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 5. Let trap be ? GetMethod(handler, \"getPrototypeOf\").\n    let trap = GetMethod(realm, handler, \"getPrototypeOf\");\n\n    // 6. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[GetPrototypeOf]]().\n      return target.$GetPrototypeOf();\n    }\n\n    // 7. Let handlerProto be ? Call(trap, handler, « target »).\n    let handlerProto = Call(realm, trap, handler, [target]);\n\n    // 8. If Type(handlerProto) is neither Object nor Null, throw a TypeError exception.\n    if (!(handlerProto instanceof ObjectValue) && !(handlerProto instanceof NullValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 9. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 10. If extensibleTarget is true, return handlerProto.\n    if (extensibleTarget) return handlerProto;\n\n    // 11. Let targetProto be ? target.[[GetPrototypeOf]]().\n    let targetProto = target.$GetPrototypeOf();\n\n    // 12. If SameValue(handlerProto, targetProto) is false, throw a TypeError exception.\n    if (!SameValuePartial(realm, handlerProto, targetProto)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 13. Return handlerProto.\n    return handlerProto;\n  }\n\n  // ECMA262 9.5.2\n  $SetPrototypeOf(V: ObjectValue | NullValue): boolean {\n    let realm = this.$Realm;\n\n    // 1. Assert: Either Type(V) is Object or Type(V) is Null.\n    invariant(V instanceof ObjectValue || V instanceof NullValue, \"expected object or null\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"setPrototypeOf\").\n    let trap = GetMethod(realm, handler, \"setPrototypeOf\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[SetPrototypeOf]](V).\n      return target.$SetPrototypeOf(V);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, V »)).\n    let booleanTrapResult = To.ToBooleanPartial(realm, Call(realm, trap, handler, [target, V]));\n\n    // 9. If booleanTrapResult is false, return false.\n    if (!booleanTrapResult) return false;\n\n    // 10. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 11. If extensibleTarget is true, return true.\n    if (extensibleTarget) return true;\n\n    // 12. Let targetProto be ? target.[[GetPrototypeOf]]().\n    let targetProto = target.$GetPrototypeOf();\n\n    // 13. If SameValue(V, targetProto) is false, throw a TypeError exception.\n    if (!SameValuePartial(realm, V, targetProto)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 14. Return true.\n    return true;\n  }\n\n  // ECMA262 9.5.3\n  $IsExtensible(): boolean {\n    let realm = this.$Realm;\n\n    // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 2. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n\n    // 5. Let trap be ? GetMethod(handler, \"isExtensible\").\n    let trap = GetMethod(realm, handler, \"isExtensible\");\n\n    // 6. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[IsExtensible]]().\n      invariant(target instanceof ObjectValue);\n      return target.$IsExtensible();\n    }\n\n    // 7. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target »)).\n    let booleanTrapResult = To.ToBooleanPartial(realm, Call(realm, trap, handler, [target]));\n\n    // 8. Let targetResult be ? target.[[IsExtensible]]().\n    invariant(target instanceof ObjectValue);\n    let targetResult = target.$IsExtensible();\n\n    // 9. If SameValue(booleanTrapResult, targetResult) is false, throw a TypeError exception.\n    if (booleanTrapResult !== targetResult) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 10. Return booleanTrapResult.\n    return booleanTrapResult;\n  }\n\n  // ECMA262 9.5.4\n  $PreventExtensions(): boolean {\n    let realm = this.$Realm;\n\n    // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 2. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n\n    // 5. Let trap be ? GetMethod(handler, \"preventExtensions\").\n    let trap = GetMethod(realm, handler, \"preventExtensions\");\n\n    // 6. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[PreventExtensions]]().\n      invariant(target instanceof ObjectValue);\n      return target.$PreventExtensions();\n    }\n\n    // 7. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target »)).\n    let booleanTrapResult = To.ToBooleanPartial(realm, Call(realm, trap, handler, [target]));\n\n    // 8. If booleanTrapResult is true, then\n    if (booleanTrapResult) {\n      // a. Let targetIsExtensible be ? target.[[IsExtensible]]().\n      invariant(target instanceof ObjectValue);\n      let targetIsExtensible = target.$IsExtensible();\n\n      // b. If targetIsExtensible is true, throw a TypeError exception.\n      if (targetIsExtensible) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    }\n\n    // 9. Return booleanTrapResult.\n    return booleanTrapResult;\n  }\n\n  // ECMA262 9.5.5\n  $GetOwnProperty(P: PropertyKeyValue): Descriptor | void {\n    let realm = this.$Realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"getOwnPropertyDescriptor\").\n    let trap = GetMethod(realm, handler, \"getOwnPropertyDescriptor\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[GetOwnProperty]](P).\n      return target.$GetOwnProperty(P);\n    }\n\n    // 8. Let trapResultObj be ? Call(trap, handler, « target, P »).\n    let trapResultObj = Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P]);\n\n    // 9. If Type(trapResultObj) is neither Object nor Undefined, throw a TypeError exception.\n    if (!(trapResultObj instanceof ObjectValue) && !(trapResultObj instanceof UndefinedValue)) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 11. If trapResultObj is undefined, then\n    if (trapResultObj instanceof UndefinedValue) {\n      // a. If targetDesc is undefined, return undefined.\n      if (!targetDesc) return undefined;\n      Properties.ThrowIfMightHaveBeenDeleted(targetDesc);\n      targetDesc = targetDesc.throwIfNotConcrete(realm);\n\n      // b. If targetDesc.[[Configurable]] is false, throw a TypeError exception.\n      if (!targetDesc.configurable) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // c. Let extensibleTarget be ? IsExtensible(target).\n      let extensibleTarget = IsExtensible(realm, target);\n\n      // d. Assert: Type(extensibleTarget) is Boolean.\n      invariant(typeof extensibleTarget === \"boolean\", \"expected boolean\");\n\n      // e. If extensibleTarget is false, throw a TypeError exception.\n      if (!extensibleTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // f. Return undefined.\n      return undefined;\n    }\n\n    // 12. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 13. Let resultDesc be ? ToPropertyDescriptor(trapResultObj).\n    let resultDesc = To.ToPropertyDescriptor(realm, trapResultObj);\n\n    // 14. Call CompletePropertyDescriptor(resultDesc).\n    Properties.CompletePropertyDescriptor(realm, resultDesc);\n\n    // 15. Let valid be IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc).\n    let valid = Properties.IsCompatiblePropertyDescriptor(realm, extensibleTarget, resultDesc, targetDesc);\n\n    // 16. If valid is false, throw a TypeError exception.\n    if (!valid) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 17. If resultDesc.[[Configurable]] is false, then\n    resultDesc = resultDesc.throwIfNotConcrete(realm);\n    if (!resultDesc.configurable) {\n      // a. If targetDesc is undefined or targetDesc.[[Configurable]] is true, then\n      if (!targetDesc || targetDesc.throwIfNotConcrete(realm).configurable) {\n        // i. Throw a TypeError exception.\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    }\n\n    // 18. Return resultDesc.\n    return resultDesc;\n  }\n\n  // ECMA262 9.5.6\n  $DefineOwnProperty(P: PropertyKeyValue, Desc: Descriptor): boolean {\n    let realm = this.$Realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"defineProperty\").\n    let trap = GetMethod(realm, handler, \"defineProperty\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[DefineOwnProperty]](P, Desc).\n      return target.$DefineOwnProperty(P, Desc);\n    }\n\n    // 8. Let descObj be FromPropertyDescriptor(Desc).\n    let descObj = Properties.FromPropertyDescriptor(realm, Desc);\n\n    // 9. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P, descObj »)).\n    let booleanTrapResult = To.ToBooleanPartial(\n      realm,\n      Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P, descObj])\n    );\n\n    // 10. If booleanTrapResult is false, return false.\n    if (!booleanTrapResult) return false;\n\n    // 11. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 12. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 13. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is false, then\n    let settingConfigFalse;\n    if (Desc.throwIfNotConcrete(realm).configurable === false) {\n      // a. Let settingConfigFalse be true.\n      settingConfigFalse = true;\n    } else {\n      // 14. Else let settingConfigFalse be false.\n      settingConfigFalse = false;\n    }\n\n    // 15. If targetDesc is undefined, then\n    if (!targetDesc) {\n      // a. If extensibleTarget is false, throw a TypeError exception.\n      if (!extensibleTarget) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // b. If settingConfigFalse is true, throw a TypeError exception.\n      if (settingConfigFalse) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    } else {\n      // 16. Else targetDesc is not undefined,\n      Properties.ThrowIfMightHaveBeenDeleted(targetDesc);\n\n      // a. If IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc) is false, throw a TypeError exception.\n      if (!Properties.IsCompatiblePropertyDescriptor(realm, extensibleTarget, Desc, targetDesc)) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n\n      // b. If settingConfigFalse is true and targetDesc.[[Configurable]] is true, throw a TypeError exception.\n      if (settingConfigFalse && targetDesc.throwIfNotConcrete(realm).configurable) {\n        throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n      }\n    }\n\n    // 17. Return true.\n    return true;\n  }\n\n  // ECMA262 9.5.7\n  $HasProperty(P: PropertyKeyValue): boolean {\n    let realm = this.$Realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"has\").\n    let trap = GetMethod(realm, handler, \"has\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[HasProperty]](P).\n      return target.$HasProperty(P);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P »)).\n    let booleanTrapResult = To.ToBooleanPartial(\n      realm,\n      Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P])\n    );\n\n    // 9. If booleanTrapResult is false, then\n    if (!booleanTrapResult) {\n      // a. Let targetDesc be ? target.[[GetOwnProperty]](P).\n      let targetDesc = target.$GetOwnProperty(P);\n\n      // b. If targetDesc is not undefined, then\n      if (targetDesc) {\n        Properties.ThrowIfMightHaveBeenDeleted(targetDesc);\n        targetDesc = targetDesc.throwIfNotConcrete(realm);\n\n        // i. If targetDesc.[[Configurable]] is false, throw a TypeError exception.\n        if (!targetDesc.configurable) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n\n        // ii. Let extensibleTarget be ? IsExtensible(target).\n        let extensibleTarget = IsExtensible(realm, target);\n\n        // iii. If extensibleTarget is false, throw a TypeError exception.\n        if (!extensibleTarget) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n    }\n\n    // 10. Return booleanTrapResult.\n    return booleanTrapResult;\n  }\n\n  // ECMA262 9.5.8\n  $Get(P: PropertyKeyValue, Receiver: Value): Value {\n    let realm = this.$Realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 6. Let trap be ? GetMethod(handler, \"get\").\n    let trap = GetMethod(realm, handler, \"get\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[Get]](P, Receiver).\n      return target.$Get(P, Receiver);\n    }\n\n    // 8. Let trapResult be ? Call(trap, handler, « target, P, Receiver »).\n    let trapResult = Call(realm, trap, handler, [\n      target,\n      typeof P === \"string\" ? new StringValue(realm, P) : P,\n      Receiver,\n    ]);\n\n    // 9. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 10. If targetDesc is not undefined, then\n    if (targetDesc) {\n      Properties.ThrowIfMightHaveBeenDeleted(targetDesc);\n\n      // a. If IsDataDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Writable]] is false, then\n      if (IsDataDescriptor(realm, targetDesc) && targetDesc.configurable === false && targetDesc.writable === false) {\n        // i. If SameValue(trapResult, targetDesc.[[Value]]) is false, throw a TypeError exception.\n        let targetValue = targetDesc.value || realm.intrinsics.undefined;\n        invariant(targetValue instanceof Value);\n        if (!SameValuePartial(realm, trapResult, targetValue)) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n\n      // b. If IsAccessorDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Get]] is undefined, then\n      if (\n        IsAccessorDescriptor(realm, targetDesc) &&\n        targetDesc.configurable === false &&\n        (!targetDesc.get || targetDesc.get instanceof UndefinedValue)\n      ) {\n        // i. If trapResult is not undefined, throw a TypeError exception.\n        if (!(trapResult instanceof UndefinedValue)) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n    }\n\n    // 11. Return trapResult.\n    return trapResult;\n  }\n\n  // ECMA262 9.5.9\n  $Set(P: PropertyKeyValue, V: Value, Receiver: Value): boolean {\n    let realm = this.$Realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n\n    // 6. Let trap be ? GetMethod(handler, \"set\").\n    let trap = GetMethod(realm, handler, \"set\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[Set]](P, V, Receiver).\n      invariant(target instanceof ObjectValue);\n      return target.$Set(P, V, Receiver);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P, V, Receiver »)).\n    let booleanTrapResult = To.ToBooleanPartial(\n      realm,\n      Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P, V, Receiver])\n    );\n\n    // 9. If booleanTrapResult is false, return false.\n    if (!booleanTrapResult) return false;\n\n    // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    invariant(target instanceof ObjectValue);\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 11. If targetDesc is not undefined, then\n    if (targetDesc) {\n      Properties.ThrowIfMightHaveBeenDeleted(targetDesc);\n\n      // a. If IsDataDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false and targetDesc.[[Writable]] is false, then\n      if (IsDataDescriptor(realm, targetDesc) && !targetDesc.configurable && !targetDesc.writable) {\n        // i. If SameValue(V, targetDesc.[[Value]]) is false, throw a TypeError exception.\n        let targetValue = targetDesc.value || realm.intrinsics.undefined;\n        invariant(targetValue instanceof Value);\n        if (!SameValuePartial(realm, V, targetValue)) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n\n      // b. If IsAccessorDescriptor(targetDesc) is true and targetDesc.[[Configurable]] is false, then\n      if (IsAccessorDescriptor(realm, targetDesc) && !targetDesc.configurable) {\n        // i. If targetDesc.[[Set]] is undefined, throw a TypeError exception.\n        if (!targetDesc.set || targetDesc.set instanceof UndefinedValue) {\n          throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n        }\n      }\n    }\n\n    // 12. Return true.\n    return true;\n  }\n\n  // ECMA262 9.5.10\n  $Delete(P: PropertyKeyValue): boolean {\n    let realm = this.$Realm;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(realm, P), \"expected property key\");\n\n    // 2. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 3. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 5. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n\n    // 6. Let trap be ? GetMethod(handler, \"deleteProperty\").\n    let trap = GetMethod(realm, handler, \"deleteProperty\");\n\n    // 7. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[Delete]](P).\n      invariant(target instanceof ObjectValue);\n      return target.$Delete(P);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P »)).\n    let booleanTrapResult = To.ToBooleanPartial(\n      realm,\n      Call(realm, trap, handler, [target, typeof P === \"string\" ? new StringValue(realm, P) : P])\n    );\n\n    // 9. If booleanTrapResult is false, return false.\n    if (!booleanTrapResult) return false;\n\n    // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    invariant(target instanceof ObjectValue);\n    let targetDesc = target.$GetOwnProperty(P);\n\n    // 11. If targetDesc is undefined, return true.\n    if (!targetDesc) return true;\n    Properties.ThrowIfMightHaveBeenDeleted(targetDesc);\n    targetDesc = targetDesc.throwIfNotConcrete(realm);\n\n    // 12. If targetDesc.[[Configurable]] is false, throw a TypeError exception.\n    if (!targetDesc.configurable) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 13. Return true.\n    return true;\n  }\n\n  // ECMA262 9.5.11\n  $OwnPropertyKeys(): Array<PropertyKeyValue> {\n    let realm = this.$Realm;\n\n    // 1. Let handler be the value of the [[ProxyHandler]] internal slot of O.\n    let handler = this.$ProxyHandler;\n\n    // 2. If handler is null, throw a TypeError exception.\n    if (handler instanceof NullValue) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    invariant(handler instanceof ObjectValue, \"expected object\");\n\n    // 4. Let target be the value of the [[ProxyTarget]] internal slot of O.\n    let target = this.$ProxyTarget;\n    invariant(target instanceof ObjectValue);\n\n    // 5. Let trap be ? GetMethod(handler, \"ownKeys\").\n    let trap = GetMethod(realm, handler, \"ownKeys\");\n\n    // 6. If trap is undefined, then\n    if (trap instanceof UndefinedValue) {\n      // a. Return ? target.[[OwnPropertyKeys]]().\n      return target.$OwnPropertyKeys();\n    }\n\n    // 7. Let trapResultArray be ? Call(trap, handler, « target »).\n    let trapResultArray = Call(realm, trap, handler, [target]);\n\n    // 8. Let trapResult be ? CreateListFromArrayLike(trapResultArray, « String, Symbol »).\n    let trapResult: Array<PropertyKeyValue> = ((Create.CreateListFromArrayLike(realm, trapResultArray, [\n      \"String\",\n      \"Symbol\",\n    ]): any): Array<PropertyKeyValue>);\n\n    // 9. Let extensibleTarget be ? IsExtensible(target).\n    let extensibleTarget = IsExtensible(realm, target);\n\n    // 10. Let targetKeys be ? target.[[OwnPropertyKeys]]().\n    let targetKeys = target.$OwnPropertyKeys();\n\n    // 11. Assert: targetKeys is a List containing only String and Symbol values.\n    for (let key of targetKeys) {\n      invariant(key instanceof SymbolValue || key instanceof StringValue, \"expected string or symbol\");\n    }\n\n    // 12. Let targetConfigurableKeys be a new empty List.\n    let targetConfigurableKeys = [];\n\n    // 13. Let targetNonconfigurableKeys be a new empty List.\n    let targetNonconfigurableKeys = [];\n\n    // 14. Repeat, for each element key of targetKeys,\n    for (let key of targetKeys) {\n      // a. Let desc be ? target.[[GetOwnProperty]](key).\n      let desc = target.$GetOwnProperty(key);\n      if (desc) Properties.ThrowIfMightHaveBeenDeleted(desc);\n\n      // b. If desc is not undefined and desc.[[Configurable]] is false, then\n      if (desc && desc.throwIfNotConcrete(realm).configurable === false) {\n        // i. Append key as an element of targetNonconfigurableKeys.\n        targetNonconfigurableKeys.push(key);\n      } else {\n        // c. Else,\n        // i. Append key as an element of targetConfigurableKeys.\n        targetConfigurableKeys.push(key);\n      }\n    }\n\n    // 15. If extensibleTarget is true and targetNonconfigurableKeys is empty, then\n    if (extensibleTarget && !targetNonconfigurableKeys.length) {\n      // a. Return trapResult.\n      return trapResult;\n    }\n\n    // 16. Let uncheckedResultKeys be a new List which is a copy of trapResult.\n    let uncheckedResultKeys = trapResult.slice();\n\n    // 17. Repeat, for each key that is an element of targetNonconfigurableKeys,\n    for (let key of targetNonconfigurableKeys) {\n      // a. If key is not an element of uncheckedResultKeys, throw a TypeError exception.\n      let index = FindPropertyKey(realm, uncheckedResultKeys, key);\n      if (index < 0) {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"key is not an element of uncheckedResultKeys\"\n        );\n      }\n\n      // b. Remove key from uncheckedResultKeys.\n      uncheckedResultKeys.splice(index, 1);\n    }\n\n    // 18. If extensibleTarget is true, return trapResult.\n    if (extensibleTarget) return trapResult;\n\n    // 19. Repeat, for each key that is an element of targetConfigurableKeys,\n    for (let key of targetConfigurableKeys) {\n      // a. If key is not an element of uncheckedResultKeys, throw a TypeError exception.\n      let index = FindPropertyKey(realm, uncheckedResultKeys, key);\n      if (index < 0) {\n        throw realm.createErrorThrowCompletion(\n          realm.intrinsics.TypeError,\n          \"key is not an element of uncheckedResultKeys\"\n        );\n      }\n\n      // b. Remove key from uncheckedResultKeys.\n      uncheckedResultKeys.splice(index, 1);\n    }\n\n    // 20. If uncheckedResultKeys is not empty, throw a TypeError exception.\n    if (uncheckedResultKeys.length) {\n      throw realm.createErrorThrowCompletion(realm.intrinsics.TypeError);\n    }\n\n    // 21. Return trapResult.\n    return trapResult;\n  }\n}\n"],"file":"ProxyValue.js"}