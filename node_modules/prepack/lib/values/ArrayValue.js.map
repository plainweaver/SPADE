{"version":3,"sources":["../../src/values/ArrayValue.js"],"names":["evaluatePossibleNestedOptimizedFunctionsAndStoreEffects","realm","abstractArrayValue","possibleNestedOptimizedFunctions","func","thisValue","funcToModel","BoundFunctionValue","$BoundTargetFunction","$BoundThis","ECMAScriptSourceFunctionValue","isCalledInMultipleContexts","previouslyComputedEffects","collectedNestedOptimizedFunctionEffects","get","undefined","instantRender","enabled","instantRenderBailout","expressionLocation","Leak","value","funcCall","Utils","createModelledFunctionCall","pureFuncCall","evaluatePure","NestedOptimizedFunctionSideEffect","effects","evaluateForEffects","e","nestedOptimizedFunctionEffects","Map","set","modelUnknownPropertyOfSpecializedArray","args","array","sentinelProperty","key","descriptor","PropertyDescriptor","writable","enumerable","configurable","object","mayAliasedObjects","Set","arrayNestedOptimizedFunctionsEnabled","length","kind","result","SimpleNormalCompletion","reachableObjects","Materialize","computeReachableObjects","reachableObject","createdObjects","has","add","mappedArray","ArrayValue","isIntrinsicAndHasWidenedNumericProperty","unknownProperty","unknownPropertyValue","AbstractValue","aliasSet","aliasedObject","ObjectValue","createFromType","Value","createArrayWithWidenedNumericProperty","intrinsicName","react","optimizeNestedFunctions","constructor","intrinsics","ArrayPrototype","getKind","isSimpleObject","$TypedArrayName","$DefineOwnProperty","P","Desc","A","$Realm","StringValue","Properties","ArraySetLength","succeeded","OrdinaryDefineOwnProperty","oldLenDesc","OrdinaryGetOwnProperty","ThrowIfMightHaveBeenDeleted","throwIfNotConcrete","oldLen","NumberValue","index","To","ToUint32","createTemporalWithWidenedNumericProperty","operationDescriptor","generator","deriveConcreteObject","isPure","obj","isScopedTemplate","isIntrinsicDerivedObject","prop","desc"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2017-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/* @flow strict-local */\n\nimport type { Effects, Realm } from \"../realm.js\";\nimport type { PropertyBinding, PropertyKeyValue, Descriptor, ObjectKind } from \"../types.js\";\nimport {\n  AbstractValue,\n  BoundFunctionValue,\n  ECMAScriptSourceFunctionValue,\n  NumberValue,\n  ObjectValue,\n  StringValue,\n  Value,\n} from \"./index.js\";\nimport { IsAccessorDescriptor, IsPropertyKey, IsArrayIndex } from \"../methods/is.js\";\nimport { Leak, Materialize, Properties, To, Utils } from \"../singletons.js\";\nimport { type OperationDescriptor } from \"../utils/generator.js\";\nimport invariant from \"../invariant.js\";\nimport { NestedOptimizedFunctionSideEffect } from \"../errors.js\";\nimport { PropertyDescriptor } from \"../descriptors.js\";\nimport { SimpleNormalCompletion } from \"../completions.js\";\n\ntype ArrayNestedOptimizedFunctionType = \"map\" | \"filter\";\ntype PossibleNestedOptimizedFunctions = [\n  {\n    func: BoundFunctionValue | ECMAScriptSourceFunctionValue,\n    thisValue: Value,\n    kind: ArrayNestedOptimizedFunctionType,\n  },\n];\n\nfunction evaluatePossibleNestedOptimizedFunctionsAndStoreEffects(\n  realm: Realm,\n  abstractArrayValue: ArrayValue,\n  possibleNestedOptimizedFunctions: PossibleNestedOptimizedFunctions\n): void {\n  for (let { func, thisValue } of possibleNestedOptimizedFunctions) {\n    let funcToModel = func;\n    if (func instanceof BoundFunctionValue) {\n      funcToModel = func.$BoundTargetFunction;\n      thisValue = func.$BoundThis;\n    }\n    invariant(funcToModel instanceof ECMAScriptSourceFunctionValue);\n\n    if (funcToModel.isCalledInMultipleContexts) return;\n\n    let previouslyComputedEffects = realm.collectedNestedOptimizedFunctionEffects.get(funcToModel);\n    if (previouslyComputedEffects !== undefined) {\n      if (realm.instantRender.enabled) {\n        realm.instantRenderBailout(\"Array operators may only be optimized once\", funcToModel.expressionLocation);\n      } else {\n        // We currently do not support context-sensitive specialization,\n        // where the calls we specialize depend on the specialization context.\n        // TODO: #2454\n        // TODO: Implement context-sensitive specialization instead of giving up\n        funcToModel.isCalledInMultipleContexts = true;\n        Leak.value(realm, func);\n        return;\n      }\n    }\n\n    let funcCall = Utils.createModelledFunctionCall(realm, funcToModel, undefined, thisValue);\n    // We take the modelled function and wrap it in a pure evaluation so we can check for\n    // side-effects that occur when evaluating the function. If there are side-effects, then\n    // we don't try and optimize the nested function.\n    let pureFuncCall = () =>\n      realm.evaluatePure(funcCall, /*bubbles*/ false, () => {\n        throw new NestedOptimizedFunctionSideEffect();\n      });\n    let effects;\n    try {\n      effects = realm.evaluateForEffects(pureFuncCall, null, \"temporalArray nestedOptimizedFunction\");\n    } catch (e) {\n      // If the nested optimized function had side-effects, we need to fallback to\n      // the default behaviour and leaked the nested functions so any bindings\n      // within the function properly leak and materialize.\n      if (e instanceof NestedOptimizedFunctionSideEffect) {\n        if (realm.instantRender.enabled) {\n          realm.instantRenderBailout(\n            \"InstantRender does not support impure array operators\",\n            funcCall.expressionLocation\n          );\n        }\n        Leak.value(realm, func);\n        return;\n      }\n      throw e;\n    }\n\n    // Check if effects were pure then add them\n    if (abstractArrayValue.nestedOptimizedFunctionEffects === undefined) {\n      abstractArrayValue.nestedOptimizedFunctionEffects = new Map();\n    }\n    abstractArrayValue.nestedOptimizedFunctionEffects.set(funcToModel, effects);\n    realm.collectedNestedOptimizedFunctionEffects.set(funcToModel, effects);\n  }\n}\n\n/*\n  We track aliases explicitly, because we currently do not have the primitives to model objects created\ninside of the loop. TODO: Revisit when #2543 and subsequent modeling work\nlands. At that point, instead of of a mayAliasSet, we can return a widened\nabstract value.\n*/\nfunction modelUnknownPropertyOfSpecializedArray(\n  realm: Realm,\n  args: Array<Value>,\n  array: ArrayValue,\n  possibleNestedOptimizedFunctions: ?PossibleNestedOptimizedFunctions\n): PropertyBinding {\n  let sentinelProperty = {\n    key: undefined,\n    descriptor: new PropertyDescriptor({\n      writable: true,\n      enumerable: true,\n      configurable: true,\n    }),\n    object: array,\n  };\n\n  let mayAliasedObjects: Set<ObjectValue> = new Set();\n\n  if (realm.arrayNestedOptimizedFunctionsEnabled && possibleNestedOptimizedFunctions) {\n    invariant(possibleNestedOptimizedFunctions.length > 0);\n    if (possibleNestedOptimizedFunctions[0].kind === \"map\") {\n      for (let { func } of possibleNestedOptimizedFunctions) {\n        let funcToModel;\n        if (func instanceof BoundFunctionValue) {\n          funcToModel = func.$BoundTargetFunction;\n        } else {\n          funcToModel = func;\n        }\n        invariant(funcToModel instanceof ECMAScriptSourceFunctionValue);\n        if (array.nestedOptimizedFunctionEffects !== undefined) {\n          let effects = array.nestedOptimizedFunctionEffects.get(funcToModel);\n          if (effects !== undefined) {\n            invariant(effects.result instanceof SimpleNormalCompletion);\n            let reachableObjects = Materialize.computeReachableObjects(realm, effects.result.value);\n            for (let reachableObject of reachableObjects) {\n              if (!effects.createdObjects.has(reachableObject)) mayAliasedObjects.add(reachableObject);\n            }\n          }\n        }\n      }\n    }\n    // For filter, we just collect the may alias set of the mapped array\n    if (args.length > 0) {\n      let mappedArray = args[0];\n      if (ArrayValue.isIntrinsicAndHasWidenedNumericProperty(mappedArray)) {\n        invariant(mappedArray instanceof ArrayValue);\n        invariant(mappedArray.unknownProperty !== undefined);\n        invariant(mappedArray.unknownProperty.descriptor instanceof PropertyDescriptor);\n\n        let unknownPropertyValue = mappedArray.unknownProperty.descriptor.value;\n        invariant(unknownPropertyValue instanceof AbstractValue);\n\n        let aliasSet = unknownPropertyValue.args[0];\n        invariant(aliasSet instanceof AbstractValue && aliasSet.kind === \"mayAliasSet\");\n        for (let aliasedObject of aliasSet.args) {\n          invariant(aliasedObject instanceof ObjectValue);\n          mayAliasedObjects.add(aliasedObject);\n        }\n      }\n    }\n  }\n\n  let aliasSet = AbstractValue.createFromType(realm, Value, \"mayAliasSet\", [...mayAliasedObjects]);\n  sentinelProperty.descriptor.value = AbstractValue.createFromType(realm, Value, \"widened numeric property\", [\n    aliasSet,\n  ]);\n\n  return sentinelProperty;\n}\n\nfunction createArrayWithWidenedNumericProperty(\n  realm: Realm,\n  args: Array<Value>,\n  intrinsicName: string,\n  possibleNestedOptimizedFunctions?: PossibleNestedOptimizedFunctions\n): ArrayValue {\n  let abstractArrayValue = new ArrayValue(realm, intrinsicName);\n\n  if (possibleNestedOptimizedFunctions !== undefined && possibleNestedOptimizedFunctions.length > 0) {\n    if (realm.arrayNestedOptimizedFunctionsEnabled && (!realm.react.enabled || realm.react.optimizeNestedFunctions)) {\n      evaluatePossibleNestedOptimizedFunctionsAndStoreEffects(\n        realm,\n        abstractArrayValue,\n        possibleNestedOptimizedFunctions\n      );\n    } else {\n      // If nested optimized functions are disabled, we need to fallback to\n      // the default behaviour and leaked the nested functions so any bindings\n      // within the function properly leak and materialize.\n      for (let { func } of possibleNestedOptimizedFunctions) {\n        Leak.value(realm, func);\n      }\n    }\n  }\n  // Add unknownProperty so we manually handle this object property access\n  abstractArrayValue.unknownProperty = modelUnknownPropertyOfSpecializedArray(\n    realm,\n    args,\n    abstractArrayValue,\n    possibleNestedOptimizedFunctions\n  );\n  return abstractArrayValue;\n}\n\nexport default class ArrayValue extends ObjectValue {\n  constructor(realm: Realm, intrinsicName?: string) {\n    super(realm, realm.intrinsics.ArrayPrototype, intrinsicName);\n  }\n  nestedOptimizedFunctionEffects: void | Map<ECMAScriptSourceFunctionValue, Effects>;\n\n  getKind(): ObjectKind {\n    return \"Array\";\n  }\n\n  isSimpleObject(): boolean {\n    return this.$TypedArrayName === undefined;\n  }\n\n  // ECMA262 9.4.2.1\n  $DefineOwnProperty(P: PropertyKeyValue, Desc: Descriptor): boolean {\n    let A = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    invariant(IsPropertyKey(this.$Realm, P), \"expected a property key\");\n\n    // 2. If P is \"length\", then\n    if (P === \"length\" || (P instanceof StringValue && P.value === \"length\")) {\n      // a. Return ? ArraySetLength(A, Desc).\n      return Properties.ArraySetLength(this.$Realm, A, Desc);\n    } else if (IsArrayIndex(this.$Realm, P)) {\n      if (ArrayValue.isIntrinsicAndHasWidenedNumericProperty(this)) {\n        // The length of an array with widenend numeric properties is always abstract\n        let succeeded = Properties.OrdinaryDefineOwnProperty(this.$Realm, A, P, Desc);\n        if (succeeded === false) return false;\n        return true;\n      }\n      // 3. Else if P is an array index, then\n\n      // a. Let oldLenDesc be OrdinaryGetOwnProperty(A, \"length\").\n      let oldLenDesc = Properties.OrdinaryGetOwnProperty(this.$Realm, A, \"length\");\n\n      // b. Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are\n      //    created with a length data property that cannot be deleted or reconfigured.\n      invariant(\n        oldLenDesc !== undefined && !IsAccessorDescriptor(this.$Realm, oldLenDesc),\n        \"cannot be undefined or an accessor descriptor\"\n      );\n      Properties.ThrowIfMightHaveBeenDeleted(oldLenDesc);\n      oldLenDesc = oldLenDesc.throwIfNotConcrete(this.$Realm);\n\n      // c. Let oldLen be oldLenDesc.[[Value]].\n      let oldLen = oldLenDesc.value;\n      invariant(oldLen instanceof Value);\n      oldLen = oldLen.throwIfNotConcrete();\n      invariant(oldLen instanceof NumberValue, \"expected number value\");\n      oldLen = oldLen.value;\n\n      // d. Let index be ! ToUint32(P).\n      let index = To.ToUint32(this.$Realm, typeof P === \"string\" ? new StringValue(this.$Realm, P) : P);\n\n      // e. If index ≥ oldLen and oldLenDesc.[[Writable]] is false, return false.\n      if (index >= oldLen && oldLenDesc.writable === false) return false;\n\n      // f. Let succeeded be ! OrdinaryDefineOwnProperty(A, P, Desc).\n      let succeeded = Properties.OrdinaryDefineOwnProperty(this.$Realm, A, P, Desc);\n\n      // g. If succeeded is false, return false.\n      if (succeeded === false) return false;\n\n      // h. If index ≥ oldLen, then\n      if (index >= oldLen) {\n        // i. Set oldLenDesc.[[Value]] to index + 1.\n        oldLenDesc.value = new NumberValue(this.$Realm, index + 1);\n\n        // ii. Let succeeded be OrdinaryDefineOwnProperty(A, \"length\", oldLenDesc).\n        succeeded = Properties.OrdinaryDefineOwnProperty(this.$Realm, A, \"length\", oldLenDesc);\n\n        // iii. Assert: succeeded is true.\n        invariant(succeeded, \"expected length definition to succeed\");\n      }\n\n      // i. Return true.\n      return true;\n    }\n\n    // 1. Return OrdinaryDefineOwnProperty(A, P, Desc).\n    return Properties.OrdinaryDefineOwnProperty(this.$Realm, A, P, Desc);\n  }\n\n  static createTemporalWithWidenedNumericProperty(\n    realm: Realm,\n    args: Array<Value>,\n    operationDescriptor: OperationDescriptor,\n    possibleNestedOptimizedFunctions?: PossibleNestedOptimizedFunctions\n  ): ArrayValue {\n    invariant(realm.generator !== undefined);\n\n    let value = realm.generator.deriveConcreteObject(\n      intrinsicName =>\n        createArrayWithWidenedNumericProperty(realm, args, intrinsicName, possibleNestedOptimizedFunctions),\n      args,\n      operationDescriptor,\n      { isPure: true }\n    );\n    invariant(value instanceof ArrayValue);\n    return value;\n  }\n\n  static isIntrinsicAndHasWidenedNumericProperty(obj: Value): boolean {\n    if (obj instanceof ArrayValue && obj.intrinsicName !== undefined && obj.isScopedTemplate !== undefined) {\n      invariant(ObjectValue.isIntrinsicDerivedObject(obj));\n      const prop = obj.unknownProperty;\n      if (prop !== undefined && prop.descriptor !== undefined) {\n        const desc = prop.descriptor.throwIfNotConcrete(obj.$Realm);\n        return desc.value instanceof AbstractValue && desc.value.kind === \"widened numeric property\";\n      }\n    }\n    return false;\n  }\n}\n"],"file":"ArrayValue.js"}