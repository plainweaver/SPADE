define('@glimmer/syntax', ['exports', '@glimmer/util', 'simple-html-tokenizer', 'handlebars'], function (exports, util, simpleHtmlTokenizer, handlebars) { 'use strict';

    function buildMustache(path, params, hash, raw, loc, strip) {
        if (typeof path === 'string') {
            path = buildHead(path);
        }
        return {
            type: 'MustacheStatement',
            path: path,
            params: params || [],
            hash: hash || buildHash([]),
            escaped: !raw,
            loc: buildLoc(loc || null),
            strip: strip || { open: false, close: false }
        };
    }
    function buildBlock(path, params, hash, _defaultBlock, _elseBlock, loc, openStrip, inverseStrip, closeStrip) {
        var defaultBlock = void 0;
        var elseBlock = void 0;
        if (_defaultBlock.type === 'Template') {
            defaultBlock = util.assign({}, _defaultBlock, { type: 'Block' });
        } else {
            defaultBlock = _defaultBlock;
        }
        if (_elseBlock !== undefined && _elseBlock !== null && _elseBlock.type === 'Template') {
            elseBlock = util.assign({}, _elseBlock, { type: 'Block' });
        } else {
            elseBlock = _elseBlock;
        }
        return {
            type: 'BlockStatement',
            path: buildHead(path),
            params: params || [],
            hash: hash || buildHash([]),
            program: defaultBlock || null,
            inverse: elseBlock || null,
            loc: buildLoc(loc || null),
            openStrip: openStrip || { open: false, close: false },
            inverseStrip: inverseStrip || { open: false, close: false },
            closeStrip: closeStrip || { open: false, close: false }
        };
    }
    function buildElementModifier(path, params, hash, loc) {
        return {
            type: 'ElementModifierStatement',
            path: buildHead(path),
            params: params || [],
            hash: hash || buildHash([]),
            loc: buildLoc(loc || null)
        };
    }
    function buildPartial(name, params, hash, indent, loc) {
        return {
            type: 'PartialStatement',
            name: name,
            params: params || [],
            hash: hash || buildHash([]),
            indent: indent || '',
            strip: { open: false, close: false },
            loc: buildLoc(loc || null)
        };
    }
    function buildComment(value, loc) {
        return {
            type: 'CommentStatement',
            value: value,
            loc: buildLoc(loc || null)
        };
    }
    function buildMustacheComment(value, loc) {
        return {
            type: 'MustacheCommentStatement',
            value: value,
            loc: buildLoc(loc || null)
        };
    }
    function buildConcat(parts, loc) {
        return {
            type: 'ConcatStatement',
            parts: parts || [],
            loc: buildLoc(loc || null)
        };
    }
    function isLocSexp(value) {
        return Array.isArray(value) && value.length === 2 && value[0] === 'loc';
    }
    function isParamsSexp(value) {
        return Array.isArray(value) && !isLocSexp(value);
    }
    function isHashSexp(value) {
        if (typeof value === 'object' && value && !Array.isArray(value)) {
            return true;
        } else {
            return false;
        }
    }
    function normalizeModifier(sexp) {
        if (typeof sexp === 'string') {
            return buildElementModifier(sexp);
        }
        var path = normalizeHead(sexp[0]);
        var params = void 0;
        var hash = void 0;
        var loc = null;
        var parts = sexp.slice(1);
        var next = parts.shift();
        _process: {
            if (isParamsSexp(next)) {
                params = next;
            } else {
                break _process;
            }
            next = parts.shift();
            if (isHashSexp(next)) {
                hash = normalizeHash(next);
            } else {
                break _process;
            }
        }
        if (isLocSexp(next)) {
            loc = next[1];
        }
        return {
            type: 'ElementModifierStatement',
            path: path,
            params: params || [],
            hash: hash || buildHash([]),
            loc: buildLoc(loc || null)
        };
    }
    function normalizeAttr(sexp) {
        var name = sexp[0];
        var value = void 0;
        if (typeof sexp[1] === 'string') {
            value = buildText(sexp[1]);
        } else {
            value = sexp[1];
        }
        var loc = sexp[2] ? sexp[2][1] : undefined;
        return buildAttr(name, value, loc);
    }
    function normalizeHash(hash, loc) {
        var pairs = [];
        Object.keys(hash).forEach(function (key) {
            pairs.push(buildPair(key, hash[key]));
        });
        return buildHash(pairs, loc);
    }
    function normalizeHead(path) {
        if (typeof path === 'string') {
            return buildHead(path);
        } else {
            return buildHead(path[1], path[2] && path[2][1]);
        }
    }
    function normalizeElementOptions() {
        var out = {};

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        for (var _iterator = args, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var arg = _ref;

            switch (arg[0]) {
                case 'attrs':
                    {
                        var rest = arg.slice(1);

                        out.attrs = rest.map(normalizeAttr);
                        break;
                    }
                case 'modifiers':
                    {
                        var _rest = arg.slice(1);

                        out.modifiers = _rest.map(normalizeModifier);
                        break;
                    }
                case 'body':
                    {
                        var _rest2 = arg.slice(1);

                        out.children = _rest2;
                        break;
                    }
                case 'comments':
                    {
                        var _rest3 = arg.slice(1);

                        out.comments = _rest3;
                        break;
                    }
                case 'as':
                    {
                        var _rest4 = arg.slice(1);

                        out.blockParams = _rest4;
                        break;
                    }
                case 'loc':
                    {
                        var _rest5 = arg[1];

                        out.loc = _rest5;
                        break;
                    }
            }
        }
        return out;
    }
    function buildElement(tag, options) {
        var normalized = void 0;
        if (Array.isArray(options)) {
            for (var _len2 = arguments.length, rest = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                rest[_key2 - 2] = arguments[_key2];
            }

            normalized = normalizeElementOptions.apply(undefined, [options].concat(rest));
        } else {
            normalized = options || {};
        }
        var _normalized = normalized,
            attrs = _normalized.attrs,
            blockParams = _normalized.blockParams,
            modifiers = _normalized.modifiers,
            comments = _normalized.comments,
            children = _normalized.children,
            loc = _normalized.loc;
        // this is used for backwards compat, prior to `selfClosing` being part of the ElementNode AST

        var selfClosing = false;
        if (typeof tag === 'object') {
            selfClosing = tag.selfClosing;
            tag = tag.name;
        } else {
            if (tag.slice(-1) === '/') {
                tag = tag.slice(0, -1);
                selfClosing = true;
            }
        }
        return {
            type: 'ElementNode',
            tag: tag || '',
            selfClosing: selfClosing,
            attributes: attrs || [],
            blockParams: blockParams || [],
            modifiers: modifiers || [],
            comments: comments || [],
            children: children || [],
            loc: buildLoc(loc || null)
        };
    }
    function buildAttr(name, value, loc) {
        return {
            type: 'AttrNode',
            name: name,
            value: value,
            loc: buildLoc(loc || null)
        };
    }
    function buildText(chars, loc) {
        return {
            type: 'TextNode',
            chars: chars || '',
            loc: buildLoc(loc || null)
        };
    }
    // Expressions
    function buildSexpr(path, params, hash, loc) {
        return {
            type: 'SubExpression',
            path: buildHead(path),
            params: params || [],
            hash: hash || buildHash([]),
            loc: buildLoc(loc || null)
        };
    }
    function buildHead(original, loc) {
        if (typeof original !== 'string') return original;
        var parts = original.split('.');
        var thisHead = false;
        if (parts[0] === 'this') {
            thisHead = true;
            parts = parts.slice(1);
        }
        return {
            type: 'PathExpression',
            original: original,
            this: thisHead,
            parts: parts,
            data: false,
            loc: buildLoc(loc || null)
        };
    }
    function buildLiteral(type, value, loc) {
        return {
            type: type,
            value: value,
            original: value,
            loc: buildLoc(loc || null)
        };
    }
    // Miscellaneous
    function buildHash(pairs, loc) {
        return {
            type: 'Hash',
            pairs: pairs || [],
            loc: buildLoc(loc || null)
        };
    }
    function buildPair(key, value, loc) {
        return {
            type: 'HashPair',
            key: key,
            value: value,
            loc: buildLoc(loc || null)
        };
    }
    function buildProgram(body, blockParams, loc) {
        return {
            type: 'Template',
            body: body || [],
            blockParams: blockParams || [],
            loc: buildLoc(loc || null)
        };
    }
    function buildBlockItself(body, blockParams) {
        var chained = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var loc = arguments[3];

        return {
            type: 'Block',
            body: body || [],
            blockParams: blockParams || [],
            chained: chained,
            loc: buildLoc(loc || null)
        };
    }
    function buildTemplate(body, blockParams, loc) {
        return {
            type: 'Template',
            body: body || [],
            blockParams: blockParams || [],
            loc: buildLoc(loc || null)
        };
    }
    function buildSource(source) {
        return source || null;
    }
    function buildPosition(line, column) {
        return {
            line: line,
            column: column
        };
    }
    var SYNTHETIC = {
        source: '(synthetic)',
        start: { line: 1, column: 0 },
        end: { line: 1, column: 0 }
    };
    function buildLoc() {
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
        }

        if (args.length === 1) {
            var loc = args[0];
            if (loc && typeof loc === 'object') {
                return {
                    source: buildSource(loc.source),
                    start: buildPosition(loc.start.line, loc.start.column),
                    end: buildPosition(loc.end.line, loc.end.column)
                };
            } else {
                return SYNTHETIC;
            }
        } else {
            var startLine = args[0],
                startColumn = args[1],
                endLine = args[2],
                endColumn = args[3],
                source = args[4];

            return {
                source: buildSource(source),
                start: buildPosition(startLine, startColumn),
                end: buildPosition(endLine, endColumn)
            };
        }
    }
    var b = {
        mustache: buildMustache,
        block: buildBlock,
        partial: buildPartial,
        comment: buildComment,
        mustacheComment: buildMustacheComment,
        element: buildElement,
        elementModifier: buildElementModifier,
        attr: buildAttr,
        text: buildText,
        sexpr: buildSexpr,
        path: buildHead,
        concat: buildConcat,
        hash: buildHash,
        pair: buildPair,
        literal: buildLiteral,
        program: buildProgram,
        blockItself: buildBlockItself,
        template: buildTemplate,
        loc: buildLoc,
        pos: buildPosition,
        string: literal('StringLiteral'),
        boolean: literal('BooleanLiteral'),
        number: literal('NumberLiteral'),
        undefined: function (_undefined) {
            function undefined() {
                return _undefined.apply(this, arguments);
            }

            undefined.toString = function () {
                return _undefined.toString();
            };

            return undefined;
        }(function () {
            return buildLiteral('UndefinedLiteral', undefined);
        }),
        null: function _null() {
            return buildLiteral('NullLiteral', null);
        }
    };
    function literal(type) {
        return function (value) {
            return buildLiteral(type, value);
        };
    }

    /**
     * Subclass of `Error` with additional information
     * about location of incorrect markup.
     */
    var SyntaxError = function () {
        SyntaxError.prototype = Object.create(Error.prototype);
        SyntaxError.prototype.constructor = SyntaxError;
        function SyntaxError(message, location) {
            var error = Error.call(this, message);
            this.message = message;
            this.stack = error.stack;
            this.location = location;
        }
        return SyntaxError;
    }();

    // Regex to validate the identifier for block parameters.
    // Based on the ID validation regex in Handlebars.
    var ID_INVERSE_PATTERN = /[!"#%-,\.\/;->@\[-\^`\{-~]/;
    // Checks the element's attributes to see if it uses block params.
    // If it does, registers the block params with the program and
    // removes the corresponding attributes from the element.
    function parseElementBlockParams(element) {
        var params = parseBlockParams(element);
        if (params) element.blockParams = params;
    }
    function parseBlockParams(element) {
        var l = element.attributes.length;
        var attrNames = [];
        for (var i = 0; i < l; i++) {
            attrNames.push(element.attributes[i].name);
        }
        var asIndex = attrNames.indexOf('as');
        if (asIndex !== -1 && l > asIndex && attrNames[asIndex + 1].charAt(0) === '|') {
            // Some basic validation, since we're doing the parsing ourselves
            var paramsString = attrNames.slice(asIndex).join(' ');
            if (paramsString.charAt(paramsString.length - 1) !== '|' || paramsString.match(/\|/g).length !== 2) {
                throw new SyntaxError("Invalid block parameters syntax: '" + paramsString + "'", element.loc);
            }
            var params = [];
            for (var _i = asIndex + 1; _i < l; _i++) {
                var param = attrNames[_i].replace(/\|/g, '');
                if (param !== '') {
                    if (ID_INVERSE_PATTERN.test(param)) {
                        throw new SyntaxError("Invalid identifier for block parameters: '" + param + "' in '" + paramsString + "'", element.loc);
                    }
                    params.push(param);
                }
            }
            if (params.length === 0) {
                throw new SyntaxError("Cannot use zero block parameters: '" + paramsString + "'", element.loc);
            }
            element.attributes = element.attributes.slice(0, asIndex);
            return params;
        }
        return null;
    }
    function childrenFor(node) {
        switch (node.type) {
            case 'Block':
            case 'Template':
                return node.body;
            case 'ElementNode':
                return node.children;
        }
    }
    function appendChild(parent, node) {
        childrenFor(parent).push(node);
    }
    function isLiteral(path) {
        return path.type === 'StringLiteral' || path.type === 'BooleanLiteral' || path.type === 'NumberLiteral' || path.type === 'NullLiteral' || path.type === 'UndefinedLiteral';
    }
    function printLiteral(literal) {
        if (literal.type === 'UndefinedLiteral') {
            return 'undefined';
        } else {
            return JSON.stringify(literal.value);
        }
    }

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    var Parser = function () {
        function Parser(source) {
            var entityParser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new simpleHtmlTokenizer.EntityParser(simpleHtmlTokenizer.HTML5NamedCharRefs);

            _classCallCheck(this, Parser);

            this.elementStack = [];
            this.currentAttribute = null;
            this.currentNode = null;
            this.source = source.split(/(?:\r\n?|\n)/g);
            this.tokenizer = new simpleHtmlTokenizer.EventedTokenizer(this, entityParser);
        }

        Parser.prototype.acceptTemplate = function acceptTemplate(node) {
            return this[node.type](node);
        };

        Parser.prototype.acceptNode = function acceptNode(node) {
            return this[node.type](node);
        };

        Parser.prototype.currentElement = function currentElement() {
            return this.elementStack[this.elementStack.length - 1];
        };

        Parser.prototype.sourceForNode = function sourceForNode(node, endNode) {
            var firstLine = node.loc.start.line - 1;
            var currentLine = firstLine - 1;
            var firstColumn = node.loc.start.column;
            var string = [];
            var line = void 0;
            var lastLine = void 0;
            var lastColumn = void 0;
            if (endNode) {
                lastLine = endNode.loc.end.line - 1;
                lastColumn = endNode.loc.end.column;
            } else {
                lastLine = node.loc.end.line - 1;
                lastColumn = node.loc.end.column;
            }
            while (currentLine < lastLine) {
                currentLine++;
                line = this.source[currentLine];
                if (currentLine === firstLine) {
                    if (firstLine === lastLine) {
                        string.push(line.slice(firstColumn, lastColumn));
                    } else {
                        string.push(line.slice(firstColumn));
                    }
                } else if (currentLine === lastLine) {
                    string.push(line.slice(0, lastColumn));
                } else {
                    string.push(line);
                }
            }
            return string.join('\n');
        };

        _createClass(Parser, [{
            key: 'currentAttr',
            get: function get() {
                return this.currentAttribute;
            }
        }, {
            key: 'currentTag',
            get: function get() {
                var node = this.currentNode;

                return node;
            }
        }, {
            key: 'currentStartTag',
            get: function get() {
                var node = this.currentNode;

                return node;
            }
        }, {
            key: 'currentEndTag',
            get: function get() {
                var node = this.currentNode;

                return node;
            }
        }, {
            key: 'currentComment',
            get: function get() {
                var node = this.currentNode;

                return node;
            }
        }, {
            key: 'currentData',
            get: function get() {
                var node = this.currentNode;

                return node;
            }
        }]);

        return Parser;
    }();

    var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }
    var HandlebarsNodeVisitors = function (_Parser) {
        _inherits(HandlebarsNodeVisitors, _Parser);

        function HandlebarsNodeVisitors() {
            _classCallCheck$1(this, HandlebarsNodeVisitors);

            var _this = _possibleConstructorReturn(this, _Parser.apply(this, arguments));

            _this.cursorCount = 0;
            return _this;
        }

        HandlebarsNodeVisitors.prototype.cursor = function cursor() {
            return '%cursor:' + this.cursorCount++ + '%';
        };

        HandlebarsNodeVisitors.prototype.Program = function Program(program) {
            var body = [];
            this.cursorCount = 0;
            var node = void 0;
            if (this.isTopLevel) {
                node = b.template(body, program.blockParams, program.loc);
            } else {
                node = b.blockItself(body, program.blockParams, program.chained, program.loc);
            }
            var i = void 0,
                l = program.body.length;
            this.elementStack.push(node);
            if (l === 0) {
                return this.elementStack.pop();
            }
            for (i = 0; i < l; i++) {
                this.acceptNode(program.body[i]);
            }
            // Ensure that that the element stack is balanced properly.
            var poppedNode = this.elementStack.pop();
            if (poppedNode !== node) {
                var elementNode = poppedNode;
                throw new SyntaxError('Unclosed element `' + elementNode.tag + '` (on line ' + elementNode.loc.start.line + ').', elementNode.loc);
            }
            return node;
        };

        HandlebarsNodeVisitors.prototype.BlockStatement = function BlockStatement(block) {
            if (this.tokenizer['state'] === 'comment') {
                this.appendToCommentData(this.sourceForNode(block));
                return;
            }
            if (this.tokenizer['state'] !== 'comment' && this.tokenizer['state'] !== 'data' && this.tokenizer['state'] !== 'beforeData') {
                throw new SyntaxError('A block may only be used inside an HTML element or another block.', block.loc);
            }

            var _acceptCallNodes = acceptCallNodes(this, block),
                path = _acceptCallNodes.path,
                params = _acceptCallNodes.params,
                hash = _acceptCallNodes.hash;

            var program = this.Program(block.program);
            var inverse = block.inverse ? this.Program(block.inverse) : null;
            if (path.original === 'in-element') {
                hash = addInElementHash(this.cursor(), hash, block.loc);
            }
            var node = b.block(path, params, hash, program, inverse, block.loc, block.openStrip, block.inverseStrip, block.closeStrip);
            var parentProgram = this.currentElement();
            appendChild(parentProgram, node);
        };

        HandlebarsNodeVisitors.prototype.MustacheStatement = function MustacheStatement(rawMustache) {
            var tokenizer = this.tokenizer;

            if (tokenizer.state === 'comment') {
                this.appendToCommentData(this.sourceForNode(rawMustache));
                return;
            }
            var mustache = void 0;
            var escaped = rawMustache.escaped,
                loc = rawMustache.loc,
                strip = rawMustache.strip;

            if (isLiteral(rawMustache.path)) {
                mustache = {
                    type: 'MustacheStatement',
                    path: this.acceptNode(rawMustache.path),
                    params: [],
                    hash: b.hash(),
                    escaped: escaped,
                    loc: loc,
                    strip: strip
                };
            } else {
                var _acceptCallNodes2 = acceptCallNodes(this, rawMustache),
                    path = _acceptCallNodes2.path,
                    params = _acceptCallNodes2.params,
                    hash = _acceptCallNodes2.hash;

                mustache = b.mustache(path, params, hash, !escaped, loc, strip);
            }
            switch (tokenizer.state) {
                // Tag helpers
                case "tagOpen" /* tagOpen */:
                case "tagName" /* tagName */:
                    throw new SyntaxError('Cannot use mustaches in an elements tagname: `' + this.sourceForNode(rawMustache, rawMustache.path) + '` at L' + loc.start.line + ':C' + loc.start.column, mustache.loc);
                case "beforeAttributeName" /* beforeAttributeName */:
                    addElementModifier(this.currentStartTag, mustache);
                    break;
                case "attributeName" /* attributeName */:
                case "afterAttributeName" /* afterAttributeName */:
                    this.beginAttributeValue(false);
                    this.finishAttributeValue();
                    addElementModifier(this.currentStartTag, mustache);
                    tokenizer.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                    break;
                case "afterAttributeValueQuoted" /* afterAttributeValueQuoted */:
                    addElementModifier(this.currentStartTag, mustache);
                    tokenizer.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                    break;
                // Attribute values
                case "beforeAttributeValue" /* beforeAttributeValue */:
                    this.beginAttributeValue(false);
                    appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                    tokenizer.transitionTo("attributeValueUnquoted" /* attributeValueUnquoted */);
                    break;
                case "attributeValueDoubleQuoted" /* attributeValueDoubleQuoted */:
                case "attributeValueSingleQuoted" /* attributeValueSingleQuoted */:
                case "attributeValueUnquoted" /* attributeValueUnquoted */:
                    appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                    break;
                // TODO: Only append child when the tokenizer state makes
                // sense to do so, otherwise throw an error.
                default:
                    appendChild(this.currentElement(), mustache);
            }
            return mustache;
        };

        HandlebarsNodeVisitors.prototype.ContentStatement = function ContentStatement(content) {
            updateTokenizerLocation(this.tokenizer, content);
            this.tokenizer.tokenizePart(content.value);
            this.tokenizer.flushData();
        };

        HandlebarsNodeVisitors.prototype.CommentStatement = function CommentStatement(rawComment) {
            var tokenizer = this.tokenizer;

            if (tokenizer.state === "comment" /* comment */) {
                    this.appendToCommentData(this.sourceForNode(rawComment));
                    return null;
                }
            var value = rawComment.value,
                loc = rawComment.loc;

            var comment = b.mustacheComment(value, loc);
            switch (tokenizer.state) {
                case "beforeAttributeName" /* beforeAttributeName */:
                    this.currentStartTag.comments.push(comment);
                    break;
                case "beforeData" /* beforeData */:
                case "data" /* data */:
                    appendChild(this.currentElement(), comment);
                    break;
                default:
                    throw new SyntaxError('Using a Handlebars comment when in the `' + tokenizer['state'] + '` state is not supported: "' + comment.value + '" on line ' + loc.start.line + ':' + loc.start.column, rawComment.loc);
            }
            return comment;
        };

        HandlebarsNodeVisitors.prototype.PartialStatement = function PartialStatement(partial) {
            var loc = partial.loc;

            throw new SyntaxError('Handlebars partials are not supported: "' + this.sourceForNode(partial, partial.name) + '" at L' + loc.start.line + ':C' + loc.start.column, partial.loc);
        };

        HandlebarsNodeVisitors.prototype.PartialBlockStatement = function PartialBlockStatement(partialBlock) {
            var loc = partialBlock.loc;

            throw new SyntaxError('Handlebars partial blocks are not supported: "' + this.sourceForNode(partialBlock, partialBlock.name) + '" at L' + loc.start.line + ':C' + loc.start.column, partialBlock.loc);
        };

        HandlebarsNodeVisitors.prototype.Decorator = function Decorator(decorator) {
            var loc = decorator.loc;

            throw new SyntaxError('Handlebars decorators are not supported: "' + this.sourceForNode(decorator, decorator.path) + '" at L' + loc.start.line + ':C' + loc.start.column, decorator.loc);
        };

        HandlebarsNodeVisitors.prototype.DecoratorBlock = function DecoratorBlock(decoratorBlock) {
            var loc = decoratorBlock.loc;

            throw new SyntaxError('Handlebars decorator blocks are not supported: "' + this.sourceForNode(decoratorBlock, decoratorBlock.path) + '" at L' + loc.start.line + ':C' + loc.start.column, decoratorBlock.loc);
        };

        HandlebarsNodeVisitors.prototype.SubExpression = function SubExpression(sexpr) {
            var _acceptCallNodes3 = acceptCallNodes(this, sexpr),
                path = _acceptCallNodes3.path,
                params = _acceptCallNodes3.params,
                hash = _acceptCallNodes3.hash;

            return b.sexpr(path, params, hash, sexpr.loc);
        };

        HandlebarsNodeVisitors.prototype.PathExpression = function PathExpression(path) {
            var original = path.original,
                loc = path.loc;

            var parts = void 0;
            if (original.indexOf('/') !== -1) {
                if (original.slice(0, 2) === './') {
                    throw new SyntaxError('Using "./" is not supported in Glimmer and unnecessary: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
                }
                if (original.slice(0, 3) === '../') {
                    throw new SyntaxError('Changing context using "../" is not supported in Glimmer: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
                }
                if (original.indexOf('.') !== -1) {
                    throw new SyntaxError('Mixing \'.\' and \'/\' in paths is not supported in Glimmer; use only \'.\' to separate property paths: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
                }
                parts = [path.parts.join('/')];
            } else if (original === '.') {
                var locationInfo = 'L' + loc.start.line + ':C' + loc.start.column;
                throw new SyntaxError('\'.\' is not a supported path in Glimmer; check for a path with a trailing \'.\' at ' + locationInfo + '.', path.loc);
            } else {
                parts = path.parts;
            }
            var thisHead = false;
            // This is to fix a bug in the Handlebars AST where the path expressions in
            // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)
            // are simply turned into `{{foo}}`. The fix is to push it back onto the
            // parts array and let the runtime see the difference. However, we cannot
            // simply use the string `this` as it means literally the property called
            // "this" in the current context (it can be expressed in the syntax as
            // `{{[this]}}`, where the square bracket are generally for this kind of
            // escaping â€“ such as `{{foo.["bar.baz"]}}` would mean lookup a property
            // named literally "bar.baz" on `this.foo`). By convention, we use `null`
            // for this purpose.
            if (original.match(/^this(\..+)?$/)) {
                thisHead = true;
            }
            return {
                type: 'PathExpression',
                original: path.original,
                this: thisHead,
                parts: parts,
                data: path.data,
                loc: path.loc
            };
        };

        HandlebarsNodeVisitors.prototype.Hash = function Hash(hash) {
            var pairs = [];
            for (var i = 0; i < hash.pairs.length; i++) {
                var pair = hash.pairs[i];
                pairs.push(b.pair(pair.key, this.acceptNode(pair.value), pair.loc));
            }
            return b.hash(pairs, hash.loc);
        };

        HandlebarsNodeVisitors.prototype.StringLiteral = function StringLiteral(string) {
            return b.literal('StringLiteral', string.value, string.loc);
        };

        HandlebarsNodeVisitors.prototype.BooleanLiteral = function BooleanLiteral(boolean) {
            return b.literal('BooleanLiteral', boolean.value, boolean.loc);
        };

        HandlebarsNodeVisitors.prototype.NumberLiteral = function NumberLiteral(number) {
            return b.literal('NumberLiteral', number.value, number.loc);
        };

        HandlebarsNodeVisitors.prototype.UndefinedLiteral = function UndefinedLiteral(undef) {
            return b.literal('UndefinedLiteral', undefined, undef.loc);
        };

        HandlebarsNodeVisitors.prototype.NullLiteral = function NullLiteral(nul) {
            return b.literal('NullLiteral', null, nul.loc);
        };

        _createClass$1(HandlebarsNodeVisitors, [{
            key: 'isTopLevel',
            get: function get() {
                return this.elementStack.length === 0;
            }
        }]);

        return HandlebarsNodeVisitors;
    }(Parser);
    function calculateRightStrippedOffsets(original, value) {
        if (value === '') {
            // if it is empty, just return the count of newlines
            // in original
            return {
                lines: original.split('\n').length - 1,
                columns: 0
            };
        }
        // otherwise, return the number of newlines prior to
        // `value`
        var difference = original.split(value)[0];
        var lines = difference.split(/\n/);
        var lineCount = lines.length - 1;
        return {
            lines: lineCount,
            columns: lines[lineCount].length
        };
    }
    function updateTokenizerLocation(tokenizer, content) {
        var line = content.loc.start.line;
        var column = content.loc.start.column;
        var offsets = calculateRightStrippedOffsets(content.original, content.value);
        line = line + offsets.lines;
        if (offsets.lines) {
            column = offsets.columns;
        } else {
            column = column + offsets.columns;
        }
        tokenizer.line = line;
        tokenizer.column = column;
    }
    function acceptCallNodes(compiler, node) {
        var path = compiler.PathExpression(node.path);
        var params = node.params ? node.params.map(function (e) {
            return compiler.acceptNode(e);
        }) : [];
        var hash = node.hash ? compiler.Hash(node.hash) : b.hash();
        return { path: path, params: params, hash: hash };
    }
    function addElementModifier(element, mustache) {
        var path = mustache.path,
            params = mustache.params,
            hash = mustache.hash,
            loc = mustache.loc;

        if (isLiteral(path)) {
            var _modifier = '{{' + printLiteral(path) + '}}';
            var tag = '<' + element.name + ' ... ' + _modifier + ' ...';
            throw new SyntaxError('In ' + tag + ', ' + _modifier + ' is not a valid modifier: "' + path.original + '" on line ' + (loc && loc.start.line) + '.', mustache.loc);
        }
        var modifier = b.elementModifier(path, params, hash, loc);
        element.modifiers.push(modifier);
    }
    function addInElementHash(cursor, hash, loc) {
        var hasInsertBefore = false;
        hash.pairs.forEach(function (pair) {
            if (pair.key === 'guid') {
                throw new SyntaxError('Cannot pass `guid` from user space', loc);
            }
            if (pair.key === 'insertBefore') {
                hasInsertBefore = true;
            }
        });
        var guid = b.literal('StringLiteral', cursor);
        var guidPair = b.pair('guid', guid);
        hash.pairs.unshift(guidPair);
        if (!hasInsertBefore) {
            var undefinedLiteral = b.literal('UndefinedLiteral', undefined);
            var beforeSibling = b.pair('insertBefore', undefinedLiteral);
            hash.pairs.push(beforeSibling);
        }
        return hash;
    }
    function appendDynamicAttributeValuePart(attribute, part) {
        attribute.isDynamic = true;
        attribute.parts.push(part);
    }

    // ensure stays in sync with typing
    // ParentNode and ChildKey types are derived from VisitorKeysMap
    var visitorKeys = {
        Program: util.tuple('body'),
        Template: util.tuple('body'),
        Block: util.tuple('body'),
        MustacheStatement: util.tuple('path', 'params', 'hash'),
        BlockStatement: util.tuple('path', 'params', 'hash', 'program', 'inverse'),
        ElementModifierStatement: util.tuple('path', 'params', 'hash'),
        PartialStatement: util.tuple('name', 'params', 'hash'),
        CommentStatement: util.tuple(),
        MustacheCommentStatement: util.tuple(),
        ElementNode: util.tuple('attributes', 'modifiers', 'children', 'comments'),
        AttrNode: util.tuple('value'),
        TextNode: util.tuple(),
        ConcatStatement: util.tuple('parts'),
        SubExpression: util.tuple('path', 'params', 'hash'),
        PathExpression: util.tuple(),
        StringLiteral: util.tuple(),
        BooleanLiteral: util.tuple(),
        NumberLiteral: util.tuple(),
        NullLiteral: util.tuple(),
        UndefinedLiteral: util.tuple(),
        Hash: util.tuple('pairs'),
        HashPair: util.tuple('value')
    };

    var TraversalError = function () {
        TraversalError.prototype = Object.create(Error.prototype);
        TraversalError.prototype.constructor = TraversalError;
        function TraversalError(message, node, parent, key) {
            var error = Error.call(this, message);
            this.key = key;
            this.message = message;
            this.node = node;
            this.parent = parent;
            this.stack = error.stack;
        }
        return TraversalError;
    }();
    function cannotRemoveNode(node, parent, key) {
        return new TraversalError('Cannot remove a node unless it is part of an array', node, parent, key);
    }
    function cannotReplaceNode(node, parent, key) {
        return new TraversalError('Cannot replace a node with multiple nodes unless it is part of an array', node, parent, key);
    }
    function cannotReplaceOrRemoveInKeyHandlerYet(node, key) {
        return new TraversalError('Replacing and removing in key handlers is not yet supported.', node, null, key);
    }

    var _createClass$2 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var Path = function () {
        function Path(node) {
            var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var parentKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

            _classCallCheck$2(this, Path);

            this.node = node;
            this.parent = parent;
            this.parentKey = parentKey;
        }

        _createClass$2(Path, [{
            key: "parentNode",
            get: function get() {
                return this.parent ? this.parent.node : null;
            }
        }]);

        return Path;
    }();

    function getEnterFunction(handler) {
        if (typeof handler === 'function') {
            return handler;
        } else {
            return handler.enter;
        }
    }
    function getExitFunction(handler) {
        if (typeof handler === 'function') {
            return undefined;
        } else {
            return handler.exit;
        }
    }
    function getKeyHandler(handler, key) {
        var keyVisitor = typeof handler !== 'function' ? handler.keys : undefined;
        if (keyVisitor === undefined) return;
        var keyHandler = keyVisitor[key];
        if (keyHandler !== undefined) {
            return keyHandler;
        }
        return keyVisitor.All;
    }
    function getNodeHandler(visitor, nodeType) {
        if (nodeType === 'Template' || nodeType === 'Block') {
            if (visitor.Program) {
                return visitor.Program;
            }
        }
        var handler = visitor[nodeType];
        if (handler !== undefined) {
            return handler;
        }
        return visitor.All;
    }
    function visitNode(visitor, path) {
        var node = path.node,
            parent = path.parent,
            parentKey = path.parentKey;

        var handler = getNodeHandler(visitor, node.type);
        var enter = void 0;
        var exit = void 0;
        if (handler !== undefined) {
            enter = getEnterFunction(handler);
            exit = getExitFunction(handler);
        }
        var result = void 0;
        if (enter !== undefined) {
            result = enter(node, path);
        }
        if (result !== undefined && result !== null) {
            if (JSON.stringify(node) === JSON.stringify(result)) {
                result = undefined;
            } else if (Array.isArray(result)) {
                visitArray(visitor, result, parent, parentKey);
                return result;
            } else {
                var _path = new Path(result, parent, parentKey);
                return visitNode(visitor, _path) || result;
            }
        }
        if (result === undefined) {
            var keys = visitorKeys[node.type];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                // we know if it has child keys we can widen to a ParentNode
                visitKey(visitor, handler, path, key);
            }
            if (exit !== undefined) {
                result = exit(node, path);
            }
        }
        return result;
    }
    function get(node, key) {
        return node[key];
    }
    function set(node, key, value) {
        node[key] = value;
    }
    function visitKey(visitor, handler, path, key) {
        var node = path.node;

        var value = get(node, key);
        if (!value) {
            return;
        }
        var keyEnter = void 0;
        var keyExit = void 0;
        if (handler !== undefined) {
            var keyHandler = getKeyHandler(handler, key);
            if (keyHandler !== undefined) {
                keyEnter = getEnterFunction(keyHandler);
                keyExit = getExitFunction(keyHandler);
            }
        }
        if (keyEnter !== undefined) {
            if (keyEnter(node, key) !== undefined) {
                throw cannotReplaceOrRemoveInKeyHandlerYet(node, key);
            }
        }
        if (Array.isArray(value)) {
            visitArray(visitor, value, path, key);
        } else {
            var keyPath = new Path(value, path, key);
            var result = visitNode(visitor, keyPath);
            if (result !== undefined) {
                // TODO: dynamically check the results by having a table of
                // expected node types in value space, not just type space
                assignKey(node, key, value, result);
            }
        }
        if (keyExit !== undefined) {
            if (keyExit(node, key) !== undefined) {
                throw cannotReplaceOrRemoveInKeyHandlerYet(node, key);
            }
        }
    }
    function visitArray(visitor, array, parent, parentKey) {
        for (var i = 0; i < array.length; i++) {
            var node = array[i];
            var path = new Path(node, parent, parentKey);
            var result = visitNode(visitor, path);
            if (result !== undefined) {
                i += spliceArray(array, i, result) - 1;
            }
        }
    }
    function assignKey(node, key, value, result) {
        if (result === null) {
            throw cannotRemoveNode(value, node, key);
        } else if (Array.isArray(result)) {
            if (result.length === 1) {
                set(node, key, result[0]);
            } else {
                if (result.length === 0) {
                    throw cannotRemoveNode(value, node, key);
                } else {
                    throw cannotReplaceNode(value, node, key);
                }
            }
        } else {
            set(node, key, result);
        }
    }
    function spliceArray(array, index, result) {
        if (result === null) {
            array.splice(index, 1);
            return 0;
        } else if (Array.isArray(result)) {
            array.splice.apply(array, [index, 1].concat(result));
            return result.length;
        } else {
            array.splice(index, 1, result);
            return 1;
        }
    }
    function traverse(node, visitor) {
        var path = new Path(node);
        visitNode(visitor, path);
    }

    var ATTR_VALUE_REGEX_TEST = /[\xA0"&]/;
    var ATTR_VALUE_REGEX_REPLACE = new RegExp(ATTR_VALUE_REGEX_TEST.source, 'g');
    var TEXT_REGEX_TEST = /[\xA0&<>]/;
    var TEXT_REGEX_REPLACE = new RegExp(TEXT_REGEX_TEST.source, 'g');
    function attrValueReplacer(char) {
        switch (char.charCodeAt(0)) {
            case 160 /* NBSP */:
                return '&nbsp;';
            case 34 /* QUOT */:
                return '&quot;';
            case 38 /* AMP */:
                return '&amp;';
            default:
                return char;
        }
    }
    function textReplacer(char) {
        switch (char.charCodeAt(0)) {
            case 160 /* NBSP */:
                return '&nbsp;';
            case 38 /* AMP */:
                return '&amp;';
            case 60 /* LT */:
                return '&lt;';
            case 62 /* GT */:
                return '&gt;';
            default:
                return char;
        }
    }
    function escapeAttrValue(attrValue) {
        if (ATTR_VALUE_REGEX_TEST.test(attrValue)) {
            return attrValue.replace(ATTR_VALUE_REGEX_REPLACE, attrValueReplacer);
        }
        return attrValue;
    }
    function escapeText(text) {
        if (TEXT_REGEX_TEST.test(text)) {
            return text.replace(TEXT_REGEX_REPLACE, textReplacer);
        }
        return text;
    }

    function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    var NON_WHITESPACE = /\S/;

    var Printer = function () {
        function Printer(options) {
            _classCallCheck$3(this, Printer);

            this.buffer = '';
            this.options = options;
        }
        /*
          This is used by _all_ methods on this Printer class that add to `this.buffer`,
          it allows consumers of the printer to use alternate string representations for
          a given node.
             The primary use case for this are things like source -> source codemod utilities.
          For example, ember-template-recast attempts to always preserve the original string
          formatting in each AST node if no modifications are made to it.
        */


        Printer.prototype.handledByOverride = function handledByOverride(node) {
            var ensureLeadingWhitespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            if (this.options.override !== undefined) {
                var result = this.options.override(node, this.options);
                if (typeof result === 'string') {
                    if (ensureLeadingWhitespace && NON_WHITESPACE.test(result[0])) {
                        result = ' ' + result;
                    }
                    this.buffer += result;
                    return true;
                }
            }
            return false;
        };

        Printer.prototype.Node = function Node(node) {
            switch (node.type) {
                case 'MustacheStatement':
                case 'BlockStatement':
                case 'PartialStatement':
                case 'MustacheCommentStatement':
                case 'CommentStatement':
                case 'TextNode':
                case 'ElementNode':
                case 'AttrNode':
                case 'Block':
                case 'Template':
                    return this.TopLevelStatement(node);
                case 'StringLiteral':
                case 'BooleanLiteral':
                case 'NumberLiteral':
                case 'UndefinedLiteral':
                case 'NullLiteral':
                case 'PathExpression':
                case 'SubExpression':
                    return this.Expression(node);
                case 'Program':
                    return this.Block(node);
                case 'ConcatStatement':
                    // should have an AttrNode parent
                    return this.ConcatStatement(node);
                case 'Hash':
                    return this.Hash(node);
                case 'HashPair':
                    return this.HashPair(node);
                case 'ElementModifierStatement':
                    return this.ElementModifierStatement(node);
            }
            return unreachable(node);
        };

        Printer.prototype.Expression = function Expression(expression) {
            switch (expression.type) {
                case 'StringLiteral':
                case 'BooleanLiteral':
                case 'NumberLiteral':
                case 'UndefinedLiteral':
                case 'NullLiteral':
                    return this.Literal(expression);
                case 'PathExpression':
                    return this.PathExpression(expression);
                case 'SubExpression':
                    return this.SubExpression(expression);
            }
            return unreachable(expression);
        };

        Printer.prototype.Literal = function Literal(literal) {
            switch (literal.type) {
                case 'StringLiteral':
                    return this.StringLiteral(literal);
                case 'BooleanLiteral':
                    return this.BooleanLiteral(literal);
                case 'NumberLiteral':
                    return this.NumberLiteral(literal);
                case 'UndefinedLiteral':
                    return this.UndefinedLiteral(literal);
                case 'NullLiteral':
                    return this.NullLiteral(literal);
            }
            return unreachable(literal);
        };

        Printer.prototype.TopLevelStatement = function TopLevelStatement(statement) {
            switch (statement.type) {
                case 'MustacheStatement':
                    return this.MustacheStatement(statement);
                case 'BlockStatement':
                    return this.BlockStatement(statement);
                case 'PartialStatement':
                    return this.PartialStatement(statement);
                case 'MustacheCommentStatement':
                    return this.MustacheCommentStatement(statement);
                case 'CommentStatement':
                    return this.CommentStatement(statement);
                case 'TextNode':
                    return this.TextNode(statement);
                case 'ElementNode':
                    return this.ElementNode(statement);
                case 'Block':
                case 'Template':
                    return this.Block(statement);
                case 'AttrNode':
                    // should have element
                    return this.AttrNode(statement);
            }
            unreachable(statement);
        };

        Printer.prototype.Block = function Block(block) {
            /*
              When processing a template like:
                   ```hbs
              {{#if whatever}}
                whatever
              {{else if somethingElse}}
                something else
              {{else}}
                fallback
              {{/if}}
              ```
                   The AST still _effectively_ looks like:
                   ```hbs
              {{#if whatever}}
                whatever
              {{else}}{{#if somethingElse}}
                something else
              {{else}}
                fallback
              {{/if}}{{/if}}
              ```
                   The only way we can tell if that is the case is by checking for
              `block.chained`, but unfortunately when the actual statements are
              processed the `block.body[0]` node (which will always be a
              `BlockStatement`) has no clue that its anscestor `Block` node was
              chained.
                   This "forwards" the `chained` setting so that we can check
              it later when processing the `BlockStatement`.
            */
            if (block.chained) {
                var firstChild = block.body[0];
                firstChild.chained = true;
            }
            if (this.handledByOverride(block)) {
                return;
            }
            this.TopLevelStatements(block.body);
        };

        Printer.prototype.TopLevelStatements = function TopLevelStatements(statements) {
            var _this = this;

            statements.forEach(function (statement) {
                return _this.TopLevelStatement(statement);
            });
        };

        Printer.prototype.ElementNode = function ElementNode(el) {
            if (this.handledByOverride(el)) {
                return;
            }
            this.OpenElementNode(el);
            this.TopLevelStatements(el.children);
            this.CloseElementNode(el);
        };

        Printer.prototype.OpenElementNode = function OpenElementNode(el) {
            var _this2 = this;

            this.buffer += '<' + el.tag;
            if (el.attributes.length) {
                el.attributes.forEach(function (attr) {
                    _this2.buffer += ' ';
                    _this2.AttrNode(attr);
                });
            }
            if (el.modifiers.length) {
                el.modifiers.forEach(function (mod) {
                    _this2.buffer += ' ';
                    _this2.ElementModifierStatement(mod);
                });
            }
            if (el.comments.length) {
                el.comments.forEach(function (comment) {
                    _this2.buffer += ' ';
                    _this2.MustacheCommentStatement(comment);
                });
            }
            if (el.blockParams.length) {
                this.BlockParams(el.blockParams);
            }
            if (el.selfClosing) {
                this.buffer += ' /';
            }
            this.buffer += '>';
        };

        Printer.prototype.CloseElementNode = function CloseElementNode(el) {
            if (el.selfClosing || voidMap[el.tag.toLowerCase()]) {
                return;
            }
            this.buffer += '</' + el.tag + '>';
        };

        Printer.prototype.AttrNode = function AttrNode(attr) {
            if (this.handledByOverride(attr)) {
                return;
            }
            var name = attr.name,
                value = attr.value;

            this.buffer += name;
            if (value.type !== 'TextNode' || value.chars.length > 0) {
                this.buffer += '=';
                this.AttrNodeValue(value);
            }
        };

        Printer.prototype.AttrNodeValue = function AttrNodeValue(value) {
            if (value.type === 'TextNode') {
                this.buffer += '"';
                this.TextNode(value, true);
                this.buffer += '"';
            } else {
                this.Node(value);
            }
        };

        Printer.prototype.TextNode = function TextNode(text, isAttr) {
            if (this.handledByOverride(text)) {
                return;
            }
            if (this.options.entityEncoding === 'raw') {
                this.buffer += text.chars;
            } else if (isAttr) {
                this.buffer += escapeAttrValue(text.chars);
            } else {
                this.buffer += escapeText(text.chars);
            }
        };

        Printer.prototype.MustacheStatement = function MustacheStatement(mustache) {
            if (this.handledByOverride(mustache)) {
                return;
            }
            this.buffer += mustache.escaped ? '{{' : '{{{';
            if (mustache.strip.open) {
                this.buffer += '~';
            }
            this.Expression(mustache.path);
            this.Params(mustache.params);
            this.Hash(mustache.hash);
            if (mustache.strip.close) {
                this.buffer += '~';
            }
            this.buffer += mustache.escaped ? '}}' : '}}}';
        };

        Printer.prototype.BlockStatement = function BlockStatement(block) {
            if (this.handledByOverride(block)) {
                return;
            }
            if (block.chained) {
                this.buffer += block.inverseStrip.open ? '{{~' : '{{';
                this.buffer += 'else ';
            } else {
                this.buffer += block.openStrip.open ? '{{~#' : '{{#';
            }
            this.Expression(block.path);
            this.Params(block.params);
            this.Hash(block.hash);
            if (block.program.blockParams.length) {
                this.BlockParams(block.program.blockParams);
            }
            if (block.chained) {
                this.buffer += block.inverseStrip.close ? '~}}' : '}}';
            } else {
                this.buffer += block.openStrip.close ? '~}}' : '}}';
            }
            this.Block(block.program);
            if (block.inverse) {
                if (!block.inverse.chained) {
                    this.buffer += block.inverseStrip.open ? '{{~' : '{{';
                    this.buffer += 'else';
                    this.buffer += block.inverseStrip.close ? '~}}' : '}}';
                }
                this.Block(block.inverse);
            }
            if (!block.chained) {
                this.buffer += block.closeStrip.open ? '{{~/' : '{{/';
                this.Expression(block.path);
                this.buffer += block.closeStrip.close ? '~}}' : '}}';
            }
        };

        Printer.prototype.BlockParams = function BlockParams(blockParams) {
            this.buffer += ' as |' + blockParams.join(' ') + '|';
        };

        Printer.prototype.PartialStatement = function PartialStatement(partial) {
            if (this.handledByOverride(partial)) {
                return;
            }
            this.buffer += '{{>';
            this.Expression(partial.name);
            this.Params(partial.params);
            this.Hash(partial.hash);
            this.buffer += '}}';
        };

        Printer.prototype.ConcatStatement = function ConcatStatement(concat) {
            var _this3 = this;

            if (this.handledByOverride(concat)) {
                return;
            }
            this.buffer += '"';
            concat.parts.forEach(function (part) {
                if (part.type === 'TextNode') {
                    _this3.TextNode(part, true);
                } else {
                    _this3.Node(part);
                }
            });
            this.buffer += '"';
        };

        Printer.prototype.MustacheCommentStatement = function MustacheCommentStatement(comment) {
            if (this.handledByOverride(comment)) {
                return;
            }
            this.buffer += '{{!--' + comment.value + '--}}';
        };

        Printer.prototype.ElementModifierStatement = function ElementModifierStatement(mod) {
            if (this.handledByOverride(mod)) {
                return;
            }
            this.buffer += '{{';
            this.Expression(mod.path);
            this.Params(mod.params);
            this.Hash(mod.hash);
            this.buffer += '}}';
        };

        Printer.prototype.CommentStatement = function CommentStatement(comment) {
            if (this.handledByOverride(comment)) {
                return;
            }
            this.buffer += '<!--' + comment.value + '-->';
        };

        Printer.prototype.PathExpression = function PathExpression(path) {
            if (this.handledByOverride(path)) {
                return;
            }
            this.buffer += path.original;
        };

        Printer.prototype.SubExpression = function SubExpression(sexp) {
            if (this.handledByOverride(sexp)) {
                return;
            }
            this.buffer += '(';
            this.Expression(sexp.path);
            this.Params(sexp.params);
            this.Hash(sexp.hash);
            this.buffer += ')';
        };

        Printer.prototype.Params = function Params(params) {
            var _this4 = this;

            // TODO: implement a top level Params AST node (just like the Hash object)
            // so that this can also be overridden
            if (params.length) {
                params.forEach(function (param) {
                    _this4.buffer += ' ';
                    _this4.Expression(param);
                });
            }
        };

        Printer.prototype.Hash = function Hash(hash) {
            var _this5 = this;

            if (this.handledByOverride(hash, true)) {
                return;
            }
            hash.pairs.forEach(function (pair) {
                _this5.buffer += ' ';
                _this5.HashPair(pair);
            });
        };

        Printer.prototype.HashPair = function HashPair(pair) {
            if (this.handledByOverride(pair)) {
                return;
            }
            this.buffer += pair.key;
            this.buffer += '=';
            this.Node(pair.value);
        };

        Printer.prototype.StringLiteral = function StringLiteral(str) {
            if (this.handledByOverride(str)) {
                return;
            }
            this.buffer += JSON.stringify(str.value);
        };

        Printer.prototype.BooleanLiteral = function BooleanLiteral(bool) {
            if (this.handledByOverride(bool)) {
                return;
            }
            this.buffer += bool.value;
        };

        Printer.prototype.NumberLiteral = function NumberLiteral(number) {
            if (this.handledByOverride(number)) {
                return;
            }
            this.buffer += number.value;
        };

        Printer.prototype.UndefinedLiteral = function UndefinedLiteral(node) {
            if (this.handledByOverride(node)) {
                return;
            }
            this.buffer += 'undefined';
        };

        Printer.prototype.NullLiteral = function NullLiteral(node) {
            if (this.handledByOverride(node)) {
                return;
            }
            this.buffer += 'null';
        };

        Printer.prototype.print = function print(node) {
            var options = this.options;

            if (options.override) {
                var result = options.override(node, options);
                if (result !== undefined) {
                    return result;
                }
            }
            this.buffer = '';
            this.Node(node);
            return this.buffer;
        };

        return Printer;
    }();

    function unreachable(node) {
        throw new Error('Non-exhaustive node narrowing ' + node.type);
    }

    function build(ast) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { entityEncoding: 'transformed' };

        if (!ast) {
            return '';
        }
        var printer = new Printer(options);
        return printer.print(ast);
    }

    function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var Walker = function () {
        function Walker(order) {
            _classCallCheck$4(this, Walker);

            this.order = order;
            this.stack = [];
        }

        Walker.prototype.visit = function visit(node, callback) {
            if (!node) {
                return;
            }
            this.stack.push(node);
            if (this.order === 'post') {
                this.children(node, callback);
                callback(node, this);
            } else {
                callback(node, this);
                this.children(node, callback);
            }
            this.stack.pop();
        };

        Walker.prototype.children = function children(node, callback) {
            var type = void 0;
            if (node.type === 'Block' || node.type === 'Template' && visitors.Program) {
                type = 'Program';
            } else {
                type = node.type;
            }
            var visitor = visitors[type];
            if (visitor) {
                visitor(this, node, callback);
            }
        };

        return Walker;
    }();

    var visitors = {
        Program: function Program(walker, node, callback) {
            for (var i = 0; i < node.body.length; i++) {
                walker.visit(node.body[i], callback);
            }
        },
        Template: function Template(walker, node, callback) {
            for (var i = 0; i < node.body.length; i++) {
                walker.visit(node.body[i], callback);
            }
        },
        Block: function Block(walker, node, callback) {
            for (var i = 0; i < node.body.length; i++) {
                walker.visit(node.body[i], callback);
            }
        },
        ElementNode: function ElementNode(walker, node, callback) {
            for (var i = 0; i < node.children.length; i++) {
                walker.visit(node.children[i], callback);
            }
        },
        BlockStatement: function BlockStatement(walker, node, callback) {
            walker.visit(node.program, callback);
            walker.visit(node.inverse || null, callback);
        }
    };

    function _defaults$1(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

    function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults$1(subClass, superClass); }
    var voidMap = Object.create(null);
    var voidTagNames = 'area base br col command embed hr img input keygen link meta param source track wbr';
    voidTagNames.split(' ').forEach(function (tagName) {
        voidMap[tagName] = true;
    });
    var TokenizerEventHandlers = function (_HandlebarsNodeVisito) {
        _inherits$1(TokenizerEventHandlers, _HandlebarsNodeVisito);

        function TokenizerEventHandlers() {
            _classCallCheck$5(this, TokenizerEventHandlers);

            var _this = _possibleConstructorReturn$1(this, _HandlebarsNodeVisito.apply(this, arguments));

            _this.tagOpenLine = 0;
            _this.tagOpenColumn = 0;
            return _this;
        }

        TokenizerEventHandlers.prototype.reset = function reset() {
            this.currentNode = null;
        };
        // Comment


        TokenizerEventHandlers.prototype.beginComment = function beginComment() {
            this.currentNode = b.comment('');
            this.currentNode.loc = {
                source: null,
                start: b.pos(this.tagOpenLine, this.tagOpenColumn),
                end: null
            };
        };

        TokenizerEventHandlers.prototype.appendToCommentData = function appendToCommentData(char) {
            this.currentComment.value += char;
        };

        TokenizerEventHandlers.prototype.finishComment = function finishComment() {
            this.currentComment.loc.end = b.pos(this.tokenizer.line, this.tokenizer.column);
            appendChild(this.currentElement(), this.currentComment);
        };
        // Data


        TokenizerEventHandlers.prototype.beginData = function beginData() {
            this.currentNode = b.text();
            this.currentNode.loc = {
                source: null,
                start: b.pos(this.tokenizer.line, this.tokenizer.column),
                end: null
            };
        };

        TokenizerEventHandlers.prototype.appendToData = function appendToData(char) {
            this.currentData.chars += char;
        };

        TokenizerEventHandlers.prototype.finishData = function finishData() {
            this.currentData.loc.end = b.pos(this.tokenizer.line, this.tokenizer.column);
            appendChild(this.currentElement(), this.currentData);
        };
        // Tags - basic


        TokenizerEventHandlers.prototype.tagOpen = function tagOpen() {
            this.tagOpenLine = this.tokenizer.line;
            this.tagOpenColumn = this.tokenizer.column;
        };

        TokenizerEventHandlers.prototype.beginStartTag = function beginStartTag() {
            this.currentNode = {
                type: 'StartTag',
                name: '',
                attributes: [],
                modifiers: [],
                comments: [],
                selfClosing: false,
                loc: SYNTHETIC
            };
        };

        TokenizerEventHandlers.prototype.beginEndTag = function beginEndTag() {
            this.currentNode = {
                type: 'EndTag',
                name: '',
                attributes: [],
                modifiers: [],
                comments: [],
                selfClosing: false,
                loc: SYNTHETIC
            };
        };

        TokenizerEventHandlers.prototype.finishTag = function finishTag() {
            var _tokenizer = this.tokenizer,
                line = _tokenizer.line,
                column = _tokenizer.column;

            var tag = this.currentTag;
            tag.loc = b.loc(this.tagOpenLine, this.tagOpenColumn, line, column);
            if (tag.type === 'StartTag') {
                this.finishStartTag();
                if (voidMap[tag.name] || tag.selfClosing) {
                    this.finishEndTag(true);
                }
            } else if (tag.type === 'EndTag') {
                this.finishEndTag(false);
            }
        };

        TokenizerEventHandlers.prototype.finishStartTag = function finishStartTag() {
            var _currentStartTag = this.currentStartTag,
                name = _currentStartTag.name,
                attrs = _currentStartTag.attributes,
                modifiers = _currentStartTag.modifiers,
                comments = _currentStartTag.comments,
                selfClosing = _currentStartTag.selfClosing;

            var loc = b.loc(this.tagOpenLine, this.tagOpenColumn);
            var element = b.element({ name: name, selfClosing: selfClosing }, { attrs: attrs, modifiers: modifiers, comments: comments, loc: loc });
            this.elementStack.push(element);
        };

        TokenizerEventHandlers.prototype.finishEndTag = function finishEndTag(isVoid) {
            var tag = this.currentTag;
            var element = this.elementStack.pop();
            var parent = this.currentElement();
            validateEndTag(tag, element, isVoid);
            element.loc.end.line = this.tokenizer.line;
            element.loc.end.column = this.tokenizer.column;
            parseElementBlockParams(element);
            appendChild(parent, element);
        };

        TokenizerEventHandlers.prototype.markTagAsSelfClosing = function markTagAsSelfClosing() {
            this.currentTag.selfClosing = true;
        };
        // Tags - name


        TokenizerEventHandlers.prototype.appendToTagName = function appendToTagName(char) {
            this.currentTag.name += char;
        };
        // Tags - attributes


        TokenizerEventHandlers.prototype.beginAttribute = function beginAttribute() {
            var tag = this.currentTag;
            if (tag.type === 'EndTag') {
                throw new SyntaxError('Invalid end tag: closing tag must not have attributes, ' + ('in `' + tag.name + '` (on line ' + this.tokenizer.line + ').'), tag.loc);
            }
            this.currentAttribute = {
                name: '',
                parts: [],
                isQuoted: false,
                isDynamic: false,
                start: b.pos(this.tokenizer.line, this.tokenizer.column),
                valueStartLine: 0,
                valueStartColumn: 0
            };
        };

        TokenizerEventHandlers.prototype.appendToAttributeName = function appendToAttributeName(char) {
            this.currentAttr.name += char;
        };

        TokenizerEventHandlers.prototype.beginAttributeValue = function beginAttributeValue(isQuoted) {
            this.currentAttr.isQuoted = isQuoted;
            this.currentAttr.valueStartLine = this.tokenizer.line;
            this.currentAttr.valueStartColumn = this.tokenizer.column;
        };

        TokenizerEventHandlers.prototype.appendToAttributeValue = function appendToAttributeValue(char) {
            var parts = this.currentAttr.parts;
            var lastPart = parts[parts.length - 1];
            if (lastPart && lastPart.type === 'TextNode') {
                lastPart.chars += char;
                // update end location for each added char
                lastPart.loc.end.line = this.tokenizer.line;
                lastPart.loc.end.column = this.tokenizer.column;
            } else {
                // initially assume the text node is a single char
                var loc = b.loc(this.tokenizer.line, this.tokenizer.column, this.tokenizer.line, this.tokenizer.column);
                // the tokenizer line/column have already been advanced, correct location info
                if (char === '\n') {
                    loc.start.line -= 1;
                    loc.start.column = lastPart ? lastPart.loc.end.column : this.currentAttr.valueStartColumn;
                } else {
                    loc.start.column -= 1;
                }
                var text = b.text(char, loc);
                parts.push(text);
            }
        };

        TokenizerEventHandlers.prototype.finishAttributeValue = function finishAttributeValue() {
            var _currentAttr = this.currentAttr,
                name = _currentAttr.name,
                parts = _currentAttr.parts,
                isQuoted = _currentAttr.isQuoted,
                isDynamic = _currentAttr.isDynamic,
                valueStartLine = _currentAttr.valueStartLine,
                valueStartColumn = _currentAttr.valueStartColumn;

            var value = assembleAttributeValue(parts, isQuoted, isDynamic, this.tokenizer.line);
            value.loc = b.loc(valueStartLine, valueStartColumn, this.tokenizer.line, this.tokenizer.column);
            var loc = b.loc(this.currentAttr.start.line, this.currentAttr.start.column, this.tokenizer.line, this.tokenizer.column);
            var attribute = b.attr(name, value, loc);
            this.currentStartTag.attributes.push(attribute);
        };

        TokenizerEventHandlers.prototype.reportSyntaxError = function reportSyntaxError(message) {
            throw new SyntaxError('Syntax error at line ' + this.tokenizer.line + ' col ' + this.tokenizer.column + ': ' + message, b.loc(this.tokenizer.line, this.tokenizer.column));
        };

        return TokenizerEventHandlers;
    }(HandlebarsNodeVisitors);
    function assembleAttributeValue(parts, isQuoted, isDynamic, line) {
        if (isDynamic) {
            if (isQuoted) {
                return assembleConcatenatedValue(parts);
            } else {
                if (parts.length === 1 || parts.length === 2 && parts[1].type === 'TextNode' && parts[1].chars === '/') {
                    return parts[0];
                } else {
                    throw new SyntaxError('An unquoted attribute value must be a string or a mustache, ' + 'preceeded by whitespace or a \'=\' character, and ' + ('followed by whitespace, a \'>\' character, or \'/>\' (on line ' + line + ')'), b.loc(line, 0));
                }
            }
        } else {
            return parts.length > 0 ? parts[0] : b.text('');
        }
    }
    function assembleConcatenatedValue(parts) {
        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part.type !== 'MustacheStatement' && part.type !== 'TextNode') {
                throw new SyntaxError('Unsupported node in quoted attribute value: ' + part['type'], part.loc);
            }
        }
        return b.concat(parts);
    }
    function validateEndTag(tag, element, selfClosing) {
        var error = void 0;
        if (voidMap[tag.name] && !selfClosing) {
            // EngTag is also called by StartTag for void and self-closing tags (i.e.
            // <input> or <br />, so we need to check for that here. Otherwise, we would
            // throw an error for those cases.
            error = 'Invalid end tag ' + formatEndTagInfo(tag) + ' (void elements cannot have end tags).';
        } else if (element.tag === undefined) {
            error = 'Closing tag ' + formatEndTagInfo(tag) + ' without an open tag.';
        } else if (element.tag !== tag.name) {
            error = 'Closing tag ' + formatEndTagInfo(tag) + ' did not match last open tag `' + element.tag + '` (on line ' + element.loc.start.line + ').';
        }
        if (error) {
            throw new SyntaxError(error, element.loc);
        }
    }
    function formatEndTagInfo(tag) {
        return '`' + tag.name + '` (on line ' + tag.loc.end.line + ')';
    }
    var syntax = {
        parse: preprocess,
        builders: b,
        print: build,
        traverse: traverse,
        Walker: Walker
    };
    function preprocess(html) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var mode = options.mode || 'precompile';
        var ast = void 0;
        if (typeof html === 'object') {
            ast = html;
        } else if (mode === 'codemod') {
            ast = handlebars.parseWithoutProcessing(html, options.parseOptions);
        } else {
            ast = handlebars.parse(html, options.parseOptions);
        }
        var entityParser = undefined;
        if (mode === 'codemod') {
            entityParser = new simpleHtmlTokenizer.EntityParser({});
        }
        var program = new TokenizerEventHandlers(html, entityParser).acceptTemplate(ast);
        if (options && options.plugins && options.plugins.ast) {
            for (var i = 0, l = options.plugins.ast.length; i < l; i++) {
                var transform = options.plugins.ast[i];
                var env = util.assign({}, options, { syntax: syntax }, { plugins: undefined });
                var pluginResult = transform(env);
                traverse(program, pluginResult.visitor);
            }
        }
        return program;
    }



    var nodes = /*#__PURE__*/Object.freeze({

    });

    // used by ember-compiler

    exports.AST = nodes;
    exports.preprocess = preprocess;
    exports.builders = b;
    exports.TraversalError = TraversalError;
    exports.cannotRemoveNode = cannotRemoveNode;
    exports.cannotReplaceNode = cannotReplaceNode;
    exports.cannotReplaceOrRemoveInKeyHandlerYet = cannotReplaceOrRemoveInKeyHandlerYet;
    exports.traverse = traverse;
    exports.Path = Path;
    exports.Walker = Walker;
    exports.print = build;
    exports.SyntaxError = SyntaxError;
    exports.isLiteral = isLiteral;
    exports.printLiteral = printLiteral;

    Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci1zeW50YXguanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvYnVpbGRlcnMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL2Vycm9ycy9zeW50YXgtZXJyb3IudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3V0aWxzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi9wYXJzZXIudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3BhcnNlci9oYW5kbGViYXJzLW5vZGUtdmlzaXRvcnMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3R5cGVzL3Zpc2l0b3Ita2V5cy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvdHJhdmVyc2FsL2Vycm9ycy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvdHJhdmVyc2FsL3BhdGgudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3RyYXZlcnNhbC90cmF2ZXJzZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvZ2VuZXJhdGlvbi91dGlsLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi9nZW5lcmF0aW9uL3ByaW50ZXIudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL2dlbmVyYXRpb24vcHJpbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3RyYXZlcnNhbC93YWxrZXIudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3BhcnNlci90b2tlbml6ZXItZXZlbnQtaGFuZGxlcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQVNUIGZyb20gJy4vdHlwZXMvbm9kZXMnO1xuaW1wb3J0IHsgT3B0aW9uLCBEaWN0IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBkZXByZWNhdGUsIGFzc2lnbiB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgREVWTU9ERSB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcbmltcG9ydCB7IFN0cmluZ0xpdGVyYWwsIEJvb2xlYW5MaXRlcmFsLCBOdW1iZXJMaXRlcmFsIH0gZnJvbSAnLi90eXBlcy9oYW5kbGViYXJzLWFzdCc7XG5cbi8vIFN0YXRlbWVudHNcblxuZXhwb3J0IHR5cGUgQnVpbGRlckhlYWQgPSBzdHJpbmcgfCBBU1QuRXhwcmVzc2lvbjtcbmV4cG9ydCB0eXBlIFRhZ0Rlc2NyaXB0b3IgPSBzdHJpbmcgfCB7IG5hbWU6IHN0cmluZzsgc2VsZkNsb3Npbmc6IGJvb2xlYW4gfTtcblxuZnVuY3Rpb24gYnVpbGRNdXN0YWNoZShcbiAgcGF0aDogQnVpbGRlckhlYWQgfCBBU1QuTGl0ZXJhbCxcbiAgcGFyYW1zPzogQVNULkV4cHJlc3Npb25bXSxcbiAgaGFzaD86IEFTVC5IYXNoLFxuICByYXc/OiBib29sZWFuLFxuICBsb2M/OiBBU1QuU291cmNlTG9jYXRpb24sXG4gIHN0cmlwPzogQVNULlN0cmlwRmxhZ3Ncbik6IEFTVC5NdXN0YWNoZVN0YXRlbWVudCB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXRoID0gYnVpbGRIZWFkKHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnTXVzdGFjaGVTdGF0ZW1lbnQnLFxuICAgIHBhdGgsXG4gICAgcGFyYW1zOiBwYXJhbXMgfHwgW10sXG4gICAgaGFzaDogaGFzaCB8fCBidWlsZEhhc2goW10pLFxuICAgIGVzY2FwZWQ6ICFyYXcsXG4gICAgbG9jOiBidWlsZExvYyhsb2MgfHwgbnVsbCksXG4gICAgc3RyaXA6IHN0cmlwIHx8IHsgb3BlbjogZmFsc2UsIGNsb3NlOiBmYWxzZSB9LFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZEJsb2NrKFxuICBwYXRoOiBCdWlsZGVySGVhZCxcbiAgcGFyYW1zOiBPcHRpb248QVNULkV4cHJlc3Npb25bXT4sXG4gIGhhc2g6IE9wdGlvbjxBU1QuSGFzaD4sXG4gIF9kZWZhdWx0QmxvY2s6IEFTVC5Qb3NzaWJseURlcHJlY2F0ZWRCbG9jayxcbiAgX2Vsc2VCbG9jaz86IE9wdGlvbjxBU1QuUG9zc2libHlEZXByZWNhdGVkQmxvY2s+LFxuICBsb2M/OiBBU1QuU291cmNlTG9jYXRpb24sXG4gIG9wZW5TdHJpcD86IEFTVC5TdHJpcEZsYWdzLFxuICBpbnZlcnNlU3RyaXA/OiBBU1QuU3RyaXBGbGFncyxcbiAgY2xvc2VTdHJpcD86IEFTVC5TdHJpcEZsYWdzXG4pOiBBU1QuQmxvY2tTdGF0ZW1lbnQge1xuICBsZXQgZGVmYXVsdEJsb2NrOiBBU1QuQmxvY2s7XG4gIGxldCBlbHNlQmxvY2s6IE9wdGlvbjxBU1QuQmxvY2s+IHwgdW5kZWZpbmVkO1xuXG4gIGlmIChfZGVmYXVsdEJsb2NrLnR5cGUgPT09ICdUZW1wbGF0ZScpIHtcbiAgICBpZiAoREVWTU9ERSkge1xuICAgICAgZGVwcmVjYXRlKGBiLnByb2dyYW0gaXMgZGVwcmVjYXRlZC4gVXNlIGIuYmxvY2tJdHNlbGYgaW5zdGVhZC5gKTtcbiAgICB9XG5cbiAgICBkZWZhdWx0QmxvY2sgPSAoYXNzaWduKHt9LCBfZGVmYXVsdEJsb2NrLCB7IHR5cGU6ICdCbG9jaycgfSkgYXMgdW5rbm93bikgYXMgQVNULkJsb2NrO1xuICB9IGVsc2Uge1xuICAgIGRlZmF1bHRCbG9jayA9IF9kZWZhdWx0QmxvY2s7XG4gIH1cblxuICBpZiAoX2Vsc2VCbG9jayAhPT0gdW5kZWZpbmVkICYmIF9lbHNlQmxvY2sgIT09IG51bGwgJiYgX2Vsc2VCbG9jay50eXBlID09PSAnVGVtcGxhdGUnKSB7XG4gICAgaWYgKERFVk1PREUpIHtcbiAgICAgIGRlcHJlY2F0ZShgYi5wcm9ncmFtIGlzIGRlcHJlY2F0ZWQuIFVzZSBiLmJsb2NrSXRzZWxmIGluc3RlYWQuYCk7XG4gICAgfVxuXG4gICAgZWxzZUJsb2NrID0gKGFzc2lnbih7fSwgX2Vsc2VCbG9jaywgeyB0eXBlOiAnQmxvY2snIH0pIGFzIHVua25vd24pIGFzIEFTVC5CbG9jaztcbiAgfSBlbHNlIHtcbiAgICBlbHNlQmxvY2sgPSBfZWxzZUJsb2NrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQmxvY2tTdGF0ZW1lbnQnLFxuICAgIHBhdGg6IGJ1aWxkSGVhZChwYXRoKSxcbiAgICBwYXJhbXM6IHBhcmFtcyB8fCBbXSxcbiAgICBoYXNoOiBoYXNoIHx8IGJ1aWxkSGFzaChbXSksXG4gICAgcHJvZ3JhbTogZGVmYXVsdEJsb2NrIHx8IG51bGwsXG4gICAgaW52ZXJzZTogZWxzZUJsb2NrIHx8IG51bGwsXG4gICAgbG9jOiBidWlsZExvYyhsb2MgfHwgbnVsbCksXG4gICAgb3BlblN0cmlwOiBvcGVuU3RyaXAgfHwgeyBvcGVuOiBmYWxzZSwgY2xvc2U6IGZhbHNlIH0sXG4gICAgaW52ZXJzZVN0cmlwOiBpbnZlcnNlU3RyaXAgfHwgeyBvcGVuOiBmYWxzZSwgY2xvc2U6IGZhbHNlIH0sXG4gICAgY2xvc2VTdHJpcDogY2xvc2VTdHJpcCB8fCB7IG9wZW46IGZhbHNlLCBjbG9zZTogZmFsc2UgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRFbGVtZW50TW9kaWZpZXIoXG4gIHBhdGg6IEJ1aWxkZXJIZWFkLFxuICBwYXJhbXM/OiBBU1QuRXhwcmVzc2lvbltdLFxuICBoYXNoPzogQVNULkhhc2gsXG4gIGxvYz86IE9wdGlvbjxBU1QuU291cmNlTG9jYXRpb24+XG4pOiBBU1QuRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50JyxcbiAgICBwYXRoOiBidWlsZEhlYWQocGF0aCksXG4gICAgcGFyYW1zOiBwYXJhbXMgfHwgW10sXG4gICAgaGFzaDogaGFzaCB8fCBidWlsZEhhc2goW10pLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFBhcnRpYWwoXG4gIG5hbWU6IEFTVC5QYXRoRXhwcmVzc2lvbixcbiAgcGFyYW1zPzogQVNULkV4cHJlc3Npb25bXSxcbiAgaGFzaD86IEFTVC5IYXNoLFxuICBpbmRlbnQ/OiBzdHJpbmcsXG4gIGxvYz86IEFTVC5Tb3VyY2VMb2NhdGlvblxuKTogQVNULlBhcnRpYWxTdGF0ZW1lbnQge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdQYXJ0aWFsU3RhdGVtZW50JyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHBhcmFtczogcGFyYW1zIHx8IFtdLFxuICAgIGhhc2g6IGhhc2ggfHwgYnVpbGRIYXNoKFtdKSxcbiAgICBpbmRlbnQ6IGluZGVudCB8fCAnJyxcbiAgICBzdHJpcDogeyBvcGVuOiBmYWxzZSwgY2xvc2U6IGZhbHNlIH0sXG4gICAgbG9jOiBidWlsZExvYyhsb2MgfHwgbnVsbCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQ29tbWVudCh2YWx1ZTogc3RyaW5nLCBsb2M/OiBBU1QuU291cmNlTG9jYXRpb24pOiBBU1QuQ29tbWVudFN0YXRlbWVudCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0NvbW1lbnRTdGF0ZW1lbnQnLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRNdXN0YWNoZUNvbW1lbnQoXG4gIHZhbHVlOiBzdHJpbmcsXG4gIGxvYz86IEFTVC5Tb3VyY2VMb2NhdGlvblxuKTogQVNULk11c3RhY2hlQ29tbWVudFN0YXRlbWVudCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ011c3RhY2hlQ29tbWVudFN0YXRlbWVudCcsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZENvbmNhdChcbiAgcGFydHM6IChBU1QuVGV4dE5vZGUgfCBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpW10sXG4gIGxvYz86IEFTVC5Tb3VyY2VMb2NhdGlvblxuKTogQVNULkNvbmNhdFN0YXRlbWVudCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0NvbmNhdFN0YXRlbWVudCcsXG4gICAgcGFydHM6IHBhcnRzIHx8IFtdLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpLFxuICB9O1xufVxuXG4vLyBOb2Rlc1xuXG5leHBvcnQgdHlwZSBFbGVtZW50QXJncyA9XG4gIHwgWydhdHRycycsIC4uLkF0dHJTZXhwW11dXG4gIHwgWydtb2RpZmllcnMnLCAuLi5Nb2RpZmllclNleHBbXV1cbiAgfCBbJ2JvZHknLCAuLi5BU1QuU3RhdGVtZW50W11dXG4gIHwgWydjb21tZW50cycsIC4uLkVsZW1lbnRDb21tZW50W11dXG4gIHwgWydhcycsIC4uLnN0cmluZ1tdXVxuICB8IFsnbG9jJywgQVNULlNvdXJjZUxvY2F0aW9uXTtcblxuZXhwb3J0IHR5cGUgUGF0aFNleHAgPSBzdHJpbmcgfCBbJ3BhdGgnLCBzdHJpbmcsIExvY1NleHA/XTtcblxuZXhwb3J0IHR5cGUgTW9kaWZpZXJTZXhwID1cbiAgfCBzdHJpbmdcbiAgfCBbUGF0aFNleHAsIExvY1NleHA/XVxuICB8IFtQYXRoU2V4cCwgQVNULkV4cHJlc3Npb25bXSwgTG9jU2V4cD9dXG4gIHwgW1BhdGhTZXhwLCBBU1QuRXhwcmVzc2lvbltdLCBEaWN0PEFTVC5FeHByZXNzaW9uPiwgTG9jU2V4cD9dO1xuXG5leHBvcnQgdHlwZSBBdHRyU2V4cCA9IFtzdHJpbmcsIEFTVC5BdHRyTm9kZVsndmFsdWUnXSB8IHN0cmluZywgTG9jU2V4cD9dO1xuXG5leHBvcnQgdHlwZSBMb2NTZXhwID0gWydsb2MnLCBBU1QuU291cmNlTG9jYXRpb25dO1xuXG5leHBvcnQgdHlwZSBFbGVtZW50Q29tbWVudCA9IEFTVC5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQgfCBBU1QuU291cmNlTG9jYXRpb24gfCBzdHJpbmc7XG5cbmV4cG9ydCB0eXBlIFNleHBWYWx1ZSA9XG4gIHwgc3RyaW5nXG4gIHwgQVNULkV4cHJlc3Npb25bXVxuICB8IERpY3Q8QVNULkV4cHJlc3Npb24+XG4gIHwgTG9jU2V4cFxuICB8IFBhdGhTZXhwXG4gIHwgdW5kZWZpbmVkO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNMb2NTZXhwKHZhbHVlOiBTZXhwVmFsdWUpOiB2YWx1ZSBpcyBMb2NTZXhwIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMiAmJiB2YWx1ZVswXSA9PT0gJ2xvYyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhcmFtc1NleHAodmFsdWU6IFNleHBWYWx1ZSk6IHZhbHVlIGlzIEFTVC5FeHByZXNzaW9uW10ge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgIWlzTG9jU2V4cCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hhc2hTZXhwKHZhbHVlOiBTZXhwVmFsdWUpOiB2YWx1ZSBpcyBEaWN0PEFTVC5FeHByZXNzaW9uPiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGV4cGVjdFR5cGU8RGljdDxBU1QuRXhwcmVzc2lvbj4+KHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhwZWN0VHlwZTxUPihfaW5wdXQ6IFQpOiB2b2lkIHtcbiAgcmV0dXJuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplTW9kaWZpZXIoc2V4cDogTW9kaWZpZXJTZXhwKTogQVNULkVsZW1lbnRNb2RpZmllclN0YXRlbWVudCB7XG4gIGlmICh0eXBlb2Ygc2V4cCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYnVpbGRFbGVtZW50TW9kaWZpZXIoc2V4cCk7XG4gIH1cblxuICBsZXQgcGF0aDogQVNULkV4cHJlc3Npb24gPSBub3JtYWxpemVIZWFkKHNleHBbMF0pO1xuICBsZXQgcGFyYW1zOiBBU1QuRXhwcmVzc2lvbltdIHwgdW5kZWZpbmVkO1xuICBsZXQgaGFzaDogQVNULkhhc2ggfCB1bmRlZmluZWQ7XG4gIGxldCBsb2M6IEFTVC5Tb3VyY2VMb2NhdGlvbiB8IG51bGwgPSBudWxsO1xuXG4gIGxldCBwYXJ0cyA9IHNleHAuc2xpY2UoMSk7XG4gIGxldCBuZXh0ID0gcGFydHMuc2hpZnQoKTtcblxuICBfcHJvY2Vzczoge1xuICAgIGlmIChpc1BhcmFtc1NleHAobmV4dCkpIHtcbiAgICAgIHBhcmFtcyA9IG5leHQgYXMgQVNULkV4cHJlc3Npb25bXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWsgX3Byb2Nlc3M7XG4gICAgfVxuXG4gICAgbmV4dCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoaXNIYXNoU2V4cChuZXh0KSkge1xuICAgICAgaGFzaCA9IG5vcm1hbGl6ZUhhc2gobmV4dCBhcyBEaWN0PEFTVC5FeHByZXNzaW9uPik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrIF9wcm9jZXNzO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0xvY1NleHAobmV4dCkpIHtcbiAgICBsb2MgPSBuZXh0WzFdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50JyxcbiAgICBwYXRoLFxuICAgIHBhcmFtczogcGFyYW1zIHx8IFtdLFxuICAgIGhhc2g6IGhhc2ggfHwgYnVpbGRIYXNoKFtdKSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUF0dHIoc2V4cDogQXR0clNleHApOiBBU1QuQXR0ck5vZGUge1xuICBsZXQgbmFtZSA9IHNleHBbMF07XG4gIGxldCB2YWx1ZTtcblxuICBpZiAodHlwZW9mIHNleHBbMV0gPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSBidWlsZFRleHQoc2V4cFsxXSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBzZXhwWzFdO1xuICB9XG5cbiAgbGV0IGxvYyA9IHNleHBbMl0gPyBzZXhwWzJdWzFdIDogdW5kZWZpbmVkO1xuXG4gIHJldHVybiBidWlsZEF0dHIobmFtZSwgdmFsdWUsIGxvYyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVIYXNoKGhhc2g6IERpY3Q8QVNULkV4cHJlc3Npb24+LCBsb2M/OiBBU1QuU291cmNlTG9jYXRpb24pOiBBU1QuSGFzaCB7XG4gIGxldCBwYWlyczogQVNULkhhc2hQYWlyW10gPSBbXTtcblxuICBPYmplY3Qua2V5cyhoYXNoKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgcGFpcnMucHVzaChidWlsZFBhaXIoa2V5LCBoYXNoW2tleV0pKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGJ1aWxkSGFzaChwYWlycywgbG9jKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWQocGF0aDogUGF0aFNleHApOiBBU1QuRXhwcmVzc2lvbiB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYnVpbGRIZWFkKHBhdGgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWlsZEhlYWQocGF0aFsxXSwgcGF0aFsyXSAmJiBwYXRoWzJdWzFdKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRWxlbWVudE9wdGlvbnMoLi4uYXJnczogRWxlbWVudEFyZ3NbXSk6IEJ1aWxkRWxlbWVudE9wdGlvbnMge1xuICBsZXQgb3V0OiBCdWlsZEVsZW1lbnRPcHRpb25zID0ge307XG5cbiAgZm9yIChsZXQgYXJnIG9mIGFyZ3MpIHtcbiAgICBzd2l0Y2ggKGFyZ1swXSkge1xuICAgICAgY2FzZSAnYXR0cnMnOiB7XG4gICAgICAgIGxldCBbLCAuLi5yZXN0XSA9IGFyZztcbiAgICAgICAgb3V0LmF0dHJzID0gcmVzdC5tYXAobm9ybWFsaXplQXR0cik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnbW9kaWZpZXJzJzoge1xuICAgICAgICBsZXQgWywgLi4ucmVzdF0gPSBhcmc7XG4gICAgICAgIG91dC5tb2RpZmllcnMgPSByZXN0Lm1hcChub3JtYWxpemVNb2RpZmllcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnYm9keSc6IHtcbiAgICAgICAgbGV0IFssIC4uLnJlc3RdID0gYXJnO1xuICAgICAgICBvdXQuY2hpbGRyZW4gPSByZXN0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2NvbW1lbnRzJzoge1xuICAgICAgICBsZXQgWywgLi4ucmVzdF0gPSBhcmc7XG5cbiAgICAgICAgb3V0LmNvbW1lbnRzID0gcmVzdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdhcyc6IHtcbiAgICAgICAgbGV0IFssIC4uLnJlc3RdID0gYXJnO1xuICAgICAgICBvdXQuYmxvY2tQYXJhbXMgPSByZXN0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2xvYyc6IHtcbiAgICAgICAgbGV0IFssIHJlc3RdID0gYXJnO1xuICAgICAgICBvdXQubG9jID0gcmVzdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCdWlsZEVsZW1lbnRPcHRpb25zIHtcbiAgYXR0cnM/OiBBU1QuQXR0ck5vZGVbXTtcbiAgbW9kaWZpZXJzPzogQVNULkVsZW1lbnRNb2RpZmllclN0YXRlbWVudFtdO1xuICBjaGlsZHJlbj86IEFTVC5TdGF0ZW1lbnRbXTtcbiAgY29tbWVudHM/OiBFbGVtZW50Q29tbWVudFtdO1xuICBibG9ja1BhcmFtcz86IHN0cmluZ1tdO1xuICBsb2M/OiBBU1QuU291cmNlTG9jYXRpb247XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRWxlbWVudCh0YWc6IFRhZ0Rlc2NyaXB0b3IsIG9wdGlvbnM/OiBCdWlsZEVsZW1lbnRPcHRpb25zKTogQVNULkVsZW1lbnROb2RlO1xuZnVuY3Rpb24gYnVpbGRFbGVtZW50KHRhZzogVGFnRGVzY3JpcHRvciwgLi4ub3B0aW9uczogRWxlbWVudEFyZ3NbXSk6IEFTVC5FbGVtZW50Tm9kZTtcbmZ1bmN0aW9uIGJ1aWxkRWxlbWVudChcbiAgdGFnOiBUYWdEZXNjcmlwdG9yLFxuICBvcHRpb25zPzogQnVpbGRFbGVtZW50T3B0aW9ucyB8IEVsZW1lbnRBcmdzLFxuICAuLi5yZXN0OiBFbGVtZW50QXJnc1tdXG4pOiBBU1QuRWxlbWVudE5vZGUge1xuICBsZXQgbm9ybWFsaXplZDogQnVpbGRFbGVtZW50T3B0aW9ucztcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICBub3JtYWxpemVkID0gbm9ybWFsaXplRWxlbWVudE9wdGlvbnMob3B0aW9ucywgLi4ucmVzdCk7XG4gIH0gZWxzZSB7XG4gICAgbm9ybWFsaXplZCA9IG9wdGlvbnMgfHwge307XG4gIH1cblxuICBsZXQgeyBhdHRycywgYmxvY2tQYXJhbXMsIG1vZGlmaWVycywgY29tbWVudHMsIGNoaWxkcmVuLCBsb2MgfSA9IG5vcm1hbGl6ZWQ7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIGZvciBiYWNrd2FyZHMgY29tcGF0LCBwcmlvciB0byBgc2VsZkNsb3NpbmdgIGJlaW5nIHBhcnQgb2YgdGhlIEVsZW1lbnROb2RlIEFTVFxuICBsZXQgc2VsZkNsb3NpbmcgPSBmYWxzZTtcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdvYmplY3QnKSB7XG4gICAgc2VsZkNsb3NpbmcgPSB0YWcuc2VsZkNsb3Npbmc7XG4gICAgdGFnID0gdGFnLm5hbWU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRhZy5zbGljZSgtMSkgPT09ICcvJykge1xuICAgICAgdGFnID0gdGFnLnNsaWNlKDAsIC0xKTtcbiAgICAgIHNlbGZDbG9zaW5nID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdFbGVtZW50Tm9kZScsXG4gICAgdGFnOiB0YWcgfHwgJycsXG4gICAgc2VsZkNsb3Npbmc6IHNlbGZDbG9zaW5nLFxuICAgIGF0dHJpYnV0ZXM6IGF0dHJzIHx8IFtdLFxuICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyB8fCBbXSxcbiAgICBtb2RpZmllcnM6IG1vZGlmaWVycyB8fCBbXSxcbiAgICBjb21tZW50czogKGNvbW1lbnRzIGFzIEFTVC5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnRbXSkgfHwgW10sXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuIHx8IFtdLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZEF0dHIoXG4gIG5hbWU6IHN0cmluZyxcbiAgdmFsdWU6IEFTVC5BdHRyTm9kZVsndmFsdWUnXSxcbiAgbG9jPzogQVNULlNvdXJjZUxvY2F0aW9uXG4pOiBBU1QuQXR0ck5vZGUge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdBdHRyTm9kZScsXG4gICAgbmFtZTogbmFtZSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgbG9jOiBidWlsZExvYyhsb2MgfHwgbnVsbCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVGV4dChjaGFycz86IHN0cmluZywgbG9jPzogQVNULlNvdXJjZUxvY2F0aW9uKTogQVNULlRleHROb2RlIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnVGV4dE5vZGUnLFxuICAgIGNoYXJzOiBjaGFycyB8fCAnJyxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuLy8gRXhwcmVzc2lvbnNcblxuZnVuY3Rpb24gYnVpbGRTZXhwcihcbiAgcGF0aDogQnVpbGRlckhlYWQsXG4gIHBhcmFtcz86IEFTVC5FeHByZXNzaW9uW10sXG4gIGhhc2g/OiBBU1QuSGFzaCxcbiAgbG9jPzogQVNULlNvdXJjZUxvY2F0aW9uXG4pOiBBU1QuU3ViRXhwcmVzc2lvbiB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1N1YkV4cHJlc3Npb24nLFxuICAgIHBhdGg6IGJ1aWxkSGVhZChwYXRoKSxcbiAgICBwYXJhbXM6IHBhcmFtcyB8fCBbXSxcbiAgICBoYXNoOiBoYXNoIHx8IGJ1aWxkSGFzaChbXSksXG4gICAgbG9jOiBidWlsZExvYyhsb2MgfHwgbnVsbCksXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkSGVhZChvcmlnaW5hbDogQnVpbGRlckhlYWQsIGxvYz86IEFTVC5Tb3VyY2VMb2NhdGlvbik6IEFTVC5FeHByZXNzaW9uIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ3N0cmluZycpIHJldHVybiBvcmlnaW5hbDtcblxuICBsZXQgcGFydHMgPSBvcmlnaW5hbC5zcGxpdCgnLicpO1xuICBsZXQgdGhpc0hlYWQgPSBmYWxzZTtcblxuICBpZiAocGFydHNbMF0gPT09ICd0aGlzJykge1xuICAgIHRoaXNIZWFkID0gdHJ1ZTtcbiAgICBwYXJ0cyA9IHBhcnRzLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnUGF0aEV4cHJlc3Npb24nLFxuICAgIG9yaWdpbmFsLFxuICAgIHRoaXM6IHRoaXNIZWFkLFxuICAgIHBhcnRzLFxuICAgIGRhdGE6IGZhbHNlLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZExpdGVyYWw8VCBleHRlbmRzIEFTVC5MaXRlcmFsPihcbiAgdHlwZTogVFsndHlwZSddLFxuICB2YWx1ZTogVFsndmFsdWUnXSxcbiAgbG9jPzogQVNULlNvdXJjZUxvY2F0aW9uXG4pOiBUIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIHZhbHVlLFxuICAgIG9yaWdpbmFsOiB2YWx1ZSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfSBhcyBUO1xufVxuXG4vLyBNaXNjZWxsYW5lb3VzXG5cbmZ1bmN0aW9uIGJ1aWxkSGFzaChwYWlycz86IEFTVC5IYXNoUGFpcltdLCBsb2M/OiBBU1QuU291cmNlTG9jYXRpb24pOiBBU1QuSGFzaCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0hhc2gnLFxuICAgIHBhaXJzOiBwYWlycyB8fCBbXSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRQYWlyKGtleTogc3RyaW5nLCB2YWx1ZTogQVNULkV4cHJlc3Npb24sIGxvYz86IEFTVC5Tb3VyY2VMb2NhdGlvbik6IEFTVC5IYXNoUGFpciB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0hhc2hQYWlyJyxcbiAgICBrZXk6IGtleSxcbiAgICB2YWx1ZSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRQcm9ncmFtKFxuICBib2R5PzogQVNULlN0YXRlbWVudFtdLFxuICBibG9ja1BhcmFtcz86IHN0cmluZ1tdLFxuICBsb2M/OiBBU1QuU291cmNlTG9jYXRpb25cbik6IEFTVC5UZW1wbGF0ZSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1RlbXBsYXRlJyxcbiAgICBib2R5OiBib2R5IHx8IFtdLFxuICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyB8fCBbXSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRCbG9ja0l0c2VsZihcbiAgYm9keT86IEFTVC5TdGF0ZW1lbnRbXSxcbiAgYmxvY2tQYXJhbXM/OiBzdHJpbmdbXSxcbiAgY2hhaW5lZCA9IGZhbHNlLFxuICBsb2M/OiBBU1QuU291cmNlTG9jYXRpb25cbik6IEFTVC5CbG9jayB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0Jsb2NrJyxcbiAgICBib2R5OiBib2R5IHx8IFtdLFxuICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyB8fCBbXSxcbiAgICBjaGFpbmVkLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFRlbXBsYXRlKFxuICBib2R5PzogQVNULlN0YXRlbWVudFtdLFxuICBibG9ja1BhcmFtcz86IHN0cmluZ1tdLFxuICBsb2M/OiBBU1QuU291cmNlTG9jYXRpb25cbik6IEFTVC5UZW1wbGF0ZSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1RlbXBsYXRlJyxcbiAgICBib2R5OiBib2R5IHx8IFtdLFxuICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyB8fCBbXSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRTb3VyY2Uoc291cmNlPzogc3RyaW5nKSB7XG4gIHJldHVybiBzb3VyY2UgfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gYnVpbGRQb3NpdGlvbihsaW5lOiBudW1iZXIsIGNvbHVtbjogbnVtYmVyKSB7XG4gIHJldHVybiB7XG4gICAgbGluZSxcbiAgICBjb2x1bW4sXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBTWU5USEVUSUM6IEFTVC5Tb3VyY2VMb2NhdGlvbiA9IHtcbiAgc291cmNlOiAnKHN5bnRoZXRpYyknLFxuICBzdGFydDogeyBsaW5lOiAxLCBjb2x1bW46IDAgfSxcbiAgZW5kOiB7IGxpbmU6IDEsIGNvbHVtbjogMCB9LFxufTtcblxuZnVuY3Rpb24gYnVpbGRMb2MobG9jOiBPcHRpb248QVNULlNvdXJjZUxvY2F0aW9uPik6IEFTVC5Tb3VyY2VMb2NhdGlvbjtcbmZ1bmN0aW9uIGJ1aWxkTG9jKFxuICBzdGFydExpbmU6IG51bWJlcixcbiAgc3RhcnRDb2x1bW46IG51bWJlcixcbiAgZW5kTGluZT86IG51bWJlcixcbiAgZW5kQ29sdW1uPzogbnVtYmVyLFxuICBzb3VyY2U/OiBzdHJpbmdcbik6IEFTVC5Tb3VyY2VMb2NhdGlvbjtcblxuZnVuY3Rpb24gYnVpbGRMb2MoLi4uYXJnczogYW55W10pOiBBU1QuU291cmNlTG9jYXRpb24ge1xuICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICBsZXQgbG9jID0gYXJnc1swXTtcblxuICAgIGlmIChsb2MgJiYgdHlwZW9mIGxvYyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogYnVpbGRTb3VyY2UobG9jLnNvdXJjZSksXG4gICAgICAgIHN0YXJ0OiBidWlsZFBvc2l0aW9uKGxvYy5zdGFydC5saW5lLCBsb2Muc3RhcnQuY29sdW1uKSxcbiAgICAgICAgZW5kOiBidWlsZFBvc2l0aW9uKGxvYy5lbmQubGluZSwgbG9jLmVuZC5jb2x1bW4pLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFNZTlRIRVRJQztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IFtzdGFydExpbmUsIHN0YXJ0Q29sdW1uLCBlbmRMaW5lLCBlbmRDb2x1bW4sIHNvdXJjZV0gPSBhcmdzO1xuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2U6IGJ1aWxkU291cmNlKHNvdXJjZSksXG4gICAgICBzdGFydDogYnVpbGRQb3NpdGlvbihzdGFydExpbmUsIHN0YXJ0Q29sdW1uKSxcbiAgICAgIGVuZDogYnVpbGRQb3NpdGlvbihlbmRMaW5lLCBlbmRDb2x1bW4pLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBtdXN0YWNoZTogYnVpbGRNdXN0YWNoZSxcbiAgYmxvY2s6IGJ1aWxkQmxvY2ssXG4gIHBhcnRpYWw6IGJ1aWxkUGFydGlhbCxcbiAgY29tbWVudDogYnVpbGRDb21tZW50LFxuICBtdXN0YWNoZUNvbW1lbnQ6IGJ1aWxkTXVzdGFjaGVDb21tZW50LFxuICBlbGVtZW50OiBidWlsZEVsZW1lbnQsXG4gIGVsZW1lbnRNb2RpZmllcjogYnVpbGRFbGVtZW50TW9kaWZpZXIsXG4gIGF0dHI6IGJ1aWxkQXR0cixcbiAgdGV4dDogYnVpbGRUZXh0LFxuICBzZXhwcjogYnVpbGRTZXhwcixcbiAgcGF0aDogYnVpbGRIZWFkLFxuICBjb25jYXQ6IGJ1aWxkQ29uY2F0LFxuICBoYXNoOiBidWlsZEhhc2gsXG4gIHBhaXI6IGJ1aWxkUGFpcixcbiAgbGl0ZXJhbDogYnVpbGRMaXRlcmFsLFxuICBwcm9ncmFtOiBidWlsZFByb2dyYW0sXG4gIGJsb2NrSXRzZWxmOiBidWlsZEJsb2NrSXRzZWxmLFxuICB0ZW1wbGF0ZTogYnVpbGRUZW1wbGF0ZSxcbiAgbG9jOiBidWlsZExvYyxcbiAgcG9zOiBidWlsZFBvc2l0aW9uLFxuXG4gIHN0cmluZzogbGl0ZXJhbCgnU3RyaW5nTGl0ZXJhbCcpIGFzICh2YWx1ZTogc3RyaW5nKSA9PiBTdHJpbmdMaXRlcmFsLFxuICBib29sZWFuOiBsaXRlcmFsKCdCb29sZWFuTGl0ZXJhbCcpIGFzICh2YWx1ZTogYm9vbGVhbikgPT4gQm9vbGVhbkxpdGVyYWwsXG4gIG51bWJlcjogbGl0ZXJhbCgnTnVtYmVyTGl0ZXJhbCcpIGFzICh2YWx1ZTogbnVtYmVyKSA9PiBOdW1iZXJMaXRlcmFsLFxuICB1bmRlZmluZWQoKSB7XG4gICAgcmV0dXJuIGJ1aWxkTGl0ZXJhbCgnVW5kZWZpbmVkTGl0ZXJhbCcsIHVuZGVmaW5lZCk7XG4gIH0sXG4gIG51bGwoKSB7XG4gICAgcmV0dXJuIGJ1aWxkTGl0ZXJhbCgnTnVsbExpdGVyYWwnLCBudWxsKTtcbiAgfSxcbn07XG5cbnR5cGUgQnVpbGRMaXRlcmFsPFQgZXh0ZW5kcyBBU1QuTGl0ZXJhbD4gPSAodmFsdWU6IFRbJ3ZhbHVlJ10pID0+IFQ7XG5cbmZ1bmN0aW9uIGxpdGVyYWw8VCBleHRlbmRzIEFTVC5MaXRlcmFsPih0eXBlOiBUWyd0eXBlJ10pOiBCdWlsZExpdGVyYWw8VD4ge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWU6IFRbJ3ZhbHVlJ10pOiBUIHtcbiAgICByZXR1cm4gYnVpbGRMaXRlcmFsKHR5cGUsIHZhbHVlKTtcbiAgfTtcbn1cbiIsImltcG9ydCAqIGFzIEFTVCBmcm9tICcuLi90eXBlcy9ub2Rlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3ludGF4RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGxvY2F0aW9uOiBBU1QuU291cmNlTG9jYXRpb247XG4gIGNvbnN0cnVjdG9yOiBTeW50YXhFcnJvckNvbnN0cnVjdG9yO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN5bnRheEVycm9yQ29uc3RydWN0b3Ige1xuICBuZXcgKG1lc3NhZ2U6IHN0cmluZywgbG9jYXRpb246IEFTVC5Tb3VyY2VMb2NhdGlvbik6IFN5bnRheEVycm9yO1xuICByZWFkb25seSBwcm90b3R5cGU6IFN5bnRheEVycm9yO1xufVxuXG4vKipcbiAqIFN1YmNsYXNzIG9mIGBFcnJvcmAgd2l0aCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiBhYm91dCBsb2NhdGlvbiBvZiBpbmNvcnJlY3QgbWFya3VwLlxuICovXG5jb25zdCBTeW50YXhFcnJvcjogU3ludGF4RXJyb3JDb25zdHJ1Y3RvciA9IChmdW5jdGlvbigpIHtcbiAgU3ludGF4RXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBTeW50YXhFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTeW50YXhFcnJvcjtcblxuICBmdW5jdGlvbiBTeW50YXhFcnJvcih0aGlzOiBTeW50YXhFcnJvciwgbWVzc2FnZTogc3RyaW5nLCBsb2NhdGlvbjogQVNULlNvdXJjZUxvY2F0aW9uKSB7XG4gICAgbGV0IGVycm9yID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgfVxuXG4gIHJldHVybiBTeW50YXhFcnJvciBhcyBhbnk7XG59KSgpO1xuXG5leHBvcnQgZGVmYXVsdCBTeW50YXhFcnJvcjtcbiIsImltcG9ydCAqIGFzIEFTVCBmcm9tICcuL3R5cGVzL25vZGVzJztcbmltcG9ydCAqIGFzIEhCUyBmcm9tICcuL3R5cGVzL2hhbmRsZWJhcnMtYXN0JztcbmltcG9ydCB7IE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IFN5bnRheEVycm9yIGZyb20gJy4vZXJyb3JzL3N5bnRheC1lcnJvcic7XG5cbi8vIFJlZ2V4IHRvIHZhbGlkYXRlIHRoZSBpZGVudGlmaWVyIGZvciBibG9jayBwYXJhbWV0ZXJzLlxuLy8gQmFzZWQgb24gdGhlIElEIHZhbGlkYXRpb24gcmVnZXggaW4gSGFuZGxlYmFycy5cblxubGV0IElEX0lOVkVSU0VfUEFUVEVSTiA9IC9bIVwiIyUtLFxcLlxcLzstPkBcXFstXFxeYFxcey1+XS87XG5cbi8vIENoZWNrcyB0aGUgZWxlbWVudCdzIGF0dHJpYnV0ZXMgdG8gc2VlIGlmIGl0IHVzZXMgYmxvY2sgcGFyYW1zLlxuLy8gSWYgaXQgZG9lcywgcmVnaXN0ZXJzIHRoZSBibG9jayBwYXJhbXMgd2l0aCB0aGUgcHJvZ3JhbSBhbmRcbi8vIHJlbW92ZXMgdGhlIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlcyBmcm9tIHRoZSBlbGVtZW50LlxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFbGVtZW50QmxvY2tQYXJhbXMoZWxlbWVudDogQVNULkVsZW1lbnROb2RlKSB7XG4gIGxldCBwYXJhbXMgPSBwYXJzZUJsb2NrUGFyYW1zKGVsZW1lbnQpO1xuICBpZiAocGFyYW1zKSBlbGVtZW50LmJsb2NrUGFyYW1zID0gcGFyYW1zO1xufVxuXG5mdW5jdGlvbiBwYXJzZUJsb2NrUGFyYW1zKGVsZW1lbnQ6IEFTVC5FbGVtZW50Tm9kZSk6IE9wdGlvbjxzdHJpbmdbXT4ge1xuICBsZXQgbCA9IGVsZW1lbnQuYXR0cmlidXRlcy5sZW5ndGg7XG4gIGxldCBhdHRyTmFtZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIGF0dHJOYW1lcy5wdXNoKGVsZW1lbnQuYXR0cmlidXRlc1tpXS5uYW1lKTtcbiAgfVxuXG4gIGxldCBhc0luZGV4ID0gYXR0ck5hbWVzLmluZGV4T2YoJ2FzJyk7XG5cbiAgaWYgKGFzSW5kZXggIT09IC0xICYmIGwgPiBhc0luZGV4ICYmIGF0dHJOYW1lc1thc0luZGV4ICsgMV0uY2hhckF0KDApID09PSAnfCcpIHtcbiAgICAvLyBTb21lIGJhc2ljIHZhbGlkYXRpb24sIHNpbmNlIHdlJ3JlIGRvaW5nIHRoZSBwYXJzaW5nIG91cnNlbHZlc1xuICAgIGxldCBwYXJhbXNTdHJpbmcgPSBhdHRyTmFtZXMuc2xpY2UoYXNJbmRleCkuam9pbignICcpO1xuICAgIGlmIChcbiAgICAgIHBhcmFtc1N0cmluZy5jaGFyQXQocGFyYW1zU3RyaW5nLmxlbmd0aCAtIDEpICE9PSAnfCcgfHxcbiAgICAgIHBhcmFtc1N0cmluZy5tYXRjaCgvXFx8L2cpIS5sZW5ndGggIT09IDJcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkludmFsaWQgYmxvY2sgcGFyYW1ldGVycyBzeW50YXg6ICdcIiArIHBhcmFtc1N0cmluZyArIFwiJ1wiLCBlbGVtZW50LmxvYyk7XG4gICAgfVxuXG4gICAgbGV0IHBhcmFtcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBhc0luZGV4ICsgMTsgaSA8IGw7IGkrKykge1xuICAgICAgbGV0IHBhcmFtID0gYXR0ck5hbWVzW2ldLnJlcGxhY2UoL1xcfC9nLCAnJyk7XG4gICAgICBpZiAocGFyYW0gIT09ICcnKSB7XG4gICAgICAgIGlmIChJRF9JTlZFUlNFX1BBVFRFUk4udGVzdChwYXJhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgaWRlbnRpZmllciBmb3IgYmxvY2sgcGFyYW1ldGVyczogJ1wiICsgcGFyYW0gKyBcIicgaW4gJ1wiICsgcGFyYW1zU3RyaW5nICsgXCInXCIsXG4gICAgICAgICAgICBlbGVtZW50LmxvY1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IHVzZSB6ZXJvIGJsb2NrIHBhcmFtZXRlcnM6ICdcIiArIHBhcmFtc1N0cmluZyArIFwiJ1wiLFxuICAgICAgICBlbGVtZW50LmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBlbGVtZW50LmF0dHJpYnV0ZXMgPSBlbGVtZW50LmF0dHJpYnV0ZXMuc2xpY2UoMCwgYXNJbmRleCk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hpbGRyZW5Gb3IoXG4gIG5vZGU6IEFTVC5CbG9jayB8IEFTVC5UZW1wbGF0ZSB8IEFTVC5FbGVtZW50Tm9kZVxuKTogQVNULlRvcExldmVsU3RhdGVtZW50W10ge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgJ0Jsb2NrJzpcbiAgICBjYXNlICdUZW1wbGF0ZSc6XG4gICAgICByZXR1cm4gbm9kZS5ib2R5O1xuICAgIGNhc2UgJ0VsZW1lbnROb2RlJzpcbiAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRDaGlsZChcbiAgcGFyZW50OiBBU1QuQmxvY2sgfCBBU1QuVGVtcGxhdGUgfCBBU1QuRWxlbWVudE5vZGUsXG4gIG5vZGU6IEFTVC5TdGF0ZW1lbnRcbikge1xuICBjaGlsZHJlbkZvcihwYXJlbnQpLnB1c2gobm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xpdGVyYWwocGF0aDogSEJTLkV4cHJlc3Npb24pOiBwYXRoIGlzIEhCUy5MaXRlcmFsO1xuZXhwb3J0IGZ1bmN0aW9uIGlzTGl0ZXJhbChwYXRoOiBBU1QuRXhwcmVzc2lvbik6IHBhdGggaXMgQVNULkxpdGVyYWw7XG5leHBvcnQgZnVuY3Rpb24gaXNMaXRlcmFsKFxuICBwYXRoOiBIQlMuRXhwcmVzc2lvbiB8IEFTVC5FeHByZXNzaW9uXG4pOiBwYXRoIGlzIEhCUy5MaXRlcmFsIHwgQVNULkxpdGVyYWwge1xuICByZXR1cm4gKFxuICAgIHBhdGgudHlwZSA9PT0gJ1N0cmluZ0xpdGVyYWwnIHx8XG4gICAgcGF0aC50eXBlID09PSAnQm9vbGVhbkxpdGVyYWwnIHx8XG4gICAgcGF0aC50eXBlID09PSAnTnVtYmVyTGl0ZXJhbCcgfHxcbiAgICBwYXRoLnR5cGUgPT09ICdOdWxsTGl0ZXJhbCcgfHxcbiAgICBwYXRoLnR5cGUgPT09ICdVbmRlZmluZWRMaXRlcmFsJ1xuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRMaXRlcmFsKGxpdGVyYWw6IEFTVC5MaXRlcmFsKTogc3RyaW5nIHtcbiAgaWYgKGxpdGVyYWwudHlwZSA9PT0gJ1VuZGVmaW5lZExpdGVyYWwnKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShsaXRlcmFsLnZhbHVlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgRXZlbnRlZFRva2VuaXplcixcbiAgRW50aXR5UGFyc2VyLFxuICBIVE1MNU5hbWVkQ2hhclJlZnMgYXMgbmFtZWRDaGFyUmVmcyxcbn0gZnJvbSAnc2ltcGxlLWh0bWwtdG9rZW5pemVyJztcbmltcG9ydCAqIGFzIEFTVCBmcm9tICcuL3R5cGVzL25vZGVzJztcbmltcG9ydCAqIGFzIEhCUyBmcm9tICcuL3R5cGVzL2hhbmRsZWJhcnMtYXN0JztcbmltcG9ydCB7IE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzZXJ0LCBleHBlY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcblxuZXhwb3J0IHR5cGUgRWxlbWVudCA9IEFTVC5UZW1wbGF0ZSB8IEFTVC5CbG9jayB8IEFTVC5FbGVtZW50Tm9kZTtcblxuZXhwb3J0IGludGVyZmFjZSBUYWc8VCBleHRlbmRzICdTdGFydFRhZycgfCAnRW5kVGFnJz4ge1xuICB0eXBlOiBUO1xuICBuYW1lOiBzdHJpbmc7XG4gIGF0dHJpYnV0ZXM6IGFueVtdO1xuICBtb2RpZmllcnM6IGFueVtdO1xuICBjb21tZW50czogYW55W107XG4gIHNlbGZDbG9zaW5nOiBib29sZWFuO1xuICBsb2M6IEFTVC5Tb3VyY2VMb2NhdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRyaWJ1dGUge1xuICBuYW1lOiBzdHJpbmc7XG4gIHBhcnRzOiAoQVNULk11c3RhY2hlU3RhdGVtZW50IHwgQVNULlRleHROb2RlKVtdO1xuICBpc1F1b3RlZDogYm9vbGVhbjtcbiAgaXNEeW5hbWljOiBib29sZWFuO1xuICBzdGFydDogQVNULlBvc2l0aW9uO1xuICB2YWx1ZVN0YXJ0TGluZTogbnVtYmVyO1xuICB2YWx1ZVN0YXJ0Q29sdW1uOiBudW1iZXI7XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQYXJzZXIge1xuICBwcm90ZWN0ZWQgZWxlbWVudFN0YWNrOiBFbGVtZW50W10gPSBbXTtcbiAgcHJpdmF0ZSBzb3VyY2U6IHN0cmluZ1tdO1xuICBwdWJsaWMgY3VycmVudEF0dHJpYnV0ZTogT3B0aW9uPEF0dHJpYnV0ZT4gPSBudWxsO1xuICBwdWJsaWMgY3VycmVudE5vZGU6IE9wdGlvbjxcbiAgICBBU1QuQ29tbWVudFN0YXRlbWVudCB8IEFTVC5UZXh0Tm9kZSB8IFRhZzwnU3RhcnRUYWcnIHwgJ0VuZFRhZyc+XG4gID4gPSBudWxsO1xuICBwdWJsaWMgdG9rZW5pemVyOiBFdmVudGVkVG9rZW5pemVyO1xuXG4gIGNvbnN0cnVjdG9yKHNvdXJjZTogc3RyaW5nLCBlbnRpdHlQYXJzZXIgPSBuZXcgRW50aXR5UGFyc2VyKG5hbWVkQ2hhclJlZnMpKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2Uuc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcbiAgICB0aGlzLnRva2VuaXplciA9IG5ldyBFdmVudGVkVG9rZW5pemVyKHRoaXMsIGVudGl0eVBhcnNlcik7XG4gIH1cblxuICBhYnN0cmFjdCBQcm9ncmFtKG5vZGU6IEhCUy5Qcm9ncmFtKTogSEJTLk91dHB1dDwnUHJvZ3JhbSc+O1xuICBhYnN0cmFjdCBNdXN0YWNoZVN0YXRlbWVudChub2RlOiBIQlMuTXVzdGFjaGVTdGF0ZW1lbnQpOiBIQlMuT3V0cHV0PCdNdXN0YWNoZVN0YXRlbWVudCc+O1xuICBhYnN0cmFjdCBEZWNvcmF0b3Iobm9kZTogSEJTLkRlY29yYXRvcik6IEhCUy5PdXRwdXQ8J0RlY29yYXRvcic+O1xuICBhYnN0cmFjdCBCbG9ja1N0YXRlbWVudChub2RlOiBIQlMuQmxvY2tTdGF0ZW1lbnQpOiBIQlMuT3V0cHV0PCdCbG9ja1N0YXRlbWVudCc+O1xuICBhYnN0cmFjdCBEZWNvcmF0b3JCbG9jayhub2RlOiBIQlMuRGVjb3JhdG9yQmxvY2spOiBIQlMuT3V0cHV0PCdEZWNvcmF0b3JCbG9jayc+O1xuICBhYnN0cmFjdCBQYXJ0aWFsU3RhdGVtZW50KG5vZGU6IEhCUy5QYXJ0aWFsU3RhdGVtZW50KTogSEJTLk91dHB1dDwnUGFydGlhbFN0YXRlbWVudCc+O1xuICBhYnN0cmFjdCBQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQoXG4gICAgbm9kZTogSEJTLlBhcnRpYWxCbG9ja1N0YXRlbWVudFxuICApOiBIQlMuT3V0cHV0PCdQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQnPjtcbiAgYWJzdHJhY3QgQ29udGVudFN0YXRlbWVudChub2RlOiBIQlMuQ29udGVudFN0YXRlbWVudCk6IEhCUy5PdXRwdXQ8J0NvbnRlbnRTdGF0ZW1lbnQnPjtcbiAgYWJzdHJhY3QgQ29tbWVudFN0YXRlbWVudChub2RlOiBIQlMuQ29tbWVudFN0YXRlbWVudCk6IEhCUy5PdXRwdXQ8J0NvbW1lbnRTdGF0ZW1lbnQnPjtcbiAgYWJzdHJhY3QgU3ViRXhwcmVzc2lvbihub2RlOiBIQlMuU3ViRXhwcmVzc2lvbik6IEhCUy5PdXRwdXQ8J1N1YkV4cHJlc3Npb24nPjtcbiAgYWJzdHJhY3QgUGF0aEV4cHJlc3Npb24obm9kZTogSEJTLlBhdGhFeHByZXNzaW9uKTogSEJTLk91dHB1dDwnUGF0aEV4cHJlc3Npb24nPjtcbiAgYWJzdHJhY3QgU3RyaW5nTGl0ZXJhbChub2RlOiBIQlMuU3RyaW5nTGl0ZXJhbCk6IEhCUy5PdXRwdXQ8J1N0cmluZ0xpdGVyYWwnPjtcbiAgYWJzdHJhY3QgQm9vbGVhbkxpdGVyYWwobm9kZTogSEJTLkJvb2xlYW5MaXRlcmFsKTogSEJTLk91dHB1dDwnQm9vbGVhbkxpdGVyYWwnPjtcbiAgYWJzdHJhY3QgTnVtYmVyTGl0ZXJhbChub2RlOiBIQlMuTnVtYmVyTGl0ZXJhbCk6IEhCUy5PdXRwdXQ8J051bWJlckxpdGVyYWwnPjtcbiAgYWJzdHJhY3QgVW5kZWZpbmVkTGl0ZXJhbChub2RlOiBIQlMuVW5kZWZpbmVkTGl0ZXJhbCk6IEhCUy5PdXRwdXQ8J1VuZGVmaW5lZExpdGVyYWwnPjtcbiAgYWJzdHJhY3QgTnVsbExpdGVyYWwobm9kZTogSEJTLk51bGxMaXRlcmFsKTogSEJTLk91dHB1dDwnTnVsbExpdGVyYWwnPjtcblxuICBhYnN0cmFjdCByZXNldCgpOiB2b2lkO1xuICBhYnN0cmFjdCBmaW5pc2hEYXRhKCk6IHZvaWQ7XG4gIGFic3RyYWN0IHRhZ09wZW4oKTogdm9pZDtcbiAgYWJzdHJhY3QgYmVnaW5EYXRhKCk6IHZvaWQ7XG4gIGFic3RyYWN0IGFwcGVuZFRvRGF0YShjaGFyOiBzdHJpbmcpOiB2b2lkO1xuICBhYnN0cmFjdCBiZWdpblN0YXJ0VGFnKCk6IHZvaWQ7XG4gIGFic3RyYWN0IGFwcGVuZFRvVGFnTmFtZShjaGFyOiBzdHJpbmcpOiB2b2lkO1xuICBhYnN0cmFjdCBiZWdpbkF0dHJpYnV0ZSgpOiB2b2lkO1xuICBhYnN0cmFjdCBhcHBlbmRUb0F0dHJpYnV0ZU5hbWUoY2hhcjogc3RyaW5nKTogdm9pZDtcbiAgYWJzdHJhY3QgYmVnaW5BdHRyaWJ1dGVWYWx1ZShxdW90ZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICBhYnN0cmFjdCBhcHBlbmRUb0F0dHJpYnV0ZVZhbHVlKGNoYXI6IHN0cmluZyk6IHZvaWQ7XG4gIGFic3RyYWN0IGZpbmlzaEF0dHJpYnV0ZVZhbHVlKCk6IHZvaWQ7XG4gIGFic3RyYWN0IG1hcmtUYWdBc1NlbGZDbG9zaW5nKCk6IHZvaWQ7XG4gIGFic3RyYWN0IGJlZ2luRW5kVGFnKCk6IHZvaWQ7XG4gIGFic3RyYWN0IGZpbmlzaFRhZygpOiB2b2lkO1xuICBhYnN0cmFjdCBiZWdpbkNvbW1lbnQoKTogdm9pZDtcbiAgYWJzdHJhY3QgYXBwZW5kVG9Db21tZW50RGF0YShjaGFyOiBzdHJpbmcpOiB2b2lkO1xuICBhYnN0cmFjdCBmaW5pc2hDb21tZW50KCk6IHZvaWQ7XG4gIGFic3RyYWN0IHJlcG9ydFN5bnRheEVycm9yKGVycm9yOiBzdHJpbmcpOiB2b2lkO1xuXG4gIGdldCBjdXJyZW50QXR0cigpOiBBdHRyaWJ1dGUge1xuICAgIHJldHVybiBleHBlY3QodGhpcy5jdXJyZW50QXR0cmlidXRlLCAnZXhwZWN0ZWQgYXR0cmlidXRlJyk7XG4gIH1cblxuICBnZXQgY3VycmVudFRhZygpOiBUYWc8J1N0YXJ0VGFnJyB8ICdFbmRUYWcnPiB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgIGFzc2VydChub2RlICYmIChub2RlLnR5cGUgPT09ICdTdGFydFRhZycgfHwgbm9kZS50eXBlID09PSAnRW5kVGFnJyksICdleHBlY3RlZCB0YWcnKTtcbiAgICByZXR1cm4gbm9kZSBhcyBUYWc8J1N0YXJ0VGFnJyB8ICdFbmRUYWcnPjtcbiAgfVxuXG4gIGdldCBjdXJyZW50U3RhcnRUYWcoKTogVGFnPCdTdGFydFRhZyc+IHtcbiAgICBsZXQgbm9kZSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgYXNzZXJ0KG5vZGUgJiYgbm9kZS50eXBlID09PSAnU3RhcnRUYWcnLCAnZXhwZWN0ZWQgc3RhcnQgdGFnJyk7XG4gICAgcmV0dXJuIG5vZGUgYXMgVGFnPCdTdGFydFRhZyc+O1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRFbmRUYWcoKTogVGFnPCdFbmRUYWcnPiB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgIGFzc2VydChub2RlICYmIG5vZGUudHlwZSA9PT0gJ0VuZFRhZycsICdleHBlY3RlZCBlbmQgdGFnJyk7XG4gICAgcmV0dXJuIG5vZGUgYXMgVGFnPCdFbmRUYWcnPjtcbiAgfVxuXG4gIGdldCBjdXJyZW50Q29tbWVudCgpOiBBU1QuQ29tbWVudFN0YXRlbWVudCB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgIGFzc2VydChub2RlICYmIG5vZGUudHlwZSA9PT0gJ0NvbW1lbnRTdGF0ZW1lbnQnLCAnZXhwZWN0ZWQgYSBjb21tZW50Jyk7XG4gICAgcmV0dXJuIG5vZGUgYXMgQVNULkNvbW1lbnRTdGF0ZW1lbnQ7XG4gIH1cblxuICBnZXQgY3VycmVudERhdGEoKTogQVNULlRleHROb2RlIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgYXNzZXJ0KG5vZGUgJiYgbm9kZS50eXBlID09PSAnVGV4dE5vZGUnLCAnZXhwZWN0ZWQgYSB0ZXh0IG5vZGUnKTtcbiAgICByZXR1cm4gbm9kZSBhcyBBU1QuVGV4dE5vZGU7XG4gIH1cblxuICBhY2NlcHRUZW1wbGF0ZShub2RlOiBIQlMuUHJvZ3JhbSk6IEFTVC5UZW1wbGF0ZSB7XG4gICAgcmV0dXJuICh0aGlzIGFzIGFueSlbbm9kZS50eXBlXShub2RlKSBhcyBBU1QuVGVtcGxhdGU7XG4gIH1cblxuICBhY2NlcHROb2RlKG5vZGU6IEhCUy5Qcm9ncmFtKTogQVNULkJsb2NrIHwgQVNULlRlbXBsYXRlO1xuICBhY2NlcHROb2RlPFUgZXh0ZW5kcyBIQlMuTm9kZSB8IEFTVC5Ob2RlPihub2RlOiBIQlMuTm9kZSk6IFU7XG4gIGFjY2VwdE5vZGUobm9kZTogSEJTLk5vZGUpOiBhbnkge1xuICAgIHJldHVybiAodGhpcyBhcyBhbnkpW25vZGUudHlwZV0obm9kZSk7XG4gIH1cblxuICBjdXJyZW50RWxlbWVudCgpOiBFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50U3RhY2tbdGhpcy5lbGVtZW50U3RhY2subGVuZ3RoIC0gMV07XG4gIH1cblxuICBzb3VyY2VGb3JOb2RlKG5vZGU6IEhCUy5Ob2RlLCBlbmROb2RlPzogeyBsb2M6IEhCUy5Tb3VyY2VMb2NhdGlvbiB9KTogc3RyaW5nIHtcbiAgICBsZXQgZmlyc3RMaW5lID0gbm9kZS5sb2Muc3RhcnQubGluZSAtIDE7XG4gICAgbGV0IGN1cnJlbnRMaW5lID0gZmlyc3RMaW5lIC0gMTtcbiAgICBsZXQgZmlyc3RDb2x1bW4gPSBub2RlLmxvYy5zdGFydC5jb2x1bW47XG4gICAgbGV0IHN0cmluZyA9IFtdO1xuICAgIGxldCBsaW5lO1xuXG4gICAgbGV0IGxhc3RMaW5lOiBudW1iZXI7XG4gICAgbGV0IGxhc3RDb2x1bW46IG51bWJlcjtcblxuICAgIGlmIChlbmROb2RlKSB7XG4gICAgICBsYXN0TGluZSA9IGVuZE5vZGUubG9jLmVuZC5saW5lIC0gMTtcbiAgICAgIGxhc3RDb2x1bW4gPSBlbmROb2RlLmxvYy5lbmQuY29sdW1uO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0TGluZSA9IG5vZGUubG9jLmVuZC5saW5lIC0gMTtcbiAgICAgIGxhc3RDb2x1bW4gPSBub2RlLmxvYy5lbmQuY29sdW1uO1xuICAgIH1cblxuICAgIHdoaWxlIChjdXJyZW50TGluZSA8IGxhc3RMaW5lKSB7XG4gICAgICBjdXJyZW50TGluZSsrO1xuICAgICAgbGluZSA9IHRoaXMuc291cmNlW2N1cnJlbnRMaW5lXTtcblxuICAgICAgaWYgKGN1cnJlbnRMaW5lID09PSBmaXJzdExpbmUpIHtcbiAgICAgICAgaWYgKGZpcnN0TGluZSA9PT0gbGFzdExpbmUpIHtcbiAgICAgICAgICBzdHJpbmcucHVzaChsaW5lLnNsaWNlKGZpcnN0Q29sdW1uLCBsYXN0Q29sdW1uKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyaW5nLnB1c2gobGluZS5zbGljZShmaXJzdENvbHVtbikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRMaW5lID09PSBsYXN0TGluZSkge1xuICAgICAgICBzdHJpbmcucHVzaChsaW5lLnNsaWNlKDAsIGxhc3RDb2x1bW4pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmluZy5wdXNoKGxpbmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmcuam9pbignXFxuJyk7XG4gIH1cbn1cbiIsImltcG9ydCBiIGZyb20gJy4uL2J1aWxkZXJzJztcbmltcG9ydCB7IGFwcGVuZENoaWxkLCBpc0xpdGVyYWwsIHByaW50TGl0ZXJhbCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCAqIGFzIEFTVCBmcm9tICcuLi90eXBlcy9ub2Rlcyc7XG5pbXBvcnQgKiBhcyBIQlMgZnJvbSAnLi4vdHlwZXMvaGFuZGxlYmFycy1hc3QnO1xuaW1wb3J0IHsgUGFyc2VyLCBUYWcsIEF0dHJpYnV0ZSB9IGZyb20gJy4uL3BhcnNlcic7XG5pbXBvcnQgU3ludGF4RXJyb3IgZnJvbSAnLi4vZXJyb3JzL3N5bnRheC1lcnJvcic7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IFJlY2FzdCB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgVG9rZW5pemVyU3RhdGUgfSBmcm9tICdzaW1wbGUtaHRtbC10b2tlbml6ZXInO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSGFuZGxlYmFyc05vZGVWaXNpdG9ycyBleHRlbmRzIFBhcnNlciB7XG4gIGFic3RyYWN0IGFwcGVuZFRvQ29tbWVudERhdGEoczogc3RyaW5nKTogdm9pZDtcbiAgYWJzdHJhY3QgYmVnaW5BdHRyaWJ1dGVWYWx1ZShxdW90ZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICBhYnN0cmFjdCBmaW5pc2hBdHRyaWJ1dGVWYWx1ZSgpOiB2b2lkO1xuXG4gIGN1cnNvckNvdW50ID0gMDtcblxuICBjdXJzb3IoKSB7XG4gICAgcmV0dXJuIGAlY3Vyc29yOiR7dGhpcy5jdXJzb3JDb3VudCsrfSVgO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgaXNUb3BMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50U3RhY2subGVuZ3RoID09PSAwO1xuICB9XG5cbiAgUHJvZ3JhbShwcm9ncmFtOiBIQlMuUHJvZ3JhbSk6IEFTVC5CbG9jaztcbiAgUHJvZ3JhbShwcm9ncmFtOiBIQlMuUHJvZ3JhbSk6IEFTVC5UZW1wbGF0ZTtcbiAgUHJvZ3JhbShwcm9ncmFtOiBIQlMuUHJvZ3JhbSk6IEFTVC5UZW1wbGF0ZSB8IEFTVC5CbG9jaztcbiAgUHJvZ3JhbShwcm9ncmFtOiBIQlMuUHJvZ3JhbSk6IEFTVC5CbG9jayB8IEFTVC5UZW1wbGF0ZSB7XG4gICAgbGV0IGJvZHk6IEFTVC5TdGF0ZW1lbnRbXSA9IFtdO1xuICAgIHRoaXMuY3Vyc29yQ291bnQgPSAwO1xuXG4gICAgbGV0IG5vZGU7XG5cbiAgICBpZiAodGhpcy5pc1RvcExldmVsKSB7XG4gICAgICBub2RlID0gYi50ZW1wbGF0ZShib2R5LCBwcm9ncmFtLmJsb2NrUGFyYW1zLCBwcm9ncmFtLmxvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBiLmJsb2NrSXRzZWxmKGJvZHksIHByb2dyYW0uYmxvY2tQYXJhbXMsIHByb2dyYW0uY2hhaW5lZCwgcHJvZ3JhbS5sb2MpO1xuICAgIH1cblxuICAgIGxldCBpLFxuICAgICAgbCA9IHByb2dyYW0uYm9keS5sZW5ndGg7XG5cbiAgICB0aGlzLmVsZW1lbnRTdGFjay5wdXNoKG5vZGUpO1xuXG4gICAgaWYgKGwgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRTdGFjay5wb3AoKSBhcyBBU1QuQmxvY2sgfCBBU1QuVGVtcGxhdGU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5hY2NlcHROb2RlKHByb2dyYW0uYm9keVtpXSk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhhdCB0aGUgZWxlbWVudCBzdGFjayBpcyBiYWxhbmNlZCBwcm9wZXJseS5cbiAgICBsZXQgcG9wcGVkTm9kZSA9IHRoaXMuZWxlbWVudFN0YWNrLnBvcCgpO1xuICAgIGlmIChwb3BwZWROb2RlICE9PSBub2RlKSB7XG4gICAgICBsZXQgZWxlbWVudE5vZGUgPSBwb3BwZWROb2RlIGFzIEFTVC5FbGVtZW50Tm9kZTtcblxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAnVW5jbG9zZWQgZWxlbWVudCBgJyArIGVsZW1lbnROb2RlLnRhZyArICdgIChvbiBsaW5lICcgKyBlbGVtZW50Tm9kZS5sb2MhLnN0YXJ0LmxpbmUgKyAnKS4nLFxuICAgICAgICBlbGVtZW50Tm9kZS5sb2NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBCbG9ja1N0YXRlbWVudChibG9jazogSEJTLkJsb2NrU3RhdGVtZW50KTogQVNULkJsb2NrU3RhdGVtZW50IHwgdm9pZCB7XG4gICAgaWYgKHRoaXMudG9rZW5pemVyWydzdGF0ZSddID09PSAnY29tbWVudCcpIHtcbiAgICAgIHRoaXMuYXBwZW5kVG9Db21tZW50RGF0YSh0aGlzLnNvdXJjZUZvck5vZGUoYmxvY2spKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnRva2VuaXplclsnc3RhdGUnXSAhPT0gJ2NvbW1lbnQnICYmXG4gICAgICB0aGlzLnRva2VuaXplclsnc3RhdGUnXSAhPT0gJ2RhdGEnICYmXG4gICAgICB0aGlzLnRva2VuaXplclsnc3RhdGUnXSAhPT0gJ2JlZm9yZURhdGEnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICdBIGJsb2NrIG1heSBvbmx5IGJlIHVzZWQgaW5zaWRlIGFuIEhUTUwgZWxlbWVudCBvciBhbm90aGVyIGJsb2NrLicsXG4gICAgICAgIGJsb2NrLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IGFjY2VwdENhbGxOb2Rlcyh0aGlzLCBibG9jayk7XG4gICAgbGV0IHByb2dyYW0gPSB0aGlzLlByb2dyYW0oYmxvY2sucHJvZ3JhbSk7XG4gICAgbGV0IGludmVyc2UgPSBibG9jay5pbnZlcnNlID8gdGhpcy5Qcm9ncmFtKGJsb2NrLmludmVyc2UpIDogbnVsbDtcblxuICAgIGlmIChwYXRoLm9yaWdpbmFsID09PSAnaW4tZWxlbWVudCcpIHtcbiAgICAgIGhhc2ggPSBhZGRJbkVsZW1lbnRIYXNoKHRoaXMuY3Vyc29yKCksIGhhc2gsIGJsb2NrLmxvYyk7XG4gICAgfVxuXG4gICAgbGV0IG5vZGUgPSBiLmJsb2NrKFxuICAgICAgcGF0aCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIGhhc2gsXG4gICAgICBwcm9ncmFtLFxuICAgICAgaW52ZXJzZSxcbiAgICAgIGJsb2NrLmxvYyxcbiAgICAgIGJsb2NrLm9wZW5TdHJpcCxcbiAgICAgIGJsb2NrLmludmVyc2VTdHJpcCxcbiAgICAgIGJsb2NrLmNsb3NlU3RyaXBcbiAgICApO1xuXG4gICAgbGV0IHBhcmVudFByb2dyYW0gPSB0aGlzLmN1cnJlbnRFbGVtZW50KCk7XG5cbiAgICBhcHBlbmRDaGlsZChwYXJlbnRQcm9ncmFtLCBub2RlKTtcbiAgfVxuXG4gIE11c3RhY2hlU3RhdGVtZW50KHJhd011c3RhY2hlOiBIQlMuTXVzdGFjaGVTdGF0ZW1lbnQpOiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQgfCB2b2lkIHtcbiAgICBsZXQgeyB0b2tlbml6ZXIgfSA9IHRoaXM7XG5cbiAgICBpZiAodG9rZW5pemVyLnN0YXRlID09PSAnY29tbWVudCcpIHtcbiAgICAgIHRoaXMuYXBwZW5kVG9Db21tZW50RGF0YSh0aGlzLnNvdXJjZUZvck5vZGUocmF3TXVzdGFjaGUpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbXVzdGFjaGU6IEFTVC5NdXN0YWNoZVN0YXRlbWVudDtcbiAgICBsZXQgeyBlc2NhcGVkLCBsb2MsIHN0cmlwIH0gPSByYXdNdXN0YWNoZTtcblxuICAgIGlmIChpc0xpdGVyYWwocmF3TXVzdGFjaGUucGF0aCkpIHtcbiAgICAgIG11c3RhY2hlID0ge1xuICAgICAgICB0eXBlOiAnTXVzdGFjaGVTdGF0ZW1lbnQnLFxuICAgICAgICBwYXRoOiB0aGlzLmFjY2VwdE5vZGU8QVNULkxpdGVyYWw+KHJhd011c3RhY2hlLnBhdGgpLFxuICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICBoYXNoOiBiLmhhc2goKSxcbiAgICAgICAgZXNjYXBlZCxcbiAgICAgICAgbG9jLFxuICAgICAgICBzdHJpcCxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCB9ID0gYWNjZXB0Q2FsbE5vZGVzKHRoaXMsIHJhd011c3RhY2hlIGFzIEhCUy5NdXN0YWNoZVN0YXRlbWVudCAmIHtcbiAgICAgICAgcGF0aDogSEJTLlBhdGhFeHByZXNzaW9uO1xuICAgICAgfSk7XG4gICAgICBtdXN0YWNoZSA9IGIubXVzdGFjaGUocGF0aCwgcGFyYW1zLCBoYXNoLCAhZXNjYXBlZCwgbG9jLCBzdHJpcCk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0b2tlbml6ZXIuc3RhdGUpIHtcbiAgICAgIC8vIFRhZyBoZWxwZXJzXG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLnRhZ09wZW46XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLnRhZ05hbWU6XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICBgQ2Fubm90IHVzZSBtdXN0YWNoZXMgaW4gYW4gZWxlbWVudHMgdGFnbmFtZTogXFxgJHt0aGlzLnNvdXJjZUZvck5vZGUoXG4gICAgICAgICAgICByYXdNdXN0YWNoZSxcbiAgICAgICAgICAgIHJhd011c3RhY2hlLnBhdGhcbiAgICAgICAgICApfVxcYCBhdCBMJHtsb2Muc3RhcnQubGluZX06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gLFxuICAgICAgICAgIG11c3RhY2hlLmxvY1xuICAgICAgICApO1xuXG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZU5hbWU6XG4gICAgICAgIGFkZEVsZW1lbnRNb2RpZmllcih0aGlzLmN1cnJlbnRTdGFydFRhZywgbXVzdGFjaGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYXR0cmlidXRlTmFtZTpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYWZ0ZXJBdHRyaWJ1dGVOYW1lOlxuICAgICAgICB0aGlzLmJlZ2luQXR0cmlidXRlVmFsdWUoZmFsc2UpO1xuICAgICAgICB0aGlzLmZpbmlzaEF0dHJpYnV0ZVZhbHVlKCk7XG4gICAgICAgIGFkZEVsZW1lbnRNb2RpZmllcih0aGlzLmN1cnJlbnRTdGFydFRhZywgbXVzdGFjaGUpO1xuICAgICAgICB0b2tlbml6ZXIudHJhbnNpdGlvblRvKFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYWZ0ZXJBdHRyaWJ1dGVWYWx1ZVF1b3RlZDpcbiAgICAgICAgYWRkRWxlbWVudE1vZGlmaWVyKHRoaXMuY3VycmVudFN0YXJ0VGFnLCBtdXN0YWNoZSk7XG4gICAgICAgIHRva2VuaXplci50cmFuc2l0aW9uVG8oVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlTmFtZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBBdHRyaWJ1dGUgdmFsdWVzXG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZVZhbHVlOlxuICAgICAgICB0aGlzLmJlZ2luQXR0cmlidXRlVmFsdWUoZmFsc2UpO1xuICAgICAgICBhcHBlbmREeW5hbWljQXR0cmlidXRlVmFsdWVQYXJ0KHRoaXMuY3VycmVudEF0dHJpYnV0ZSEsIG11c3RhY2hlKTtcbiAgICAgICAgdG9rZW5pemVyLnRyYW5zaXRpb25UbyhUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVWYWx1ZVVucXVvdGVkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZVZhbHVlRG91YmxlUXVvdGVkOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVWYWx1ZVNpbmdsZVF1b3RlZDpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYXR0cmlidXRlVmFsdWVVbnF1b3RlZDpcbiAgICAgICAgYXBwZW5kRHluYW1pY0F0dHJpYnV0ZVZhbHVlUGFydCh0aGlzLmN1cnJlbnRBdHRyaWJ1dGUhLCBtdXN0YWNoZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBUT0RPOiBPbmx5IGFwcGVuZCBjaGlsZCB3aGVuIHRoZSB0b2tlbml6ZXIgc3RhdGUgbWFrZXNcbiAgICAgIC8vIHNlbnNlIHRvIGRvIHNvLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcHBlbmRDaGlsZCh0aGlzLmN1cnJlbnRFbGVtZW50KCksIG11c3RhY2hlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbXVzdGFjaGU7XG4gIH1cblxuICBDb250ZW50U3RhdGVtZW50KGNvbnRlbnQ6IEhCUy5Db250ZW50U3RhdGVtZW50KTogdm9pZCB7XG4gICAgdXBkYXRlVG9rZW5pemVyTG9jYXRpb24odGhpcy50b2tlbml6ZXIsIGNvbnRlbnQpO1xuXG4gICAgdGhpcy50b2tlbml6ZXIudG9rZW5pemVQYXJ0KGNvbnRlbnQudmFsdWUpO1xuICAgIHRoaXMudG9rZW5pemVyLmZsdXNoRGF0YSgpO1xuICB9XG5cbiAgQ29tbWVudFN0YXRlbWVudChyYXdDb21tZW50OiBIQlMuQ29tbWVudFN0YXRlbWVudCk6IE9wdGlvbjxBU1QuTXVzdGFjaGVDb21tZW50U3RhdGVtZW50PiB7XG4gICAgbGV0IHsgdG9rZW5pemVyIH0gPSB0aGlzO1xuXG4gICAgaWYgKHRva2VuaXplci5zdGF0ZSA9PT0gVG9rZW5pemVyU3RhdGUuY29tbWVudCkge1xuICAgICAgdGhpcy5hcHBlbmRUb0NvbW1lbnREYXRhKHRoaXMuc291cmNlRm9yTm9kZShyYXdDb21tZW50KSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgeyB2YWx1ZSwgbG9jIH0gPSByYXdDb21tZW50O1xuICAgIGxldCBjb21tZW50ID0gYi5tdXN0YWNoZUNvbW1lbnQodmFsdWUsIGxvYyk7XG5cbiAgICBzd2l0Y2ggKHRva2VuaXplci5zdGF0ZSkge1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVOYW1lOlxuICAgICAgICB0aGlzLmN1cnJlbnRTdGFydFRhZy5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5iZWZvcmVEYXRhOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5kYXRhOlxuICAgICAgICBhcHBlbmRDaGlsZCh0aGlzLmN1cnJlbnRFbGVtZW50KCksIGNvbW1lbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgIGBVc2luZyBhIEhhbmRsZWJhcnMgY29tbWVudCB3aGVuIGluIHRoZSBcXGAke3Rva2VuaXplclsnc3RhdGUnXX1cXGAgc3RhdGUgaXMgbm90IHN1cHBvcnRlZDogXCIke2NvbW1lbnQudmFsdWV9XCIgb24gbGluZSAke2xvYy5zdGFydC5saW5lfToke2xvYy5zdGFydC5jb2x1bW59YCxcbiAgICAgICAgICByYXdDb21tZW50LmxvY1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tZW50O1xuICB9XG5cbiAgUGFydGlhbFN0YXRlbWVudChwYXJ0aWFsOiBIQlMuUGFydGlhbFN0YXRlbWVudCk6IG5ldmVyIHtcbiAgICBsZXQgeyBsb2MgfSA9IHBhcnRpYWw7XG5cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBgSGFuZGxlYmFycyBwYXJ0aWFscyBhcmUgbm90IHN1cHBvcnRlZDogXCIke3RoaXMuc291cmNlRm9yTm9kZShwYXJ0aWFsLCBwYXJ0aWFsLm5hbWUpfVwiIGF0IEwke1xuICAgICAgICBsb2Muc3RhcnQubGluZVxuICAgICAgfTpDJHtsb2Muc3RhcnQuY29sdW1ufWAsXG4gICAgICBwYXJ0aWFsLmxvY1xuICAgICk7XG4gIH1cblxuICBQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQocGFydGlhbEJsb2NrOiBIQlMuUGFydGlhbEJsb2NrU3RhdGVtZW50KTogbmV2ZXIge1xuICAgIGxldCB7IGxvYyB9ID0gcGFydGlhbEJsb2NrO1xuXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgYEhhbmRsZWJhcnMgcGFydGlhbCBibG9ja3MgYXJlIG5vdCBzdXBwb3J0ZWQ6IFwiJHt0aGlzLnNvdXJjZUZvck5vZGUoXG4gICAgICAgIHBhcnRpYWxCbG9jayxcbiAgICAgICAgcGFydGlhbEJsb2NrLm5hbWVcbiAgICAgICl9XCIgYXQgTCR7bG9jLnN0YXJ0LmxpbmV9OkMke2xvYy5zdGFydC5jb2x1bW59YCxcbiAgICAgIHBhcnRpYWxCbG9jay5sb2NcbiAgICApO1xuICB9XG5cbiAgRGVjb3JhdG9yKGRlY29yYXRvcjogSEJTLkRlY29yYXRvcik6IG5ldmVyIHtcbiAgICBsZXQgeyBsb2MgfSA9IGRlY29yYXRvcjtcblxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgIGBIYW5kbGViYXJzIGRlY29yYXRvcnMgYXJlIG5vdCBzdXBwb3J0ZWQ6IFwiJHt0aGlzLnNvdXJjZUZvck5vZGUoXG4gICAgICAgIGRlY29yYXRvcixcbiAgICAgICAgZGVjb3JhdG9yLnBhdGhcbiAgICAgICl9XCIgYXQgTCR7bG9jLnN0YXJ0LmxpbmV9OkMke2xvYy5zdGFydC5jb2x1bW59YCxcbiAgICAgIGRlY29yYXRvci5sb2NcbiAgICApO1xuICB9XG5cbiAgRGVjb3JhdG9yQmxvY2soZGVjb3JhdG9yQmxvY2s6IEhCUy5EZWNvcmF0b3JCbG9jayk6IG5ldmVyIHtcbiAgICBsZXQgeyBsb2MgfSA9IGRlY29yYXRvckJsb2NrO1xuXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgYEhhbmRsZWJhcnMgZGVjb3JhdG9yIGJsb2NrcyBhcmUgbm90IHN1cHBvcnRlZDogXCIke3RoaXMuc291cmNlRm9yTm9kZShcbiAgICAgICAgZGVjb3JhdG9yQmxvY2ssXG4gICAgICAgIGRlY29yYXRvckJsb2NrLnBhdGhcbiAgICAgICl9XCIgYXQgTCR7bG9jLnN0YXJ0LmxpbmV9OkMke2xvYy5zdGFydC5jb2x1bW59YCxcbiAgICAgIGRlY29yYXRvckJsb2NrLmxvY1xuICAgICk7XG4gIH1cblxuICBTdWJFeHByZXNzaW9uKHNleHByOiBIQlMuU3ViRXhwcmVzc2lvbik6IEFTVC5TdWJFeHByZXNzaW9uIHtcbiAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IGFjY2VwdENhbGxOb2Rlcyh0aGlzLCBzZXhwcik7XG4gICAgcmV0dXJuIGIuc2V4cHIocGF0aCwgcGFyYW1zLCBoYXNoLCBzZXhwci5sb2MpO1xuICB9XG5cbiAgUGF0aEV4cHJlc3Npb24ocGF0aDogSEJTLlBhdGhFeHByZXNzaW9uKTogQVNULlBhdGhFeHByZXNzaW9uIHtcbiAgICBsZXQgeyBvcmlnaW5hbCwgbG9jIH0gPSBwYXRoO1xuICAgIGxldCBwYXJ0czogc3RyaW5nW107XG5cbiAgICBpZiAob3JpZ2luYWwuaW5kZXhPZignLycpICE9PSAtMSkge1xuICAgICAgaWYgKG9yaWdpbmFsLnNsaWNlKDAsIDIpID09PSAnLi8nKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICBgVXNpbmcgXCIuL1wiIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2xpbW1lciBhbmQgdW5uZWNlc3Nhcnk6IFwiJHtwYXRoLm9yaWdpbmFsfVwiIG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX0uYCxcbiAgICAgICAgICBwYXRoLmxvY1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsLnNsaWNlKDAsIDMpID09PSAnLi4vJykge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgYENoYW5naW5nIGNvbnRleHQgdXNpbmcgXCIuLi9cIiBpcyBub3Qgc3VwcG9ydGVkIGluIEdsaW1tZXI6IFwiJHtwYXRoLm9yaWdpbmFsfVwiIG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX0uYCxcbiAgICAgICAgICBwYXRoLmxvY1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgIGBNaXhpbmcgJy4nIGFuZCAnLycgaW4gcGF0aHMgaXMgbm90IHN1cHBvcnRlZCBpbiBHbGltbWVyOyB1c2Ugb25seSAnLicgdG8gc2VwYXJhdGUgcHJvcGVydHkgcGF0aHM6IFwiJHtwYXRoLm9yaWdpbmFsfVwiIG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX0uYCxcbiAgICAgICAgICBwYXRoLmxvY1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcGFydHMgPSBbcGF0aC5wYXJ0cy5qb2luKCcvJyldO1xuICAgIH0gZWxzZSBpZiAob3JpZ2luYWwgPT09ICcuJykge1xuICAgICAgbGV0IGxvY2F0aW9uSW5mbyA9IGBMJHtsb2Muc3RhcnQubGluZX06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gO1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICBgJy4nIGlzIG5vdCBhIHN1cHBvcnRlZCBwYXRoIGluIEdsaW1tZXI7IGNoZWNrIGZvciBhIHBhdGggd2l0aCBhIHRyYWlsaW5nICcuJyBhdCAke2xvY2F0aW9uSW5mb30uYCxcbiAgICAgICAgcGF0aC5sb2NcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzID0gcGF0aC5wYXJ0cztcbiAgICB9XG5cbiAgICBsZXQgdGhpc0hlYWQgPSBmYWxzZTtcblxuICAgIC8vIFRoaXMgaXMgdG8gZml4IGEgYnVnIGluIHRoZSBIYW5kbGViYXJzIEFTVCB3aGVyZSB0aGUgcGF0aCBleHByZXNzaW9ucyBpblxuICAgIC8vIGB7e3RoaXMuZm9vfX1gIChhbmQgc2ltaWxhcmx5IGB7e2Zvby1iYXIgdGhpcy5mb28gbmFtZWQ9dGhpcy5mb299fWAgZXRjKVxuICAgIC8vIGFyZSBzaW1wbHkgdHVybmVkIGludG8gYHt7Zm9vfX1gLiBUaGUgZml4IGlzIHRvIHB1c2ggaXQgYmFjayBvbnRvIHRoZVxuICAgIC8vIHBhcnRzIGFycmF5IGFuZCBsZXQgdGhlIHJ1bnRpbWUgc2VlIHRoZSBkaWZmZXJlbmNlLiBIb3dldmVyLCB3ZSBjYW5ub3RcbiAgICAvLyBzaW1wbHkgdXNlIHRoZSBzdHJpbmcgYHRoaXNgIGFzIGl0IG1lYW5zIGxpdGVyYWxseSB0aGUgcHJvcGVydHkgY2FsbGVkXG4gICAgLy8gXCJ0aGlzXCIgaW4gdGhlIGN1cnJlbnQgY29udGV4dCAoaXQgY2FuIGJlIGV4cHJlc3NlZCBpbiB0aGUgc3ludGF4IGFzXG4gICAgLy8gYHt7W3RoaXNdfX1gLCB3aGVyZSB0aGUgc3F1YXJlIGJyYWNrZXQgYXJlIGdlbmVyYWxseSBmb3IgdGhpcyBraW5kIG9mXG4gICAgLy8gZXNjYXBpbmcgw6LCgMKTIHN1Y2ggYXMgYHt7Zm9vLltcImJhci5iYXpcIl19fWAgd291bGQgbWVhbiBsb29rdXAgYSBwcm9wZXJ0eVxuICAgIC8vIG5hbWVkIGxpdGVyYWxseSBcImJhci5iYXpcIiBvbiBgdGhpcy5mb29gKS4gQnkgY29udmVudGlvbiwgd2UgdXNlIGBudWxsYFxuICAgIC8vIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgaWYgKG9yaWdpbmFsLm1hdGNoKC9edGhpcyhcXC4uKyk/JC8pKSB7XG4gICAgICB0aGlzSGVhZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdQYXRoRXhwcmVzc2lvbicsXG4gICAgICBvcmlnaW5hbDogcGF0aC5vcmlnaW5hbCxcbiAgICAgIHRoaXM6IHRoaXNIZWFkLFxuICAgICAgcGFydHMsXG4gICAgICBkYXRhOiBwYXRoLmRhdGEsXG4gICAgICBsb2M6IHBhdGgubG9jLFxuICAgIH07XG4gIH1cblxuICBIYXNoKGhhc2g6IEhCUy5IYXNoKTogQVNULkhhc2gge1xuICAgIGxldCBwYWlyczogQVNULkhhc2hQYWlyW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFzaC5wYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBhaXIgPSBoYXNoLnBhaXJzW2ldO1xuICAgICAgcGFpcnMucHVzaChiLnBhaXIocGFpci5rZXksIHRoaXMuYWNjZXB0Tm9kZShwYWlyLnZhbHVlKSwgcGFpci5sb2MpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYi5oYXNoKHBhaXJzLCBoYXNoLmxvYyk7XG4gIH1cblxuICBTdHJpbmdMaXRlcmFsKHN0cmluZzogSEJTLlN0cmluZ0xpdGVyYWwpOiBBU1QuU3RyaW5nTGl0ZXJhbCB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCgnU3RyaW5nTGl0ZXJhbCcsIHN0cmluZy52YWx1ZSwgc3RyaW5nLmxvYyk7XG4gIH1cblxuICBCb29sZWFuTGl0ZXJhbChib29sZWFuOiBIQlMuQm9vbGVhbkxpdGVyYWwpOiBBU1QuQm9vbGVhbkxpdGVyYWwge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ0Jvb2xlYW5MaXRlcmFsJywgYm9vbGVhbi52YWx1ZSwgYm9vbGVhbi5sb2MpO1xuICB9XG5cbiAgTnVtYmVyTGl0ZXJhbChudW1iZXI6IEhCUy5OdW1iZXJMaXRlcmFsKTogQVNULk51bWJlckxpdGVyYWwge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ051bWJlckxpdGVyYWwnLCBudW1iZXIudmFsdWUsIG51bWJlci5sb2MpO1xuICB9XG5cbiAgVW5kZWZpbmVkTGl0ZXJhbCh1bmRlZjogSEJTLlVuZGVmaW5lZExpdGVyYWwpOiBBU1QuVW5kZWZpbmVkTGl0ZXJhbCB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCgnVW5kZWZpbmVkTGl0ZXJhbCcsIHVuZGVmaW5lZCwgdW5kZWYubG9jKTtcbiAgfVxuXG4gIE51bGxMaXRlcmFsKG51bDogSEJTLk51bGxMaXRlcmFsKTogQVNULk51bGxMaXRlcmFsIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKCdOdWxsTGl0ZXJhbCcsIG51bGwsIG51bC5sb2MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJpZ2h0U3RyaXBwZWRPZmZzZXRzKG9yaWdpbmFsOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgaWYgKHZhbHVlID09PSAnJykge1xuICAgIC8vIGlmIGl0IGlzIGVtcHR5LCBqdXN0IHJldHVybiB0aGUgY291bnQgb2YgbmV3bGluZXNcbiAgICAvLyBpbiBvcmlnaW5hbFxuICAgIHJldHVybiB7XG4gICAgICBsaW5lczogb3JpZ2luYWwuc3BsaXQoJ1xcbicpLmxlbmd0aCAtIDEsXG4gICAgICBjb2x1bW5zOiAwLFxuICAgIH07XG4gIH1cblxuICAvLyBvdGhlcndpc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIG5ld2xpbmVzIHByaW9yIHRvXG4gIC8vIGB2YWx1ZWBcbiAgbGV0IGRpZmZlcmVuY2UgPSBvcmlnaW5hbC5zcGxpdCh2YWx1ZSlbMF07XG4gIGxldCBsaW5lcyA9IGRpZmZlcmVuY2Uuc3BsaXQoL1xcbi8pO1xuICBsZXQgbGluZUNvdW50ID0gbGluZXMubGVuZ3RoIC0gMTtcblxuICByZXR1cm4ge1xuICAgIGxpbmVzOiBsaW5lQ291bnQsXG4gICAgY29sdW1uczogbGluZXNbbGluZUNvdW50XS5sZW5ndGgsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRva2VuaXplckxvY2F0aW9uKHRva2VuaXplcjogUGFyc2VyWyd0b2tlbml6ZXInXSwgY29udGVudDogSEJTLkNvbnRlbnRTdGF0ZW1lbnQpIHtcbiAgbGV0IGxpbmUgPSBjb250ZW50LmxvYy5zdGFydC5saW5lO1xuICBsZXQgY29sdW1uID0gY29udGVudC5sb2Muc3RhcnQuY29sdW1uO1xuXG4gIGxldCBvZmZzZXRzID0gY2FsY3VsYXRlUmlnaHRTdHJpcHBlZE9mZnNldHMoXG4gICAgY29udGVudC5vcmlnaW5hbCBhcyBSZWNhc3Q8SEJTLlN0cmlwRmxhZ3MsIHN0cmluZz4sXG4gICAgY29udGVudC52YWx1ZVxuICApO1xuXG4gIGxpbmUgPSBsaW5lICsgb2Zmc2V0cy5saW5lcztcbiAgaWYgKG9mZnNldHMubGluZXMpIHtcbiAgICBjb2x1bW4gPSBvZmZzZXRzLmNvbHVtbnM7XG4gIH0gZWxzZSB7XG4gICAgY29sdW1uID0gY29sdW1uICsgb2Zmc2V0cy5jb2x1bW5zO1xuICB9XG5cbiAgdG9rZW5pemVyLmxpbmUgPSBsaW5lO1xuICB0b2tlbml6ZXIuY29sdW1uID0gY29sdW1uO1xufVxuXG5mdW5jdGlvbiBhY2NlcHRDYWxsTm9kZXMoXG4gIGNvbXBpbGVyOiBIYW5kbGViYXJzTm9kZVZpc2l0b3JzLFxuICBub2RlOiB7XG4gICAgcGF0aDogSEJTLlBhdGhFeHByZXNzaW9uO1xuICAgIHBhcmFtczogSEJTLkV4cHJlc3Npb25bXTtcbiAgICBoYXNoOiBIQlMuSGFzaDtcbiAgfVxuKTogeyBwYXRoOiBBU1QuUGF0aEV4cHJlc3Npb247IHBhcmFtczogQVNULkV4cHJlc3Npb25bXTsgaGFzaDogQVNULkhhc2ggfSB7XG4gIGxldCBwYXRoID0gY29tcGlsZXIuUGF0aEV4cHJlc3Npb24obm9kZS5wYXRoKTtcblxuICBsZXQgcGFyYW1zID0gbm9kZS5wYXJhbXMgPyBub2RlLnBhcmFtcy5tYXAoZSA9PiBjb21waWxlci5hY2NlcHROb2RlPEFTVC5FeHByZXNzaW9uPihlKSkgOiBbXTtcbiAgbGV0IGhhc2ggPSBub2RlLmhhc2ggPyBjb21waWxlci5IYXNoKG5vZGUuaGFzaCkgOiBiLmhhc2goKTtcblxuICByZXR1cm4geyBwYXRoLCBwYXJhbXMsIGhhc2ggfTtcbn1cblxuZnVuY3Rpb24gYWRkRWxlbWVudE1vZGlmaWVyKGVsZW1lbnQ6IFRhZzwnU3RhcnRUYWcnPiwgbXVzdGFjaGU6IEFTVC5NdXN0YWNoZVN0YXRlbWVudCkge1xuICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2gsIGxvYyB9ID0gbXVzdGFjaGU7XG5cbiAgaWYgKGlzTGl0ZXJhbChwYXRoKSkge1xuICAgIGxldCBtb2RpZmllciA9IGB7eyR7cHJpbnRMaXRlcmFsKHBhdGgpfX19YDtcbiAgICBsZXQgdGFnID0gYDwke2VsZW1lbnQubmFtZX0gLi4uICR7bW9kaWZpZXJ9IC4uLmA7XG5cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBgSW4gJHt0YWd9LCAke21vZGlmaWVyfSBpcyBub3QgYSB2YWxpZCBtb2RpZmllcjogXCIke3BhdGgub3JpZ2luYWx9XCIgb24gbGluZSAke2xvYyAmJlxuICAgICAgICBsb2Muc3RhcnQubGluZX0uYCxcbiAgICAgIG11c3RhY2hlLmxvY1xuICAgICk7XG4gIH1cblxuICBsZXQgbW9kaWZpZXIgPSBiLmVsZW1lbnRNb2RpZmllcihwYXRoLCBwYXJhbXMsIGhhc2gsIGxvYyk7XG4gIGVsZW1lbnQubW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xufVxuXG5mdW5jdGlvbiBhZGRJbkVsZW1lbnRIYXNoKGN1cnNvcjogc3RyaW5nLCBoYXNoOiBBU1QuSGFzaCwgbG9jOiBBU1QuU291cmNlTG9jYXRpb24pIHtcbiAgbGV0IGhhc0luc2VydEJlZm9yZSA9IGZhbHNlO1xuICBoYXNoLnBhaXJzLmZvckVhY2gocGFpciA9PiB7XG4gICAgaWYgKHBhaXIua2V5ID09PSAnZ3VpZCcpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ2Fubm90IHBhc3MgYGd1aWRgIGZyb20gdXNlciBzcGFjZScsIGxvYyk7XG4gICAgfVxuXG4gICAgaWYgKHBhaXIua2V5ID09PSAnaW5zZXJ0QmVmb3JlJykge1xuICAgICAgaGFzSW5zZXJ0QmVmb3JlID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIGxldCBndWlkID0gYi5saXRlcmFsKCdTdHJpbmdMaXRlcmFsJywgY3Vyc29yKTtcbiAgbGV0IGd1aWRQYWlyID0gYi5wYWlyKCdndWlkJywgZ3VpZCk7XG4gIGhhc2gucGFpcnMudW5zaGlmdChndWlkUGFpcik7XG5cbiAgaWYgKCFoYXNJbnNlcnRCZWZvcmUpIHtcbiAgICBsZXQgdW5kZWZpbmVkTGl0ZXJhbCA9IGIubGl0ZXJhbCgnVW5kZWZpbmVkTGl0ZXJhbCcsIHVuZGVmaW5lZCk7XG4gICAgbGV0IGJlZm9yZVNpYmxpbmcgPSBiLnBhaXIoJ2luc2VydEJlZm9yZScsIHVuZGVmaW5lZExpdGVyYWwpO1xuICAgIGhhc2gucGFpcnMucHVzaChiZWZvcmVTaWJsaW5nKTtcbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufVxuXG5mdW5jdGlvbiBhcHBlbmREeW5hbWljQXR0cmlidXRlVmFsdWVQYXJ0KGF0dHJpYnV0ZTogQXR0cmlidXRlLCBwYXJ0OiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgYXR0cmlidXRlLmlzRHluYW1pYyA9IHRydWU7XG4gIGF0dHJpYnV0ZS5wYXJ0cy5wdXNoKHBhcnQpO1xufVxuIiwiaW1wb3J0IHsgdHVwbGUgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCAqIGFzIEFTVCBmcm9tICcuLi90eXBlcy9ub2Rlcyc7XG5cbi8vIGVuc3VyZSBzdGF5cyBpbiBzeW5jIHdpdGggdHlwaW5nXG4vLyBQYXJlbnROb2RlIGFuZCBDaGlsZEtleSB0eXBlcyBhcmUgZGVyaXZlZCBmcm9tIFZpc2l0b3JLZXlzTWFwXG5jb25zdCB2aXNpdG9yS2V5cyA9IHtcbiAgUHJvZ3JhbTogdHVwbGUoJ2JvZHknKSxcbiAgVGVtcGxhdGU6IHR1cGxlKCdib2R5JyksXG4gIEJsb2NrOiB0dXBsZSgnYm9keScpLFxuXG4gIE11c3RhY2hlU3RhdGVtZW50OiB0dXBsZSgncGF0aCcsICdwYXJhbXMnLCAnaGFzaCcpLFxuICBCbG9ja1N0YXRlbWVudDogdHVwbGUoJ3BhdGgnLCAncGFyYW1zJywgJ2hhc2gnLCAncHJvZ3JhbScsICdpbnZlcnNlJyksXG4gIEVsZW1lbnRNb2RpZmllclN0YXRlbWVudDogdHVwbGUoJ3BhdGgnLCAncGFyYW1zJywgJ2hhc2gnKSxcbiAgUGFydGlhbFN0YXRlbWVudDogdHVwbGUoJ25hbWUnLCAncGFyYW1zJywgJ2hhc2gnKSxcbiAgQ29tbWVudFN0YXRlbWVudDogdHVwbGUoKSxcbiAgTXVzdGFjaGVDb21tZW50U3RhdGVtZW50OiB0dXBsZSgpLFxuICBFbGVtZW50Tm9kZTogdHVwbGUoJ2F0dHJpYnV0ZXMnLCAnbW9kaWZpZXJzJywgJ2NoaWxkcmVuJywgJ2NvbW1lbnRzJyksXG4gIEF0dHJOb2RlOiB0dXBsZSgndmFsdWUnKSxcbiAgVGV4dE5vZGU6IHR1cGxlKCksXG5cbiAgQ29uY2F0U3RhdGVtZW50OiB0dXBsZSgncGFydHMnKSxcbiAgU3ViRXhwcmVzc2lvbjogdHVwbGUoJ3BhdGgnLCAncGFyYW1zJywgJ2hhc2gnKSxcbiAgUGF0aEV4cHJlc3Npb246IHR1cGxlKCksXG5cbiAgU3RyaW5nTGl0ZXJhbDogdHVwbGUoKSxcbiAgQm9vbGVhbkxpdGVyYWw6IHR1cGxlKCksXG4gIE51bWJlckxpdGVyYWw6IHR1cGxlKCksXG4gIE51bGxMaXRlcmFsOiB0dXBsZSgpLFxuICBVbmRlZmluZWRMaXRlcmFsOiB0dXBsZSgpLFxuXG4gIEhhc2g6IHR1cGxlKCdwYWlycycpLFxuICBIYXNoUGFpcjogdHVwbGUoJ3ZhbHVlJyksXG59O1xuXG50eXBlIFZpc2l0b3JLZXlzTWFwID0gdHlwZW9mIHZpc2l0b3JLZXlzO1xuXG5leHBvcnQgdHlwZSBWaXNpdG9yS2V5cyA9IHsgW1AgaW4ga2V5b2YgVmlzaXRvcktleXNNYXBdOiBWaXNpdG9yS2V5c01hcFtQXVtudW1iZXJdIH07XG5leHBvcnQgdHlwZSBWaXNpdG9yS2V5PE4gZXh0ZW5kcyBBU1QuTm9kZT4gPSBWaXNpdG9yS2V5c1tOWyd0eXBlJ11dICYga2V5b2YgTjtcblxuZXhwb3J0IGRlZmF1bHQgdmlzaXRvcktleXM7XG4iLCJpbXBvcnQgKiBhcyBBU1QgZnJvbSAnLi4vdHlwZXMvbm9kZXMnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhdmVyc2FsRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yOiBUcmF2ZXJzYWxFcnJvckNvbnN0cnVjdG9yO1xuICBrZXk6IHN0cmluZztcbiAgbm9kZTogQVNULk5vZGU7XG4gIHBhcmVudDogT3B0aW9uPEFTVC5Ob2RlPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmF2ZXJzYWxFcnJvckNvbnN0cnVjdG9yIHtcbiAgbmV3IChtZXNzYWdlOiBzdHJpbmcsIG5vZGU6IEFTVC5Ob2RlLCBwYXJlbnQ6IE9wdGlvbjxBU1QuTm9kZT4sIGtleTogc3RyaW5nKTogVHJhdmVyc2FsRXJyb3I7XG4gIHJlYWRvbmx5IHByb3RvdHlwZTogVHJhdmVyc2FsRXJyb3I7XG59XG5cbmNvbnN0IFRyYXZlcnNhbEVycm9yOiBUcmF2ZXJzYWxFcnJvckNvbnN0cnVjdG9yID0gKGZ1bmN0aW9uKCkge1xuICBUcmF2ZXJzYWxFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIFRyYXZlcnNhbEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyYXZlcnNhbEVycm9yO1xuXG4gIGZ1bmN0aW9uIFRyYXZlcnNhbEVycm9yKFxuICAgIHRoaXM6IFRyYXZlcnNhbEVycm9yLFxuICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICBub2RlOiBBU1QuTm9kZSxcbiAgICBwYXJlbnQ6IE9wdGlvbjxBU1QuTm9kZT4sXG4gICAga2V5OiBzdHJpbmdcbiAgKSB7XG4gICAgbGV0IGVycm9yID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gIH1cblxuICByZXR1cm4gVHJhdmVyc2FsRXJyb3IgYXMgYW55O1xufSkoKTtcblxuZXhwb3J0IGRlZmF1bHQgVHJhdmVyc2FsRXJyb3I7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYW5ub3RSZW1vdmVOb2RlKG5vZGU6IEFTVC5Ob2RlLCBwYXJlbnQ6IEFTVC5Ob2RlLCBrZXk6IHN0cmluZykge1xuICByZXR1cm4gbmV3IFRyYXZlcnNhbEVycm9yKFxuICAgICdDYW5ub3QgcmVtb3ZlIGEgbm9kZSB1bmxlc3MgaXQgaXMgcGFydCBvZiBhbiBhcnJheScsXG4gICAgbm9kZSxcbiAgICBwYXJlbnQsXG4gICAga2V5XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYW5ub3RSZXBsYWNlTm9kZShub2RlOiBBU1QuTm9kZSwgcGFyZW50OiBBU1QuTm9kZSwga2V5OiBzdHJpbmcpIHtcbiAgcmV0dXJuIG5ldyBUcmF2ZXJzYWxFcnJvcihcbiAgICAnQ2Fubm90IHJlcGxhY2UgYSBub2RlIHdpdGggbXVsdGlwbGUgbm9kZXMgdW5sZXNzIGl0IGlzIHBhcnQgb2YgYW4gYXJyYXknLFxuICAgIG5vZGUsXG4gICAgcGFyZW50LFxuICAgIGtleVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2Fubm90UmVwbGFjZU9yUmVtb3ZlSW5LZXlIYW5kbGVyWWV0KG5vZGU6IEFTVC5Ob2RlLCBrZXk6IHN0cmluZykge1xuICByZXR1cm4gbmV3IFRyYXZlcnNhbEVycm9yKFxuICAgICdSZXBsYWNpbmcgYW5kIHJlbW92aW5nIGluIGtleSBoYW5kbGVycyBpcyBub3QgeWV0IHN1cHBvcnRlZC4nLFxuICAgIG5vZGUsXG4gICAgbnVsbCxcbiAgICBrZXlcbiAgKTtcbn1cbiIsImltcG9ydCB7IE5vZGUgfSBmcm9tICcuLi90eXBlcy9ub2Rlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdGg8TiBleHRlbmRzIE5vZGU+IHtcbiAgbm9kZTogTjtcbiAgcGFyZW50OiBQYXRoPE5vZGU+IHwgbnVsbDtcbiAgcGFyZW50S2V5OiBzdHJpbmcgfCBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKG5vZGU6IE4sIHBhcmVudDogUGF0aDxOb2RlPiB8IG51bGwgPSBudWxsLCBwYXJlbnRLZXk6IHN0cmluZyB8IG51bGwgPSBudWxsKSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnBhcmVudEtleSA9IHBhcmVudEtleTtcbiAgfVxuXG4gIGdldCBwYXJlbnROb2RlKCk6IE5vZGUgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5ub2RlIDogbnVsbDtcbiAgfVxufVxuIiwiaW1wb3J0IHZpc2l0b3JLZXlzLCB7IFZpc2l0b3JLZXlzLCBWaXNpdG9yS2V5IH0gZnJvbSAnLi4vdHlwZXMvdmlzaXRvci1rZXlzJztcbmltcG9ydCB7XG4gIGNhbm5vdFJlbW92ZU5vZGUsXG4gIGNhbm5vdFJlcGxhY2VOb2RlLFxuICBjYW5ub3RSZXBsYWNlT3JSZW1vdmVJbktleUhhbmRsZXJZZXQsXG59IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCAqIGFzIEFTVCBmcm9tICcuLi90eXBlcy9ub2Rlcyc7XG5pbXBvcnQgeyBkZXByZWNhdGUgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IERFVk1PREUgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5pbXBvcnQgeyBOb2RlSGFuZGxlciwgTm9kZVZpc2l0b3IsIEtleUhhbmRsZXIsIE5vZGVUcmF2ZXJzYWwsIEtleVRyYXZlcnNhbCB9IGZyb20gJy4vdmlzaXRvcic7XG5pbXBvcnQgUGF0aCBmcm9tICcuL3BhdGgnO1xuXG5mdW5jdGlvbiBnZXRFbnRlckZ1bmN0aW9uPE4gZXh0ZW5kcyBBU1QuTm9kZT4oXG4gIGhhbmRsZXI6IE5vZGVUcmF2ZXJzYWw8Tj5cbik6IE5vZGVIYW5kbGVyPE4+IHwgdW5kZWZpbmVkO1xuZnVuY3Rpb24gZ2V0RW50ZXJGdW5jdGlvbjxOIGV4dGVuZHMgQVNULk5vZGUsIEsgZXh0ZW5kcyBWaXNpdG9yS2V5PE4+PihcbiAgaGFuZGxlcjogS2V5VHJhdmVyc2FsPE4sIEs+XG4pOiBLZXlIYW5kbGVyPE4sIEs+IHwgdW5kZWZpbmVkO1xuZnVuY3Rpb24gZ2V0RW50ZXJGdW5jdGlvbjxOIGV4dGVuZHMgQVNULk5vZGUsIEsgZXh0ZW5kcyBWaXNpdG9yS2V5PE4+PihcbiAgaGFuZGxlcjogTm9kZVRyYXZlcnNhbDxOPiB8IEtleVRyYXZlcnNhbDxOLCBLPlxuKTogTm9kZUhhbmRsZXI8Tj4gfCBLZXlIYW5kbGVyPE4sIEs+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGhhbmRsZXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGhhbmRsZXIuZW50ZXIgYXMgTm9kZUhhbmRsZXI8Tj4gfCBLZXlIYW5kbGVyPE4sIEs+O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEV4aXRGdW5jdGlvbjxOIGV4dGVuZHMgQVNULk5vZGU+KGhhbmRsZXI6IE5vZGVUcmF2ZXJzYWw8Tj4pOiBOb2RlSGFuZGxlcjxOPiB8IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGdldEV4aXRGdW5jdGlvbjxOIGV4dGVuZHMgQVNULk5vZGUsIEsgZXh0ZW5kcyBWaXNpdG9yS2V5PE4+PihcbiAgaGFuZGxlcjogS2V5VHJhdmVyc2FsPE4sIEs+XG4pOiBLZXlIYW5kbGVyPE4sIEs+IHwgdW5kZWZpbmVkO1xuZnVuY3Rpb24gZ2V0RXhpdEZ1bmN0aW9uPE4gZXh0ZW5kcyBBU1QuTm9kZSwgSyBleHRlbmRzIFZpc2l0b3JLZXk8Tj4+KFxuICBoYW5kbGVyOiBOb2RlVHJhdmVyc2FsPE4+IHwgS2V5VHJhdmVyc2FsPE4sIEs+XG4pOiBOb2RlSGFuZGxlcjxOPiB8IEtleUhhbmRsZXI8TiwgSz4gfCB1bmRlZmluZWQge1xuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBoYW5kbGVyLmV4aXQgYXMgTm9kZUhhbmRsZXI8Tj4gfCBLZXlIYW5kbGVyPE4sIEs+O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEtleUhhbmRsZXI8TiBleHRlbmRzIEFTVC5Ob2RlLCBLIGV4dGVuZHMgVmlzaXRvcktleTxOPj4oXG4gIGhhbmRsZXI6IE5vZGVUcmF2ZXJzYWw8Tj4sXG4gIGtleTogS1xuKTogS2V5VHJhdmVyc2FsPE4sIEs+IHwgS2V5VHJhdmVyc2FsPE4sIFZpc2l0b3JLZXk8Tj4+IHwgdW5kZWZpbmVkIHtcbiAgbGV0IGtleVZpc2l0b3IgPSB0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJyA/IGhhbmRsZXIua2V5cyA6IHVuZGVmaW5lZDtcbiAgaWYgKGtleVZpc2l0b3IgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gIGxldCBrZXlIYW5kbGVyID0ga2V5VmlzaXRvcltrZXldO1xuICBpZiAoa2V5SGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGtleUhhbmRsZXIgYXMgS2V5VHJhdmVyc2FsPE4sIEs+O1xuICB9XG4gIHJldHVybiBrZXlWaXNpdG9yLkFsbDtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZUhhbmRsZXI8TiBleHRlbmRzIEFTVC5Ob2RlPihcbiAgdmlzaXRvcjogTm9kZVZpc2l0b3IsXG4gIG5vZGVUeXBlOiBOWyd0eXBlJ11cbik6IE5vZGVUcmF2ZXJzYWw8Tj47XG5mdW5jdGlvbiBnZXROb2RlSGFuZGxlcih2aXNpdG9yOiBOb2RlVmlzaXRvciwgbm9kZVR5cGU6ICdBbGwnKTogTm9kZVRyYXZlcnNhbDxBU1QuTm9kZT47XG5mdW5jdGlvbiBnZXROb2RlSGFuZGxlcjxOIGV4dGVuZHMgQVNULk5vZGU+KFxuICB2aXNpdG9yOiBOb2RlVmlzaXRvcixcbiAgbm9kZVR5cGU6IE5bJ3R5cGUnXVxuKTogTm9kZVRyYXZlcnNhbDxOPiB8IE5vZGVUcmF2ZXJzYWw8QVNULk5vZGU+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG5vZGVUeXBlID09PSAnVGVtcGxhdGUnIHx8IG5vZGVUeXBlID09PSAnQmxvY2snKSB7XG4gICAgaWYgKHZpc2l0b3IuUHJvZ3JhbSkge1xuICAgICAgaWYgKERFVk1PREUpIHtcbiAgICAgICAgZGVwcmVjYXRlKGBUT0RPYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2aXNpdG9yLlByb2dyYW0gYXMgYW55O1xuICAgIH1cbiAgfVxuXG4gIGxldCBoYW5kbGVyID0gdmlzaXRvcltub2RlVHlwZV07XG4gIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gKGhhbmRsZXIgYXMgdW5rbm93bikgYXMgTm9kZVRyYXZlcnNhbDxOPjtcbiAgfVxuICByZXR1cm4gdmlzaXRvci5BbGw7XG59XG5cbmZ1bmN0aW9uIHZpc2l0Tm9kZTxOIGV4dGVuZHMgQVNULk5vZGU+KFxuICB2aXNpdG9yOiBOb2RlVmlzaXRvcixcbiAgcGF0aDogUGF0aDxOPlxuKTogQVNULk5vZGUgfCBBU1QuTm9kZVtdIHwgdW5kZWZpbmVkIHwgbnVsbCB8IHZvaWQge1xuICBsZXQgeyBub2RlLCBwYXJlbnQsIHBhcmVudEtleSB9ID0gcGF0aDtcblxuICBsZXQgaGFuZGxlcjogTm9kZVRyYXZlcnNhbDxOPiA9IGdldE5vZGVIYW5kbGVyKHZpc2l0b3IsIG5vZGUudHlwZSk7XG4gIGxldCBlbnRlcjtcbiAgbGV0IGV4aXQ7XG5cbiAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGVudGVyID0gZ2V0RW50ZXJGdW5jdGlvbihoYW5kbGVyKTtcbiAgICBleGl0ID0gZ2V0RXhpdEZ1bmN0aW9uKGhhbmRsZXIpO1xuICB9XG5cbiAgbGV0IHJlc3VsdDogQVNULk5vZGUgfCBBU1QuTm9kZVtdIHwgdW5kZWZpbmVkIHwgbnVsbCB8IHZvaWQ7XG4gIGlmIChlbnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmVzdWx0ID0gZW50ZXIobm9kZSwgcGF0aCk7XG4gIH1cblxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9PSBudWxsKSB7XG4gICAgaWYgKEpTT04uc3RyaW5naWZ5KG5vZGUpID09PSBKU09OLnN0cmluZ2lmeShyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgIHZpc2l0QXJyYXkodmlzaXRvciwgcmVzdWx0LCBwYXJlbnQsIHBhcmVudEtleSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGF0aCA9IG5ldyBQYXRoKHJlc3VsdCwgcGFyZW50LCBwYXJlbnRLZXkpO1xuICAgICAgcmV0dXJuIHZpc2l0Tm9kZSh2aXNpdG9yLCBwYXRoKSB8fCByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGtleXMgPSB2aXNpdG9yS2V5c1tub2RlLnR5cGVdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQga2V5ID0ga2V5c1tpXSBhcyBWaXNpdG9yS2V5c1tOWyd0eXBlJ11dICYga2V5b2YgTjtcbiAgICAgIC8vIHdlIGtub3cgaWYgaXQgaGFzIGNoaWxkIGtleXMgd2UgY2FuIHdpZGVuIHRvIGEgUGFyZW50Tm9kZVxuICAgICAgdmlzaXRLZXkodmlzaXRvciwgaGFuZGxlciwgcGF0aCwga2V5KTtcbiAgICB9XG5cbiAgICBpZiAoZXhpdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXN1bHQgPSBleGl0KG5vZGUsIHBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldDxOIGV4dGVuZHMgQVNULk5vZGU+KFxuICBub2RlOiBOLFxuICBrZXk6IFZpc2l0b3JLZXlzW05bJ3R5cGUnXV0gJiBrZXlvZiBOXG4pOiBBU1QuTm9kZSB8IEFTVC5Ob2RlW10ge1xuICByZXR1cm4gKG5vZGVba2V5XSBhcyB1bmtub3duKSBhcyBBU1QuTm9kZSB8IEFTVC5Ob2RlW107XG59XG5cbmZ1bmN0aW9uIHNldDxOIGV4dGVuZHMgQVNULk5vZGUsIEsgZXh0ZW5kcyBrZXlvZiBOPihub2RlOiBOLCBrZXk6IEssIHZhbHVlOiBOW0tdKTogdm9pZCB7XG4gIG5vZGVba2V5XSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiB2aXNpdEtleTxOIGV4dGVuZHMgQVNULk5vZGU+KFxuICB2aXNpdG9yOiBOb2RlVmlzaXRvcixcbiAgaGFuZGxlcjogTm9kZVRyYXZlcnNhbDxOPixcbiAgcGF0aDogUGF0aDxOPixcbiAga2V5OiBWaXNpdG9yS2V5c1tOWyd0eXBlJ11dICYga2V5b2YgTlxuKSB7XG4gIGxldCB7IG5vZGUgfSA9IHBhdGg7XG5cbiAgbGV0IHZhbHVlID0gZ2V0KG5vZGUsIGtleSk7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQga2V5RW50ZXI7XG4gIGxldCBrZXlFeGl0O1xuXG4gIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQga2V5SGFuZGxlciA9IGdldEtleUhhbmRsZXIoaGFuZGxlciwga2V5KTtcbiAgICBpZiAoa2V5SGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXlFbnRlciA9IGdldEVudGVyRnVuY3Rpb24oa2V5SGFuZGxlcik7XG4gICAgICBrZXlFeGl0ID0gZ2V0RXhpdEZ1bmN0aW9uKGtleUhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChrZXlFbnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGtleUVudGVyKG5vZGUsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgY2Fubm90UmVwbGFjZU9yUmVtb3ZlSW5LZXlIYW5kbGVyWWV0KG5vZGUsIGtleSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmlzaXRBcnJheSh2aXNpdG9yLCB2YWx1ZSwgcGF0aCwga2V5KTtcbiAgfSBlbHNlIHtcbiAgICBsZXQga2V5UGF0aCA9IG5ldyBQYXRoKHZhbHVlLCBwYXRoLCBrZXkpO1xuICAgIGxldCByZXN1bHQgPSB2aXNpdE5vZGUodmlzaXRvciwga2V5UGF0aCk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUT0RPOiBkeW5hbWljYWxseSBjaGVjayB0aGUgcmVzdWx0cyBieSBoYXZpbmcgYSB0YWJsZSBvZlxuICAgICAgLy8gZXhwZWN0ZWQgbm9kZSB0eXBlcyBpbiB2YWx1ZSBzcGFjZSwgbm90IGp1c3QgdHlwZSBzcGFjZVxuICAgICAgYXNzaWduS2V5KG5vZGUsIGtleSwgdmFsdWUsIHJlc3VsdCBhcyBhbnkpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChrZXlFeGl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoa2V5RXhpdChub2RlLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IGNhbm5vdFJlcGxhY2VPclJlbW92ZUluS2V5SGFuZGxlcllldChub2RlLCBrZXkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2aXNpdEFycmF5KFxuICB2aXNpdG9yOiBOb2RlVmlzaXRvcixcbiAgYXJyYXk6IEFTVC5Ob2RlW10sXG4gIHBhcmVudDogUGF0aDxBU1QuTm9kZT4gfCBudWxsLFxuICBwYXJlbnRLZXk6IHN0cmluZyB8IG51bGxcbikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IG5vZGUgPSBhcnJheVtpXTtcbiAgICBsZXQgcGF0aCA9IG5ldyBQYXRoKG5vZGUsIHBhcmVudCwgcGFyZW50S2V5KTtcbiAgICBsZXQgcmVzdWx0ID0gdmlzaXROb2RlKHZpc2l0b3IsIHBhdGgpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaSArPSBzcGxpY2VBcnJheShhcnJheSwgaSwgcmVzdWx0KSAtIDE7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbktleTxOIGV4dGVuZHMgQVNULk5vZGUsIEsgZXh0ZW5kcyBWaXNpdG9yS2V5PE4+PihcbiAgbm9kZTogTixcbiAga2V5OiBLLFxuICB2YWx1ZTogQVNULk5vZGUsXG4gIHJlc3VsdDogTltLXSB8IFtOW0tdXSB8IG51bGxcbikge1xuICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgY2Fubm90UmVtb3ZlTm9kZSh2YWx1ZSwgbm9kZSwga2V5KTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgc2V0KG5vZGUsIGtleSwgcmVzdWx0WzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgY2Fubm90UmVtb3ZlTm9kZSh2YWx1ZSwgbm9kZSwga2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGNhbm5vdFJlcGxhY2VOb2RlKHZhbHVlLCBub2RlLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZXQobm9kZSwga2V5LCByZXN1bHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNwbGljZUFycmF5KGFycmF5OiBBU1QuTm9kZVtdLCBpbmRleDogbnVtYmVyLCByZXN1bHQ6IEFTVC5Ob2RlIHwgQVNULk5vZGVbXSB8IG51bGwpIHtcbiAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgIGFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxLCAuLi5yZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIGFycmF5LnNwbGljZShpbmRleCwgMSwgcmVzdWx0KTtcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmF2ZXJzZShub2RlOiBBU1QuTm9kZSwgdmlzaXRvcjogTm9kZVZpc2l0b3IpIHtcbiAgbGV0IHBhdGggPSBuZXcgUGF0aChub2RlKTtcbiAgdmlzaXROb2RlKHZpc2l0b3IsIHBhdGgpO1xufVxuIiwiY29uc3QgZW51bSBDaGFyIHtcbiAgTkJTUCA9IDB4YTAsXG4gIFFVT1QgPSAweDIyLFxuICBMVCA9IDB4M2MsXG4gIEdUID0gMHgzZSxcbiAgQU1QID0gMHgyNixcbn1cblxuY29uc3QgQVRUUl9WQUxVRV9SRUdFWF9URVNUID0gL1tcXHhBMFwiJl0vO1xuY29uc3QgQVRUUl9WQUxVRV9SRUdFWF9SRVBMQUNFID0gbmV3IFJlZ0V4cChBVFRSX1ZBTFVFX1JFR0VYX1RFU1Quc291cmNlLCAnZycpO1xuXG5jb25zdCBURVhUX1JFR0VYX1RFU1QgPSAvW1xceEEwJjw+XS87XG5jb25zdCBURVhUX1JFR0VYX1JFUExBQ0UgPSBuZXcgUmVnRXhwKFRFWFRfUkVHRVhfVEVTVC5zb3VyY2UsICdnJyk7XG5cbmZ1bmN0aW9uIGF0dHJWYWx1ZVJlcGxhY2VyKGNoYXI6IHN0cmluZykge1xuICBzd2l0Y2ggKGNoYXIuY2hhckNvZGVBdCgwKSkge1xuICAgIGNhc2UgQ2hhci5OQlNQOlxuICAgICAgcmV0dXJuICcmbmJzcDsnO1xuICAgIGNhc2UgQ2hhci5RVU9UOlxuICAgICAgcmV0dXJuICcmcXVvdDsnO1xuICAgIGNhc2UgQ2hhci5BTVA6XG4gICAgICByZXR1cm4gJyZhbXA7JztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGNoYXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGV4dFJlcGxhY2VyKGNoYXI6IHN0cmluZykge1xuICBzd2l0Y2ggKGNoYXIuY2hhckNvZGVBdCgwKSkge1xuICAgIGNhc2UgQ2hhci5OQlNQOlxuICAgICAgcmV0dXJuICcmbmJzcDsnO1xuICAgIGNhc2UgQ2hhci5BTVA6XG4gICAgICByZXR1cm4gJyZhbXA7JztcbiAgICBjYXNlIENoYXIuTFQ6XG4gICAgICByZXR1cm4gJyZsdDsnO1xuICAgIGNhc2UgQ2hhci5HVDpcbiAgICAgIHJldHVybiAnJmd0Oyc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjaGFyO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVBdHRyVmFsdWUoYXR0clZhbHVlOiBzdHJpbmcpIHtcbiAgaWYgKEFUVFJfVkFMVUVfUkVHRVhfVEVTVC50ZXN0KGF0dHJWYWx1ZSkpIHtcbiAgICByZXR1cm4gYXR0clZhbHVlLnJlcGxhY2UoQVRUUl9WQUxVRV9SRUdFWF9SRVBMQUNFLCBhdHRyVmFsdWVSZXBsYWNlcik7XG4gIH1cbiAgcmV0dXJuIGF0dHJWYWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZVRleHQodGV4dDogc3RyaW5nKSB7XG4gIGlmIChURVhUX1JFR0VYX1RFU1QudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoVEVYVF9SRUdFWF9SRVBMQUNFLCB0ZXh0UmVwbGFjZXIpO1xuICB9XG4gIHJldHVybiB0ZXh0O1xufVxuIiwiaW1wb3J0IHtcbiAgQXR0ck5vZGUsXG4gIEJsb2NrLFxuICBCbG9ja1N0YXRlbWVudCxcbiAgRWxlbWVudE5vZGUsXG4gIE11c3RhY2hlU3RhdGVtZW50LFxuICBOb2RlLFxuICBQcm9ncmFtLFxuICBUZXh0Tm9kZSxcbiAgUGFydGlhbFN0YXRlbWVudCxcbiAgQ29uY2F0U3RhdGVtZW50LFxuICBNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQsXG4gIENvbW1lbnRTdGF0ZW1lbnQsXG4gIEVsZW1lbnRNb2RpZmllclN0YXRlbWVudCxcbiAgRXhwcmVzc2lvbixcbiAgUGF0aEV4cHJlc3Npb24sXG4gIFN1YkV4cHJlc3Npb24sXG4gIEhhc2gsXG4gIEhhc2hQYWlyLFxuICBMaXRlcmFsLFxuICBTdHJpbmdMaXRlcmFsLFxuICBCb29sZWFuTGl0ZXJhbCxcbiAgTnVtYmVyTGl0ZXJhbCxcbiAgVW5kZWZpbmVkTGl0ZXJhbCxcbiAgTnVsbExpdGVyYWwsXG4gIFRvcExldmVsU3RhdGVtZW50LFxuICBUZW1wbGF0ZSxcbn0gZnJvbSAnLi4vdHlwZXMvbm9kZXMnO1xuaW1wb3J0IHsgdm9pZE1hcCB9IGZyb20gJy4uL3BhcnNlci90b2tlbml6ZXItZXZlbnQtaGFuZGxlcnMnO1xuaW1wb3J0IHsgZXNjYXBlVGV4dCwgZXNjYXBlQXR0clZhbHVlIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3QgTk9OX1dISVRFU1BBQ0UgPSAvXFxTLztcblxuZXhwb3J0IGludGVyZmFjZSBQcmludGVyT3B0aW9ucyB7XG4gIGVudGl0eUVuY29kaW5nOiAndHJhbnNmb3JtZWQnIHwgJ3Jhdyc7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gb3ZlcnJpZGUgdGhlIG1lY2hhbmlzbSBvZiBwcmludGluZyBhIGdpdmVuIEFTVC5Ob2RlLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgZ2VuZXJhbGx5IG9ubHkgYmUgdXNlZnVsIHRvIHNvdXJjZSAtPiBzb3VyY2UgY29kZW1vZHNcbiAgICogd2hlcmUgeW91IHdvdWxkIGxpa2UgdG8gc3BlY2lhbGl6ZS9vdmVycmlkZSB0aGUgd2F5IGEgZ2l2ZW4gbm9kZSBpc1xuICAgKiBwcmludGVkIChlLmcuIHlvdSB3b3VsZCBsaWtlIHRvIHByZXNlcnZlIGFzIG11Y2ggb2YgdGhlIG9yaWdpbmFsXG4gICAqIGZvcm1hdHRpbmcgYXMgcG9zc2libGUpLlxuICAgKlxuICAgKiBXaGVuIHRoZSBwcm92aWRlZCBvdmVycmlkZSByZXR1cm5zIHVuZGVmaW5lZCwgdGhlIGRlZmF1bHQgYnVpbHQgaW4gcHJpbnRpbmdcbiAgICogd2lsbCBiZSBkb25lIGZvciB0aGUgQVNULk5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhc3QgdGhlIGFzdCBub2RlIHRvIGJlIHByaW50ZWRcbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgc3BlY2lmaWVkIGR1cmluZyB0aGUgcHJpbnQoKSBpbnZvY2F0aW9uXG4gICAqL1xuICBvdmVycmlkZT8oYXN0OiBOb2RlLCBvcHRpb25zOiBQcmludGVyT3B0aW9ucyk6IHZvaWQgfCBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByaW50ZXIge1xuICBwcml2YXRlIGJ1ZmZlciA9ICcnO1xuICBwcml2YXRlIG9wdGlvbnM6IFByaW50ZXJPcHRpb25zO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFByaW50ZXJPcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIC8qXG4gICAgVGhpcyBpcyB1c2VkIGJ5IF9hbGxfIG1ldGhvZHMgb24gdGhpcyBQcmludGVyIGNsYXNzIHRoYXQgYWRkIHRvIGB0aGlzLmJ1ZmZlcmAsXG4gICAgaXQgYWxsb3dzIGNvbnN1bWVycyBvZiB0aGUgcHJpbnRlciB0byB1c2UgYWx0ZXJuYXRlIHN0cmluZyByZXByZXNlbnRhdGlvbnMgZm9yXG4gICAgYSBnaXZlbiBub2RlLlxuXG4gICAgVGhlIHByaW1hcnkgdXNlIGNhc2UgZm9yIHRoaXMgYXJlIHRoaW5ncyBsaWtlIHNvdXJjZSAtPiBzb3VyY2UgY29kZW1vZCB1dGlsaXRpZXMuXG4gICAgRm9yIGV4YW1wbGUsIGVtYmVyLXRlbXBsYXRlLXJlY2FzdCBhdHRlbXB0cyB0byBhbHdheXMgcHJlc2VydmUgdGhlIG9yaWdpbmFsIHN0cmluZ1xuICAgIGZvcm1hdHRpbmcgaW4gZWFjaCBBU1Qgbm9kZSBpZiBubyBtb2RpZmljYXRpb25zIGFyZSBtYWRlIHRvIGl0LlxuICAqL1xuICBoYW5kbGVkQnlPdmVycmlkZShub2RlOiBOb2RlLCBlbnN1cmVMZWFkaW5nV2hpdGVzcGFjZSA9IGZhbHNlKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vdmVycmlkZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy5vcHRpb25zLm92ZXJyaWRlKG5vZGUsIHRoaXMub3B0aW9ucyk7XG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGVuc3VyZUxlYWRpbmdXaGl0ZXNwYWNlICYmIE5PTl9XSElURVNQQUNFLnRlc3QocmVzdWx0WzBdKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGAgJHtyZXN1bHR9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYnVmZmVyICs9IHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgTm9kZShub2RlOiBOb2RlKTogdm9pZCB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ011c3RhY2hlU3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ0Jsb2NrU3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ1BhcnRpYWxTdGF0ZW1lbnQnOlxuICAgICAgY2FzZSAnTXVzdGFjaGVDb21tZW50U3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ0NvbW1lbnRTdGF0ZW1lbnQnOlxuICAgICAgY2FzZSAnVGV4dE5vZGUnOlxuICAgICAgY2FzZSAnRWxlbWVudE5vZGUnOlxuICAgICAgY2FzZSAnQXR0ck5vZGUnOlxuICAgICAgY2FzZSAnQmxvY2snOlxuICAgICAgY2FzZSAnVGVtcGxhdGUnOlxuICAgICAgICByZXR1cm4gdGhpcy5Ub3BMZXZlbFN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgJ1N0cmluZ0xpdGVyYWwnOlxuICAgICAgY2FzZSAnQm9vbGVhbkxpdGVyYWwnOlxuICAgICAgY2FzZSAnTnVtYmVyTGl0ZXJhbCc6XG4gICAgICBjYXNlICdVbmRlZmluZWRMaXRlcmFsJzpcbiAgICAgIGNhc2UgJ051bGxMaXRlcmFsJzpcbiAgICAgIGNhc2UgJ1BhdGhFeHByZXNzaW9uJzpcbiAgICAgIGNhc2UgJ1N1YkV4cHJlc3Npb24nOlxuICAgICAgICByZXR1cm4gdGhpcy5FeHByZXNzaW9uKG5vZGUpO1xuICAgICAgY2FzZSAnUHJvZ3JhbSc6XG4gICAgICAgIHJldHVybiB0aGlzLkJsb2NrKG5vZGUpO1xuICAgICAgY2FzZSAnQ29uY2F0U3RhdGVtZW50JzpcbiAgICAgICAgLy8gc2hvdWxkIGhhdmUgYW4gQXR0ck5vZGUgcGFyZW50XG4gICAgICAgIHJldHVybiB0aGlzLkNvbmNhdFN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgJ0hhc2gnOlxuICAgICAgICByZXR1cm4gdGhpcy5IYXNoKG5vZGUpO1xuICAgICAgY2FzZSAnSGFzaFBhaXInOlxuICAgICAgICByZXR1cm4gdGhpcy5IYXNoUGFpcihub2RlKTtcbiAgICAgIGNhc2UgJ0VsZW1lbnRNb2RpZmllclN0YXRlbWVudCc6XG4gICAgICAgIHJldHVybiB0aGlzLkVsZW1lbnRNb2RpZmllclN0YXRlbWVudChub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5yZWFjaGFibGUobm9kZSk7XG4gIH1cblxuICBFeHByZXNzaW9uKGV4cHJlc3Npb246IEV4cHJlc3Npb24pOiB2b2lkIHtcbiAgICBzd2l0Y2ggKGV4cHJlc3Npb24udHlwZSkge1xuICAgICAgY2FzZSAnU3RyaW5nTGl0ZXJhbCc6XG4gICAgICBjYXNlICdCb29sZWFuTGl0ZXJhbCc6XG4gICAgICBjYXNlICdOdW1iZXJMaXRlcmFsJzpcbiAgICAgIGNhc2UgJ1VuZGVmaW5lZExpdGVyYWwnOlxuICAgICAgY2FzZSAnTnVsbExpdGVyYWwnOlxuICAgICAgICByZXR1cm4gdGhpcy5MaXRlcmFsKGV4cHJlc3Npb24pO1xuICAgICAgY2FzZSAnUGF0aEV4cHJlc3Npb24nOlxuICAgICAgICByZXR1cm4gdGhpcy5QYXRoRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgICAgIGNhc2UgJ1N1YkV4cHJlc3Npb24nOlxuICAgICAgICByZXR1cm4gdGhpcy5TdWJFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICAgIH1cbiAgICByZXR1cm4gdW5yZWFjaGFibGUoZXhwcmVzc2lvbik7XG4gIH1cblxuICBMaXRlcmFsKGxpdGVyYWw6IExpdGVyYWwpIHtcbiAgICBzd2l0Y2ggKGxpdGVyYWwudHlwZSkge1xuICAgICAgY2FzZSAnU3RyaW5nTGl0ZXJhbCc6XG4gICAgICAgIHJldHVybiB0aGlzLlN0cmluZ0xpdGVyYWwobGl0ZXJhbCk7XG4gICAgICBjYXNlICdCb29sZWFuTGl0ZXJhbCc6XG4gICAgICAgIHJldHVybiB0aGlzLkJvb2xlYW5MaXRlcmFsKGxpdGVyYWwpO1xuICAgICAgY2FzZSAnTnVtYmVyTGl0ZXJhbCc6XG4gICAgICAgIHJldHVybiB0aGlzLk51bWJlckxpdGVyYWwobGl0ZXJhbCk7XG4gICAgICBjYXNlICdVbmRlZmluZWRMaXRlcmFsJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuVW5kZWZpbmVkTGl0ZXJhbChsaXRlcmFsKTtcbiAgICAgIGNhc2UgJ051bGxMaXRlcmFsJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuTnVsbExpdGVyYWwobGl0ZXJhbCk7XG4gICAgfVxuICAgIHJldHVybiB1bnJlYWNoYWJsZShsaXRlcmFsKTtcbiAgfVxuXG4gIFRvcExldmVsU3RhdGVtZW50KHN0YXRlbWVudDogVG9wTGV2ZWxTdGF0ZW1lbnQpIHtcbiAgICBzd2l0Y2ggKHN0YXRlbWVudC50eXBlKSB7XG4gICAgICBjYXNlICdNdXN0YWNoZVN0YXRlbWVudCc6XG4gICAgICAgIHJldHVybiB0aGlzLk11c3RhY2hlU3RhdGVtZW50KHN0YXRlbWVudCk7XG4gICAgICBjYXNlICdCbG9ja1N0YXRlbWVudCc6XG4gICAgICAgIHJldHVybiB0aGlzLkJsb2NrU3RhdGVtZW50KHN0YXRlbWVudCk7XG4gICAgICBjYXNlICdQYXJ0aWFsU3RhdGVtZW50JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuUGFydGlhbFN0YXRlbWVudChzdGF0ZW1lbnQpO1xuICAgICAgY2FzZSAnTXVzdGFjaGVDb21tZW50U3RhdGVtZW50JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuTXVzdGFjaGVDb21tZW50U3RhdGVtZW50KHN0YXRlbWVudCk7XG4gICAgICBjYXNlICdDb21tZW50U3RhdGVtZW50JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuQ29tbWVudFN0YXRlbWVudChzdGF0ZW1lbnQpO1xuICAgICAgY2FzZSAnVGV4dE5vZGUnOlxuICAgICAgICByZXR1cm4gdGhpcy5UZXh0Tm9kZShzdGF0ZW1lbnQpO1xuICAgICAgY2FzZSAnRWxlbWVudE5vZGUnOlxuICAgICAgICByZXR1cm4gdGhpcy5FbGVtZW50Tm9kZShzdGF0ZW1lbnQpO1xuICAgICAgY2FzZSAnQmxvY2snOlxuICAgICAgY2FzZSAnVGVtcGxhdGUnOlxuICAgICAgICByZXR1cm4gdGhpcy5CbG9jayhzdGF0ZW1lbnQpO1xuICAgICAgY2FzZSAnQXR0ck5vZGUnOlxuICAgICAgICAvLyBzaG91bGQgaGF2ZSBlbGVtZW50XG4gICAgICAgIHJldHVybiB0aGlzLkF0dHJOb2RlKHN0YXRlbWVudCk7XG4gICAgfVxuICAgIHVucmVhY2hhYmxlKHN0YXRlbWVudCk7XG4gIH1cblxuICBCbG9jayhibG9jazogQmxvY2sgfCBQcm9ncmFtIHwgVGVtcGxhdGUpOiB2b2lkIHtcbiAgICAvKlxuICAgICAgV2hlbiBwcm9jZXNzaW5nIGEgdGVtcGxhdGUgbGlrZTpcblxuICAgICAgYGBgaGJzXG4gICAgICB7eyNpZiB3aGF0ZXZlcn19XG4gICAgICAgIHdoYXRldmVyXG4gICAgICB7e2Vsc2UgaWYgc29tZXRoaW5nRWxzZX19XG4gICAgICAgIHNvbWV0aGluZyBlbHNlXG4gICAgICB7e2Vsc2V9fVxuICAgICAgICBmYWxsYmFja1xuICAgICAge3svaWZ9fVxuICAgICAgYGBgXG5cbiAgICAgIFRoZSBBU1Qgc3RpbGwgX2VmZmVjdGl2ZWx5XyBsb29rcyBsaWtlOlxuXG4gICAgICBgYGBoYnNcbiAgICAgIHt7I2lmIHdoYXRldmVyfX1cbiAgICAgICAgd2hhdGV2ZXJcbiAgICAgIHt7ZWxzZX19e3sjaWYgc29tZXRoaW5nRWxzZX19XG4gICAgICAgIHNvbWV0aGluZyBlbHNlXG4gICAgICB7e2Vsc2V9fVxuICAgICAgICBmYWxsYmFja1xuICAgICAge3svaWZ9fXt7L2lmfX1cbiAgICAgIGBgYFxuXG4gICAgICBUaGUgb25seSB3YXkgd2UgY2FuIHRlbGwgaWYgdGhhdCBpcyB0aGUgY2FzZSBpcyBieSBjaGVja2luZyBmb3JcbiAgICAgIGBibG9jay5jaGFpbmVkYCwgYnV0IHVuZm9ydHVuYXRlbHkgd2hlbiB0aGUgYWN0dWFsIHN0YXRlbWVudHMgYXJlXG4gICAgICBwcm9jZXNzZWQgdGhlIGBibG9jay5ib2R5WzBdYCBub2RlICh3aGljaCB3aWxsIGFsd2F5cyBiZSBhXG4gICAgICBgQmxvY2tTdGF0ZW1lbnRgKSBoYXMgbm8gY2x1ZSB0aGF0IGl0cyBhbnNjZXN0b3IgYEJsb2NrYCBub2RlIHdhc1xuICAgICAgY2hhaW5lZC5cblxuICAgICAgVGhpcyBcImZvcndhcmRzXCIgdGhlIGBjaGFpbmVkYCBzZXR0aW5nIHNvIHRoYXQgd2UgY2FuIGNoZWNrXG4gICAgICBpdCBsYXRlciB3aGVuIHByb2Nlc3NpbmcgdGhlIGBCbG9ja1N0YXRlbWVudGAuXG4gICAgKi9cbiAgICBpZiAoYmxvY2suY2hhaW5lZCkge1xuICAgICAgbGV0IGZpcnN0Q2hpbGQgPSBibG9jay5ib2R5WzBdIGFzIEJsb2NrU3RhdGVtZW50O1xuICAgICAgZmlyc3RDaGlsZC5jaGFpbmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYW5kbGVkQnlPdmVycmlkZShibG9jaykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLlRvcExldmVsU3RhdGVtZW50cyhibG9jay5ib2R5KTtcbiAgfVxuXG4gIFRvcExldmVsU3RhdGVtZW50cyhzdGF0ZW1lbnRzOiBUb3BMZXZlbFN0YXRlbWVudFtdKSB7XG4gICAgc3RhdGVtZW50cy5mb3JFYWNoKHN0YXRlbWVudCA9PiB0aGlzLlRvcExldmVsU3RhdGVtZW50KHN0YXRlbWVudCkpO1xuICB9XG5cbiAgRWxlbWVudE5vZGUoZWw6IEVsZW1lbnROb2RlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUoZWwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5PcGVuRWxlbWVudE5vZGUoZWwpO1xuICAgIHRoaXMuVG9wTGV2ZWxTdGF0ZW1lbnRzKGVsLmNoaWxkcmVuKTtcbiAgICB0aGlzLkNsb3NlRWxlbWVudE5vZGUoZWwpO1xuICB9XG5cbiAgT3BlbkVsZW1lbnROb2RlKGVsOiBFbGVtZW50Tm9kZSk6IHZvaWQge1xuICAgIHRoaXMuYnVmZmVyICs9IGA8JHtlbC50YWd9YDtcbiAgICBpZiAoZWwuYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgIGVsLmF0dHJpYnV0ZXMuZm9yRWFjaChhdHRyID0+IHtcbiAgICAgICAgdGhpcy5idWZmZXIgKz0gJyAnO1xuICAgICAgICB0aGlzLkF0dHJOb2RlKGF0dHIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbC5tb2RpZmllcnMubGVuZ3RoKSB7XG4gICAgICBlbC5tb2RpZmllcnMuZm9yRWFjaChtb2QgPT4ge1xuICAgICAgICB0aGlzLmJ1ZmZlciArPSAnICc7XG4gICAgICAgIHRoaXMuRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50KG1vZCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVsLmNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgZWwuY29tbWVudHMuZm9yRWFjaChjb21tZW50ID0+IHtcbiAgICAgICAgdGhpcy5idWZmZXIgKz0gJyAnO1xuICAgICAgICB0aGlzLk11c3RhY2hlQ29tbWVudFN0YXRlbWVudChjb21tZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZWwuYmxvY2tQYXJhbXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLkJsb2NrUGFyYW1zKGVsLmJsb2NrUGFyYW1zKTtcbiAgICB9XG4gICAgaWYgKGVsLnNlbGZDbG9zaW5nKSB7XG4gICAgICB0aGlzLmJ1ZmZlciArPSAnIC8nO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlciArPSAnPic7XG4gIH1cblxuICBDbG9zZUVsZW1lbnROb2RlKGVsOiBFbGVtZW50Tm9kZSk6IHZvaWQge1xuICAgIGlmIChlbC5zZWxmQ2xvc2luZyB8fCB2b2lkTWFwW2VsLnRhZy50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlciArPSBgPC8ke2VsLnRhZ30+YDtcbiAgfVxuXG4gIEF0dHJOb2RlKGF0dHI6IEF0dHJOb2RlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUoYXR0cikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgeyBuYW1lLCB2YWx1ZSB9ID0gYXR0cjtcblxuICAgIHRoaXMuYnVmZmVyICs9IG5hbWU7XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09ICdUZXh0Tm9kZScgfHwgdmFsdWUuY2hhcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5idWZmZXIgKz0gJz0nO1xuICAgICAgdGhpcy5BdHRyTm9kZVZhbHVlKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBBdHRyTm9kZVZhbHVlKHZhbHVlOiBBdHRyTm9kZVsndmFsdWUnXSkge1xuICAgIGlmICh2YWx1ZS50eXBlID09PSAnVGV4dE5vZGUnKSB7XG4gICAgICB0aGlzLmJ1ZmZlciArPSAnXCInO1xuICAgICAgdGhpcy5UZXh0Tm9kZSh2YWx1ZSwgdHJ1ZSk7XG4gICAgICB0aGlzLmJ1ZmZlciArPSAnXCInO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLk5vZGUodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIFRleHROb2RlKHRleHQ6IFRleHROb2RlLCBpc0F0dHI/OiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUodGV4dCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmVudGl0eUVuY29kaW5nID09PSAncmF3Jykge1xuICAgICAgdGhpcy5idWZmZXIgKz0gdGV4dC5jaGFycztcbiAgICB9IGVsc2UgaWYgKGlzQXR0cikge1xuICAgICAgdGhpcy5idWZmZXIgKz0gZXNjYXBlQXR0clZhbHVlKHRleHQuY2hhcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJ1ZmZlciArPSBlc2NhcGVUZXh0KHRleHQuY2hhcnMpO1xuICAgIH1cbiAgfVxuXG4gIE11c3RhY2hlU3RhdGVtZW50KG11c3RhY2hlOiBNdXN0YWNoZVN0YXRlbWVudCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmhhbmRsZWRCeU92ZXJyaWRlKG11c3RhY2hlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyICs9IG11c3RhY2hlLmVzY2FwZWQgPyAne3snIDogJ3t7eyc7XG5cbiAgICBpZiAobXVzdGFjaGUuc3RyaXAub3Blbikge1xuICAgICAgdGhpcy5idWZmZXIgKz0gJ34nO1xuICAgIH1cblxuICAgIHRoaXMuRXhwcmVzc2lvbihtdXN0YWNoZS5wYXRoKTtcbiAgICB0aGlzLlBhcmFtcyhtdXN0YWNoZS5wYXJhbXMpO1xuICAgIHRoaXMuSGFzaChtdXN0YWNoZS5oYXNoKTtcblxuICAgIGlmIChtdXN0YWNoZS5zdHJpcC5jbG9zZSkge1xuICAgICAgdGhpcy5idWZmZXIgKz0gJ34nO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyICs9IG11c3RhY2hlLmVzY2FwZWQgPyAnfX0nIDogJ319fSc7XG4gIH1cblxuICBCbG9ja1N0YXRlbWVudChibG9jazogQmxvY2tTdGF0ZW1lbnQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5oYW5kbGVkQnlPdmVycmlkZShibG9jaykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYmxvY2suY2hhaW5lZCkge1xuICAgICAgdGhpcy5idWZmZXIgKz0gYmxvY2suaW52ZXJzZVN0cmlwLm9wZW4gPyAne3t+JyA6ICd7eyc7XG4gICAgICB0aGlzLmJ1ZmZlciArPSAnZWxzZSAnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJ1ZmZlciArPSBibG9jay5vcGVuU3RyaXAub3BlbiA/ICd7e34jJyA6ICd7eyMnO1xuICAgIH1cblxuICAgIHRoaXMuRXhwcmVzc2lvbihibG9jay5wYXRoKTtcbiAgICB0aGlzLlBhcmFtcyhibG9jay5wYXJhbXMpO1xuICAgIHRoaXMuSGFzaChibG9jay5oYXNoKTtcbiAgICBpZiAoYmxvY2sucHJvZ3JhbS5ibG9ja1BhcmFtcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuQmxvY2tQYXJhbXMoYmxvY2sucHJvZ3JhbS5ibG9ja1BhcmFtcyk7XG4gICAgfVxuXG4gICAgaWYgKGJsb2NrLmNoYWluZWQpIHtcbiAgICAgIHRoaXMuYnVmZmVyICs9IGJsb2NrLmludmVyc2VTdHJpcC5jbG9zZSA/ICd+fX0nIDogJ319JztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5idWZmZXIgKz0gYmxvY2sub3BlblN0cmlwLmNsb3NlID8gJ359fScgOiAnfX0nO1xuICAgIH1cblxuICAgIHRoaXMuQmxvY2soYmxvY2sucHJvZ3JhbSk7XG5cbiAgICBpZiAoYmxvY2suaW52ZXJzZSkge1xuICAgICAgaWYgKCFibG9jay5pbnZlcnNlLmNoYWluZWQpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgKz0gYmxvY2suaW52ZXJzZVN0cmlwLm9wZW4gPyAne3t+JyA6ICd7eyc7XG4gICAgICAgIHRoaXMuYnVmZmVyICs9ICdlbHNlJztcbiAgICAgICAgdGhpcy5idWZmZXIgKz0gYmxvY2suaW52ZXJzZVN0cmlwLmNsb3NlID8gJ359fScgOiAnfX0nO1xuICAgICAgfVxuXG4gICAgICB0aGlzLkJsb2NrKGJsb2NrLmludmVyc2UpO1xuICAgIH1cblxuICAgIGlmICghYmxvY2suY2hhaW5lZCkge1xuICAgICAgdGhpcy5idWZmZXIgKz0gYmxvY2suY2xvc2VTdHJpcC5vcGVuID8gJ3t7fi8nIDogJ3t7Lyc7XG4gICAgICB0aGlzLkV4cHJlc3Npb24oYmxvY2sucGF0aCk7XG4gICAgICB0aGlzLmJ1ZmZlciArPSBibG9jay5jbG9zZVN0cmlwLmNsb3NlID8gJ359fScgOiAnfX0nO1xuICAgIH1cbiAgfVxuXG4gIEJsb2NrUGFyYW1zKGJsb2NrUGFyYW1zOiBzdHJpbmdbXSkge1xuICAgIHRoaXMuYnVmZmVyICs9IGAgYXMgfCR7YmxvY2tQYXJhbXMuam9pbignICcpfXxgO1xuICB9XG5cbiAgUGFydGlhbFN0YXRlbWVudChwYXJ0aWFsOiBQYXJ0aWFsU3RhdGVtZW50KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUocGFydGlhbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlciArPSAne3s+JztcbiAgICB0aGlzLkV4cHJlc3Npb24ocGFydGlhbC5uYW1lKTtcbiAgICB0aGlzLlBhcmFtcyhwYXJ0aWFsLnBhcmFtcyk7XG4gICAgdGhpcy5IYXNoKHBhcnRpYWwuaGFzaCk7XG4gICAgdGhpcy5idWZmZXIgKz0gJ319JztcbiAgfVxuXG4gIENvbmNhdFN0YXRlbWVudChjb25jYXQ6IENvbmNhdFN0YXRlbWVudCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmhhbmRsZWRCeU92ZXJyaWRlKGNvbmNhdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlciArPSAnXCInO1xuICAgIGNvbmNhdC5wYXJ0cy5mb3JFYWNoKHBhcnQgPT4ge1xuICAgICAgaWYgKHBhcnQudHlwZSA9PT0gJ1RleHROb2RlJykge1xuICAgICAgICB0aGlzLlRleHROb2RlKHBhcnQsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5Ob2RlKHBhcnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYnVmZmVyICs9ICdcIic7XG4gIH1cblxuICBNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQoY29tbWVudDogTXVzdGFjaGVDb21tZW50U3RhdGVtZW50KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUoY29tbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlciArPSBge3shLS0ke2NvbW1lbnQudmFsdWV9LS19fWA7XG4gIH1cblxuICBFbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnQobW9kOiBFbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5oYW5kbGVkQnlPdmVycmlkZShtb2QpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXIgKz0gJ3t7JztcbiAgICB0aGlzLkV4cHJlc3Npb24obW9kLnBhdGgpO1xuICAgIHRoaXMuUGFyYW1zKG1vZC5wYXJhbXMpO1xuICAgIHRoaXMuSGFzaChtb2QuaGFzaCk7XG4gICAgdGhpcy5idWZmZXIgKz0gJ319JztcbiAgfVxuXG4gIENvbW1lbnRTdGF0ZW1lbnQoY29tbWVudDogQ29tbWVudFN0YXRlbWVudCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmhhbmRsZWRCeU92ZXJyaWRlKGNvbW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXIgKz0gYDwhLS0ke2NvbW1lbnQudmFsdWV9LS0+YDtcbiAgfVxuXG4gIFBhdGhFeHByZXNzaW9uKHBhdGg6IFBhdGhFeHByZXNzaW9uKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUocGF0aCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlciArPSBwYXRoLm9yaWdpbmFsO1xuICB9XG5cbiAgU3ViRXhwcmVzc2lvbihzZXhwOiBTdWJFeHByZXNzaW9uKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUoc2V4cCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlciArPSAnKCc7XG4gICAgdGhpcy5FeHByZXNzaW9uKHNleHAucGF0aCk7XG4gICAgdGhpcy5QYXJhbXMoc2V4cC5wYXJhbXMpO1xuICAgIHRoaXMuSGFzaChzZXhwLmhhc2gpO1xuICAgIHRoaXMuYnVmZmVyICs9ICcpJztcbiAgfVxuXG4gIFBhcmFtcyhwYXJhbXM6IEV4cHJlc3Npb25bXSkge1xuICAgIC8vIFRPRE86IGltcGxlbWVudCBhIHRvcCBsZXZlbCBQYXJhbXMgQVNUIG5vZGUgKGp1c3QgbGlrZSB0aGUgSGFzaCBvYmplY3QpXG4gICAgLy8gc28gdGhhdCB0aGlzIGNhbiBhbHNvIGJlIG92ZXJyaWRkZW5cbiAgICBpZiAocGFyYW1zLmxlbmd0aCkge1xuICAgICAgcGFyYW1zLmZvckVhY2gocGFyYW0gPT4ge1xuICAgICAgICB0aGlzLmJ1ZmZlciArPSAnICc7XG4gICAgICAgIHRoaXMuRXhwcmVzc2lvbihwYXJhbSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBIYXNoKGhhc2g6IEhhc2gpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5oYW5kbGVkQnlPdmVycmlkZShoYXNoLCB0cnVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhhc2gucGFpcnMuZm9yRWFjaChwYWlyID0+IHtcbiAgICAgIHRoaXMuYnVmZmVyICs9ICcgJztcbiAgICAgIHRoaXMuSGFzaFBhaXIocGFpcik7XG4gICAgfSk7XG4gIH1cblxuICBIYXNoUGFpcihwYWlyOiBIYXNoUGFpcik6IHZvaWQge1xuICAgIGlmICh0aGlzLmhhbmRsZWRCeU92ZXJyaWRlKHBhaXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXIgKz0gcGFpci5rZXk7XG4gICAgdGhpcy5idWZmZXIgKz0gJz0nO1xuICAgIHRoaXMuTm9kZShwYWlyLnZhbHVlKTtcbiAgfVxuXG4gIFN0cmluZ0xpdGVyYWwoc3RyOiBTdHJpbmdMaXRlcmFsKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUoc3RyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyICs9IEpTT04uc3RyaW5naWZ5KHN0ci52YWx1ZSk7XG4gIH1cblxuICBCb29sZWFuTGl0ZXJhbChib29sOiBCb29sZWFuTGl0ZXJhbCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmhhbmRsZWRCeU92ZXJyaWRlKGJvb2wpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXIgKz0gYm9vbC52YWx1ZTtcbiAgfVxuXG4gIE51bWJlckxpdGVyYWwobnVtYmVyOiBOdW1iZXJMaXRlcmFsKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFuZGxlZEJ5T3ZlcnJpZGUobnVtYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyICs9IG51bWJlci52YWx1ZTtcbiAgfVxuXG4gIFVuZGVmaW5lZExpdGVyYWwobm9kZTogVW5kZWZpbmVkTGl0ZXJhbCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmhhbmRsZWRCeU92ZXJyaWRlKG5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXIgKz0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBOdWxsTGl0ZXJhbChub2RlOiBOdWxsTGl0ZXJhbCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmhhbmRsZWRCeU92ZXJyaWRlKG5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXIgKz0gJ251bGwnO1xuICB9XG5cbiAgcHJpbnQobm9kZTogTm9kZSkge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IHRoaXM7XG5cbiAgICBpZiAob3B0aW9ucy5vdmVycmlkZSkge1xuICAgICAgbGV0IHJlc3VsdCA9IG9wdGlvbnMub3ZlcnJpZGUobm9kZSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyID0gJyc7XG4gICAgdGhpcy5Ob2RlKG5vZGUpO1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnJlYWNoYWJsZShub2RlOiBuZXZlcik6IG5ldmVyIHtcbiAgdGhyb3cgbmV3IEVycm9yKGBOb24tZXhoYXVzdGl2ZSBub2RlIG5hcnJvd2luZyAkeygobm9kZSBhcyBhbnkpIGFzIE5vZGUpLnR5cGV9YCk7XG59XG4iLCJpbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi4vdHlwZXMvbm9kZXMnO1xuaW1wb3J0IFByaW50ZXIsIHsgUHJpbnRlck9wdGlvbnMgfSBmcm9tICcuL3ByaW50ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZChcbiAgYXN0OiBOb2RlLFxuICBvcHRpb25zOiBQcmludGVyT3B0aW9ucyA9IHsgZW50aXR5RW5jb2Rpbmc6ICd0cmFuc2Zvcm1lZCcgfVxuKTogc3RyaW5nIHtcbiAgaWYgKCFhc3QpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBsZXQgcHJpbnRlciA9IG5ldyBQcmludGVyKG9wdGlvbnMpO1xuICByZXR1cm4gcHJpbnRlci5wcmludChhc3QpO1xufVxuIiwiaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgKiBhcyBBU1QgZnJvbSAnLi4vdHlwZXMvbm9kZXMnO1xuXG5leHBvcnQgdHlwZSBOb2RlQ2FsbGJhY2s8TiBleHRlbmRzIEFTVC5Ob2RlPiA9IChub2RlOiBOLCB3YWxrZXI6IFdhbGtlcikgPT4gdm9pZDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2Fsa2VyIHtcbiAgcHVibGljIHN0YWNrOiBhbnlbXSA9IFtdO1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgb3JkZXI/OiBhbnkpIHt9XG5cbiAgdmlzaXQ8TiBleHRlbmRzIEFTVC5Ob2RlPihub2RlOiBPcHRpb248Tj4sIGNhbGxiYWNrOiBOb2RlQ2FsbGJhY2s8Tj4pIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrLnB1c2gobm9kZSk7XG5cbiAgICBpZiAodGhpcy5vcmRlciA9PT0gJ3Bvc3QnKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuKG5vZGUsIGNhbGxiYWNrKTtcbiAgICAgIGNhbGxiYWNrKG5vZGUsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhub2RlLCB0aGlzKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4obm9kZSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gIH1cblxuICBjaGlsZHJlbihub2RlOiBhbnksIGNhbGxiYWNrOiBhbnkpIHtcbiAgICBsZXQgdHlwZTtcbiAgICBpZiAobm9kZS50eXBlID09PSAnQmxvY2snIHx8IChub2RlLnR5cGUgPT09ICdUZW1wbGF0ZScgJiYgdmlzaXRvcnMuUHJvZ3JhbSkpIHtcbiAgICAgIHR5cGUgPSAnUHJvZ3JhbSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgfVxuXG4gICAgbGV0IHZpc2l0b3IgPSAodmlzaXRvcnMgYXMgYW55KVt0eXBlXTtcbiAgICBpZiAodmlzaXRvcikge1xuICAgICAgdmlzaXRvcih0aGlzLCBub2RlLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG59XG5cbmxldCB2aXNpdG9ycyA9IHtcbiAgUHJvZ3JhbSh3YWxrZXI6IFdhbGtlciwgbm9kZTogQVNULlByb2dyYW0sIGNhbGxiYWNrOiBOb2RlQ2FsbGJhY2s8QVNULk5vZGU+KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdhbGtlci52aXNpdChub2RlLmJvZHlbaV0sIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG5cbiAgVGVtcGxhdGUod2Fsa2VyOiBXYWxrZXIsIG5vZGU6IEFTVC5UZW1wbGF0ZSwgY2FsbGJhY2s6IE5vZGVDYWxsYmFjazxBU1QuTm9kZT4pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgd2Fsa2VyLnZpc2l0KG5vZGUuYm9keVtpXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcblxuICBCbG9jayh3YWxrZXI6IFdhbGtlciwgbm9kZTogQVNULkJsb2NrLCBjYWxsYmFjazogTm9kZUNhbGxiYWNrPEFTVC5Ob2RlPikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB3YWxrZXIudmlzaXQobm9kZS5ib2R5W2ldLCBjYWxsYmFjayk7XG4gICAgfVxuICB9LFxuXG4gIEVsZW1lbnROb2RlKHdhbGtlcjogV2Fsa2VyLCBub2RlOiBBU1QuRWxlbWVudE5vZGUsIGNhbGxiYWNrOiBOb2RlQ2FsbGJhY2s8QVNULk5vZGU+KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3YWxrZXIudmlzaXQobm9kZS5jaGlsZHJlbltpXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcblxuICBCbG9ja1N0YXRlbWVudCh3YWxrZXI6IFdhbGtlciwgbm9kZTogQVNULkJsb2NrU3RhdGVtZW50LCBjYWxsYmFjazogTm9kZUNhbGxiYWNrPEFTVC5CbG9jaz4pIHtcbiAgICB3YWxrZXIudmlzaXQobm9kZS5wcm9ncmFtLCBjYWxsYmFjayk7XG4gICAgd2Fsa2VyLnZpc2l0KG5vZGUuaW52ZXJzZSB8fCBudWxsLCBjYWxsYmFjayk7XG4gIH0sXG59O1xuIiwiaW1wb3J0IGIsIHsgU1lOVEhFVElDIH0gZnJvbSAnLi4vYnVpbGRlcnMnO1xuaW1wb3J0IHsgYXBwZW5kQ2hpbGQsIHBhcnNlRWxlbWVudEJsb2NrUGFyYW1zIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgSGFuZGxlYmFyc05vZGVWaXNpdG9ycyB9IGZyb20gJy4vaGFuZGxlYmFycy1ub2RlLXZpc2l0b3JzJztcbmltcG9ydCAqIGFzIEFTVCBmcm9tICcuLi90eXBlcy9ub2Rlcyc7XG5pbXBvcnQgKiBhcyBIQlMgZnJvbSAnLi4vdHlwZXMvaGFuZGxlYmFycy1hc3QnO1xuaW1wb3J0IFN5bnRheEVycm9yIGZyb20gJy4uL2Vycm9ycy9zeW50YXgtZXJyb3InO1xuaW1wb3J0IHsgVGFnIH0gZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCBidWlsZGVycyBmcm9tICcuLi9idWlsZGVycyc7XG5pbXBvcnQgdHJhdmVyc2UgZnJvbSAnLi4vdHJhdmVyc2FsL3RyYXZlcnNlJztcbmltcG9ydCBwcmludCBmcm9tICcuLi9nZW5lcmF0aW9uL3ByaW50JztcbmltcG9ydCBXYWxrZXIgZnJvbSAnLi4vdHJhdmVyc2FsL3dhbGtlcic7XG5pbXBvcnQgKiBhcyBoYW5kbGViYXJzIGZyb20gJ2hhbmRsZWJhcnMnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBOb2RlVmlzaXRvciB9IGZyb20gJy4uL3RyYXZlcnNhbC92aXNpdG9yJztcbmltcG9ydCB7IEVudGl0eVBhcnNlciB9IGZyb20gJ3NpbXBsZS1odG1sLXRva2VuaXplcic7XG5cbmV4cG9ydCBjb25zdCB2b2lkTWFwOiB7XG4gIFt0YWdOYW1lOiBzdHJpbmddOiBib29sZWFuO1xufSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmxldCB2b2lkVGFnTmFtZXMgPVxuICAnYXJlYSBiYXNlIGJyIGNvbCBjb21tYW5kIGVtYmVkIGhyIGltZyBpbnB1dCBrZXlnZW4gbGluayBtZXRhIHBhcmFtIHNvdXJjZSB0cmFjayB3YnInO1xudm9pZFRhZ05hbWVzLnNwbGl0KCcgJykuZm9yRWFjaCh0YWdOYW1lID0+IHtcbiAgdm9pZE1hcFt0YWdOYW1lXSA9IHRydWU7XG59KTtcblxuZXhwb3J0IGNsYXNzIFRva2VuaXplckV2ZW50SGFuZGxlcnMgZXh0ZW5kcyBIYW5kbGViYXJzTm9kZVZpc2l0b3JzIHtcbiAgcHJpdmF0ZSB0YWdPcGVuTGluZSA9IDA7XG4gIHByaXZhdGUgdGFnT3BlbkNvbHVtbiA9IDA7XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IG51bGw7XG4gIH1cblxuICAvLyBDb21tZW50XG5cbiAgYmVnaW5Db21tZW50KCkge1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSBiLmNvbW1lbnQoJycpO1xuICAgIHRoaXMuY3VycmVudE5vZGUubG9jID0ge1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgc3RhcnQ6IGIucG9zKHRoaXMudGFnT3BlbkxpbmUsIHRoaXMudGFnT3BlbkNvbHVtbiksXG4gICAgICBlbmQ6IChudWxsIGFzIGFueSkgYXMgQVNULlBvc2l0aW9uLFxuICAgIH07XG4gIH1cblxuICBhcHBlbmRUb0NvbW1lbnREYXRhKGNoYXI6IHN0cmluZykge1xuICAgIHRoaXMuY3VycmVudENvbW1lbnQudmFsdWUgKz0gY2hhcjtcbiAgfVxuXG4gIGZpbmlzaENvbW1lbnQoKSB7XG4gICAgdGhpcy5jdXJyZW50Q29tbWVudC5sb2MuZW5kID0gYi5wb3ModGhpcy50b2tlbml6ZXIubGluZSwgdGhpcy50b2tlbml6ZXIuY29sdW1uKTtcblxuICAgIGFwcGVuZENoaWxkKHRoaXMuY3VycmVudEVsZW1lbnQoKSwgdGhpcy5jdXJyZW50Q29tbWVudCk7XG4gIH1cblxuICAvLyBEYXRhXG5cbiAgYmVnaW5EYXRhKCkge1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSBiLnRleHQoKTtcbiAgICB0aGlzLmN1cnJlbnROb2RlLmxvYyA9IHtcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIHN0YXJ0OiBiLnBvcyh0aGlzLnRva2VuaXplci5saW5lLCB0aGlzLnRva2VuaXplci5jb2x1bW4pLFxuICAgICAgZW5kOiAobnVsbCBhcyBhbnkpIGFzIEFTVC5Qb3NpdGlvbixcbiAgICB9O1xuICB9XG5cbiAgYXBwZW5kVG9EYXRhKGNoYXI6IHN0cmluZykge1xuICAgIHRoaXMuY3VycmVudERhdGEuY2hhcnMgKz0gY2hhcjtcbiAgfVxuXG4gIGZpbmlzaERhdGEoKSB7XG4gICAgdGhpcy5jdXJyZW50RGF0YS5sb2MuZW5kID0gYi5wb3ModGhpcy50b2tlbml6ZXIubGluZSwgdGhpcy50b2tlbml6ZXIuY29sdW1uKTtcblxuICAgIGFwcGVuZENoaWxkKHRoaXMuY3VycmVudEVsZW1lbnQoKSwgdGhpcy5jdXJyZW50RGF0YSk7XG4gIH1cblxuICAvLyBUYWdzIC0gYmFzaWNcblxuICB0YWdPcGVuKCkge1xuICAgIHRoaXMudGFnT3BlbkxpbmUgPSB0aGlzLnRva2VuaXplci5saW5lO1xuICAgIHRoaXMudGFnT3BlbkNvbHVtbiA9IHRoaXMudG9rZW5pemVyLmNvbHVtbjtcbiAgfVxuXG4gIGJlZ2luU3RhcnRUYWcoKSB7XG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IHtcbiAgICAgIHR5cGU6ICdTdGFydFRhZycsXG4gICAgICBuYW1lOiAnJyxcbiAgICAgIGF0dHJpYnV0ZXM6IFtdLFxuICAgICAgbW9kaWZpZXJzOiBbXSxcbiAgICAgIGNvbW1lbnRzOiBbXSxcbiAgICAgIHNlbGZDbG9zaW5nOiBmYWxzZSxcbiAgICAgIGxvYzogU1lOVEhFVElDLFxuICAgIH07XG4gIH1cblxuICBiZWdpbkVuZFRhZygpIHtcbiAgICB0aGlzLmN1cnJlbnROb2RlID0ge1xuICAgICAgdHlwZTogJ0VuZFRhZycsXG4gICAgICBuYW1lOiAnJyxcbiAgICAgIGF0dHJpYnV0ZXM6IFtdLFxuICAgICAgbW9kaWZpZXJzOiBbXSxcbiAgICAgIGNvbW1lbnRzOiBbXSxcbiAgICAgIHNlbGZDbG9zaW5nOiBmYWxzZSxcbiAgICAgIGxvYzogU1lOVEhFVElDLFxuICAgIH07XG4gIH1cblxuICBmaW5pc2hUYWcoKSB7XG4gICAgbGV0IHsgbGluZSwgY29sdW1uIH0gPSB0aGlzLnRva2VuaXplcjtcblxuICAgIGxldCB0YWcgPSB0aGlzLmN1cnJlbnRUYWc7XG4gICAgdGFnLmxvYyA9IGIubG9jKHRoaXMudGFnT3BlbkxpbmUsIHRoaXMudGFnT3BlbkNvbHVtbiwgbGluZSwgY29sdW1uKTtcblxuICAgIGlmICh0YWcudHlwZSA9PT0gJ1N0YXJ0VGFnJykge1xuICAgICAgdGhpcy5maW5pc2hTdGFydFRhZygpO1xuXG4gICAgICBpZiAodm9pZE1hcFt0YWcubmFtZV0gfHwgdGFnLnNlbGZDbG9zaW5nKSB7XG4gICAgICAgIHRoaXMuZmluaXNoRW5kVGFnKHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGFnLnR5cGUgPT09ICdFbmRUYWcnKSB7XG4gICAgICB0aGlzLmZpbmlzaEVuZFRhZyhmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgZmluaXNoU3RhcnRUYWcoKSB7XG4gICAgbGV0IHsgbmFtZSwgYXR0cmlidXRlczogYXR0cnMsIG1vZGlmaWVycywgY29tbWVudHMsIHNlbGZDbG9zaW5nIH0gPSB0aGlzLmN1cnJlbnRTdGFydFRhZztcbiAgICBsZXQgbG9jID0gYi5sb2ModGhpcy50YWdPcGVuTGluZSwgdGhpcy50YWdPcGVuQ29sdW1uKTtcbiAgICBsZXQgZWxlbWVudCA9IGIuZWxlbWVudCh7IG5hbWUsIHNlbGZDbG9zaW5nIH0sIHsgYXR0cnMsIG1vZGlmaWVycywgY29tbWVudHMsIGxvYyB9KTtcbiAgICB0aGlzLmVsZW1lbnRTdGFjay5wdXNoKGVsZW1lbnQpO1xuICB9XG5cbiAgZmluaXNoRW5kVGFnKGlzVm9pZDogYm9vbGVhbikge1xuICAgIGxldCB0YWcgPSB0aGlzLmN1cnJlbnRUYWc7XG5cbiAgICBsZXQgZWxlbWVudCA9IHRoaXMuZWxlbWVudFN0YWNrLnBvcCgpIGFzIEFTVC5FbGVtZW50Tm9kZTtcbiAgICBsZXQgcGFyZW50ID0gdGhpcy5jdXJyZW50RWxlbWVudCgpO1xuXG4gICAgdmFsaWRhdGVFbmRUYWcodGFnLCBlbGVtZW50LCBpc1ZvaWQpO1xuXG4gICAgZWxlbWVudC5sb2MuZW5kLmxpbmUgPSB0aGlzLnRva2VuaXplci5saW5lO1xuICAgIGVsZW1lbnQubG9jLmVuZC5jb2x1bW4gPSB0aGlzLnRva2VuaXplci5jb2x1bW47XG5cbiAgICBwYXJzZUVsZW1lbnRCbG9ja1BhcmFtcyhlbGVtZW50KTtcbiAgICBhcHBlbmRDaGlsZChwYXJlbnQsIGVsZW1lbnQpO1xuICB9XG5cbiAgbWFya1RhZ0FzU2VsZkNsb3NpbmcoKSB7XG4gICAgdGhpcy5jdXJyZW50VGFnLnNlbGZDbG9zaW5nID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRhZ3MgLSBuYW1lXG5cbiAgYXBwZW5kVG9UYWdOYW1lKGNoYXI6IHN0cmluZykge1xuICAgIHRoaXMuY3VycmVudFRhZy5uYW1lICs9IGNoYXI7XG4gIH1cblxuICAvLyBUYWdzIC0gYXR0cmlidXRlc1xuXG4gIGJlZ2luQXR0cmlidXRlKCkge1xuICAgIGxldCB0YWcgPSB0aGlzLmN1cnJlbnRUYWc7XG4gICAgaWYgKHRhZy50eXBlID09PSAnRW5kVGFnJykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICBgSW52YWxpZCBlbmQgdGFnOiBjbG9zaW5nIHRhZyBtdXN0IG5vdCBoYXZlIGF0dHJpYnV0ZXMsIGAgK1xuICAgICAgICAgIGBpbiBcXGAke3RhZy5uYW1lfVxcYCAob24gbGluZSAke3RoaXMudG9rZW5pemVyLmxpbmV9KS5gLFxuICAgICAgICB0YWcubG9jXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudEF0dHJpYnV0ZSA9IHtcbiAgICAgIG5hbWU6ICcnLFxuICAgICAgcGFydHM6IFtdLFxuICAgICAgaXNRdW90ZWQ6IGZhbHNlLFxuICAgICAgaXNEeW5hbWljOiBmYWxzZSxcbiAgICAgIHN0YXJ0OiBiLnBvcyh0aGlzLnRva2VuaXplci5saW5lLCB0aGlzLnRva2VuaXplci5jb2x1bW4pLFxuICAgICAgdmFsdWVTdGFydExpbmU6IDAsXG4gICAgICB2YWx1ZVN0YXJ0Q29sdW1uOiAwLFxuICAgIH07XG4gIH1cblxuICBhcHBlbmRUb0F0dHJpYnV0ZU5hbWUoY2hhcjogc3RyaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50QXR0ci5uYW1lICs9IGNoYXI7XG4gIH1cblxuICBiZWdpbkF0dHJpYnV0ZVZhbHVlKGlzUXVvdGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5jdXJyZW50QXR0ci5pc1F1b3RlZCA9IGlzUXVvdGVkO1xuICAgIHRoaXMuY3VycmVudEF0dHIudmFsdWVTdGFydExpbmUgPSB0aGlzLnRva2VuaXplci5saW5lO1xuICAgIHRoaXMuY3VycmVudEF0dHIudmFsdWVTdGFydENvbHVtbiA9IHRoaXMudG9rZW5pemVyLmNvbHVtbjtcbiAgfVxuXG4gIGFwcGVuZFRvQXR0cmlidXRlVmFsdWUoY2hhcjogc3RyaW5nKSB7XG4gICAgbGV0IHBhcnRzID0gdGhpcy5jdXJyZW50QXR0ci5wYXJ0cztcbiAgICBsZXQgbGFzdFBhcnQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcblxuICAgIGlmIChsYXN0UGFydCAmJiBsYXN0UGFydC50eXBlID09PSAnVGV4dE5vZGUnKSB7XG4gICAgICBsYXN0UGFydC5jaGFycyArPSBjaGFyO1xuXG4gICAgICAvLyB1cGRhdGUgZW5kIGxvY2F0aW9uIGZvciBlYWNoIGFkZGVkIGNoYXJcbiAgICAgIGxhc3RQYXJ0LmxvYy5lbmQubGluZSA9IHRoaXMudG9rZW5pemVyLmxpbmU7XG4gICAgICBsYXN0UGFydC5sb2MuZW5kLmNvbHVtbiA9IHRoaXMudG9rZW5pemVyLmNvbHVtbjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW5pdGlhbGx5IGFzc3VtZSB0aGUgdGV4dCBub2RlIGlzIGEgc2luZ2xlIGNoYXJcbiAgICAgIGxldCBsb2MgPSBiLmxvYyhcbiAgICAgICAgdGhpcy50b2tlbml6ZXIubGluZSxcbiAgICAgICAgdGhpcy50b2tlbml6ZXIuY29sdW1uLFxuICAgICAgICB0aGlzLnRva2VuaXplci5saW5lLFxuICAgICAgICB0aGlzLnRva2VuaXplci5jb2x1bW5cbiAgICAgICk7XG5cbiAgICAgIC8vIHRoZSB0b2tlbml6ZXIgbGluZS9jb2x1bW4gaGF2ZSBhbHJlYWR5IGJlZW4gYWR2YW5jZWQsIGNvcnJlY3QgbG9jYXRpb24gaW5mb1xuICAgICAgaWYgKGNoYXIgPT09ICdcXG4nKSB7XG4gICAgICAgIGxvYy5zdGFydC5saW5lIC09IDE7XG4gICAgICAgIGxvYy5zdGFydC5jb2x1bW4gPSBsYXN0UGFydCA/IGxhc3RQYXJ0LmxvYy5lbmQuY29sdW1uIDogdGhpcy5jdXJyZW50QXR0ci52YWx1ZVN0YXJ0Q29sdW1uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9jLnN0YXJ0LmNvbHVtbiAtPSAxO1xuICAgICAgfVxuXG4gICAgICBsZXQgdGV4dCA9IGIudGV4dChjaGFyLCBsb2MpO1xuICAgICAgcGFydHMucHVzaCh0ZXh0KTtcbiAgICB9XG4gIH1cblxuICBmaW5pc2hBdHRyaWJ1dGVWYWx1ZSgpIHtcbiAgICBsZXQgeyBuYW1lLCBwYXJ0cywgaXNRdW90ZWQsIGlzRHluYW1pYywgdmFsdWVTdGFydExpbmUsIHZhbHVlU3RhcnRDb2x1bW4gfSA9IHRoaXMuY3VycmVudEF0dHI7XG4gICAgbGV0IHZhbHVlID0gYXNzZW1ibGVBdHRyaWJ1dGVWYWx1ZShwYXJ0cywgaXNRdW90ZWQsIGlzRHluYW1pYywgdGhpcy50b2tlbml6ZXIubGluZSk7XG4gICAgdmFsdWUubG9jID0gYi5sb2ModmFsdWVTdGFydExpbmUsIHZhbHVlU3RhcnRDb2x1bW4sIHRoaXMudG9rZW5pemVyLmxpbmUsIHRoaXMudG9rZW5pemVyLmNvbHVtbik7XG5cbiAgICBsZXQgbG9jID0gYi5sb2MoXG4gICAgICB0aGlzLmN1cnJlbnRBdHRyLnN0YXJ0LmxpbmUsXG4gICAgICB0aGlzLmN1cnJlbnRBdHRyLnN0YXJ0LmNvbHVtbixcbiAgICAgIHRoaXMudG9rZW5pemVyLmxpbmUsXG4gICAgICB0aGlzLnRva2VuaXplci5jb2x1bW5cbiAgICApO1xuXG4gICAgbGV0IGF0dHJpYnV0ZSA9IGIuYXR0cihuYW1lLCB2YWx1ZSwgbG9jKTtcblxuICAgIHRoaXMuY3VycmVudFN0YXJ0VGFnLmF0dHJpYnV0ZXMucHVzaChhdHRyaWJ1dGUpO1xuICB9XG5cbiAgcmVwb3J0U3ludGF4RXJyb3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgYFN5bnRheCBlcnJvciBhdCBsaW5lICR7dGhpcy50b2tlbml6ZXIubGluZX0gY29sICR7dGhpcy50b2tlbml6ZXIuY29sdW1ufTogJHttZXNzYWdlfWAsXG4gICAgICBiLmxvYyh0aGlzLnRva2VuaXplci5saW5lLCB0aGlzLnRva2VuaXplci5jb2x1bW4pXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlbWJsZUF0dHJpYnV0ZVZhbHVlKFxuICBwYXJ0czogKEFTVC5NdXN0YWNoZVN0YXRlbWVudCB8IEFTVC5UZXh0Tm9kZSlbXSxcbiAgaXNRdW90ZWQ6IGJvb2xlYW4sXG4gIGlzRHluYW1pYzogYm9vbGVhbixcbiAgbGluZTogbnVtYmVyXG4pIHtcbiAgaWYgKGlzRHluYW1pYykge1xuICAgIGlmIChpc1F1b3RlZCkge1xuICAgICAgcmV0dXJuIGFzc2VtYmxlQ29uY2F0ZW5hdGVkVmFsdWUocGFydHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoXG4gICAgICAgIHBhcnRzLmxlbmd0aCA9PT0gMSB8fFxuICAgICAgICAocGFydHMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgcGFydHNbMV0udHlwZSA9PT0gJ1RleHROb2RlJyAmJlxuICAgICAgICAgIChwYXJ0c1sxXSBhcyBBU1QuVGV4dE5vZGUpLmNoYXJzID09PSAnLycpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgIGBBbiB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyBvciBhIG11c3RhY2hlLCBgICtcbiAgICAgICAgICAgIGBwcmVjZWVkZWQgYnkgd2hpdGVzcGFjZSBvciBhICc9JyBjaGFyYWN0ZXIsIGFuZCBgICtcbiAgICAgICAgICAgIGBmb2xsb3dlZCBieSB3aGl0ZXNwYWNlLCBhICc+JyBjaGFyYWN0ZXIsIG9yICcvPicgKG9uIGxpbmUgJHtsaW5lfSlgLFxuICAgICAgICAgIGIubG9jKGxpbmUsIDApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiBiLnRleHQoJycpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VtYmxlQ29uY2F0ZW5hdGVkVmFsdWUocGFydHM6IChBU1QuTXVzdGFjaGVTdGF0ZW1lbnQgfCBBU1QuVGV4dE5vZGUpW10pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBwYXJ0OiBBU1QuQmFzZU5vZGUgPSBwYXJ0c1tpXTtcblxuICAgIGlmIChwYXJ0LnR5cGUgIT09ICdNdXN0YWNoZVN0YXRlbWVudCcgJiYgcGFydC50eXBlICE9PSAnVGV4dE5vZGUnKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICdVbnN1cHBvcnRlZCBub2RlIGluIHF1b3RlZCBhdHRyaWJ1dGUgdmFsdWU6ICcgKyBwYXJ0Wyd0eXBlJ10sXG4gICAgICAgIHBhcnQubG9jXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBiLmNvbmNhdChwYXJ0cyk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRW5kVGFnKFxuICB0YWc6IFRhZzwnU3RhcnRUYWcnIHwgJ0VuZFRhZyc+LFxuICBlbGVtZW50OiBBU1QuRWxlbWVudE5vZGUsXG4gIHNlbGZDbG9zaW5nOiBib29sZWFuXG4pIHtcbiAgbGV0IGVycm9yO1xuXG4gIGlmICh2b2lkTWFwW3RhZy5uYW1lXSAmJiAhc2VsZkNsb3NpbmcpIHtcbiAgICAvLyBFbmdUYWcgaXMgYWxzbyBjYWxsZWQgYnkgU3RhcnRUYWcgZm9yIHZvaWQgYW5kIHNlbGYtY2xvc2luZyB0YWdzIChpLmUuXG4gICAgLy8gPGlucHV0PiBvciA8YnIgLz4sIHNvIHdlIG5lZWQgdG8gY2hlY2sgZm9yIHRoYXQgaGVyZS4gT3RoZXJ3aXNlLCB3ZSB3b3VsZFxuICAgIC8vIHRocm93IGFuIGVycm9yIGZvciB0aG9zZSBjYXNlcy5cbiAgICBlcnJvciA9ICdJbnZhbGlkIGVuZCB0YWcgJyArIGZvcm1hdEVuZFRhZ0luZm8odGFnKSArICcgKHZvaWQgZWxlbWVudHMgY2Fubm90IGhhdmUgZW5kIHRhZ3MpLic7XG4gIH0gZWxzZSBpZiAoZWxlbWVudC50YWcgPT09IHVuZGVmaW5lZCkge1xuICAgIGVycm9yID0gJ0Nsb3NpbmcgdGFnICcgKyBmb3JtYXRFbmRUYWdJbmZvKHRhZykgKyAnIHdpdGhvdXQgYW4gb3BlbiB0YWcuJztcbiAgfSBlbHNlIGlmIChlbGVtZW50LnRhZyAhPT0gdGFnLm5hbWUpIHtcbiAgICBlcnJvciA9XG4gICAgICAnQ2xvc2luZyB0YWcgJyArXG4gICAgICBmb3JtYXRFbmRUYWdJbmZvKHRhZykgK1xuICAgICAgJyBkaWQgbm90IG1hdGNoIGxhc3Qgb3BlbiB0YWcgYCcgK1xuICAgICAgZWxlbWVudC50YWcgK1xuICAgICAgJ2AgKG9uIGxpbmUgJyArXG4gICAgICBlbGVtZW50LmxvYy5zdGFydC5saW5lICtcbiAgICAgICcpLic7XG4gIH1cblxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoZXJyb3IsIGVsZW1lbnQubG9jKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRFbmRUYWdJbmZvKHRhZzogVGFnPCdTdGFydFRhZycgfCAnRW5kVGFnJz4pIHtcbiAgcmV0dXJuICdgJyArIHRhZy5uYW1lICsgJ2AgKG9uIGxpbmUgJyArIHRhZy5sb2MuZW5kLmxpbmUgKyAnKSc7XG59XG5cbi8qKlxuICBBU1RQbHVnaW5zIGNhbiBtYWtlIGNoYW5nZXMgdG8gdGhlIEdsaW1tZXIgdGVtcGxhdGUgQVNUIGJlZm9yZVxuICBjb21waWxhdGlvbiBiZWdpbnMuXG4qL1xuZXhwb3J0IGludGVyZmFjZSBBU1RQbHVnaW5CdWlsZGVyIHtcbiAgKGVudjogQVNUUGx1Z2luRW52aXJvbm1lbnQpOiBBU1RQbHVnaW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQVNUUGx1Z2luIHtcbiAgbmFtZTogc3RyaW5nO1xuICB2aXNpdG9yOiBOb2RlVmlzaXRvcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBU1RQbHVnaW5FbnZpcm9ubWVudCB7XG4gIG1ldGE/OiBvYmplY3Q7XG4gIHN5bnRheDogU3ludGF4O1xufVxuaW50ZXJmYWNlIEhhbmRsZWJhcnNQYXJzZU9wdGlvbnMge1xuICBzcmNOYW1lPzogc3RyaW5nO1xuICBpZ25vcmVTdGFuZGFsb25lPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcmVwcm9jZXNzT3B0aW9ucyB7XG4gIG1ldGE/OiB1bmtub3duO1xuICBwbHVnaW5zPzoge1xuICAgIGFzdD86IEFTVFBsdWdpbkJ1aWxkZXJbXTtcbiAgfTtcbiAgcGFyc2VPcHRpb25zPzogSGFuZGxlYmFyc1BhcnNlT3B0aW9ucztcblxuICAvKipcbiAgICBVc2VmdWwgZm9yIHNwZWNpZnlpbmcgYSBncm91cCBvZiBvcHRpb25zIHRvZ2V0aGVyLlxuXG4gICAgV2hlbiBgJ2NvZGVtb2QnYCB3ZSBkaXNhYmxlIGFsbCB3aGl0ZXNwYWNlIGNvbnRyb2wgaW4gaGFuZGxlYmFyc1xuICAgICh0byBwcmVzZXJ2ZSBhcyBtdWNoIGFzIHBvc3NpYmxlKSBhbmQgd2UgYWxzbyBhdm9pZCBhbnlcbiAgICBlc2NhcGluZy91bmVzY2FwaW5nIG9mIEhUTUwgZW50aXR5IGNvZGVzLlxuICAgKi9cbiAgbW9kZT86ICdjb2RlbW9kJyB8ICdwcmVjb21waWxlJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTeW50YXgge1xuICBwYXJzZTogdHlwZW9mIHByZXByb2Nlc3M7XG4gIGJ1aWxkZXJzOiB0eXBlb2YgYnVpbGRlcnM7XG4gIHByaW50OiB0eXBlb2YgcHJpbnQ7XG4gIHRyYXZlcnNlOiB0eXBlb2YgdHJhdmVyc2U7XG4gIFdhbGtlcjogdHlwZW9mIFdhbGtlcjtcbn1cblxuY29uc3Qgc3ludGF4OiBTeW50YXggPSB7XG4gIHBhcnNlOiBwcmVwcm9jZXNzLFxuICBidWlsZGVycyxcbiAgcHJpbnQsXG4gIHRyYXZlcnNlLFxuICBXYWxrZXIsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcHJlcHJvY2VzcyhodG1sOiBzdHJpbmcsIG9wdGlvbnM6IFByZXByb2Nlc3NPcHRpb25zID0ge30pOiBBU1QuVGVtcGxhdGUge1xuICBsZXQgbW9kZSA9IG9wdGlvbnMubW9kZSB8fCAncHJlY29tcGlsZSc7XG5cbiAgbGV0IGFzdDogSEJTLlByb2dyYW07XG4gIGlmICh0eXBlb2YgaHRtbCA9PT0gJ29iamVjdCcpIHtcbiAgICBhc3QgPSBodG1sO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09ICdjb2RlbW9kJykge1xuICAgIGFzdCA9IGhhbmRsZWJhcnMucGFyc2VXaXRob3V0UHJvY2Vzc2luZyhodG1sLCBvcHRpb25zLnBhcnNlT3B0aW9ucykgYXMgSEJTLlByb2dyYW07XG4gIH0gZWxzZSB7XG4gICAgYXN0ID0gaGFuZGxlYmFycy5wYXJzZShodG1sLCBvcHRpb25zLnBhcnNlT3B0aW9ucykgYXMgSEJTLlByb2dyYW07XG4gIH1cblxuICBsZXQgZW50aXR5UGFyc2VyID0gdW5kZWZpbmVkO1xuICBpZiAobW9kZSA9PT0gJ2NvZGVtb2QnKSB7XG4gICAgZW50aXR5UGFyc2VyID0gbmV3IEVudGl0eVBhcnNlcih7fSk7XG4gIH1cblxuICBsZXQgcHJvZ3JhbSA9IG5ldyBUb2tlbml6ZXJFdmVudEhhbmRsZXJzKGh0bWwsIGVudGl0eVBhcnNlcikuYWNjZXB0VGVtcGxhdGUoYXN0KTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBsdWdpbnMgJiYgb3B0aW9ucy5wbHVnaW5zLmFzdCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gb3B0aW9ucy5wbHVnaW5zLmFzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxldCB0cmFuc2Zvcm0gPSBvcHRpb25zLnBsdWdpbnMuYXN0W2ldO1xuICAgICAgbGV0IGVudiA9IGFzc2lnbih7fSwgb3B0aW9ucywgeyBzeW50YXggfSwgeyBwbHVnaW5zOiB1bmRlZmluZWQgfSk7XG5cbiAgICAgIGxldCBwbHVnaW5SZXN1bHQgPSB0cmFuc2Zvcm0oZW52KTtcblxuICAgICAgdHJhdmVyc2UocHJvZ3JhbSwgcGx1Z2luUmVzdWx0LnZpc2l0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9ncmFtO1xufVxuIl0sIm5hbWVzIjpbImFzc2lnbiIsIkVudGl0eVBhcnNlciIsIm5hbWVkQ2hhclJlZnMiLCJFdmVudGVkVG9rZW5pemVyIiwidHVwbGUiLCJoYW5kbGViYXJzLnBhcnNlV2l0aG91dFByb2Nlc3NpbmciLCJoYW5kbGViYXJzLnBhcnNlIl0sIm1hcHBpbmdzIjoiOztJQVdBLFNBQUEsYUFBQSxDQUFBLElBQUEsRUFBQSxNQUFBLEVBQUEsSUFBQSxFQUFBLEdBQUEsRUFBQSxHQUFBLEVBQUEsS0FBQSxFQU13QjtJQUV0QixRQUFJLE9BQUEsSUFBQSxLQUFKLFFBQUEsRUFBOEI7SUFDNUIsZUFBTyxVQUFQLElBQU8sQ0FBUDtJQUNEO0lBRUQsV0FBTztJQUNMLGNBREssbUJBQUE7SUFBQSxrQkFBQTtJQUdMLGdCQUFRLFVBSEgsRUFBQTtJQUlMLGNBQU0sUUFBUSxVQUpULEVBSVMsQ0FKVDtJQUtMLGlCQUFTLENB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