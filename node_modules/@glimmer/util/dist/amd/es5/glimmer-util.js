define('@glimmer/util', ['exports'], function (exports) { 'use strict';

    var EMPTY_ARRAY = Object.freeze([]);

    // import Logger from './logger';
    // let alreadyWarned = false;
    function debugAssert(test, msg) {
        // if (!alreadyWarned) {
        //   alreadyWarned = true;
        //   Logger.warn("Don't leave debug assertions on in public builds");
        // }
        if (!test) {
            throw new Error(msg || 'assertion failure');
        }
    }
    function deprecate(desc) {
        console.warn('DEPRECATION: ' + desc);
    }

    var GUID = 0;
    function initializeGuid(object) {
        return object._guid = ++GUID;
    }
    function ensureGuid(object) {
        return object._guid || initializeGuid(object);
    }

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    function dict() {
        return Object.create(null);
    }
    function isDict(u) {
        return u !== null && u !== undefined;
    }
    function isObject(u) {
        return typeof u === 'object' && u !== null;
    }
    var DictSet = function () {
        function DictSet() {
            _classCallCheck(this, DictSet);

            this.dict = dict();
        }

        DictSet.prototype.add = function add(obj) {
            if (typeof obj === 'string') this.dict[obj] = obj;else this.dict[ensureGuid(obj)] = obj;
            return this;
        };

        DictSet.prototype.delete = function _delete(obj) {
            if (typeof obj === 'string') delete this.dict[obj];else if (obj._guid) delete this.dict[obj._guid];
        };

        return DictSet;
    }();
    var StackImpl = function () {
        function StackImpl() {
            _classCallCheck(this, StackImpl);

            this.stack = [];
            this.current = null;
        }

        StackImpl.prototype.push = function push(item) {
            this.current = item;
            this.stack.push(item);
        };

        StackImpl.prototype.pop = function pop() {
            var item = this.stack.pop();
            var len = this.stack.length;
            this.current = len === 0 ? null : this.stack[len - 1];
            return item === undefined ? null : item;
        };

        StackImpl.prototype.nth = function nth(from) {
            var len = this.stack.length;
            return len < from ? null : this.stack[len - from];
        };

        StackImpl.prototype.isEmpty = function isEmpty() {
            return this.stack.length === 0;
        };

        StackImpl.prototype.toArray = function toArray() {
            return this.stack;
        };

        _createClass(StackImpl, [{
            key: 'size',
            get: function get() {
                return this.stack.length;
            }
        }]);

        return StackImpl;
    }();

    function keys(obj) {
        return Object.keys(obj);
    }
    function unwrap(val) {
        if (val === null || val === undefined) throw new Error('Expected value to be present');
        return val;
    }
    function expect(val, message) {
        if (val === null || val === undefined) throw new Error(message);
        return val;
    }
    function unreachable() {
        var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unreachable';

        return new Error(message);
    }
    function exhausted(value) {
        throw new Error('Exhausted ' + value);
    }
    var tuple = function tuple() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return args;
    };
    var symbol = typeof Symbol !== 'undefined' ? Symbol : function (key) {
        return '__' + key + Math.floor(Math.random() * Date.now()) + '__';
    };

    var DESTROY = symbol('DESTROY');
    function isDestroyable(value) {
        return !!(value && value[DESTROY] !== undefined);
    }
    function isStringDestroyable(value) {
        return !!(value && typeof value === 'object' && typeof value.destroy === 'function');
    }

    function clearElement(parent) {
        var current = parent.firstChild;
        while (current) {
            var next = current.nextSibling;
            parent.removeChild(current);
            current = next;
        }
    }

    var SERIALIZATION_FIRST_NODE_STRING = '%+b:0%';
    function isSerializationFirstNode(node) {
        return node.nodeValue === SERIALIZATION_FIRST_NODE_STRING;
    }

    var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    var LINKED = new WeakMap();
    var WILL_DROP = symbol('WILL_DROP');
    var DID_DROP = symbol('DID_DROP');
    var CHILDREN = symbol('CHILDREN');
    var DESTRUCTORS = new WeakMap();
    function isDrop(value) {
        if (value === null || typeof value !== 'object') return false;
        return value[DID_DROP] !== undefined;
    }
    function associate(parent, child) {
        associateDestructor(parent, destructor(child));
    }
    function associateDestructor(parent, child) {
        var associated = LINKED.get(parent);
        if (!associated) {
            associated = new Set();
            LINKED.set(parent, associated);
        }
        associated.add(child);
    }
    function peekAssociated(parent) {
        return LINKED.get(parent) || null;
    }
    function takeAssociated(parent) {
        var linked = LINKED.get(parent);
        if (linked && linked.size > 0) {
            LINKED.delete(parent);
            return linked;
        } else {
            return null;
        }
    }
    function willDestroyAssociated(parent) {
        var associated = LINKED.get(parent);
        if (associated) {
            associated.forEach(function (item) {
                item[WILL_DROP]();
            });
        }
    }
    function didDestroyAssociated(parent) {
        var associated = LINKED.get(parent);
        if (associated) {
            associated.forEach(function (item) {
                item[DID_DROP]();
                associated.delete(item);
            });
        }
    }
    function destructor(value) {
        var d = DESTRUCTORS.get(value);
        if (!d) {
            if (isDestroyable(value)) {
                d = new DestroyableDestructor(value);
            } else if (isStringDestroyable(value)) {
                d = new StringDestroyableDestructor(value);
            } else {
                d = new SimpleDestructor(value);
            }
            DESTRUCTORS.set(value, d);
        }
        return d;
    }
    function snapshot(values) {
        return new SnapshotDestructor(values);
    }

    var SnapshotDestructor = function () {
        function SnapshotDestructor(destructors) {
            _classCallCheck$1(this, SnapshotDestructor);

            this.destructors = destructors;
        }

        SnapshotDestructor.prototype[WILL_DROP] = function () {
            this.destructors.forEach(function (item) {
                return item[WILL_DROP]();
            });
        };

        SnapshotDestructor.prototype[DID_DROP] = function () {
            this.destructors.forEach(function (item) {
                return item[DID_DROP]();
            });
        };

        SnapshotDestructor.prototype.toString = function toString() {
            return 'SnapshotDestructor';
        };

        _createClass$1(SnapshotDestructor, [{
            key: CHILDREN,
            get: function get() {
                return this.destructors;
            }
        }]);

        return SnapshotDestructor;
    }();

    var DestroyableDestructor = function () {
        function DestroyableDestructor(inner) {
            _classCallCheck$1(this, DestroyableDestructor);

            this.inner = inner;
        }

        DestroyableDestructor.prototype[WILL_DROP] = function () {
            willDestroyAssociated(this.inner);
        };

        DestroyableDestructor.prototype[DID_DROP] = function () {
            this.inner[DESTROY]();
            didDestroyAssociated(this.inner);
        };

        DestroyableDestructor.prototype.toString = function toString() {
            return 'DestroyableDestructor';
        };

        _createClass$1(DestroyableDestructor, [{
            key: CHILDREN,
            get: function get() {
                return LINKED.get(this.inner) || [];
            }
        }]);

        return DestroyableDestructor;
    }();

    var StringDestroyableDestructor = function () {
        function StringDestroyableDestructor(inner) {
            _classCallCheck$1(this, StringDestroyableDestructor);

            this.inner = inner;
        }

        StringDestroyableDestructor.prototype[WILL_DROP] = function () {
            if (typeof this.inner.willDestroy === 'function') {
                this.inner.willDestroy();
            }
            willDestroyAssociated(this.inner);
        };

        StringDestroyableDestructor.prototype[DID_DROP] = function () {
            this.inner.destroy();
            didDestroyAssociated(this.inner);
        };

        StringDestroyableDestructor.prototype.toString = function toString() {
            return 'StringDestroyableDestructor';
        };

        _createClass$1(StringDestroyableDestructor, [{
            key: CHILDREN,
            get: function get() {
                return LINKED.get(this.inner) || [];
            }
        }]);

        return StringDestroyableDestructor;
    }();

    var SimpleDestructor = function () {
        function SimpleDestructor(inner) {
            _classCallCheck$1(this, SimpleDestructor);

            this.inner = inner;
        }

        SimpleDestructor.prototype[WILL_DROP] = function () {
            willDestroyAssociated(this.inner);
        };

        SimpleDestructor.prototype[DID_DROP] = function () {
            didDestroyAssociated(this.inner);
        };

        SimpleDestructor.prototype.toString = function toString() {
            return 'SimpleDestructor';
        };

        _createClass$1(SimpleDestructor, [{
            key: CHILDREN,
            get: function get() {
                return LINKED.get(this.inner) || [];
            }
        }]);

        return SimpleDestructor;
    }();

    var ListContentsDestructor = function () {
        function ListContentsDestructor(inner) {
            _classCallCheck$1(this, ListContentsDestructor);

            this.inner = inner;
        }

        ListContentsDestructor.prototype[WILL_DROP] = function () {
            this.inner.forEachNode(function (d) {
                return destructor(d)[WILL_DROP]();
            });
        };

        ListContentsDestructor.prototype[DID_DROP] = function () {
            this.inner.forEachNode(function (d) {
                return destructor(d)[DID_DROP]();
            });
        };

        ListContentsDestructor.prototype.toString = function toString() {
            return 'ListContentsDestructor';
        };

        _createClass$1(ListContentsDestructor, [{
            key: CHILDREN,
            get: function get() {
                var out = [];
                this.inner.forEachNode(function (d) {
                    return out.push.apply(out, destructor(d)[CHILDREN]);
                });
                return out;
            }
        }]);

        return ListContentsDestructor;
    }();
    function debugDropTree(inner) {
        var hasDrop = isDrop(inner);
        var rawChildren = LINKED.get(inner) || null;
        var children = null;
        if (rawChildren) {
            children = [];
            for (var _iterator = rawChildren, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var child = _ref;

                children.push(debugDropTree(child));
            }
        }
        var obj = Object.create(null);
        obj.inner = inner;
        if (children) {
            obj.children = children;
        }
        obj.hasDrop = hasDrop;
        return obj;
    }
    function printDropTree(inner) {
        printDrop(destructor(inner));
    }
    function printDrop(inner) {
        console.group(String(inner));
        console.log(inner);
        var children = inner[CHILDREN] || null;
        if (children) {
            for (var _iterator2 = children, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                var _ref2;

                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done) break;
                    _ref2 = _i2.value;
                }

                var child = _ref2;

                printDrop(child);
            }
        }
        console.groupEnd();
    }

    var _createClass$2 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    var ListNode = function ListNode(value) {
        _classCallCheck$2(this, ListNode);

        this.next = null;
        this.prev = null;
        this.value = value;
    };
    var LinkedList = function () {
        function LinkedList() {
            _classCallCheck$2(this, LinkedList);

            this.clear();
        }

        LinkedList.prototype.head = function head() {
            return this._head;
        };

        LinkedList.prototype.tail = function tail() {
            return this._tail;
        };

        LinkedList.prototype.clear = function clear() {
            this._head = this._tail = null;
        };

        LinkedList.prototype.toArray = function toArray() {
            var out = [];
            this.forEachNode(function (n) {
                return out.push(n);
            });
            return out;
        };

        LinkedList.prototype.nextNode = function nextNode(node) {
            return node.next;
        };

        LinkedList.prototype.forEachNode = function forEachNode(callback) {
            var node = this._head;
            while (node !== null) {
                callback(node);
                node = node.next;
            }
        };

        LinkedList.prototype.insertBefore = function insertBefore(node) {
            var reference = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            if (reference === null) return this.append(node);
            if (reference.prev) reference.prev.next = node;else this._head = node;
            node.prev = reference.prev;
            node.next = reference;
            reference.prev = node;
            return node;
        };

        LinkedList.prototype.append = function append(node) {
            var tail = this._tail;
            if (tail) {
                tail.next = node;
                node.prev = tail;
                node.next = null;
            } else {
                this._head = node;
            }
            return this._tail = node;
        };

        LinkedList.prototype.remove = function remove(node) {
            if (node.prev) node.prev.next = node.next;else this._head = node.next;
            if (node.next) node.next.prev = node.prev;else this._tail = node.prev;
            return node;
        };

        LinkedList.prototype[WILL_DROP] = function () {
            this.forEachNode(function (d) {
                return destructor(d)[WILL_DROP]();
            });
        };

        LinkedList.prototype[DID_DROP] = function () {
            this.forEachNode(function (d) {
                return destructor(d)[DID_DROP]();
            });
        };

        _createClass$2(LinkedList, [{
            key: CHILDREN,
            get: function get() {
                var out = [];
                this.forEachNode(function (d) {
                    return out.push.apply(out, destructor(d)[CHILDREN]);
                });
                return out;
            }
        }]);

        return LinkedList;
    }();
    var ListSlice = function () {
        function ListSlice(head, tail) {
            _classCallCheck$2(this, ListSlice);

            this._head = head;
            this._tail = tail;
        }

        ListSlice.prototype.forEachNode = function forEachNode(callback) {
            var node = this._head;
            while (node !== null) {
                callback(node);
                node = this.nextNode(node);
            }
        };

        ListSlice.prototype.head = function head() {
            return this._head;
        };

        ListSlice.prototype.tail = function tail() {
            return this._tail;
        };

        ListSlice.prototype.toArray = function toArray() {
            var out = [];
            this.forEachNode(function (n) {
                return out.push(n);
            });
            return out;
        };

        ListSlice.prototype.nextNode = function nextNode(node) {
            if (node === this._tail) return null;
            return node.next;
        };

        return ListSlice;
    }();
    var EMPTY_SLICE = new ListSlice(null, null);

    var objKeys = Object.keys;

    function assign(obj) {
        for (var i = 1; i < arguments.length; i++) {
            var assignment = arguments[i];
            if (assignment === null || typeof assignment !== 'object') continue;
            var keys = objKeys(assignment);
            for (var j = 0; j < keys.length; j++) {
                var key = keys[j];
                obj[key] = assignment[key];
            }
        }
        return obj;
    }
    function fillNulls(count) {
        var arr = new Array(count);
        for (var i = 0; i < count; i++) {
            arr[i] = null;
        }
        return arr;
    }
    function values(obj) {
        var vals = [];
        for (var key in obj) {
            vals.push(obj[key]);
        }
        return vals;
    }

    function strip(strings) {
        var out = '';

        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
        }

        for (var i = 0; i < strings.length; i++) {
            var string = strings[i];
            var dynamic = args[i] !== undefined ? String(args[i]) : '';
            out += '' + string + dynamic;
        }
        var lines = out.split('\n');
        while (lines.length && lines[0].match(/^\s*$/)) {
            lines.shift();
        }
        while (lines.length && lines[lines.length - 1].match(/^\s*$/)) {
            lines.pop();
        }
        var min = Infinity;
        for (var _iterator = lines, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var line = _ref;

            var leading = line.match(/^\s*/)[0].length;
            min = Math.min(min, leading);
        }
        var stripped = [];
        for (var _iterator2 = lines, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray2) {
                if (_i2 >= _iterator2.length) break;
                _ref2 = _iterator2[_i2++];
            } else {
                _i2 = _iterator2.next();
                if (_i2.done) break;
                _ref2 = _i2.value;
            }

            var _line = _ref2;

            stripped.push(_line.slice(min));
        }
        return stripped.join('\n');
    }

    function assertNever(value) {
        var desc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unexpected unreachable branch';

        console.log('unreachable', value);
        console.trace(desc + ' :: ' + JSON.stringify(value) + ' (' + value + ')');
    }

    exports.assertNever = assertNever;
    exports.EMPTY_ARRAY = EMPTY_ARRAY;
    exports.assert = debugAssert;
    exports.deprecate = deprecate;
    exports.dict = dict;
    exports.DictSet = DictSet;
    exports.isDict = isDict;
    exports.isObject = isObject;
    exports.Stack = StackImpl;
    exports.ensureGuid = ensureGuid;
    exports.initializeGuid = initializeGuid;
    exports.isSerializationFirstNode = isSerializationFirstNode;
    exports.SERIALIZATION_FIRST_NODE_STRING = SERIALIZATION_FIRST_NODE_STRING;
    exports.EMPTY_SLICE = EMPTY_SLICE;
    exports.LinkedList = LinkedList;
    exports.ListNode = ListNode;
    exports.ListSlice = ListSlice;
    exports.assign = assign;
    exports.fillNulls = fillNulls;
    exports.values = values;
    exports.DESTROY = DESTROY;
    exports.isDestroyable = isDestroyable;
    exports.isStringDestroyable = isStringDestroyable;
    exports.clearElement = clearElement;
    exports.LINKED = LINKED;
    exports.WILL_DROP = WILL_DROP;
    exports.DID_DROP = DID_DROP;
    exports.CHILDREN = CHILDREN;
    exports.DESTRUCTORS = DESTRUCTORS;
    exports.isDrop = isDrop;
    exports.associate = associate;
    exports.associateDestructor = associateDestructor;
    exports.peekAssociated = peekAssociated;
    exports.takeAssociated = takeAssociated;
    exports.willDestroyAssociated = willDestroyAssociated;
    exports.didDestroyAssociated = didDestroyAssociated;
    exports.destructor = destructor;
    exports.snapshot = snapshot;
    exports.ListContentsDestructor = ListContentsDestructor;
    exports.debugDropTree = debugDropTree;
    exports.printDropTree = printDropTree;
    exports.printDrop = printDrop;
    exports.keys = keys;
    exports.unwrap = unwrap;
    exports.expect = expect;
    exports.unreachable = unreachable;
    exports.exhausted = exhausted;
    exports.tuple = tuple;
    exports.symbol = symbol;
    exports.strip = strip;

    Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci11dGlsLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9hcnJheS11dGlscy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2Fzc2VydC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2d1aWQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9jb2xsZWN0aW9ucy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL3BsYXRmb3JtLXV0aWxzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9saWIvZGVzdHJveS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2RvbS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2lzLXNlcmlhbGl6YXRpb24tZmlyc3Qtbm9kZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2xpZmV0aW1lcy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2xpc3QtdXRpbHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9vYmplY3QtdXRpbHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9zdHJpbmcudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBFTVBUWV9BUlJBWTogYW55W10gPSBPYmplY3QuZnJlZXplKFtdKSBhcyBhbnk7XG4iLCIvLyBpbXBvcnQgTG9nZ2VyIGZyb20gJy4vbG9nZ2VyJztcblxuLy8gbGV0IGFscmVhZHlXYXJuZWQgPSBmYWxzZTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnQXNzZXJ0KHRlc3Q6IGFueSwgbXNnOiBzdHJpbmcpIHtcbiAgLy8gaWYgKCFhbHJlYWR5V2FybmVkKSB7XG4gIC8vICAgYWxyZWFkeVdhcm5lZCA9IHRydWU7XG4gIC8vICAgTG9nZ2VyLndhcm4oXCJEb24ndCBsZWF2ZSBkZWJ1ZyBhc3NlcnRpb25zIG9uIGluIHB1YmxpYyBidWlsZHNcIik7XG4gIC8vIH1cblxuICBpZiAoIXRlc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdhc3NlcnRpb24gZmFpbHVyZScpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9kQXNzZXJ0KCkge31cblxuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZShkZXNjOiBzdHJpbmcpIHtcbiAgY29uc29sZS53YXJuKGBERVBSRUNBVElPTjogJHtkZXNjfWApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkZWJ1Z0Fzc2VydDtcbiIsImxldCBHVUlEID0gMDtcblxuZXhwb3J0IGludGVyZmFjZSBIYXNHdWlkIHtcbiAgX2d1aWQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVHdWlkKG9iamVjdDogSGFzR3VpZCk6IG51bWJlciB7XG4gIHJldHVybiAob2JqZWN0Ll9ndWlkID0gKytHVUlEKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUd1aWQob2JqZWN0OiBIYXNHdWlkKTogbnVtYmVyIHtcbiAgcmV0dXJuIG9iamVjdC5fZ3VpZCB8fCBpbml0aWFsaXplR3VpZChvYmplY3QpO1xufVxuIiwiaW1wb3J0IHsgSGFzR3VpZCwgZW5zdXJlR3VpZCB9IGZyb20gJy4vZ3VpZCc7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICcuL3BsYXRmb3JtLXV0aWxzJztcbmltcG9ydCB7IERpY3QsIFN0YWNrIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0PFQ+IHtcbiAgYWRkKHZhbHVlOiBUKTogU2V0PFQ+O1xuICBkZWxldGUodmFsdWU6IFQpOiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGljdDxUID0gdW5rbm93bj4oKTogRGljdDxUPiB7XG4gIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEaWN0PFQ+KHU6IFQpOiB1IGlzIERpY3QgJiBUIHtcbiAgcmV0dXJuIHUgIT09IG51bGwgJiYgdSAhPT0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3Q8VD4odTogVCk6IHUgaXMgb2JqZWN0ICYgVCB7XG4gIHJldHVybiB0eXBlb2YgdSA9PT0gJ29iamVjdCcgJiYgdSAhPT0gbnVsbDtcbn1cblxuZXhwb3J0IHR5cGUgU2V0TWVtYmVyID0gSGFzR3VpZCB8IHN0cmluZztcblxuZXhwb3J0IGNsYXNzIERpY3RTZXQ8VCBleHRlbmRzIFNldE1lbWJlcj4gaW1wbGVtZW50cyBTZXQ8VD4ge1xuICBwcml2YXRlIGRpY3Q6IERpY3Q8VD47XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kaWN0ID0gZGljdDxUPigpO1xuICB9XG5cbiAgYWRkKG9iajogVCk6IFNldDxUPiB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB0aGlzLmRpY3Rbb2JqIGFzIGFueV0gPSBvYmo7XG4gICAgZWxzZSB0aGlzLmRpY3RbZW5zdXJlR3VpZChvYmogYXMgYW55KV0gPSBvYmo7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZWxldGUob2JqOiBUKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSBkZWxldGUgdGhpcy5kaWN0W29iaiBhcyBhbnldO1xuICAgIGVsc2UgaWYgKChvYmogYXMgYW55KS5fZ3VpZCkgZGVsZXRlIHRoaXMuZGljdFsob2JqIGFzIGFueSkuX2d1aWRdO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTdGFja0ltcGw8VD4gaW1wbGVtZW50cyBTdGFjazxUPiB7XG4gIHByaXZhdGUgc3RhY2s6IFRbXSA9IFtdO1xuICBwdWJsaWMgY3VycmVudDogT3B0aW9uPFQ+ID0gbnVsbDtcblxuICBwdWJsaWMgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2subGVuZ3RoO1xuICB9XG5cbiAgcHVzaChpdGVtOiBUKSB7XG4gICAgdGhpcy5jdXJyZW50ID0gaXRlbTtcbiAgICB0aGlzLnN0YWNrLnB1c2goaXRlbSk7XG4gIH1cblxuICBwb3AoKTogT3B0aW9uPFQ+IHtcbiAgICBsZXQgaXRlbSA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgbGV0IGxlbiA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgIHRoaXMuY3VycmVudCA9IGxlbiA9PT0gMCA/IG51bGwgOiB0aGlzLnN0YWNrW2xlbiAtIDFdO1xuXG4gICAgcmV0dXJuIGl0ZW0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBpdGVtO1xuICB9XG5cbiAgbnRoKGZyb206IG51bWJlcik6IE9wdGlvbjxUPiB7XG4gICAgbGV0IGxlbiA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgIHJldHVybiBsZW4gPCBmcm9tID8gbnVsbCA6IHRoaXMuc3RhY2tbbGVuIC0gZnJvbV07XG4gIH1cblxuICBpc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIHRvQXJyYXkoKTogVFtdIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjaztcbiAgfVxufVxuIiwiZXhwb3J0IHR5cGUgT3B0aW9uPFQ+ID0gVCB8IG51bGw7XG5leHBvcnQgdHlwZSBNYXliZTxUPiA9IE9wdGlvbjxUPiB8IHVuZGVmaW5lZCB8IHZvaWQ7XG5cbmV4cG9ydCB0eXBlIEZhY3Rvcnk8VD4gPSBuZXcgKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gVDtcblxuZXhwb3J0IGZ1bmN0aW9uIGtleXM8VD4ob2JqOiBUKTogQXJyYXk8a2V5b2YgVD4ge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKSBhcyBBcnJheTxrZXlvZiBUPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcDxUPih2YWw6IE1heWJlPFQ+KTogVCB7XG4gIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdmFsdWUgdG8gYmUgcHJlc2VudGApO1xuICByZXR1cm4gdmFsIGFzIFQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBlY3Q8VD4odmFsOiBNYXliZTxUPiwgbWVzc2FnZTogc3RyaW5nKTogVCB7XG4gIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIHZhbCBhcyBUO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5yZWFjaGFibGUobWVzc2FnZSA9ICd1bnJlYWNoYWJsZScpOiBFcnJvciB7XG4gIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleGhhdXN0ZWQodmFsdWU6IG5ldmVyKTogbmV2ZXIge1xuICB0aHJvdyBuZXcgRXJyb3IoYEV4aGF1c3RlZCAke3ZhbHVlfWApO1xufVxuXG5leHBvcnQgdHlwZSBMaXQgPSBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgdW5kZWZpbmVkIHwgbnVsbCB8IHZvaWQgfCB7fTtcblxuZXhwb3J0IGNvbnN0IHR1cGxlID0gPFQgZXh0ZW5kcyBMaXRbXT4oLi4uYXJnczogVCkgPT4gYXJncztcblxuZXhwb3J0IGNvbnN0IHN5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnXG4gICAgPyBTeW1ib2xcbiAgICA6IChrZXk6IHN0cmluZykgPT4gYF9fJHtrZXl9JHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBEYXRlLm5vdygpKX1fX2AgYXMgYW55O1xuIiwiaW1wb3J0IHsgTWF5YmUsIFN5bWJvbERlc3Ryb3lhYmxlLCBEZXN0cm95YWJsZSwgRGVzdHJveVN5bWJvbCB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgc3ltYm9sIH0gZnJvbSAnLi9wbGF0Zm9ybS11dGlscyc7XG5cbmV4cG9ydCBjb25zdCBERVNUUk9ZOiBEZXN0cm95U3ltYm9sID0gc3ltYm9sKCdERVNUUk9ZJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Rlc3Ryb3lhYmxlKFxuICB2YWx1ZTogTWF5YmU8b2JqZWN0PiB8IFN5bWJvbERlc3Ryb3lhYmxlXG4pOiB2YWx1ZSBpcyBTeW1ib2xEZXN0cm95YWJsZSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiAodmFsdWUgYXMgU3ltYm9sRGVzdHJveWFibGUpW0RFU1RST1ldICE9PSB1bmRlZmluZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmdEZXN0cm95YWJsZSh2YWx1ZTogTWF5YmU8UGFydGlhbDxEZXN0cm95YWJsZT4+KTogdmFsdWUgaXMgRGVzdHJveWFibGUge1xuICByZXR1cm4gISEodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4iLCJpbXBvcnQgeyBPcHRpb24gfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFNpbXBsZUVsZW1lbnQsIFNpbXBsZU5vZGUgfSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJFbGVtZW50KHBhcmVudDogU2ltcGxlRWxlbWVudCkge1xuICBsZXQgY3VycmVudDogT3B0aW9uPFNpbXBsZU5vZGU+ID0gcGFyZW50LmZpcnN0Q2hpbGQ7XG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBsZXQgbmV4dCA9IGN1cnJlbnQubmV4dFNpYmxpbmc7XG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBuZXh0O1xuICB9XG59XG4iLCJpbXBvcnQgeyBTaW1wbGVOb2RlIH0gZnJvbSAnQHNpbXBsZS1kb20vaW50ZXJmYWNlJztcblxuZXhwb3J0IGNvbnN0IFNFUklBTElaQVRJT05fRklSU1RfTk9ERV9TVFJJTkcgPSAnJStiOjAlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2VyaWFsaXphdGlvbkZpcnN0Tm9kZShub2RlOiBTaW1wbGVOb2RlKTogYm9vbGVhbiB7XG4gIHJldHVybiBub2RlLm5vZGVWYWx1ZSA9PT0gU0VSSUFMSVpBVElPTl9GSVJTVF9OT0RFX1NUUklORztcbn1cbiIsImltcG9ydCB7IGlzRGVzdHJveWFibGUsIGlzU3RyaW5nRGVzdHJveWFibGUsIERFU1RST1kgfSBmcm9tICcuL2Rlc3Ryb3knO1xuaW1wb3J0IHtcbiAgT3B0aW9uLFxuICBTeW1ib2xEZXN0cm95YWJsZSxcbiAgRGVzdHJveWFibGUsXG4gIERyb3AsXG4gIFdpbGxEcm9wU3ltYm9sLFxuICBEaWREcm9wU3ltYm9sLFxuICBDaGlsZHJlblN5bWJvbCxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBMaW5rZWRMaXN0LCBMaW5rZWRMaXN0Tm9kZSB9IGZyb20gJy4vbGlzdC11dGlscyc7XG5pbXBvcnQgeyBERVZNT0RFIH0gZnJvbSAnQGdsaW1tZXIvbG9jYWwtZGVidWctZmxhZ3MnO1xuaW1wb3J0IHsgc3ltYm9sIH0gZnJvbSAnLi9wbGF0Zm9ybS11dGlscyc7XG5cbmV4cG9ydCBjb25zdCBMSU5LRUQ6IFdlYWtNYXA8b2JqZWN0LCBTZXQ8RHJvcD4+ID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBjb25zdCBXSUxMX0RST1A6IFdpbGxEcm9wU3ltYm9sID0gc3ltYm9sKCdXSUxMX0RST1AnKTtcbmV4cG9ydCBjb25zdCBESURfRFJPUDogRGlkRHJvcFN5bWJvbCA9IHN5bWJvbCgnRElEX0RST1AnKTtcbmV4cG9ydCBjb25zdCBDSElMRFJFTjogQ2hpbGRyZW5TeW1ib2wgPSBzeW1ib2woJ0NISUxEUkVOJyk7XG5leHBvcnQgY29uc3QgREVTVFJVQ1RPUlMgPSBuZXcgV2Vha01hcCgpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEcm9wKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgRHJvcCB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAodmFsdWUgYXMgRHJvcClbRElEX0RST1BdICE9PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NvY2lhdGUocGFyZW50OiBvYmplY3QsIGNoaWxkOiBvYmplY3QpIHtcbiAgYXNzb2NpYXRlRGVzdHJ1Y3RvcihwYXJlbnQsIGRlc3RydWN0b3IoY2hpbGQpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc29jaWF0ZURlc3RydWN0b3IocGFyZW50OiBvYmplY3QsIGNoaWxkOiBEcm9wKTogdm9pZCB7XG4gIGxldCBhc3NvY2lhdGVkID0gTElOS0VELmdldChwYXJlbnQpO1xuXG4gIGlmICghYXNzb2NpYXRlZCkge1xuICAgIGFzc29jaWF0ZWQgPSBuZXcgU2V0KCk7XG4gICAgTElOS0VELnNldChwYXJlbnQsIGFzc29jaWF0ZWQpO1xuICB9XG5cbiAgYXNzb2NpYXRlZC5hZGQoY2hpbGQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGVla0Fzc29jaWF0ZWQocGFyZW50OiBvYmplY3QpOiBPcHRpb248U2V0PERyb3A+PiB7XG4gIHJldHVybiBMSU5LRUQuZ2V0KHBhcmVudCkgfHwgbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRha2VBc3NvY2lhdGVkKHBhcmVudDogb2JqZWN0KTogT3B0aW9uPFNldDxEcm9wPj4ge1xuICBsZXQgbGlua2VkID0gTElOS0VELmdldChwYXJlbnQpO1xuXG4gIGlmIChsaW5rZWQgJiYgbGlua2VkLnNpemUgPiAwKSB7XG4gICAgTElOS0VELmRlbGV0ZShwYXJlbnQpO1xuICAgIHJldHVybiBsaW5rZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdpbGxEZXN0cm95QXNzb2NpYXRlZChwYXJlbnQ6IG9iamVjdCkge1xuICBsZXQgYXNzb2NpYXRlZCA9IExJTktFRC5nZXQocGFyZW50KTtcblxuICBpZiAoYXNzb2NpYXRlZCkge1xuICAgIGFzc29jaWF0ZWQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGl0ZW1bV0lMTF9EUk9QXSgpO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWREZXN0cm95QXNzb2NpYXRlZChwYXJlbnQ6IG9iamVjdCkge1xuICBsZXQgYXNzb2NpYXRlZCA9IExJTktFRC5nZXQocGFyZW50KTtcblxuICBpZiAoYXNzb2NpYXRlZCkge1xuICAgIGFzc29jaWF0ZWQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGl0ZW1bRElEX0RST1BdKCk7XG4gICAgICBhc3NvY2lhdGVkIS5kZWxldGUoaXRlbSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc3RydWN0b3IodmFsdWU6IG9iamVjdCk6IERyb3Age1xuICBsZXQgZCA9IERFU1RSVUNUT1JTLmdldCh2YWx1ZSk7XG5cbiAgaWYgKCFkKSB7XG4gICAgaWYgKGlzRGVzdHJveWFibGUodmFsdWUpKSB7XG4gICAgICBkID0gbmV3IERlc3Ryb3lhYmxlRGVzdHJ1Y3Rvcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZ0Rlc3Ryb3lhYmxlKHZhbHVlKSkge1xuICAgICAgZCA9IG5ldyBTdHJpbmdEZXN0cm95YWJsZURlc3RydWN0b3IodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkID0gbmV3IFNpbXBsZURlc3RydWN0b3IodmFsdWUpO1xuICAgIH1cblxuICAgIERFU1RSVUNUT1JTLnNldCh2YWx1ZSwgZCk7XG4gIH1cblxuICByZXR1cm4gZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNuYXBzaG90KHZhbHVlczogU2V0PERyb3A+KTogRHJvcCB7XG4gIHJldHVybiBuZXcgU25hcHNob3REZXN0cnVjdG9yKHZhbHVlcyk7XG59XG5cbmNsYXNzIFNuYXBzaG90RGVzdHJ1Y3RvciBpbXBsZW1lbnRzIERyb3Age1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRlc3RydWN0b3JzOiBTZXQ8RHJvcD4pIHt9XG5cbiAgW1dJTExfRFJPUF0oKSB7XG4gICAgdGhpcy5kZXN0cnVjdG9ycy5mb3JFYWNoKGl0ZW0gPT4gaXRlbVtXSUxMX0RST1BdKCkpO1xuICB9XG5cbiAgW0RJRF9EUk9QXSgpIHtcbiAgICB0aGlzLmRlc3RydWN0b3JzLmZvckVhY2goaXRlbSA9PiBpdGVtW0RJRF9EUk9QXSgpKTtcbiAgfVxuXG4gIGdldCBbQ0hJTERSRU5dKCk6IEl0ZXJhYmxlPERyb3A+IHtcbiAgICByZXR1cm4gdGhpcy5kZXN0cnVjdG9ycztcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnU25hcHNob3REZXN0cnVjdG9yJztcbiAgfVxufVxuXG5jbGFzcyBEZXN0cm95YWJsZURlc3RydWN0b3IgaW1wbGVtZW50cyBEcm9wIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpbm5lcjogU3ltYm9sRGVzdHJveWFibGUpIHt9XG5cbiAgW1dJTExfRFJPUF0oKSB7XG4gICAgd2lsbERlc3Ryb3lBc3NvY2lhdGVkKHRoaXMuaW5uZXIpO1xuICB9XG5cbiAgW0RJRF9EUk9QXSgpIHtcbiAgICB0aGlzLmlubmVyW0RFU1RST1ldKCk7XG4gICAgZGlkRGVzdHJveUFzc29jaWF0ZWQodGhpcy5pbm5lcik7XG4gIH1cblxuICBnZXQgW0NISUxEUkVOXSgpOiBJdGVyYWJsZTxEcm9wPiB7XG4gICAgcmV0dXJuIExJTktFRC5nZXQodGhpcy5pbm5lcikgfHwgW107XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0Rlc3Ryb3lhYmxlRGVzdHJ1Y3Rvcic7XG4gIH1cbn1cblxuY2xhc3MgU3RyaW5nRGVzdHJveWFibGVEZXN0cnVjdG9yIGltcGxlbWVudHMgRHJvcCB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5uZXI6IERlc3Ryb3lhYmxlKSB7fVxuXG4gIFtXSUxMX0RST1BdKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5pbm5lci53aWxsRGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5pbm5lci53aWxsRGVzdHJveSgpO1xuICAgIH1cbiAgICB3aWxsRGVzdHJveUFzc29jaWF0ZWQodGhpcy5pbm5lcik7XG4gIH1cblxuICBbRElEX0RST1BdKCkge1xuICAgIHRoaXMuaW5uZXIuZGVzdHJveSgpO1xuICAgIGRpZERlc3Ryb3lBc3NvY2lhdGVkKHRoaXMuaW5uZXIpO1xuICB9XG5cbiAgZ2V0IFtDSElMRFJFTl0oKTogSXRlcmFibGU8RHJvcD4ge1xuICAgIHJldHVybiBMSU5LRUQuZ2V0KHRoaXMuaW5uZXIpIHx8IFtdO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdTdHJpbmdEZXN0cm95YWJsZURlc3RydWN0b3InO1xuICB9XG59XG5cbmNsYXNzIFNpbXBsZURlc3RydWN0b3IgaW1wbGVtZW50cyBEcm9wIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpbm5lcjogb2JqZWN0KSB7fVxuXG4gIFtXSUxMX0RST1BdKCkge1xuICAgIHdpbGxEZXN0cm95QXNzb2NpYXRlZCh0aGlzLmlubmVyKTtcbiAgfVxuXG4gIFtESURfRFJPUF0oKSB7XG4gICAgZGlkRGVzdHJveUFzc29jaWF0ZWQodGhpcy5pbm5lcik7XG4gIH1cblxuICBnZXQgW0NISUxEUkVOXSgpOiBJdGVyYWJsZTxEcm9wPiB7XG4gICAgcmV0dXJuIExJTktFRC5nZXQodGhpcy5pbm5lcikgfHwgW107XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1NpbXBsZURlc3RydWN0b3InO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMaXN0Q29udGVudHNEZXN0cnVjdG9yIGltcGxlbWVudHMgRHJvcCB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5uZXI6IExpbmtlZExpc3Q8TGlua2VkTGlzdE5vZGU+KSB7fVxuXG4gIFtXSUxMX0RST1BdKCkge1xuICAgIHRoaXMuaW5uZXIuZm9yRWFjaE5vZGUoZCA9PiBkZXN0cnVjdG9yKGQpW1dJTExfRFJPUF0oKSk7XG4gIH1cblxuICBbRElEX0RST1BdKCkge1xuICAgIHRoaXMuaW5uZXIuZm9yRWFjaE5vZGUoZCA9PiBkZXN0cnVjdG9yKGQpW0RJRF9EUk9QXSgpKTtcbiAgfVxuXG4gIGdldCBbQ0hJTERSRU5dKCk6IEl0ZXJhYmxlPERyb3A+IHtcbiAgICBsZXQgb3V0OiBEcm9wW10gPSBbXTtcbiAgICB0aGlzLmlubmVyLmZvckVhY2hOb2RlKGQgPT4gb3V0LnB1c2goLi4uZGVzdHJ1Y3RvcihkKVtDSElMRFJFTl0pKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdMaXN0Q29udGVudHNEZXN0cnVjdG9yJztcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlYnVnTm9kZSB7XG4gIGlubmVyOiBvYmplY3Q7XG4gIGNoaWxkcmVuOiBEZWJ1Z05vZGVbXSB8IG51bGw7XG4gIGhhc0Ryb3A6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJ1Z0Ryb3BUcmVlKGlubmVyOiBvYmplY3QpOiBEZWJ1Z05vZGUge1xuICBsZXQgaGFzRHJvcCA9IGlzRHJvcChpbm5lcik7XG4gIGxldCByYXdDaGlsZHJlbiA9IExJTktFRC5nZXQoaW5uZXIpIHx8IG51bGw7XG4gIGxldCBjaGlsZHJlbjogRGVidWdOb2RlW10gfCBudWxsID0gbnVsbDtcblxuICBpZiAocmF3Q2hpbGRyZW4pIHtcbiAgICBjaGlsZHJlbiA9IFtdO1xuICAgIGZvciAobGV0IGNoaWxkIG9mIHJhd0NoaWxkcmVuKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKGRlYnVnRHJvcFRyZWUoY2hpbGQpKTtcbiAgICB9XG4gIH1cblxuICBsZXQgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgb2JqLmlubmVyID0gaW5uZXI7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIG9iai5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9XG4gIG9iai5oYXNEcm9wID0gaGFzRHJvcDtcbiAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW50RHJvcFRyZWUoaW5uZXI6IG9iamVjdCkge1xuICBwcmludERyb3AoZGVzdHJ1Y3Rvcihpbm5lcikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnREcm9wKGlubmVyOiBEcm9wKSB7XG4gIGNvbnNvbGUuZ3JvdXAoU3RyaW5nKGlubmVyKSk7XG5cbiAgY29uc29sZS5sb2coaW5uZXIpO1xuXG4gIGxldCBjaGlsZHJlbiA9IGlubmVyW0NISUxEUkVOXSB8fCBudWxsO1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgcHJpbnREcm9wKGNoaWxkKTtcbiAgICB9XG4gIH1cblxuICBjb25zb2xlLmdyb3VwRW5kKCk7XG59XG5cbmlmIChERVZNT0RFICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICh3aW5kb3cgYXMgYW55KS5QUklOVF9EUk9QID0gcHJpbnREcm9wVHJlZTtcbn1cbiIsImltcG9ydCB7IE9wdGlvbiB9IGZyb20gJy4vcGxhdGZvcm0tdXRpbHMnO1xuaW1wb3J0IHsgV0lMTF9EUk9QLCBESURfRFJPUCwgZGVzdHJ1Y3RvciwgQ0hJTERSRU4gfSBmcm9tICcuL2xpZmV0aW1lcyc7XG5pbXBvcnQgeyBEcm9wIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlua2VkTGlzdE5vZGUge1xuICBuZXh0OiBPcHRpb248TGlua2VkTGlzdE5vZGU+O1xuICBwcmV2OiBPcHRpb248TGlua2VkTGlzdE5vZGU+O1xufVxuXG5leHBvcnQgY2xhc3MgTGlzdE5vZGU8VD4gaW1wbGVtZW50cyBMaW5rZWRMaXN0Tm9kZSB7XG4gIHB1YmxpYyBuZXh0OiBPcHRpb248TGlzdE5vZGU8VD4+ID0gbnVsbDtcbiAgcHVibGljIHByZXY6IE9wdGlvbjxMaXN0Tm9kZTxUPj4gPSBudWxsO1xuICBwdWJsaWMgdmFsdWU6IFQ7XG5cbiAgY29uc3RydWN0b3IodmFsdWU6IFQpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbn1cblxuLy8gd2UgYXJlIHVuYWJsZSB0byBleHByZXNzIHRoZSBjb25zdHJhaW50IHRoYXQgVCdzIC5wcmV2IGFuZCAubmV4dCBhcmVcbi8vIHRoZW1zZWx2ZXMgVC4gSG93ZXZlciwgaXQgd2lsbCBhbHdheXMgYmUgdHJ1ZSwgc28gdHJ1c3QgdXMuXG50eXBlIHRydXN0ID0gYW55O1xuXG5leHBvcnQgY2xhc3MgTGlua2VkTGlzdDxUIGV4dGVuZHMgTGlua2VkTGlzdE5vZGU+IGltcGxlbWVudHMgU2xpY2U8VD4sIERyb3Age1xuICBwcml2YXRlIF9oZWFkITogT3B0aW9uPFQ+O1xuICBwcml2YXRlIF90YWlsITogT3B0aW9uPFQ+O1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgfVxuXG4gIGhlYWQoKTogT3B0aW9uPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5faGVhZDtcbiAgfVxuXG4gIHRhaWwoKTogT3B0aW9uPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5fdGFpbDtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX2hlYWQgPSB0aGlzLl90YWlsID0gbnVsbDtcbiAgfVxuXG4gIHRvQXJyYXkoKTogVFtdIHtcbiAgICBsZXQgb3V0OiBUW10gPSBbXTtcbiAgICB0aGlzLmZvckVhY2hOb2RlKG4gPT4gb3V0LnB1c2gobikpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICBuZXh0Tm9kZShub2RlOiBUKTogVCB7XG4gICAgcmV0dXJuIG5vZGUubmV4dCBhcyB0cnVzdDtcbiAgfVxuXG4gIGZvckVhY2hOb2RlKGNhbGxiYWNrOiAobm9kZTogVCkgPT4gdm9pZCkge1xuICAgIGxldCBub2RlID0gdGhpcy5faGVhZDtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhub2RlIGFzIHRydXN0KTtcbiAgICAgIG5vZGUgPSBub2RlLm5leHQgYXMgdHJ1c3Q7XG4gICAgfVxuICB9XG5cbiAgaW5zZXJ0QmVmb3JlKG5vZGU6IFQsIHJlZmVyZW5jZTogT3B0aW9uPFQ+ID0gbnVsbCk6IFQge1xuICAgIGlmIChyZWZlcmVuY2UgPT09IG51bGwpIHJldHVybiB0aGlzLmFwcGVuZChub2RlKTtcblxuICAgIGlmIChyZWZlcmVuY2UucHJldikgcmVmZXJlbmNlLnByZXYubmV4dCA9IG5vZGU7XG4gICAgZWxzZSB0aGlzLl9oZWFkID0gbm9kZTtcblxuICAgIG5vZGUucHJldiA9IHJlZmVyZW5jZS5wcmV2O1xuICAgIG5vZGUubmV4dCA9IHJlZmVyZW5jZTtcbiAgICByZWZlcmVuY2UucHJldiA9IG5vZGU7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGFwcGVuZChub2RlOiBUKTogVCB7XG4gICAgbGV0IHRhaWwgPSB0aGlzLl90YWlsO1xuXG4gICAgaWYgKHRhaWwpIHtcbiAgICAgIHRhaWwubmV4dCA9IG5vZGU7XG4gICAgICBub2RlLnByZXYgPSB0YWlsO1xuICAgICAgbm9kZS5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGVhZCA9IG5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLl90YWlsID0gbm9kZSk7XG4gIH1cblxuICByZW1vdmUobm9kZTogVCk6IFQge1xuICAgIGlmIChub2RlLnByZXYpIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgIGVsc2UgdGhpcy5faGVhZCA9IG5vZGUubmV4dCBhcyB0cnVzdDtcblxuICAgIGlmIChub2RlLm5leHQpIG5vZGUubmV4dC5wcmV2ID0gbm9kZS5wcmV2O1xuICAgIGVsc2UgdGhpcy5fdGFpbCA9IG5vZGUucHJldiBhcyB0cnVzdDtcblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgW1dJTExfRFJPUF0oKSB7XG4gICAgdGhpcy5mb3JFYWNoTm9kZShkID0+IGRlc3RydWN0b3IoZClbV0lMTF9EUk9QXSgpKTtcbiAgfVxuXG4gIFtESURfRFJPUF0oKSB7XG4gICAgdGhpcy5mb3JFYWNoTm9kZShkID0+IGRlc3RydWN0b3IoZClbRElEX0RST1BdKCkpO1xuICB9XG5cbiAgZ2V0IFtDSElMRFJFTl0oKTogSXRlcmFibGU8RHJvcD4ge1xuICAgIGxldCBvdXQ6IERyb3BbXSA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaE5vZGUoZCA9PiBvdXQucHVzaCguLi5kZXN0cnVjdG9yKGQpW0NISUxEUkVOXSkpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGljZTxUIGV4dGVuZHMgTGlua2VkTGlzdE5vZGU+IHtcbiAgaGVhZCgpOiBPcHRpb248VD47XG4gIHRhaWwoKTogT3B0aW9uPFQ+O1xuICBuZXh0Tm9kZShub2RlOiBUKTogT3B0aW9uPFQ+O1xuICBmb3JFYWNoTm9kZShjYWxsYmFjazogKG5vZGU6IFQpID0+IHZvaWQpOiB2b2lkO1xuICB0b0FycmF5KCk6IFRbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDbG9uZWFibGVMaXN0Tm9kZSBleHRlbmRzIExpbmtlZExpc3ROb2RlIHtcbiAgY2xvbmUoKTogdGhpcztcbn1cblxuZXhwb3J0IGNsYXNzIExpc3RTbGljZTxUIGV4dGVuZHMgTGlua2VkTGlzdE5vZGU+IGltcGxlbWVudHMgU2xpY2U8VD4ge1xuICBwcml2YXRlIF9oZWFkOiBPcHRpb248VD47XG4gIHByaXZhdGUgX3RhaWw6IE9wdGlvbjxUPjtcblxuICBjb25zdHJ1Y3RvcihoZWFkOiBPcHRpb248VD4sIHRhaWw6IE9wdGlvbjxUPikge1xuICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgIHRoaXMuX3RhaWwgPSB0YWlsO1xuICB9XG5cbiAgZm9yRWFjaE5vZGUoY2FsbGJhY2s6IChub2RlOiBUKSA9PiB2b2lkKSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLl9oZWFkO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGNhbGxiYWNrKG5vZGUpO1xuICAgICAgbm9kZSA9IHRoaXMubmV4dE5vZGUobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgaGVhZCgpOiBPcHRpb248VD4ge1xuICAgIHJldHVybiB0aGlzLl9oZWFkO1xuICB9XG5cbiAgdGFpbCgpOiBPcHRpb248VD4ge1xuICAgIHJldHVybiB0aGlzLl90YWlsO1xuICB9XG5cbiAgdG9BcnJheSgpOiBUW10ge1xuICAgIGxldCBvdXQ6IFRbXSA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaE5vZGUobiA9PiBvdXQucHVzaChuKSk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIG5leHROb2RlKG5vZGU6IFQpOiBPcHRpb248VD4ge1xuICAgIGlmIChub2RlID09PSB0aGlzLl90YWlsKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gbm9kZS5uZXh0IGFzIFQ7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEVNUFRZX1NMSUNFID0gbmV3IExpc3RTbGljZShudWxsLCBudWxsKTtcbiIsImNvbnN0IHsga2V5czogb2JqS2V5cyB9ID0gT2JqZWN0O1xuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduPFQsIFU+KG9iajogVCwgYXNzaWdubWVudHM6IFUpOiBUICYgVTtcbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ248VCwgVSwgVj4ob2JqOiBULCBhOiBVLCBiOiBWKTogVCAmIFUgJiBWO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbjxULCBVLCBWLCBXPihvYmo6IFQsIGE6IFUsIGI6IFYsIGM6IFcpOiBUICYgVSAmIFYgJiBXO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbjxULCBVLCBWLCBXLCBYPihvYmo6IFQsIGE6IFUsIGI6IFYsIGM6IFcsIGQ6IFgpOiBUICYgVSAmIFYgJiBXICYgWDtcbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ248VCwgVSwgViwgVywgWCwgWT4oXG4gIG9iajogVCxcbiAgYTogVSxcbiAgYjogVixcbiAgYzogVyxcbiAgZDogWCxcbiAgZTogWVxuKTogVCAmIFUgJiBWICYgVyAmIFggJiBZO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbjxULCBVLCBWLCBXLCBYLCBZLCBaPihcbiAgb2JqOiBULFxuICBhOiBVLFxuICBiOiBWLFxuICBjOiBXLFxuICBkOiBYLFxuICBlOiBZLFxuICBmOiBaXG4pOiBUICYgVSAmIFYgJiBXICYgWCAmIFkgJiBaO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQ6IGFueSwgLi4uYXJnczogYW55W10pOiBhbnk7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iajogYW55KSB7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGFzc2lnbm1lbnQgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKGFzc2lnbm1lbnQgPT09IG51bGwgfHwgdHlwZW9mIGFzc2lnbm1lbnQgIT09ICdvYmplY3QnKSBjb250aW51ZTtcbiAgICBsZXQga2V5cyA9IG9iaktleXMoYXNzaWdubWVudCk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICBsZXQga2V5ID0ga2V5c1tqXTtcbiAgICAgIG9ialtrZXldID0gYXNzaWdubWVudFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsbE51bGxzPFQ+KGNvdW50OiBudW1iZXIpOiBUW10ge1xuICBsZXQgYXJyID0gbmV3IEFycmF5KGNvdW50KTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICBhcnJbaV0gPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlczxUPihvYmo6IHsgW3M6IHN0cmluZ106IFQgfSk6IFRbXSB7XG4gIGNvbnN0IHZhbHMgPSBbXTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgdmFscy5wdXNoKG9ialtrZXldKTtcbiAgfVxuICByZXR1cm4gdmFscztcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBzdHJpcChzdHJpbmdzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgLi4uYXJnczogdW5rbm93bltdKSB7XG4gIGxldCBvdXQgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHN0cmluZyA9IHN0cmluZ3NbaV07XG4gICAgbGV0IGR5bmFtaWMgPSBhcmdzW2ldICE9PSB1bmRlZmluZWQgPyBTdHJpbmcoYXJnc1tpXSkgOiAnJztcblxuICAgIG91dCArPSBgJHtzdHJpbmd9JHtkeW5hbWljfWA7XG4gIH1cblxuICBsZXQgbGluZXMgPSBvdXQuc3BsaXQoJ1xcbicpO1xuXG4gIHdoaWxlIChsaW5lcy5sZW5ndGggJiYgbGluZXNbMF0ubWF0Y2goL15cXHMqJC8pKSB7XG4gICAgbGluZXMuc2hpZnQoKTtcbiAgfVxuXG4gIHdoaWxlIChsaW5lcy5sZW5ndGggJiYgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubWF0Y2goL15cXHMqJC8pKSB7XG4gICAgbGluZXMucG9wKCk7XG4gIH1cblxuICBsZXQgbWluID0gSW5maW5pdHk7XG5cbiAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xuICAgIGxldCBsZWFkaW5nID0gbGluZS5tYXRjaCgvXlxccyovKSFbMF0ubGVuZ3RoO1xuXG4gICAgbWluID0gTWF0aC5taW4obWluLCBsZWFkaW5nKTtcbiAgfVxuXG4gIGxldCBzdHJpcHBlZCA9IFtdO1xuXG4gIGZvciAobGV0IGxpbmUgb2YgbGluZXMpIHtcbiAgICBzdHJpcHBlZC5wdXNoKGxpbmUuc2xpY2UobWluKSk7XG4gIH1cblxuICByZXR1cm4gc3RyaXBwZWQuam9pbignXFxuJyk7XG59XG4iLCJleHBvcnQgeyBFTVBUWV9BUlJBWSB9IGZyb20gJy4vbGliL2FycmF5LXV0aWxzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXNzZXJ0LCBkZXByZWNhdGUgfSBmcm9tICcuL2xpYi9hc3NlcnQnO1xuZXhwb3J0IHsgZGljdCwgRGljdFNldCwgaXNEaWN0LCBpc09iamVjdCwgU2V0LCBTdGFja0ltcGwgYXMgU3RhY2sgfSBmcm9tICcuL2xpYi9jb2xsZWN0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9kZXN0cm95JztcbmV4cG9ydCAqIGZyb20gJy4vbGliL2RvbSc7XG5leHBvcnQgeyBlbnN1cmVHdWlkLCBIYXNHdWlkLCBpbml0aWFsaXplR3VpZCB9IGZyb20gJy4vbGliL2d1aWQnO1xuZXhwb3J0IHtcbiAgaXNTZXJpYWxpemF0aW9uRmlyc3ROb2RlLFxuICBTRVJJQUxJWkFUSU9OX0ZJUlNUX05PREVfU1RSSU5HLFxufSBmcm9tICcuL2xpYi9pcy1zZXJpYWxpemF0aW9uLWZpcnN0LW5vZGUnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvbGlmZXRpbWVzJztcbmV4cG9ydCB7XG4gIENsb25lYWJsZUxpc3ROb2RlLFxuICBFTVBUWV9TTElDRSxcbiAgTGlua2VkTGlzdCxcbiAgTGlua2VkTGlzdE5vZGUsXG4gIExpc3ROb2RlLFxuICBMaXN0U2xpY2UsXG4gIFNsaWNlLFxufSBmcm9tICcuL2xpYi9saXN0LXV0aWxzJztcbmV4cG9ydCB7IGFzc2lnbiwgZmlsbE51bGxzLCB2YWx1ZXMgfSBmcm9tICcuL2xpYi9vYmplY3QtdXRpbHMnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvcGxhdGZvcm0tdXRpbHMnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvc3RyaW5nJztcblxuZXhwb3J0IHR5cGUgRklYTUU8VCwgUyBleHRlbmRzIHN0cmluZz4gPSBUICYgUyB8IFQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROZXZlcih2YWx1ZTogbmV2ZXIsIGRlc2MgPSAndW5leHBlY3RlZCB1bnJlYWNoYWJsZSBicmFuY2gnKTogdm9pZCB7XG4gIGNvbnNvbGUubG9nKCd1bnJlYWNoYWJsZScsIHZhbHVlKTtcbiAgY29uc29sZS50cmFjZShgJHtkZXNjfSA6OiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0gKCR7dmFsdWV9KWApO1xufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O1FBQWEsY0FBcUIsT0FBQSxNQUFBLENBQTNCLEVBQTJCLENBQTNCOzs7SUNFUDtBQUVBLElBQU0sU0FBQSxXQUFBLENBQUEsSUFBQSxFQUFBLEdBQUEsRUFBNEM7SUFDaEQ7SUFDQTtJQUNBO0lBQ0E7SUFFQSxRQUFJLENBQUosSUFBQSxFQUFXO0lBQ1QsY0FBTSxJQUFBLEtBQUEsQ0FBVSxPQUFoQixtQkFBTSxDQUFOO0lBQ0Q7SUFDRjtBQUVELElBRU0sU0FBQSxTQUFBLENBQUEsSUFBQSxFQUFnQztJQUNwQyxZQUFBLElBQUEsbUJBQUEsSUFBQTtJQUNEOztJQ25CRCxJQUFJLE9BQUosQ0FBQTtBQU1BLElBQU0sU0FBQSxjQUFBLENBQUEsTUFBQSxFQUF3QztJQUM1QyxXQUFRLE9BQUEsS0FBQSxHQUFlLEVBQXZCLElBQUE7SUFDRDtBQUVELElBQU0sU0FBQSxVQUFBLENBQUEsTUFBQSxFQUFvQztJQUN4QyxXQUFPLE9BQUEsS0FBQSxJQUFnQixlQUF2QixNQUF1QixDQUF2QjtJQUNEOzs7OztJQ0hLLFNBQUEsSUFBQSxHQUFjO0lBQ2xCLFdBQU8sT0FBQSxNQUFBLENBQVAsSUFBTyxDQUFQO0lBQ0Q7QUFFRCxJQUFNLFNBQUEsTUFBQSxDQUFBLENBQUEsRUFBd0I7SUFDNUIsV0FBTyxNQUFBLElBQUEsSUFBYyxNQUFyQixTQUFBO0lBQ0Q7QUFFRCxJQUFNLFNBQUEsUUFBQSxDQUFBLENBQUEsRUFBMEI7SUFDOUIsV0FBTyxPQUFBLENBQUEsS0FBQSxRQUFBLElBQXlCLE1BQWhDLElBQUE7SUFDRDtBQUlELFFBQU0sT0FBTjtJQUdFLHVCQUFBO0lBQUE7O0lBQ0UsYUFBQSxJQUFBLEdB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