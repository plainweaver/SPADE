{"version":3,"sources":["../src/Receptor.js"],"names":["findMethod","system","paths","scope","length","receptor","main","method","reduce","acc","cur","Error","join","bind","Receptor","constructor","options","execs","exits","processing","createProcess","Promise","setImmediate","keepingPaths","handler","call","createReceiver","resolve","push","proxy","Proxy","get","target","property","receiver","apply","thisArg","argsList","clearPaths","getPrototypeOf","ownKeys","Reflect","set","value","proto","Object","descs","getOwnPropertyDescriptors","setters","keys","filter","name","includes","deleteProperty","asyncFunc","callback","promise","result","shift","forEach","res","keepPaths","splice"],"mappings":"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","sourcesContent":["import promisify from '../utils/promisify';\n\nfunction findMethod(system, paths) {\n  let scope = system;\n  if (paths.length === 0) return system.receptor.main;\n\n  const method = paths.reduce((acc, cur) => {\n    scope = acc;\n    return acc[cur];\n  }, scope);\n  if (!method) throw new Error(`Unable to get a method '${paths.join('.')}'.`);\n\n  return method.bind(scope);\n}\n\n// to use async things just like sync ones.\n// enables this by intercept getter setter caller in the middle and enqueues them.\n// if a result of segment returns 'this' self, then it is chainable.\n\n/**\n * @param options.main {Function} - function for when the system itself gets executed.\n * @param options.helpers {Object<Function>>} -\n */\nexport default class Receptor {\n  constructor(system, options = {}) {\n    // queues for jobs\n    this.paths = [];\n    this.execs = [];\n    this.exits = [];\n    this.processing = false;\n\n    // to wire system's circular references.\n    this.createProcess(() => new Promise(setImmediate));\n\n    this.system = system;\n    this.main = options.main;\n    this.keepingPaths = false;\n\n    return async handler => {\n      handler.call(null, this.createReceiver());\n      return new Promise(resolve => this.exits.push(resolve));\n    };\n  }\n\n  /**\n   * Returns proxy that will act like system itself by handling get, call, etc...\n   * Not only intercepting them, but also record them in queue to process lazily.\n   * In result, it is possible to write and use async jobs just like a sync one.\n   *   example) you can write `system.use(async).use(async).listen(3000)`.\n   */\n  createReceiver() {\n    const receptor = this;\n    const proxy = new Proxy(function() {}, {\n      // -- enqueues jobs, returns sync proxy again for the moment --\n      get(target, property, receiver) {\n        receptor.paths.push(property);\n        return proxy;\n      },\n      apply(target, thisArg, argsList) {\n        const paths = [ ...receptor.paths ];\n        if (!receptor.keepingPaths) receptor.clearPaths();\n\n        receptor.createProcess(async () => {\n          const method = findMethod(receptor.system, paths);\n          await method(...argsList);\n        });\n\n        return proxy;\n      },\n\n      // -- returns promise that resolves after queued jobs are cleared --\n      async getPrototypeOf() {\n\n      },\n      async ownKeys(target) {\n        return Reflect.ownKeys(receptor.system);\n      },\n\n      // -- prevents direct manipulation and suggest using overlays. --\n      set(target, property, value, receiver) {\n        const proto = Object.getPrototypeOf(receptor.system);\n        const descs = Object.getOwnPropertyDescriptors(proto);\n        const setters = Object.keys(descs).filter(name => descs[name].set);\n\n        if (setters.includes(property)) {\n          descs[property].set(value);\n          return true;\n        }\n\n        throw new Error(\n          \"Cannot set property of system. \" +\n          \"To manipulate system's property, use overlay regularly or define setter in System to standardize the structure.\"\n        );\n      },\n      deleteProperty() {\n        throw new Error(\n          \"Cannot delete property of system. Only overlays can delete property.\"\n        );\n      }\n    });\n\n    return proxy;\n  }\n\n  /**\n   * Enqueues process and start iteration.\n   *  - supports both styles async/await and callback.\n   * @return asyncFunc's return value.\n   */\n  async createProcess(asyncFunc, callback) {\n    let promise;\n\n    if (!callback) {\n      callback = promisify();\n      promise = callback.promise;\n    }\n\n    // create and push new process\n    this.execs.push(async () => {\n      // do current process\n      const result = await asyncFunc();\n      this.execs.shift(); // remove self\n      callback(null, result);\n\n      if (this.execs.length > 0) {\n        // start next process\n        this.execs[0]();\n      } else {\n        // end of queue\n        this.processing = false;\n        this.exits.forEach(res => res());\n      }\n    });\n\n    if (!this.processing) {\n      this.processing = true;\n      this.execs[0]();\n    }\n\n    return await promise;\n  }\n\n  /**\n   * Paths won't be erased after executions.\n   */\n  keepPaths() {\n    if (this.keepingPaths) throw new Error('The receptor is already in keeping paths.');\n    this.keepingPaths = true;\n  }\n\n  /**\n   * Manually erase paths.\n   */\n  clearPaths() {\n    this.paths.splice(0, this.paths.length);\n  }\n}\n"],"file":"Receptor.js"}