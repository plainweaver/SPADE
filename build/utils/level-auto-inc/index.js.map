{"version":3,"sources":["../../../src/utils/level-auto-inc/index.js"],"names":["LevelAutoInc","storage","options","counterName","storageForCounter","queue","processing","self","createProcess","asyncFunc","callback","process","result","shift","length","push","prototype","Object","getPrototypeOf","keys","forEach","name","bind","setPrototypeOf","parseCount","data","str","toString","parseInt","_getCurrentCount","count","get","e","put","undefined","createKey","del","putWithAutoInc","value","key"],"mappings":"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","sourcesContent":["import promisify from '../promisify';\nimport { appendCallback, returnPromise } from '../versatile-function';\nimport concat from 'level-concat-iterator';\n\n// todo) current mode is to skip empty numbers if they were deleted or something.\n// todo) alternative mode would be queue processes and not to make empty numbers. This will not guarentee the order.\nfunction LevelAutoInc(storage, options) {\n  if (!(this instanceof LevelAutoInc)) {\n    return new LevelAutoInc(storage, options);\n  }\n\n  if (!options) options = {};\n  this.storage = storage;\n  this.counterName = options.counterName || '~counter';\n  this.storageForCounter = options.storageForCounter || storage;\n  this.queue = [];\n  this.processing = false;\n\n  const self = this;\n  this.createProcess = returnPromise(1, function(asyncFunc, callback) {\n    const process = async function() {\n      const result = await asyncFunc();\n      self.queue.shift();\n      if (callback) callback(null, result);\n      if (self.queue.length > 0) {\n        await self.queue[0]();\n      } else {\n        self.processing = false;\n      }\n    };\n\n    if (!self.processing) {\n      self.processing = true;\n      self.queue.push(process());\n    } else {\n      self.queue.push(process);\n    }\n  });\n\n  // appends prototype functions to original storage.\n  const prototype = { ...Object.getPrototypeOf(this) };\n  Object.keys(prototype).forEach(name => { prototype[name] = prototype[name].bind(this); });\n  Object.setPrototypeOf(this.storage, { ...Object.getPrototypeOf(this.storage), ...prototype });\n  return this.storage;\n}\n\nLevelAutoInc.prototype.parseCount = function(data) {\n  const str = data.toString();\n  if (str === 'undefined') return 0;\n  return parseInt(str);\n};\n\nLevelAutoInc.prototype._getCurrentCount = appendCallback(async function() {\n  try {\n    const count = await this.storageForCounter.get(this.counterName);\n    return this.parseCount(count);\n  } catch (e) {\n    if (e.name !== 'NotFoundError') throw e;\n    await this.storageForCounter.put(this.counterName, 'undefined');\n    return undefined;\n  }\n});\n\nLevelAutoInc.prototype.createKey = appendCallback(async function() {\n  return await this.createProcess(async () => {\n    const count = await this._getCurrentCount();\n    await this.storageForCounter.del(this.counterName);\n\n    if (count === undefined) {\n      await this.storageForCounter.put(this.counterName, 0);\n      return 0;\n    } else {\n      await this.storageForCounter.put(this.counterName, count + 1);\n      return count + 1;\n    }\n  });\n});\n\nLevelAutoInc.prototype.putWithAutoInc = appendCallback(async function(value) {\n  const key = await this.createKey();\n  await this.storage.put(key, value);\n  return key;\n});\n\nexport default LevelAutoInc;"],"file":"index.js"}