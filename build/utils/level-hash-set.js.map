{"version":3,"sources":["../../src/utils/level-hash-set.js"],"names":["changeToHash","data","buf","toString","Buffer","byteLength","crypto","createHash","update","digest","LevelHashSet","leveldb","_db","size","approximateSize","prototype","add","value","callback","promise","issueKey","err","key","put","err2","revokeKey","delete","has","db","get","result"],"mappings":";;;;;;;AAAA;;AACA;;;;AAEA,SAASA,YAAT,CAAsBC,IAAtB,EAA4B;AAC1B,QAAMC,GAAG,GAAGD,IAAI,CAACE,QAAL,CAAc,QAAd,CAAZ;;AAEA,MAAIC,MAAM,CAACC,UAAP,CAAkBH,GAAlB,IAAyB,EAA7B,EAAiC;AAC/B,WAAOD,IAAP;AACD,GAFD,MAEO;AACL,WAAOK,gBAAOC,UAAP,CAAkB,QAAlB,EAA4BC,MAA5B,CAAmCN,GAAnC,EAAwCO,MAAxC,CAA+C,QAA/C,CAAP;AACD;AACF,C,CAED;AACA;AACA;;;AACe,SAASC,YAAT,CAAsBC,OAAtB,EAA+B;AAC5C,OAAKC,GAAL,GAAWD,OAAX;AAEA,OAAKE,IAAL,GAAYF,OAAO,CAACG,eAApB;AACD;;AAEDJ,YAAY,CAACK,SAAb,CAAuBC,GAAvB,GAA6B,UAASC,KAAT,EAAgBC,QAAhB,EAA0B;AACrD,MAAIC,OAAJ;;AAEA,MAAI,CAACD,QAAL,EAAe;AACbA,IAAAA,QAAQ,GAAG,yBAAX;AACAC,IAAAA,OAAO,GAAGD,QAAQ,CAACC,OAAnB;AACD;;AAED,OAAKC,QAAL,CAAc,CAACC,GAAD,EAAMC,GAAN,KAAc;AAC1B,SAAKV,GAAL,CAASW,GAAT,CAAatB,IAAb,EAAmBqB,GAAnB,EAAwBE,IAAI,IAAI;AAC9B,UAAIH,GAAG,IAAIG,IAAX,EAAiB;AACf,aAAKC,SAAL,CAAeH,GAAf;AACAJ,QAAAA,QAAQ,CAACG,GAAD,CAAR;AACD,OAHD,MAGO;AACLH,QAAAA,QAAQ;AACT;AACF,KAPD;AAQD,GATD;AAWA,SAAOC,OAAP;AACD,CApBD;;AAsBAT,YAAY,CAACK,SAAb,CAAuBW,MAAvB,GAAgC,UAAST,KAAT,EAAgBC,QAAhB,EAA0B;AACxD,MAAIC,OAAJ;;AAEA,MAAI,CAACD,QAAL,EAAe;AACbA,IAAAA,QAAQ,GAAG,yBAAX;AACAC,IAAAA,OAAO,GAAGD,QAAQ,CAACC,OAAnB;AACD;;AAED,OAAKC,QAAL,CAAc,CAACC,GAAD,EAAMC,GAAN,KAAc;AAC1B,SAAKV,GAAL,CAASW,GAAT,CAAatB,IAAb,EAAmBqB,GAAnB,EAAwBE,IAAI,IAAI;AAC9B,UAAIH,GAAG,IAAIG,IAAX,EAAiBN,QAAQ,CAACG,GAAD,CAAR,CAAjB,KACKH,QAAQ;AACd,KAHD;AAID,GALD;AAOA,SAAOC,OAAP;AACD,CAhBD;;AAkBAT,YAAY,CAACK,SAAb,CAAuBY,GAAvB,GAA6B,UAASV,KAAT,EAAgBC,QAAhB,EAA0B;AACrD,MAAIC,OAAJ;;AAEA,MAAI,CAACD,QAAL,EAAe;AACbA,IAAAA,QAAQ,GAAG,yBAAX;AACAC,IAAAA,OAAO,GAAGD,QAAQ,CAACC,OAAnB;AACD;;AAED,OAAKS,EAAL,CAAQC,GAAR,CAAY7B,YAAY,CAACiB,KAAD,CAAxB,EAAiC,CAACI,GAAD,EAAMS,MAAN,KAAiB;AAChD,QAAIT,GAAJ,EAASH,QAAQ,CAACG,GAAD,CAAR;;AACT,QAAIS,MAAJ,EAAY;AACV,aAAOZ,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAf;AACD,KAFD,MAEO;AACL,aAAOA,QAAQ,CAAC,IAAD,EAAO,KAAP,CAAf;AACD;AACF,GAPD;AASA,SAAOC,OAAP;AACD,CAlBD","sourcesContent":["import crypto from 'crypto';\nimport promisify from './promisify';\n\nfunction changeToHash(data) {\n  const buf = data.toString('base64');\n\n  if (Buffer.byteLength(buf) < 32) {\n    return data;\n  } else {\n    return crypto.createHash('sha256').update(buf).digest('base64');\n  }\n}\n\n// todo since key is same as value, using hash-compressed value as a key can make it better.\n// todo also, this can be done in multiple times and layers and we may configure manually for an application.\n// todo like traditional CAM, parallel search in hardware would be nice.\nexport default function LevelHashSet(leveldb) {\n  this._db = leveldb;\n\n  this.size = leveldb.approximateSize;\n}\n\nLevelHashSet.prototype.add = function(value, callback) {\n  let promise;\n\n  if (!callback) {\n    callback = promisify();\n    promise = callback.promise;\n  }\n\n  this.issueKey((err, key) => {\n    this._db.put(data, key, err2 => {\n      if (err || err2) {\n        this.revokeKey(key);\n        callback(err);\n      } else {\n        callback();\n      }\n    });\n  });\n\n  return promise;\n};\n\nLevelHashSet.prototype.delete = function(value, callback) {\n  let promise;\n\n  if (!callback) {\n    callback = promisify();\n    promise = callback.promise;\n  }\n\n  this.issueKey((err, key) => {\n    this._db.put(data, key, err2 => {\n      if (err || err2) callback(err);\n      else callback();\n    });\n  });\n\n  return promise;\n};\n\nLevelHashSet.prototype.has = function(value, callback) {\n  let promise;\n\n  if (!callback) {\n    callback = promisify();\n    promise = callback.promise;\n  }\n\n  this.db.get(changeToHash(value), (err, result) => {\n    if (err) callback(err);\n    if (result) {\n      return callback(null, true);\n    } else {\n      return callback(null, false)\n    }\n  });\n\n  return promise;\n};\n"],"file":"level-hash-set.js"}