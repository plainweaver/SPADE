{"version":3,"sources":["../../../src/utils/level-domain/index.js"],"names":["LevelDomain","db","options","store","domain","primaryIndex","action","ActionSystemConnector","particle","ParticleSystemConnector","queue","active","loaded","prototype","getAllDomains","cells","cell","getAll","map","info","StorableDomain","toExecutable","getDomains","queryObject","getByQueryObject","processParticle","domains","suited","Promise","filter","dscr","rels","putIndexedObject","cell_id","id","particle_id","getParticles","result","each","forEach","rel","push","_","uniq","createDomain","domainName","dscrCode","dscrType","undefined","Error","ExecutableDomain","console","log","toStorable","ast","esprima","parseModule","deleteDomain","all","delByQueryObject"],"mappings":";;;;;;;AASA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;AAnBA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAaA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA,SAASA,WAAT,CAAqBC,EAArB,EAAyBC,OAAO,GAAG,EAAnC,EAAuC;AACrC,MAAI,EAAE,gBAAgBF,WAAlB,CAAJ,EAAoC;AAClC,WAAO,IAAIA,WAAJ,CAAgBC,EAAhB,EAAoBC,OAApB,CAAP;AACD;;AAED,OAAKC,KAAL,GAAa;AACf;AACI;AACA;AACAC,IAAAA,MAAM,EAAE,+BAAQ,2BAASH,EAAT,EAAa,QAAb,CAAR,EAAgC;AAAEI,MAAAA,YAAY,EAAE;AAAhB,KAAhC,CAJG;AAKX;AACA;AACAC,IAAAA,MAAM,EAAE,IAAIC,YAAJ,EAPG;AAQX;AACA;AACAC,IAAAA,QAAQ,EAAE,IAAIC,YAAJ,EAVC,CAYX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AApBW,GAAb,CALqC,CA4BrC;;AACA,OAAKC,KAAL,GAAa,EAAb,CA7BqC,CA8BrC;;AACA,OAAKC,MAAL,GAAc,EAAd,CA/BqC,CAgCrC;;AACA,OAAKC,MAAL,GAAc,KAAd;AACD;;AAEDZ,WAAW,CAACa,SAAZ,CAAsBC,aAAtB,GAAsC,kBAAiB;AACrD,QAAMC,KAAK,GAAG,MAAM,KAAKZ,KAAL,CAAWa,IAAX,CAAgBC,MAAhB,EAApB;AACA,SAAOF,KAAK,CAACG,GAAN,CAAUC,IAAI,IAAI,IAAIC,sBAAJ,CAAmBD,IAAnB,CAAlB,EAA4CD,GAA5C,CAAgDd,MAAM,IAAIA,MAAM,CAACiB,YAAP,EAA1D,CAAP;AACD,CAHD;;AAKArB,WAAW,CAACa,SAAZ,CAAsBS,UAAtB,GAAmC,gBAAeC,WAAf,EAA4B;AAC7D,QAAMR,KAAK,GAAG,MAAM,KAAKZ,KAAL,CAAWa,IAAX,CAAgBQ,gBAAhB,CAAiCD,WAAjC,CAApB;AACA,SAAOR,KAAK,CAACG,GAAN,CAAUC,IAAI,IAAI,IAAIC,sBAAJ,CAAmBD,IAAnB,CAAlB,EAA4CD,GAA5C,CAAgDd,MAAM,IAAIA,MAAM,CAACiB,YAAP,EAA1D,CAAP;AACD,CAHD;;AAKArB,WAAW,CAACa,SAAZ,CAAsBY,eAAtB,GAAwC,gBAAejB,QAAf,EAAyB;AAC/D,QAAMkB,OAAO,GAAG,MAAM,KAAKZ,aAAL,EAAtB;AACA,QAAMa,MAAM,GAAG,MAAMC,kBAAQC,MAAR,CAAeH,OAAf,EAAwBtB,MAAM,IAAIA,MAAM,CAAC0B,IAAP,CAAYtB,QAAZ,CAAlC,CAArB;AACA,QAAMoB,kBAAQV,GAAR,CAAYS,MAAZ,EAAoBvB,MAAM,IAAI,KAAKD,KAAL,CAAW4B,IAAX,CAAgBC,gBAAhB,CAAiC;AAAEC,IAAAA,OAAO,EAAE7B,MAAM,CAAC8B,EAAlB;AAAsBC,IAAAA,WAAW,EAAE3B,QAAQ,CAAC0B;AAA5C,GAAjC,CAA9B,CAAN;AACA,SAAOP,MAAP;AACD,CALD;AAOA;;;;;AAGA3B,WAAW,CAACa,SAAZ,CAAsBuB,YAAtB,GAAqC,gBAAeb,WAAf,EAA4B;AAC/D,QAAMR,KAAK,GAAG,MAAM,KAAKZ,KAAL,CAAWa,IAAX,CAAgBQ,gBAAhB,CAAiCD,WAAjC,CAApB;AACA,QAAMc,MAAM,GAAG,EAAf;AACA,QAAMT,kBAAQU,IAAR,CAAavB,KAAb,EAAoB,MAAMX,MAAN,IAAgB;AACxC,UAAM2B,IAAI,GAAG,MAAM,KAAK5B,KAAL,CAAW4B,IAAX,CAAgBP,gBAAhB,CAAiC;AAAES,MAAAA,OAAO,EAAE7B,MAAM,CAAC8B;AAAlB,KAAjC,CAAnB;AACAH,IAAAA,IAAI,CAACQ,OAAL,CAAaC,GAAG,IAAIH,MAAM,CAACI,IAAP,CAAYD,GAAG,CAACL,WAAhB,CAApB;AACD,GAHK,CAAN;AAKA,SAAOO,gBAAEC,IAAF,CAAON,MAAP,CAAP;AACD,CATD,C,CAWA;;;AACArC,WAAW,CAACa,SAAZ,CAAsB+B,YAAtB,GAAqC,uCAAe,gBAAe;AAAEC,EAAAA,UAAF;AAAcC,EAAAA,QAAd;AAAwBC,EAAAA;AAAxB,CAAf,EAAmD;AACrG,MAAI,OAAOD,QAAP,KAAoB,UAAxB,EAAoC;AAClC,QAAIC,QAAQ,KAAKC,SAAb,IAA0BD,QAAQ,KAAK,oBAA3C,EACE,MAAM,IAAIE,KAAJ,CAAU,iGAAV,CAAN;AAEF,UAAM7C,MAAM,GAAG,IAAI8C,wBAAJ,CAAqBL,UAArB,EAAiCC,QAAjC,CAAf;AACAK,IAAAA,OAAO,CAACC,GAAR,CAAYhD,MAAM,CAACiD,UAAP,EAAZ;AACA,UAAM,KAAKlD,KAAL,CAAWa,IAAX,CAAgBgB,gBAAhB,CAAiC5B,MAAM,CAACiD,UAAP,EAAjC,CAAN;AACA,WAAOjD,MAAP;AACD,GARD,MAUK,IAAI2C,QAAQ,KAAK,cAAjB,EAAgC;AACnC,UAAMO,GAAG,GAAGC,iBAAQC,WAAR,CAAoBV,QAApB,CAAZ;AAED;AACF,CAfoC,CAArC;AAiBA9C,WAAW,CAACa,SAAZ,CAAsB4C,YAAtB,GAAqC,uCAAe,gBAAgBlC,WAAhB,EAA6B;AAC/E,QAAMG,OAAO,GAAG,MAAM,KAAKvB,KAAL,CAAWa,IAAX,CAAgBQ,gBAAhB,CAAiCD,WAAjC,CAAtB;AACA,QAAMK,kBAAQ8B,GAAR,CAAYhC,OAAO,CAACR,GAAR,CAAYF,IAAI,IAAI,KAAKb,KAAL,CAAW4B,IAAX,CAAgB4B,gBAAhB,CAAiC;AAAE1B,IAAAA,OAAO,EAAEjB,IAAI,CAACkB;AAAhB,GAAjC,CAApB,CAAZ,CAAN;AACA,QAAM,KAAK/B,KAAL,CAAWa,IAAX,CAAgB2C,gBAAhB,CAAiCpC,WAAjC,CAAN;AACA,SAAOG,OAAP;AACD,CALoC,CAArC;eAOe1B,W","sourcesContent":["// name with adjective (part of bigger part) (sum after)\n// name without adjective\n//  - outside of any adjectives but within the set.\n\n// get all data\n// get all data, only in subsets\n// get all data, outside of subsets\n\n// todo) Same name, but different id.\nimport vm from 'vm';\nimport _ from 'lodash';\nimport Promise from 'bluebird';\nimport sublevel from 'subleveldown';\nimport esprima from 'esprima';\nimport levelgraph from 'levelgraph';\nimport indexed from '../level-second-index';\nimport ActionSystemConnector from './ASC';\nimport ParticleSystemConnector from './PSC';\nimport { returnPromise, appendCallback } from '../versatile-function';\nimport { ExecutableDomain, StorableDomain } from './Domain';\n\n// For Type Checking...\n// todo) should we move to 1. Typescript or 2. switch files dev(checks) <-> prod(does no check)\n\n// 1) merge circular sets\n// 2) if A-B-C-A, process until C.\n// 3) if A-B-C-A, checks result from C equivalent to A. (for systems in special case that dscr changes particle)\n// 4) keep circling per intervals (not recommended)\n// 5) prevent circular sets (default)\n\n// -- dscr, subset part --\n// 1) discriminate by all domains as particle added (starts from every endpoints)\n// 2) selective discrimination\n\n// -- methods, functional part --\n// 1) gradually expanding scope\nfunction LevelDomain(db, options = {}) {\n  if (!(this instanceof LevelDomain)) {\n    return new LevelDomain(db, options)\n  }\n\n  this.store = {\n// --- Basic Mandatory Stores ---\n    // Domain creation info\n    //  - stores indexedObject { domain_name }\n    domain: indexed(sublevel(db, 'domain'), { primaryIndex: null }),\n    // Discriminators\n    //  - stores indexedObject { domain_id, action_id }\n    action: new ActionSystemConnector(),\n    // Entities\n    //  - stores indexedObject { domain_id, particle_id }\n    particle: new ParticleSystemConnector(),\n\n    // --- Additional Indexed Infos ---\n    // todo) should we make this as plugins\n    // like special useful relations\n    // 1. Truely on previous set -> should check smaller set below -> save on only latest points.\n    //  - takes indexedObject\n    // subsetrel: index(sublevel(db, 'subrel')),\n    // 2. More than one are true (AND) -> being new set is qualified\n    // (circular subsetting?)\n    // 3. (etc OR XOR Cycles...)\n  };\n\n  // Enqueues queries. becomes object and parallel after load.\n  this.queue = [];\n  // Activated domains. Immediately executable.\n  this.active = {};\n  // To be turned to true after load all domains into active.\n  this.loaded = false;\n}\n\nLevelDomain.prototype.getAllDomains = async function() {\n  const cells = await this.store.cell.getAll();\n  return cells.map(info => new StorableDomain(info)).map(domain => domain.toExecutable());\n};\n\nLevelDomain.prototype.getDomains = async function(queryObject) {\n  const cells = await this.store.cell.getByQueryObject(queryObject);\n  return cells.map(info => new StorableDomain(info)).map(domain => domain.toExecutable());\n};\n\nLevelDomain.prototype.processParticle = async function(particle) {\n  const domains = await this.getAllDomains();\n  const suited = await Promise.filter(domains, domain => domain.dscr(particle));\n  await Promise.map(suited, domain => this.store.rels.putIndexedObject({ cell_id: domain.id, particle_id: particle.id }));\n  return suited;\n};\n\n/**\n * @param queryObject queryObject that finds domain cell.\n */\nLevelDomain.prototype.getParticles = async function(queryObject) {\n  const cells = await this.store.cell.getByQueryObject(queryObject);\n  const result = [];\n  await Promise.each(cells, async domain => {\n    const rels = await this.store.rels.getByQueryObject({ cell_id: domain.id });\n    rels.forEach(rel => result.push(rel.particle_id));\n  });\n\n  return _.uniq(result);\n};\n\n// dscrModuleType ['default = executableFunction', 'singleFunction', 'moduleExport', 'bodyAndArgs']\nLevelDomain.prototype.createDomain = appendCallback(async function({ domainName, dscrCode, dscrType }) {\n  if (typeof dscrCode === 'function') {\n    if (dscrType !== undefined || dscrType === 'executableFunction')\n      throw new Error(\"When dscr is an executable function, dscrType should be either omitted or 'executableFunction'.\");\n\n    const domain = new ExecutableDomain(domainName, dscrCode);\n    console.log(domain.toStorable());\n    await this.store.cell.putIndexedObject(domain.toStorable());\n    return domain;\n  }\n\n  else if (dscrType === 'moduleExport'){\n    const ast = esprima.parseModule(dscrCode);\n\n  }\n});\n\nLevelDomain.prototype.deleteDomain = appendCallback(async function (queryObject) {\n  const domains = await this.store.cell.getByQueryObject(queryObject);\n  await Promise.all(domains.map(cell => this.store.rels.delByQueryObject({ cell_id: cell.id })));\n  await this.store.cell.delByQueryObject(queryObject);\n  return domains;\n});\n\nexport default LevelDomain;\n"],"file":"index.js"}