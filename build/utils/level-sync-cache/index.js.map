{"version":3,"sources":["../../../src/utils/level-sync-cache/index.js"],"names":["LevelSyncCache","db","memory","storage","queue","processing","self","createProcess","asyncFunc","callback","process","result","shift","length","push","items","Promise","res","rej","iterator","err","data","all","map","key","value","put","prototype","get","del"],"mappings":"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","sourcesContent":["import levelup from 'levelup';\nimport memdown from 'memdown';\nimport concat from 'level-concat-iterator';\nimport { returnPromise, appendCallback } from '../versatile-function';\n\n/**\n * Memory that keeps up to date of hard storage.\n * Writes on source storage and then on a cache.\n * Reads from cache as it always contains latest data.\n */\nfunction LevelSyncCache(db) {\n  if (!(this instanceof LevelSyncCache)) {\n    return new LevelSyncCache(db);\n  }\n\n  this.memory = levelup(memdown());\n  this.storage = db;\n  this.queue = [];\n  this.processing = false;\n\n  const self = this;\n  this.queue.createProcess = returnPromise(1, function(asyncFunc, callback) {\n    const process = async function() {\n      const result = await asyncFunc();\n      self.queue.shift();\n      if (callback) callback(null, result);\n      if (self.queue.length > 0) {\n        await self.queue[0]();\n      } else {\n        self.processing = false;\n      }\n    };\n\n    if (!self.processing) {\n      self.processing = true;\n      self.queue.push(process());\n    } else {\n      self.queue.push(process);\n    }\n  });\n\n  // setup. loads all at launch\n  this.queue.createProcess(async function() {\n    const items = await new Promise((res, rej) => {\n      concat(db.iterator(), (err, data) => err ? rej(err) : res(data))\n    });\n    await Promise.all(items.map(({ key, value}) => self.memory.put(key, value)));\n  });\n}\n\nLevelSyncCache.prototype.get = returnPromise(1, function(key, callback) {\n  const self = this;\n  this.queue.createProcess(async function() {\n    return await self.memory.get(key);\n  }, callback)\n});\n\nLevelSyncCache.prototype.put = returnPromise(2, function(key, value, callback) {\n  const self = this;\n  this.queue.createProcess(async function() {\n    await self.storage.put(key, value);\n    await self.memory.put(key, value);\n  }, callback)\n});\n\nLevelSyncCache.prototype.del = returnPromise(1, function(key, callback) {\n  const self = this;\n  this.queue.createProcess(async function() {\n    await self.memory.del(key);\n    await self.storage.del(key);\n  }, callback)\n});\n\nexport default LevelSyncCache;\n"],"file":"index.js"}