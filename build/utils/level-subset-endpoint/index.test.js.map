{"version":3,"sources":["../../../src/utils/level-subset-endpoint/index.test.js"],"names":["DIR","db","dbForCells","dbForRelations","dbForEndpoints","counter","generateId","callback","toString","subsetdb","primaryIndex","storage","describe","beforeEach","resetDB","keys","Promise","res","createKeyStream","on","key","push","all","map","del","it","createSet","name","roots","getRoots","assert","deepEqual","setId","createSetInSet","setId2","endpoints","getEndpoints","includeMembers","setIdA","setIdB","setIdC","putSetInSet","e","include","message"],"mappings":"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","sourcesContent":["import fs from 'fs';\nimport { assert } from 'chai';\nimport levelup from 'levelup';\nimport rocksdb from 'rocksdb';\nimport sublevel from 'subleveldown';\nimport LevelGraph from 'levelgraph';\nimport LevelEndpoint from './index';\nimport LevelArray from '../level-array';\nimport LevelSubset from '../level-subset';\nimport LevelIndex from '../level-second-index';\n\nconst DIR = './storage/test/level-subset/endpoint';\nconst db = levelup(rocksdb(DIR));\nconst dbForCells = sublevel(db, 'cell');\nconst dbForRelations = sublevel(db, 'relation');\nconst dbForEndpoints = sublevel(db, 'endpoint');\n\nlet counter = 0;\nconst generateId = callback => { counter += 1; if (callback) return callback(null, counter.toString()); return counter.toString(); };\nconst subsetdb = LevelSubset(LevelIndex(dbForCells, { primaryIndex: 'id' }), LevelGraph(dbForRelations), generateId);\nconst storage = LevelEndpoint(subsetdb, dbForEndpoints);\n\n// after(() => {\n//   return Promise.all([\n//     dbForCells.close(),\n//     dbForRelations.close(),\n//     dbForEndpoints.close()\n//   ]).then(() => {\n//     fs.rmdirSync(DIR, { recursive: true });\n//   });\n// });\n\ndescribe('Endpoints', () => {\n  beforeEach(async () => {\n    async function resetDB(db) {\n      const keys = [];\n      await new Promise(res => db.createKeyStream().on('data', key => keys.push(key)).on('end', () => res()));\n      await Promise.all(keys.map(key => db.del(key)));\n    }\n\n    counter = 0;\n    await resetDB(dbForRelations);\n    await resetDB(dbForCells);\n    await resetDB(dbForEndpoints);\n  });\n\n  it('createDomain * 2 -> getRoots', async () => {\n      await storage.createSet({ name: 'A' });\n      await storage.createSet({ name: 'B' });\n      const roots = await storage.getRoots();\n      assert.deepEqual(roots, []);\n  });\n\n  it('should return [ A, B ] from [ A, A1, A2, B, B1, B2 ]', async () => {\n    const setId = await storage.createSet({ name: 'A' });\n    await storage.createSetInSet({ name: 'A1' }, setId);\n    await storage.createSetInSet({ name: 'A2' }, setId);\n    const setId2 = await storage.createSet({ name: 'B' });\n    await storage.createSetInSet({ name: 'B1' }, setId2);\n    await storage.createSetInSet({ name: 'B2' }, setId2);\n    const endpoints = await storage.getEndpoints();\n    assert.includeMembers(endpoints, [ setId, setId2 ])\n  });\n\n  // duplicated in test of level-subset, but keep leaving here because\n  // it is possible level-subset have feature that modifies particle in discriminating.\n  // in other words, just to ensure to prevent.\n  it('throws for circular set ðŸœ›', async () => {\n    try {\n      const setIdA = await storage.createSet({ name: 'A' });\n      const setIdB = await storage.createSet({ name: 'B' });\n      const setIdC = await storage.createSet({ name: 'C' });\n      await storage.putSetInSet(setIdB, setIdA);\n      await storage.putSetInSet(setIdC, setIdB);\n      await storage.putSetInSet(setIdA, setIdC);\n    } catch (e) {\n      assert.include(e.message, 'Circular set');\n    }\n  })\n});\n"],"file":"index.test.js"}